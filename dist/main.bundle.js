webpackJsonp([1,3],{

/***/ "./node_modules/@angular/animations/@angular/animations.es5.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationBuilder", function() { return AnimationBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationFactory", function() { return AnimationFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTO_STYLE", function() { return AUTO_STYLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animate", function() { return animate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animateChild", function() { return animateChild; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animation", function() { return animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "group", function() { return group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyframes", function() { return keyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "query", function() { return query; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequence", function() { return sequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stagger", function() { return stagger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "state", function() { return state; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "style", function() { return style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return trigger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useAnimation", function() { return useAnimation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoopAnimationPlayer", function() { return NoopAnimationPlayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵAnimationGroupPlayer", function() { return AnimationGroupPlayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵPRE_STYLE", function() { return ɵPRE_STYLE; });
/**
 * @license Angular v4.3.3
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * AnimationBuilder is an injectable service that is available when the {\@link
 * BrowserAnimationsModule BrowserAnimationsModule} or {\@link NoopAnimationsModule
 * NoopAnimationsModule} modules are used within an application.
 *
 * The purpose if this service is to produce an animation sequence programmatically within an
 * angular component or directive.
 *
 * Programmatic animations are first built and then a player is created when the build animation is
 * attached to an element.
 *
 * ```ts
 * // remember to include the BrowserAnimationsModule module for this to work...
 * import {AnimationBuilder} from '\@angular/animations';
 *
 * class MyCmp {
 *   constructor(private _builder: AnimationBuilder) {}
 *
 *   makeAnimation(element: any) {
 *     // first build the animation
 *     const myAnimation = this._builder.build([
 *       style({ width: 0 }),
 *       animate(1000, style({ width: '100px' }))
 *     ]);
 *
 *     // then create a player from it
 *     const player = myAnimation.create(element);
 *
 *     player.play();
 *   }
 * }
 * ```
 *
 * When an animation is built an instance of {\@link AnimationFactory AnimationFactory} will be
 * returned. Using that an {\@link AnimationPlayer AnimationPlayer} can be created which can then be
 * used to start the animation.
 *
 * \@experimental Animation support is experimental.
 * @abstract
 */
var AnimationBuilder = (function () {
    function AnimationBuilder() {
    }
    /**
     * @abstract
     * @param {?} animation
     * @return {?}
     */
    AnimationBuilder.prototype.build = function (animation) { };
    return AnimationBuilder;
}());
/**
 * An instance of `AnimationFactory` is returned from {\@link AnimationBuilder#build
 * AnimationBuilder.build}.
 *
 * \@experimental Animation support is experimental.
 * @abstract
 */
var AnimationFactory = (function () {
    function AnimationFactory() {
    }
    /**
     * @abstract
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    AnimationFactory.prototype.create = function (element, options) { };
    return AnimationFactory;
}());
/**
 * \@experimental Animation support is experimental.
 */
var AUTO_STYLE = '*';
/**
 * `trigger` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the
 * {\@link Component#animations component animations metadata page} to gain a better
 * understanding of how animations in Angular are used.
 *
 * `trigger` Creates an animation trigger which will a list of {\@link state state} and
 * {\@link transition transition} entries that will be evaluated when the expression
 * bound to the trigger changes.
 *
 * Triggers are registered within the component annotation data under the
 * {\@link Component#animations animations section}. An animation trigger can be placed on an element
 * within a template by referencing the name of the trigger followed by the expression value that
 * the
 * trigger is bound to (in the form of `[\@triggerName]="expression"`.
 *
 * ### Usage
 *
 * `trigger` will create an animation trigger reference based on the provided `name` value. The
 * provided `animation` value is expected to be an array consisting of {\@link state state} and
 * {\@link transition transition} declarations.
 *
 * ```typescript
 * \@Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *       state(...),
 *       state(...),
 *       transition(...),
 *       transition(...)
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "something";
 * }
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger` animation
 * trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [\@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * ## Disable Child Animations
 * A special animation control binding called `\@.disabled` can be placed on an element which will
 * then disable animations for any inner animation triggers situated within the element.
 *
 * When true, the `\@.disabled` binding will prevent inner animations from rendering. The example
 * below shows how to use this feature:
 *
 * ```ts
 * \@Component({
 *   selector: 'my-component',
 *   template: `
 *     <div [\@.disabled]="isDisabled">
 *       <div [\@childAnimation]="exp"></div>
 *     </div>
 *   `,
 *   animations: [
 *     trigger("childAnimation", [
 *       // ...
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   isDisabled = true;
 *   exp = '...';
 * }
 * ```
 *
 * The `\@childAnimation` trigger will not animate because `\@.disabled` prevents it from happening
 * (when true).
 *
 * Note that `\@.disbled` will only disable inner animations (any animations running on the same
 * element will not be disabled).
 *
 * ### Disabling Animations Application-wide
 * When an area of the template is set to have animations disabled, **all** inner components will
 * also have their animations disabled as well. This means that all animations for an angular
 * application can be disabled by placing a host binding set on `\@.disabled` on the topmost Angular
 * component.
 *
 * ```ts
 * import {Component, HostBinding} from '\@angular/core';
 *
 * \@Component({
 *   selector: 'app-component',
 *   templateUrl: 'app.component.html',
 * })
 * class AppComponent {
 *   \@HostBinding('\@.disabled')
 *   public animationsDisabled = true;
 * }
 * ```
 *
 * ### What about animations that us `query()` and `animateChild()`?
 * Despite inner animations being disabled, a parent animation can {\@link query query} for inner
 * elements located in disabled areas of the template and still animate them as it sees fit. This is
 * also the case for when a sub animation is queried by a parent and then later animated using {\@link
 * animateChild animateChild}.
 *
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} definitions
 * @return {?}
 */
function trigger(name, definitions) {
    return { type: 7 /* Trigger */, name: name, definitions: definitions, options: {} };
}
/**
 * `animate` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `animate` specifies an animation step that will apply the provided `styles` data for a given
 * amount of time based on the provided `timing` expression value. Calls to `animate` are expected
 * to be used within {\@link sequence an animation sequence}, {\@link group group}, or {\@link
 * transition transition}.
 *
 * ### Usage
 *
 * The `animate` function accepts two input parameters: `timing` and `styles`:
 *
 * - `timing` is a string based value that can be a combination of a duration with optional delay
 * and easing values. The format for the expression breaks down to `duration delay easing`
 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
 * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the
 * `duration` value in millisecond form.
 * - `styles` is the style input data which can either be a call to {\@link style style} or {\@link
 * keyframes keyframes}. If left empty then the styles from the destination state will be collected
 * and used (this is useful when describing an animation step that will complete an animation by
 * {\@link transition#the-final-animate-call animating to the final state}).
 *
 * ```typescript
 * // various functions for specifying timing data
 * animate(500, style(...))
 * animate("1s", style(...))
 * animate("100ms 0.5s", style(...))
 * animate("5s ease", style(...))
 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
 *
 * // either style() of keyframes() can be used
 * animate(500, style({ background: "red" }))
 * animate(500, keyframes([
 *   style({ background: "blue" })),
 *   style({ background: "red" }))
 * ])
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} timings
 * @param {?=} styles
 * @return {?}
 */
function animate(timings, styles) {
    if (styles === void 0) { styles = null; }
    return { type: 4 /* Animate */, styles: styles, timings: timings };
}
/**
 * `group` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are
 * useful when a series of styles must be animated/closed off at different starting/ending times.
 *
 * The `group` function can either be used within a {\@link sequence sequence} or a {\@link transition
 * transition} and it will only continue to the next instruction once all of the inner animation
 * steps have completed.
 *
 * ### Usage
 *
 * The `steps` data that is passed into the `group` animation function can either consist of {\@link
 * style style} or {\@link animate animate} function calls. Each call to `style()` or `animate()`
 * within a group will be executed instantly (use {\@link keyframes keyframes} or a {\@link
 * animate#usage animate() with a delay value} to offset styles to be applied at a later time).
 *
 * ```typescript
 * group([
 *   animate("1s", { background: "black" }))
 *   animate("2s", { color: "white" }))
 * ])
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} steps
 * @param {?=} options
 * @return {?}
 */
function group(steps, options) {
    if (options === void 0) { options = null; }
    return { type: 3 /* Group */, steps: steps, options: options };
}
/**
 * `sequence` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by
 * default when an array is passed as animation data into {\@link transition transition}.)
 *
 * The `sequence` function can either be used within a {\@link group group} or a {\@link transition
 * transition} and it will only continue to the next instruction once each of the inner animation
 * steps have completed.
 *
 * To perform animation styling in parallel with other animation steps then have a look at the
 * {\@link group group} animation function.
 *
 * ### Usage
 *
 * The `steps` data that is passed into the `sequence` animation function can either consist of
 * {\@link style style} or {\@link animate animate} function calls. A call to `style()` will apply the
 * provided styling data immediately while a call to `animate()` will apply its styling data over a
 * given time depending on its timing data.
 *
 * ```typescript
 * sequence([
 *   style({ opacity: 0 })),
 *   animate("1s", { opacity: 1 }))
 * ])
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} steps
 * @param {?=} options
 * @return {?}
 */
function sequence(steps, options) {
    if (options === void 0) { options = null; }
    return { type: 2 /* Sequence */, steps: steps, options: options };
}
/**
 * `style` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `style` declares a key/value object containing CSS properties/styles that can then be used for
 * {\@link state animation states}, within an {\@link sequence animation sequence}, or as styling data
 * for both {\@link animate animate} and {\@link keyframes keyframes}.
 *
 * ### Usage
 *
 * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs
 * to be defined.
 *
 * ```typescript
 * // string values are used for css properties
 * style({ background: "red", color: "blue" })
 *
 * // numerical (pixel) values are also supported
 * style({ width: 100, height: 0 })
 * ```
 *
 * #### Auto-styles (using `*`)
 *
 * When an asterix (`*`) character is used as a value then it will be detected from the element
 * being animated and applied as animation data when the animation starts.
 *
 * This feature proves useful for a state depending on layout and/or environment factors; in such
 * cases the styles are calculated just before the animation starts.
 *
 * ```typescript
 * // the steps below will animate from 0 to the
 * // actual height of the element
 * style({ height: 0 }),
 * animate("1s", style({ height: "*" }))
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} tokens
 * @return {?}
 */
function style(tokens) {
    return { type: 6 /* Style */, styles: tokens, offset: null };
}
/**
 * `state` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `state` declares an animation state within the given trigger. When a state is active within a
 * component then its associated styles will persist on the element that the trigger is attached to
 * (even when the animation ends).
 *
 * To animate between states, have a look at the animation {\@link transition transition} DSL
 * function. To register states to an animation trigger please have a look at the {\@link trigger
 * trigger} function.
 *
 * #### The `void` state
 *
 * The `void` state value is a reserved word that angular uses to determine when the element is not
 * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
 * associated element is void).
 *
 * #### The `*` (default) state
 *
 * The `*` state (when styled) is a fallback state that will be used if the state that is being
 * animated is not declared within the trigger.
 *
 * ### Usage
 *
 * `state` will declare an animation state with its associated styles
 * within the given trigger.
 *
 * - `stateNameExpr` can be one or more state names separated by commas.
 * - `styles` refers to the {\@link style styling data} that will be persisted on the element once
 * the state has been reached.
 *
 * ```typescript
 * // "void" is a reserved name for a state and is used to represent
 * // the state in which an element is detached from from the application.
 * state("void", style({ height: 0 }))
 *
 * // user-defined states
 * state("closed", style({ height: 0 }))
 * state("open, visible", style({ height: "*" }))
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} styles
 * @return {?}
 */
function state(name, styles) {
    return { type: 0 /* State */, name: name, styles: styles };
}
/**
 * `keyframes` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `keyframes` specifies a collection of {\@link style style} entries each optionally characterized
 * by an `offset` value.
 *
 * ### Usage
 *
 * The `keyframes` animation function is designed to be used alongside the {\@link animate animate}
 * animation function. Instead of applying animations from where they are currently to their
 * destination, keyframes can describe how each style entry is applied and at what point within the
 * animation arc (much like CSS Keyframe Animations do).
 *
 * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at what
 * percentage of the animate time the styles will be applied.
 *
 * ```typescript
 * // the provided offset values describe when each backgroundColor value is applied.
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red", offset: 0 }),
 *   style({ backgroundColor: "blue", offset: 0.2 }),
 *   style({ backgroundColor: "orange", offset: 0.3 }),
 *   style({ backgroundColor: "black", offset: 1 })
 * ]))
 * ```
 *
 * Alternatively, if there are no `offset` values used within the style entries then the offsets
 * will be calculated automatically.
 *
 * ```typescript
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red" }) // offset = 0
 *   style({ backgroundColor: "blue" }) // offset = 0.33
 *   style({ backgroundColor: "orange" }) // offset = 0.66
 *   style({ backgroundColor: "black" }) // offset = 1
 * ]))
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} steps
 * @return {?}
 */
function keyframes(steps) {
    return { type: 5 /* Keyframes */, steps: steps };
}
/**
 * `transition` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `transition` declares the {\@link sequence sequence of animation steps} that will be run when the
 * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>
 * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting
 * and/or ending state).
 *
 * A function can also be provided as the `stateChangeExpr` argument for a transition and this
 * function will be executed each time a state change occurs. If the value returned within the
 * function is true then the associated animation will be run.
 *
 * Animation transitions are placed within an {\@link trigger animation trigger}. For an transition
 * to animate to a state value and persist its styles then one or more {\@link state animation
 * states} is expected to be defined.
 *
 * ### Usage
 *
 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
 * what the previous state is and what the current state has become. In other words, if a transition
 * is defined that matches the old/current state criteria then the associated animation will be
 * triggered.
 *
 * ```typescript
 * // all transition/state changes are defined within an animation trigger
 * trigger("myAnimationTrigger", [
 *   // if a state is defined then its styles will be persisted when the
 *   // animation has fully completed itself
 *   state("on", style({ background: "green" })),
 *   state("off", style({ background: "grey" })),
 *
 *   // a transition animation that will be kicked off when the state value
 *   // bound to "myAnimationTrigger" changes from "on" to "off"
 *   transition("on => off", animate(500)),
 *
 *   // it is also possible to do run the same animation for both directions
 *   transition("on <=> off", animate(500)),
 *
 *   // or to define multiple states pairs separated by commas
 *   transition("on => off, off => void", animate(500)),
 *
 *   // this is a catch-all state change for when an element is inserted into
 *   // the page and the destination state is unknown
 *   transition("void => *", [
 *     style({ opacity: 0 }),
 *     animate(500)
 *   ]),
 *
 *   // this will capture a state change between any states
 *   transition("* => *", animate("1s 0s")),
 *
 *   // you can also go full out and include a function
 *   transition((fromState, toState) => {
 *     // when `true` then it will allow the animation below to be invoked
 *     return fromState == "off" && toState == "on";
 *   }, animate("1s 0s"))
 * ])
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger` animation
 * trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [\@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * #### The final `animate` call
 *
 * If the final step within the transition steps is a call to `animate()` that **only** uses a
 * timing value with **no style data** then it will be automatically used as the final animation arc
 * for the element to animate itself to the final state. This involves an automatic mix of
 * adding/removing CSS styles so that the element will be in the exact state it should be for the
 * applied state to be presented correctly.
 *
 * ```
 * // start off by hiding the element, but make sure that it animates properly to whatever state
 * // is currently active for "myAnimationTrigger"
 * transition("void => *", [
 *   style({ opacity: 0 }),
 *   animate(500)
 * ])
 * ```
 *
 * ### Transition Aliases (`:enter` and `:leave`)
 *
 * Given that enter (insertion) and leave (removal) animations are so common, the `transition`
 * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*
 * => void` state changes.
 *
 * ```
 * transition(":enter", [
 *   style({ opacity: 0 }),
 *   animate(500, style({ opacity: 1 }))
 * ])
 * transition(":leave", [
 *   animate(500, style({ opacity: 0 }))
 * ])
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} stateChangeExpr
 * @param {?} steps
 * @param {?=} options
 * @return {?}
 */
function transition(stateChangeExpr, steps, options) {
    if (options === void 0) { options = null; }
    return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps, options: options };
}
/**
 * `animation` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language.
 *
 * `var myAnimation = animation(...)` is designed to produce a reusable animation that can be later
 * invoked in another animation or sequence. Reusable animations are designed to make use of
 * animation parameters and the produced animation can be used via the `useAnimation` method.
 *
 * ```
 * var fadeAnimation = animation([
 *   style({ opacity: '{{ start }}' }),
 *   animate('{{ time }}',
 *     style({ opacity: '{{ end }}'))
 * ], { params: { time: '1000ms', start: 0, end: 1 }});
 * ```
 *
 * If parameters are attached to an animation then they act as **default parameter values**. When an
 * animation is invoked via `useAnimation` then parameter values are allowed to be passed in
 * directly. If any of the passed in parameter values are missing then the default values will be
 * used.
 *
 * ```
 * useAnimation(fadeAnimation, {
 *   params: {
 *     time: '2s',
 *     start: 1,
 *     end: 0
 *   }
 * })
 * ```
 *
 * If one or more parameter values are missing before animated then an error will be thrown.
 *
 * \@experimental Animation support is experimental.
 * @param {?} steps
 * @param {?=} options
 * @return {?}
 */
function animation(steps, options) {
    if (options === void 0) { options = null; }
    return { type: 8 /* Reference */, animation: steps, options: options };
}
/**
 * `animateChild` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. It works by allowing a queried element to execute its own
 * animation within the animation sequence.
 *
 * Each time an animation is triggered in angular, the parent animation
 * will always get priority and any child animations will be blocked. In order
 * for a child animation to run, the parent animation must query each of the elements
 * containing child animations and then allow the animations to run using `animateChild`.
 *
 * The example HTML code below shows both parent and child elements that have animation
 * triggers that will execute at the same time.
 *
 * ```html
 * <!-- parent-child.component.html -->
 * <button (click)="exp =! exp">Toggle</button>
 * <hr>
 *
 * <div [\@parentAnimation]="exp">
 *   <header>Hello</header>
 *   <div [\@childAnimation]="exp">
 *       one
 *   </div>
 *   <div [\@childAnimation]="exp">
 *       two
 *   </div>
 *   <div [\@childAnimation]="exp">
 *       three
 *   </div>
 * </div>
 * ```
 *
 * Now when the `exp` value changes to true, only the `parentAnimation` animation will animate
 * because it has priority. However, using `query` and `animateChild` each of the inner animations
 * can also fire:
 *
 * ```ts
 * // parent-child.component.ts
 * import {trigger, transition, animate, style, query, animateChild} from '\@angular/animations';
 * \@Component({
 *   selector: 'parent-child-component',
 *   animations: [
 *     trigger('parentAnimation', [
 *       transition('false => true', [
 *         query('header', [
 *           style({ opacity: 0 }),
 *           animate(500, style({ opacity: 1 }))
 *         ]),
 *         query('\@childAnimation', [
 *           animateChild()
 *         ])
 *       ])
 *     ]),
 *     trigger('childAnimation', [
 *       transition('false => true', [
 *         style({ opacity: 0 }),
 *         animate(500, style({ opacity: 1 }))
 *       ])
 *     ])
 *   ]
 * })
 * class ParentChildCmp {
 *   exp: boolean = false;
 * }
 * ```
 *
 * In the animation code above, when the `parentAnimation` transition kicks off it first queries to
 * find the header element and fades it in. It then finds each of the sub elements that contain the
 * `\@childAnimation` trigger and then allows for their animations to fire.
 *
 * This example can be further extended by using stagger:
 *
 * ```ts
 * query('\@childAnimation', stagger(100, [
 *   animateChild()
 * ]))
 * ```
 *
 * Now each of the sub animations start off with respect to the `100ms` staggering step.
 *
 * ## The first frame of child animations
 * When sub animations are executed using `animateChild` the animation engine will always apply the
 * first frame of every sub animation immediately at the start of the animation sequence. This way
 * the parent animation does not need to set any initial styling data on the sub elements before the
 * sub animations kick off.
 *
 * In the example above the first frame of the `childAnimation`'s `false => true` transition
 * consists of a style of `opacity: 0`. This is applied immediately when the `parentAnimation`
 * animation transition sequence starts. Only then when the `\@childAnimation` is queried and called
 * with `animateChild` will it then animate to its destination of `opacity: 1`.
 *
 * Note that this feature designed to be used alongside {\@link query query()} and it will only work
 * with animations that are assigned using the Angular animation DSL (this means that CSS keyframes
 * and transitions are not handled by this API).
 *
 * \@experimental Animation support is experimental.
 * @param {?=} options
 * @return {?}
 */
function animateChild(options) {
    if (options === void 0) { options = null; }
    return { type: 9 /* AnimateChild */, options: options };
}
/**
 * `useAnimation` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. It is used to kick off a reusable animation that is created using {\@link
 * animation animation()}.
 *
 * \@experimental Animation support is experimental.
 * @param {?} animation
 * @param {?=} options
 * @return {?}
 */
function useAnimation(animation, options) {
    if (options === void 0) { options = null; }
    return { type: 10 /* AnimateRef */, animation: animation, options: options };
}
/**
 * `query` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language.
 *
 * query() is used to find one or more inner elements within the current element that is
 * being animated within the sequence. The provided animation steps are applied
 * to the queried element (by default, an array is provided, then this will be
 * treated as an animation sequence).
 *
 * ### Usage
 *
 * query() is designed to collect mutiple elements and works internally by using
 * `element.querySelectorAll`. An additional options object can be provided which
 * can be used to limit the total amount of items to be collected.
 *
 * ```js
 * query('div', [
 *   animate(...),
 *   animate(...)
 * ], { limit: 1 })
 * ```
 *
 * query(), by default, will throw an error when zero items are found. If a query
 * has the `optional` flag set to true then this error will be ignored.
 *
 * ```js
 * query('.some-element-that-may-not-be-there', [
 *   animate(...),
 *   animate(...)
 * ], { optional: true })
 * ```
 *
 * ### Special Selector Values
 *
 * The selector value within a query can collect elements that contain angular-specific
 * characteristics
 * using special pseudo-selectors tokens.
 *
 * These include:
 *
 *  - Querying for newly inserted/removed elements using `query(":enter")`/`query(":leave")`
 *  - Querying all currently animating elements using `query(":animating")`
 *  - Querying elements that contain an animation trigger using `query("\@triggerName")`
 *  - Querying all elements that contain an animation triggers using `query("\@*")`
 *  - Including the current element into the animation sequence using `query(":self")`
 *
 *
 *  Each of these pseudo-selector tokens can be merged together into a combined query selector
 * string:
 *
 *  ```
 *  query(':self, .record:enter, .record:leave, \@subTrigger', [...])
 *  ```
 *
 * ### Demo
 *
 * ```
 * \@Component({
 *   selector: 'inner',
 *   template: `
 *     <div [\@queryAnimation]="exp">
 *       <h1>Title</h1>
 *       <div class="content">
 *         Blah blah blah
 *       </div>
 *     </div>
 *   `,
 *   animations: [
 *    trigger('queryAnimation', [
 *      transition('* => goAnimate', [
 *        // hide the inner elements
 *        query('h1', style({ opacity: 0 })),
 *        query('.content', style({ opacity: 0 })),
 *
 *        // animate the inner elements in, one by one
 *        query('h1', animate(1000, style({ opacity: 1 })),
 *        query('.content', animate(1000, style({ opacity: 1 })),
 *      ])
 *    ])
 *  ]
 * })
 * class Cmp {
 *   exp = '';
 *
 *   goAnimate() {
 *     this.exp = 'goAnimate';
 *   }
 * }
 * ```
 *
 * \@experimental Animation support is experimental.
 * @param {?} selector
 * @param {?} animation
 * @param {?=} options
 * @return {?}
 */
function query(selector, animation, options) {
    if (options === void 0) { options = null; }
    return { type: 11 /* Query */, selector: selector, animation: animation, options: options };
}
/**
 * `stagger` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. It is designed to be used inside of an animation {\@link query query()}
 * and works by issuing a timing gap between after each queried item is animated.
 *
 * ### Usage
 *
 * In the example below there is a container element that wraps a list of items stamped out
 * by an ngFor. The container element contains an animation trigger that will later be set
 * to query for each of the inner items.
 *
 * ```html
 * <!-- list.component.html -->
 * <button (click)="toggle()">Show / Hide Items</button>
 * <hr />
 * <div [\@listAnimation]="items.length">
 *   <div *ngFor="let item of items">
 *     {{ item }}
 *   </div>
 * </div>
 * ```
 *
 * The component code for this looks as such:
 *
 * ```ts
 * import {trigger, transition, style, animate, query, stagger} from '\@angular/animations';
 * \@Component({
 *   templateUrl: 'list.component.html',
 *   animations: [
 *     trigger('listAnimation', [
 *        //...
 *     ])
 *   ]
 * })
 * class ListComponent {
 *   items = [];
 *
 *   showItems() {
 *     this.items = [0,1,2,3,4];
 *   }
 *
 *   hideItems() {
 *     this.items = [];
 *   }
 *
 *   toggle() {
 *     this.items.length ? this.hideItems() : this.showItems();
 *   }
 * }
 * ```
 *
 * And now for the animation trigger code:
 *
 * ```ts
 * trigger('listAnimation', [
 *   transition('* => *', [ // each time the binding value changes
 *     query(':leave', [
 *       stagger(100, [
 *         animate('0.5s', style({ opacity: 0 }))
 *       ])
 *     ]),
 *     query(':enter', [
 *       style({ opacity: 0 }),
 *       stagger(100, [
 *         animate('0.5s', style({ opacity: 1 }))
 *       ])
 *     ])
 *   ])
 * ])
 * ```
 *
 * Now each time the items are added/removed then either the opacity
 * fade-in animation will run or each removed item will be faded out.
 * When either of these animations occur then a stagger effect will be
 * applied after each item's animation is started.
 *
 * \@experimental Animation support is experimental.
 * @param {?} timings
 * @param {?} animation
 * @return {?}
 */
function stagger(timings, animation) {
    return { type: 12 /* Stagger */, timings: timings, animation: animation };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 * @param {?} cb
 * @return {?}
 */
function scheduleMicroTask(cb) {
    Promise.resolve(null).then(cb);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationPlayer = (function () {
    function NoopAnimationPlayer() {
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._started = false;
        this._destroyed = false;
        this._finished = false;
        this.parentPlayer = null;
        this.totalTime = 0;
    }
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype._onFinish = function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NoopAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    NoopAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    NoopAnimationPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.hasStarted = function () { return this._started; };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.init = function () { };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.play = function () {
        if (!this.hasStarted()) {
            this.triggerMicrotask();
            this._onStart();
        }
        this._started = true;
    };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.triggerMicrotask = function () {
        var _this = this;
        scheduleMicroTask(function () { return _this._onFinish(); });
    };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype._onStart = function () {
        this._onStartFns.forEach(function (fn) { return fn(); });
        this._onStartFns = [];
    };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.pause = function () { };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.restart = function () { };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.finish = function () { this._onFinish(); };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.destroy = function () {
        if (!this._destroyed) {
            this._destroyed = true;
            if (!this.hasStarted()) {
                this._onStart();
            }
            this.finish();
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.reset = function () { };
    /**
     * @param {?} p
     * @return {?}
     */
    NoopAnimationPlayer.prototype.setPosition = function (p) { };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.getPosition = function () { return 0; };
    return NoopAnimationPlayer;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var AnimationGroupPlayer = (function () {
    /**
     * @param {?} _players
     */
    function AnimationGroupPlayer(_players) {
        var _this = this;
        this._players = _players;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this._onDestroyFns = [];
        this.parentPlayer = null;
        this.totalTime = 0;
        var doneCount = 0;
        var destroyCount = 0;
        var startCount = 0;
        var total = this._players.length;
        if (total == 0) {
            scheduleMicroTask(function () { return _this._onFinish(); });
        }
        else {
            this._players.forEach(function (player) {
                player.parentPlayer = _this;
                player.onDone(function () {
                    if (++doneCount >= total) {
                        _this._onFinish();
                    }
                });
                player.onDestroy(function () {
                    if (++destroyCount >= total) {
                        _this._onDestroy();
                    }
                });
                player.onStart(function () {
                    if (++startCount >= total) {
                        _this._onStart();
                    }
                });
            });
        }
        this.totalTime = this._players.reduce(function (time, player) { return Math.max(time, player.totalTime); }, 0);
    }
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype._onFinish = function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
    /**
     * @param {?} fn
     * @return {?}
     */
    AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype._onStart = function () {
        if (!this.hasStarted()) {
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
            this._started = true;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    AnimationGroupPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.play = function () {
        if (!this.parentPlayer) {
            this.init();
        }
        this._onStart();
        this._players.forEach(function (player) { return player.play(); });
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.finish = function () {
        this._onFinish();
        this._players.forEach(function (player) { return player.finish(); });
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.destroy = function () { this._onDestroy(); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype._onDestroy = function () {
        if (!this._destroyed) {
            this._destroyed = true;
            this._onFinish();
            this._players.forEach(function (player) { return player.destroy(); });
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.reset = function () {
        this._players.forEach(function (player) { return player.reset(); });
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    /**
     * @param {?} p
     * @return {?}
     */
    AnimationGroupPlayer.prototype.setPosition = function (p) {
        var /** @type {?} */ timeAtPosition = p * this.totalTime;
        this._players.forEach(function (player) {
            var /** @type {?} */ position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
            player.setPosition(position);
        });
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.getPosition = function () {
        var /** @type {?} */ min = 0;
        this._players.forEach(function (player) {
            var /** @type {?} */ p = player.getPosition();
            min = Math.min(p, min);
        });
        return min;
    };
    Object.defineProperty(AnimationGroupPlayer.prototype, "players", {
        /**
         * @return {?}
         */
        get: function () { return this._players; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.beforeDestroy = function () {
        this.players.forEach(function (player) {
            if (player.beforeDestroy) {
                player.beforeDestroy();
            }
        });
    };
    return AnimationGroupPlayer;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ɵPRE_STYLE = '!';
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all animation APIs of the animation package.
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the animation package.
 */
/**
 * Generated bundle index. Do not edit.
 */

//# sourceMappingURL=animations.es5.js.map


/***/ }),

/***/ "./node_modules/@angular/animations/@angular/animations/browser.es5.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("./node_modules/tslib/tslib.es6.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return AnimationDriver; });
/* unused harmony export ɵAnimation */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return AnimationStyleNormalizer; });
/* unused harmony export ɵNoopAnimationStyleNormalizer */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return WebAnimationsStyleNormalizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return NoopAnimationDriver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AnimationEngine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return WebAnimationsDriver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return supportsWebAnimations; });
/* unused harmony export ɵWebAnimationsPlayer */

/**
 * @license Angular v4.3.3
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function optimizeGroupPlayer(players) {
    switch (players.length) {
        case 0:
            return new __WEBPACK_IMPORTED_MODULE_1__angular_animations__["NoopAnimationPlayer"]();
        case 1:
            return players[0];
        default:
            return new __WEBPACK_IMPORTED_MODULE_1__angular_animations__["ɵAnimationGroupPlayer"](players);
    }
}
function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {
    if (preStyles === void 0) { preStyles = {}; }
    if (postStyles === void 0) { postStyles = {}; }
    var errors = [];
    var normalizedKeyframes = [];
    var previousOffset = -1;
    var previousKeyframe = null;
    keyframes.forEach(function (kf) {
        var offset = kf['offset'];
        var isSameOffset = offset == previousOffset;
        var normalizedKeyframe = (isSameOffset && previousKeyframe) || {};
        Object.keys(kf).forEach(function (prop) {
            var normalizedProp = prop;
            var normalizedValue = kf[prop];
            if (prop !== 'offset') {
                normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
                switch (normalizedValue) {
                    case __WEBPACK_IMPORTED_MODULE_1__angular_animations__["ɵPRE_STYLE"]:
                        normalizedValue = preStyles[prop];
                        break;
                    case __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"]:
                        normalizedValue = postStyles[prop];
                        break;
                    default:
                        normalizedValue =
                            normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                        break;
                }
            }
            normalizedKeyframe[normalizedProp] = normalizedValue;
        });
        if (!isSameOffset) {
            normalizedKeyframes.push(normalizedKeyframe);
        }
        previousKeyframe = normalizedKeyframe;
        previousOffset = offset;
    });
    if (errors.length) {
        var LINE_START = '\n - ';
        throw new Error("Unable to animate due to the following errors:" + LINE_START + errors.join(LINE_START));
    }
    return normalizedKeyframes;
}
function listenOnPlayer(player, eventName, event, callback) {
    switch (eventName) {
        case 'start':
            player.onStart(function () { return callback(event && copyAnimationEvent(event, 'start', player.totalTime)); });
            break;
        case 'done':
            player.onDone(function () { return callback(event && copyAnimationEvent(event, 'done', player.totalTime)); });
            break;
        case 'destroy':
            player.onDestroy(function () { return callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)); });
            break;
    }
}
function copyAnimationEvent(e, phaseName, totalTime) {
    var event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime);
    var data = e['_data'];
    if (data != null) {
        event['_data'] = data;
    }
    return event;
}
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime) {
    if (phaseName === void 0) { phaseName = ''; }
    if (totalTime === void 0) { totalTime = 0; }
    return { element: element, triggerName: triggerName, fromState: fromState, toState: toState, phaseName: phaseName, totalTime: totalTime };
}
function getOrSetAsInMap(map, key, defaultValue) {
    var value;
    if (map instanceof Map) {
        value = map.get(key);
        if (!value) {
            map.set(key, value = defaultValue);
        }
    }
    else {
        value = map[key];
        if (!value) {
            value = map[key] = defaultValue;
        }
    }
    return value;
}
function parseTimelineCommand(command) {
    var separatorPos = command.indexOf(':');
    var id = command.substring(1, separatorPos);
    var action = command.substr(separatorPos + 1);
    return [id, action];
}
var _contains = function (elm1, elm2) { return false; };
var _matches = function (element, selector) { return false; };
var _query = function (element, selector, multi) {
    return [];
};
if (typeof Element != 'undefined') {
    // this is well supported in all browsers
    _contains = function (elm1, elm2) { return elm1.contains(elm2); };
    if (Element.prototype.matches) {
        _matches = function (element, selector) { return element.matches(selector); };
    }
    else {
        var proto = Element.prototype;
        var fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||
            proto.oMatchesSelector || proto.webkitMatchesSelector;
        if (fn_1) {
            _matches = function (element, selector) { return fn_1.apply(element, [selector]); };
        }
    }
    _query = function (element, selector, multi) {
        var results = [];
        if (multi) {
            results.push.apply(results, element.querySelectorAll(selector));
        }
        else {
            var elm = element.querySelector(selector);
            if (elm) {
                results.push(elm);
            }
        }
        return results;
    };
}
var matchesElement = _matches;
var containsElement = _contains;
var invokeQuery = _query;
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @experimental
 */
var NoopAnimationDriver = (function () {
    function NoopAnimationDriver() {
    }
    NoopAnimationDriver.prototype.matchesElement = function (element, selector) {
        return matchesElement(element, selector);
    };
    NoopAnimationDriver.prototype.containsElement = function (elm1, elm2) { return containsElement(elm1, elm2); };
    NoopAnimationDriver.prototype.query = function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    NoopAnimationDriver.prototype.computeStyle = function (element, prop, defaultValue) {
        return defaultValue || '';
    };
    NoopAnimationDriver.prototype.animate = function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        return new __WEBPACK_IMPORTED_MODULE_1__angular_animations__["NoopAnimationPlayer"]();
    };
    return NoopAnimationDriver;
}());
/**
 * @experimental
 */
var AnimationDriver = (function () {
    function AnimationDriver() {
    }
    return AnimationDriver;
}());
AnimationDriver.NOOP = new NoopAnimationDriver();
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ONE_SECOND = 1000;
var ENTER_CLASSNAME = 'ng-enter';
var LEAVE_CLASSNAME = 'ng-leave';
var ENTER_SELECTOR = '.ng-enter';
var LEAVE_SELECTOR = '.ng-leave';
var NG_TRIGGER_CLASSNAME = 'ng-trigger';
var NG_TRIGGER_SELECTOR = '.ng-trigger';
var NG_ANIMATING_CLASSNAME = 'ng-animating';
var NG_ANIMATING_SELECTOR = '.ng-animating';
function resolveTimingValue(value) {
    if (typeof value == 'number')
        return value;
    var matches = value.match(/^(-?[\.\d]+)(m?s)/);
    if (!matches || matches.length < 2)
        return 0;
    return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
function _convertTimeValueToMS(value, unit) {
    switch (unit) {
        case 's':
            return value * ONE_SECOND;
        default:
            return value;
    }
}
function resolveTiming(timings, errors, allowNegativeValues) {
    return timings.hasOwnProperty('duration') ?
        timings :
        parseTimeExpression(timings, errors, allowNegativeValues);
}
function parseTimeExpression(exp, errors, allowNegativeValues) {
    var regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
    var duration;
    var delay = 0;
    var easing = '';
    if (typeof exp === 'string') {
        var matches = exp.match(regex);
        if (matches === null) {
            errors.push("The provided timing value \"" + exp + "\" is invalid.");
            return { duration: 0, delay: 0, easing: '' };
        }
        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
        var delayMatch = matches[3];
        if (delayMatch != null) {
            delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);
        }
        var easingVal = matches[5];
        if (easingVal) {
            easing = easingVal;
        }
    }
    else {
        duration = exp;
    }
    if (!allowNegativeValues) {
        var containsErrors = false;
        var startIndex = errors.length;
        if (duration < 0) {
            errors.push("Duration values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (delay < 0) {
            errors.push("Delay values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (containsErrors) {
            errors.splice(startIndex, 0, "The provided timing value \"" + exp + "\" is invalid.");
        }
    }
    return { duration: duration, delay: delay, easing: easing };
}
function copyObj(obj, destination) {
    if (destination === void 0) { destination = {}; }
    Object.keys(obj).forEach(function (prop) { destination[prop] = obj[prop]; });
    return destination;
}
function normalizeStyles(styles) {
    var normalizedStyles = {};
    if (Array.isArray(styles)) {
        styles.forEach(function (data) { return copyStyles(data, false, normalizedStyles); });
    }
    else {
        copyStyles(styles, false, normalizedStyles);
    }
    return normalizedStyles;
}
function copyStyles(styles, readPrototype, destination) {
    if (destination === void 0) { destination = {}; }
    if (readPrototype) {
        // we make use of a for-in loop so that the
        // prototypically inherited properties are
        // revealed from the backFill map
        for (var prop in styles) {
            destination[prop] = styles[prop];
        }
    }
    else {
        copyObj(styles, destination);
    }
    return destination;
}
function setStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = styles[prop];
        });
    }
}
function eraseStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = '';
        });
    }
}
function normalizeAnimationEntry(steps) {
    if (Array.isArray(steps)) {
        if (steps.length == 1)
            return steps[0];
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["sequence"])(steps);
    }
    return steps;
}
function validateStyleParams(value, options, errors) {
    var params = options.params || {};
    if (typeof value !== 'string')
        return;
    var matches = value.toString().match(PARAM_REGEX);
    if (matches) {
        matches.forEach(function (varName) {
            if (!params.hasOwnProperty(varName)) {
                errors.push("Unable to resolve the local animation param " + varName + " in the given list of values");
            }
        });
    }
}
var PARAM_REGEX = /\{\{\s*(.+?)\s*\}\}/g;
function interpolateParams(value, params, errors) {
    var original = value.toString();
    var str = original.replace(PARAM_REGEX, function (_, varName) {
        var localVal = params[varName];
        // this means that the value was never overidden by the data passed in by the user
        if (!params.hasOwnProperty(varName)) {
            errors.push("Please provide a value for the animation param " + varName);
            localVal = '';
        }
        return localVal.toString();
    });
    // we do this to assert that numeric values stay as they are
    return str == original ? value : str;
}
function iteratorToArray(iterator) {
    var arr = [];
    var item = iterator.next();
    while (!item.done) {
        arr.push(item.value);
        item = iterator.next();
    }
    return arr;
}
function mergeAnimationOptions(source, destination) {
    if (source.params) {
        var p0_1 = source.params;
        if (!destination.params) {
            destination.params = {};
        }
        var p1_1 = destination.params;
        Object.keys(p0_1).forEach(function (param) {
            if (!p1_1.hasOwnProperty(param)) {
                p1_1[param] = p0_1[param];
            }
        });
    }
    return destination;
}
var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, function () {
        var m = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            m[_i] = arguments[_i];
        }
        return m[1].toUpperCase();
    });
}
function allowPreviousPlayerStylesMerge(duration, delay) {
    return duration === 0 || delay === 0;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_ANIMATION_OPTIONS = {};
/**
 * @abstract
 */
var Ast = (function () {
    function Ast() {
        this.options = EMPTY_ANIMATION_OPTIONS;
    }
    /**
     * @abstract
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    Ast.prototype.visit = function (ast, context) { };
    Object.defineProperty(Ast.prototype, "params", {
        /**
         * @return {?}
         */
        get: function () { return this.options['params'] || null; },
        enumerable: true,
        configurable: true
    });
    return Ast;
}());
var TriggerAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](TriggerAst, _super);
    /**
     * @param {?} name
     * @param {?} states
     * @param {?} transitions
     */
    function TriggerAst(name, states, transitions) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.states = states;
        _this.transitions = transitions;
        _this.queryCount = 0;
        _this.depCount = 0;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TriggerAst.prototype.visit = function (visitor, context) { return visitor.visitTrigger(this, context); };
    return TriggerAst;
}(Ast));
var StateAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](StateAst, _super);
    /**
     * @param {?} name
     * @param {?} style
     */
    function StateAst(name, style$$1) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.style = style$$1;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StateAst.prototype.visit = function (visitor, context) { return visitor.visitState(this, context); };
    return StateAst;
}(Ast));
var TransitionAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](TransitionAst, _super);
    /**
     * @param {?} matchers
     * @param {?} animation
     */
    function TransitionAst(matchers, animation) {
        var _this = _super.call(this) || this;
        _this.matchers = matchers;
        _this.animation = animation;
        _this.queryCount = 0;
        _this.depCount = 0;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TransitionAst.prototype.visit = function (visitor, context) { return visitor.visitTransition(this, context); };
    return TransitionAst;
}(Ast));
var SequenceAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SequenceAst, _super);
    /**
     * @param {?} steps
     */
    function SequenceAst(steps) {
        var _this = _super.call(this) || this;
        _this.steps = steps;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    SequenceAst.prototype.visit = function (visitor, context) { return visitor.visitSequence(this, context); };
    return SequenceAst;
}(Ast));
var GroupAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](GroupAst, _super);
    /**
     * @param {?} steps
     */
    function GroupAst(steps) {
        var _this = _super.call(this) || this;
        _this.steps = steps;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    GroupAst.prototype.visit = function (visitor, context) { return visitor.visitGroup(this, context); };
    return GroupAst;
}(Ast));
var AnimateAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](AnimateAst, _super);
    /**
     * @param {?} timings
     * @param {?} style
     */
    function AnimateAst(timings, style$$1) {
        var _this = _super.call(this) || this;
        _this.timings = timings;
        _this.style = style$$1;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateAst.prototype.visit = function (visitor, context) { return visitor.visitAnimate(this, context); };
    return AnimateAst;
}(Ast));
var StyleAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](StyleAst, _super);
    /**
     * @param {?} styles
     * @param {?} easing
     * @param {?} offset
     */
    function StyleAst(styles, easing, offset) {
        var _this = _super.call(this) || this;
        _this.styles = styles;
        _this.easing = easing;
        _this.offset = offset;
        _this.isEmptyStep = false;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StyleAst.prototype.visit = function (visitor, context) { return visitor.visitStyle(this, context); };
    return StyleAst;
}(Ast));
var KeyframesAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](KeyframesAst, _super);
    /**
     * @param {?} styles
     */
    function KeyframesAst(styles) {
        var _this = _super.call(this) || this;
        _this.styles = styles;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    KeyframesAst.prototype.visit = function (visitor, context) { return visitor.visitKeyframes(this, context); };
    return KeyframesAst;
}(Ast));
var ReferenceAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](ReferenceAst, _super);
    /**
     * @param {?} animation
     */
    function ReferenceAst(animation) {
        var _this = _super.call(this) || this;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    ReferenceAst.prototype.visit = function (visitor, context) { return visitor.visitReference(this, context); };
    return ReferenceAst;
}(Ast));
var AnimateChildAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](AnimateChildAst, _super);
    function AnimateChildAst() {
        return _super.call(this) || this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateChildAst.prototype.visit = function (visitor, context) { return visitor.visitAnimateChild(this, context); };
    return AnimateChildAst;
}(Ast));
var AnimateRefAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](AnimateRefAst, _super);
    /**
     * @param {?} animation
     */
    function AnimateRefAst(animation) {
        var _this = _super.call(this) || this;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateRefAst.prototype.visit = function (visitor, context) { return visitor.visitAnimateRef(this, context); };
    return AnimateRefAst;
}(Ast));
var QueryAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](QueryAst, _super);
    /**
     * @param {?} selector
     * @param {?} limit
     * @param {?} optional
     * @param {?} includeSelf
     * @param {?} animation
     */
    function QueryAst(selector, limit, optional, includeSelf, animation) {
        var _this = _super.call(this) || this;
        _this.selector = selector;
        _this.limit = limit;
        _this.optional = optional;
        _this.includeSelf = includeSelf;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    QueryAst.prototype.visit = function (visitor, context) { return visitor.visitQuery(this, context); };
    return QueryAst;
}(Ast));
var StaggerAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](StaggerAst, _super);
    /**
     * @param {?} timings
     * @param {?} animation
     */
    function StaggerAst(timings, animation) {
        var _this = _super.call(this) || this;
        _this.timings = timings;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StaggerAst.prototype.visit = function (visitor, context) { return visitor.visitStagger(this, context); };
    return StaggerAst;
}(Ast));
var TimingAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](TimingAst, _super);
    /**
     * @param {?} duration
     * @param {?=} delay
     * @param {?=} easing
     */
    function TimingAst(duration, delay, easing) {
        if (delay === void 0) { delay = 0; }
        if (easing === void 0) { easing = null; }
        var _this = _super.call(this) || this;
        _this.duration = duration;
        _this.delay = delay;
        _this.easing = easing;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TimingAst.prototype.visit = function (visitor, context) { return visitor.visitTiming(this, context); };
    return TimingAst;
}(Ast));
var DynamicTimingAst = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](DynamicTimingAst, _super);
    /**
     * @param {?} value
     */
    function DynamicTimingAst(value) {
        var _this = _super.call(this, 0, 0, '') || this;
        _this.value = value;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    DynamicTimingAst.prototype.visit = function (visitor, context) { return visitor.visitTiming(this, context); };
    return DynamicTimingAst;
}(TimingAst));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} visitor
 * @param {?} node
 * @param {?} context
 * @return {?}
 */
function visitAnimationNode(visitor, node, context) {
    switch (node.type) {
        case 7 /* Trigger */:
            return visitor.visitTrigger(/** @type {?} */ (node), context);
        case 0 /* State */:
            return visitor.visitState(/** @type {?} */ (node), context);
        case 1 /* Transition */:
            return visitor.visitTransition(/** @type {?} */ (node), context);
        case 2 /* Sequence */:
            return visitor.visitSequence(/** @type {?} */ (node), context);
        case 3 /* Group */:
            return visitor.visitGroup(/** @type {?} */ (node), context);
        case 4 /* Animate */:
            return visitor.visitAnimate(/** @type {?} */ (node), context);
        case 5 /* Keyframes */:
            return visitor.visitKeyframes(/** @type {?} */ (node), context);
        case 6 /* Style */:
            return visitor.visitStyle(/** @type {?} */ (node), context);
        case 8 /* Reference */:
            return visitor.visitReference(/** @type {?} */ (node), context);
        case 9 /* AnimateChild */:
            return visitor.visitAnimateChild(/** @type {?} */ (node), context);
        case 10 /* AnimateRef */:
            return visitor.visitAnimateRef(/** @type {?} */ (node), context);
        case 11 /* Query */:
            return visitor.visitQuery(/** @type {?} */ (node), context);
        case 12 /* Stagger */:
            return visitor.visitStagger(/** @type {?} */ (node), context);
        default:
            throw new Error("Unable to resolve animation metadata node #" + node.type);
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ANY_STATE = '*';
/**
 * @param {?} transitionValue
 * @param {?} errors
 * @return {?}
 */
function parseTransitionExpr(transitionValue, errors) {
    var /** @type {?} */ expressions = [];
    if (typeof transitionValue == 'string') {
        ((transitionValue))
            .split(/\s*,\s*/)
            .forEach(function (str) { return parseInnerTransitionStr(str, expressions, errors); });
    }
    else {
        expressions.push(/** @type {?} */ (transitionValue));
    }
    return expressions;
}
/**
 * @param {?} eventStr
 * @param {?} expressions
 * @param {?} errors
 * @return {?}
 */
function parseInnerTransitionStr(eventStr, expressions, errors) {
    if (eventStr[0] == ':') {
        eventStr = parseAnimationAlias(eventStr, errors);
    }
    var /** @type {?} */ match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
    if (match == null || match.length < 4) {
        errors.push("The provided transition expression \"" + eventStr + "\" is not supported");
        return expressions;
    }
    var /** @type {?} */ fromState = match[1];
    var /** @type {?} */ separator = match[2];
    var /** @type {?} */ toState = match[3];
    expressions.push(makeLambdaFromStates(fromState, toState));
    var /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
    if (separator[0] == '<' && !isFullAnyStateExpr) {
        expressions.push(makeLambdaFromStates(toState, fromState));
    }
}
/**
 * @param {?} alias
 * @param {?} errors
 * @return {?}
 */
function parseAnimationAlias(alias, errors) {
    switch (alias) {
        case ':enter':
            return 'void => *';
        case ':leave':
            return '* => void';
        default:
            errors.push("The transition alias value \"" + alias + "\" is not supported");
            return '* => *';
    }
}
/**
 * @param {?} lhs
 * @param {?} rhs
 * @return {?}
 */
function makeLambdaFromStates(lhs, rhs) {
    return function (fromState, toState) {
        var /** @type {?} */ lhsMatch = lhs == ANY_STATE || lhs == fromState;
        var /** @type {?} */ rhsMatch = rhs == ANY_STATE || rhs == toState;
        if (!lhsMatch && typeof fromState === 'boolean') {
            lhsMatch = fromState ? lhs === 'true' : lhs === 'false';
        }
        if (!rhsMatch && typeof toState === 'boolean') {
            rhsMatch = toState ? rhs === 'true' : rhs === 'false';
        }
        return lhsMatch && rhsMatch;
    };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var SELF_TOKEN = ':self';
var SELF_TOKEN_REGEX = new RegExp("s*" + SELF_TOKEN + "s*,?", 'g');
/**
 * @param {?} metadata
 * @param {?} errors
 * @return {?}
 */
function buildAnimationAst(metadata, errors) {
    return new AnimationAstBuilderVisitor().build(metadata, errors);
}
var LEAVE_TOKEN = ':leave';
var LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');
var ENTER_TOKEN = ':enter';
var ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');
var ROOT_SELECTOR = '';
var AnimationAstBuilderVisitor = (function () {
    function AnimationAstBuilderVisitor() {
    }
    /**
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.build = function (metadata, errors) {
        var /** @type {?} */ context = new AnimationAstBuilderContext(errors);
        this._resetContextStyleTimingState(context);
        return (visitAnimationNode(this, normalizeAnimationEntry(metadata), context));
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._resetContextStyleTimingState = function (context) {
        context.currentQuerySelector = ROOT_SELECTOR;
        context.collectedStyles = {};
        context.collectedStyles[ROOT_SELECTOR] = {};
        context.currentTime = 0;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTrigger = function (metadata, context) {
        var _this = this;
        var /** @type {?} */ queryCount = context.queryCount = 0;
        var /** @type {?} */ depCount = context.depCount = 0;
        var /** @type {?} */ states = [];
        var /** @type {?} */ transitions = [];
        metadata.definitions.forEach(function (def) {
            _this._resetContextStyleTimingState(context);
            if (def.type == 0 /* State */) {
                var /** @type {?} */ stateDef_1 = (def);
                var /** @type {?} */ name = stateDef_1.name;
                name.split(/\s*,\s*/).forEach(function (n) {
                    stateDef_1.name = n;
                    states.push(_this.visitState(stateDef_1, context));
                });
                stateDef_1.name = name;
            }
            else if (def.type == 1 /* Transition */) {
                var /** @type {?} */ transition = _this.visitTransition(/** @type {?} */ (def), context);
                queryCount += transition.queryCount;
                depCount += transition.depCount;
                transitions.push(transition);
            }
            else {
                context.errors.push('only state() and transition() definitions can sit inside of a trigger()');
            }
        });
        var /** @type {?} */ ast = new TriggerAst(metadata.name, states, transitions);
        ast.options = normalizeAnimationOptions(metadata.options);
        ast.queryCount = queryCount;
        ast.depCount = depCount;
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitState = function (metadata, context) {
        return new StateAst(metadata.name, this.visitStyle(metadata.styles, context));
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTransition = function (metadata, context) {
        context.queryCount = 0;
        context.depCount = 0;
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        var /** @type {?} */ matchers = parseTransitionExpr(metadata.expr, context.errors);
        var /** @type {?} */ ast = new TransitionAst(matchers, entry);
        ast.options = normalizeAnimationOptions(metadata.options);
        ast.queryCount = context.queryCount;
        ast.depCount = context.depCount;
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitSequence = function (metadata, context) {
        var _this = this;
        var /** @type {?} */ ast = new SequenceAst(metadata.steps.map(function (s) { return visitAnimationNode(_this, s, context); }));
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitGroup = function (metadata, context) {
        var _this = this;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ furthestTime = 0;
        var /** @type {?} */ steps = metadata.steps.map(function (step) {
            context.currentTime = currentTime;
            var /** @type {?} */ innerAst = visitAnimationNode(_this, step, context);
            furthestTime = Math.max(furthestTime, context.currentTime);
            return innerAst;
        });
        context.currentTime = furthestTime;
        var /** @type {?} */ ast = new GroupAst(steps);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimate = function (metadata, context) {
        var /** @type {?} */ timingAst = constructTimingAst(metadata.timings, context.errors);
        context.currentAnimateTimings = timingAst;
        var /** @type {?} */ styles;
        var /** @type {?} */ styleMetadata = metadata.styles ? metadata.styles : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({});
        if (styleMetadata.type == 5 /* Keyframes */) {
            styles = this.visitKeyframes(/** @type {?} */ (styleMetadata), context);
        }
        else {
            var /** @type {?} */ styleMetadata_1 = (metadata.styles);
            var /** @type {?} */ isEmpty = false;
            if (!styleMetadata_1) {
                isEmpty = true;
                var /** @type {?} */ newStyleData = {};
                if (timingAst.easing) {
                    newStyleData['easing'] = timingAst.easing;
                }
                styleMetadata_1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])(newStyleData);
            }
            context.currentTime += timingAst.duration + timingAst.delay;
            var /** @type {?} */ styleAst = this.visitStyle(styleMetadata_1, context);
            styleAst.isEmptyStep = isEmpty;
            styles = styleAst;
        }
        context.currentAnimateTimings = null;
        return new AnimateAst(timingAst, styles);
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStyle = function (metadata, context) {
        var /** @type {?} */ ast = this._makeStyleAst(metadata, context);
        this._validateStyleAst(ast, context);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._makeStyleAst = function (metadata, context) {
        var /** @type {?} */ styles = [];
        if (Array.isArray(metadata.styles)) {
            ((metadata.styles)).forEach(function (styleTuple) {
                if (typeof styleTuple == 'string') {
                    if (styleTuple == __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"]) {
                        styles.push(/** @type {?} */ (styleTuple));
                    }
                    else {
                        context.errors.push("The provided style string value " + styleTuple + " is not allowed.");
                    }
                }
                else {
                    styles.push(/** @type {?} */ (styleTuple));
                }
            });
        }
        else {
            styles.push(metadata.styles);
        }
        var /** @type {?} */ collectedEasing = null;
        styles.forEach(function (styleData) {
            if (isObject(styleData)) {
                var /** @type {?} */ styleMap = (styleData);
                var /** @type {?} */ easing = styleMap['easing'];
                if (easing) {
                    collectedEasing = (easing);
                    delete styleMap['easing'];
                }
            }
        });
        return new StyleAst(styles, collectedEasing, metadata.offset);
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._validateStyleAst = function (ast, context) {
        var /** @type {?} */ timings = context.currentAnimateTimings;
        var /** @type {?} */ endTime = context.currentTime;
        var /** @type {?} */ startTime = context.currentTime;
        if (timings && startTime > 0) {
            startTime -= timings.duration + timings.delay;
        }
        ast.styles.forEach(function (tuple) {
            if (typeof tuple == 'string')
                return;
            Object.keys(tuple).forEach(function (prop) {
                var /** @type {?} */ collectedStyles = context.collectedStyles[((context.currentQuerySelector))];
                var /** @type {?} */ collectedEntry = collectedStyles[prop];
                var /** @type {?} */ updateCollectedStyle = true;
                if (collectedEntry) {
                    if (startTime != endTime && startTime >= collectedEntry.startTime &&
                        endTime <= collectedEntry.endTime) {
                        context.errors.push("The CSS property \"" + prop + "\" that exists between the times of \"" + collectedEntry.startTime + "ms\" and \"" + collectedEntry.endTime + "ms\" is also being animated in a parallel animation between the times of \"" + startTime + "ms\" and \"" + endTime + "ms\"");
                        updateCollectedStyle = false;
                    }
                    // we always choose the smaller start time value since we
                    // want to have a record of the entire animation window where
                    // the style property is being animated in between
                    startTime = collectedEntry.startTime;
                }
                if (updateCollectedStyle) {
                    collectedStyles[prop] = { startTime: startTime, endTime: endTime };
                }
                if (context.options) {
                    validateStyleParams(tuple[prop], context.options, context.errors);
                }
            });
        });
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitKeyframes = function (metadata, context) {
        var _this = this;
        if (!context.currentAnimateTimings) {
            context.errors.push("keyframes() must be placed inside of a call to animate()");
            return new KeyframesAst([]);
        }
        var /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;
        var /** @type {?} */ totalKeyframesWithOffsets = 0;
        var /** @type {?} */ offsets = [];
        var /** @type {?} */ offsetsOutOfOrder = false;
        var /** @type {?} */ keyframesOutOfRange = false;
        var /** @type {?} */ previousOffset = 0;
        var /** @type {?} */ keyframes = metadata.steps.map(function (styles) {
            var /** @type {?} */ style$$1 = _this._makeStyleAst(styles, context);
            var /** @type {?} */ offsetVal = style$$1.offset != null ? style$$1.offset : consumeOffset(style$$1.styles);
            var /** @type {?} */ offset = 0;
            if (offsetVal != null) {
                totalKeyframesWithOffsets++;
                offset = style$$1.offset = offsetVal;
            }
            keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
            offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
            previousOffset = offset;
            offsets.push(offset);
            return style$$1;
        });
        if (keyframesOutOfRange) {
            context.errors.push("Please ensure that all keyframe offsets are between 0 and 1");
        }
        if (offsetsOutOfOrder) {
            context.errors.push("Please ensure that all keyframe offsets are in order");
        }
        var /** @type {?} */ length = metadata.steps.length;
        var /** @type {?} */ generatedOffset = 0;
        if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
            context.errors.push("Not all style() steps within the declared keyframes() contain offsets");
        }
        else if (totalKeyframesWithOffsets == 0) {
            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
        }
        var /** @type {?} */ limit = length - 1;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ currentAnimateTimings = ((context.currentAnimateTimings));
        var /** @type {?} */ animateDuration = currentAnimateTimings.duration;
        keyframes.forEach(function (kf, i) {
            var /** @type {?} */ offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];
            var /** @type {?} */ durationUpToThisFrame = offset * animateDuration;
            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
            currentAnimateTimings.duration = durationUpToThisFrame;
            _this._validateStyleAst(kf, context);
            kf.offset = offset;
        });
        return new KeyframesAst(keyframes);
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitReference = function (metadata, context) {
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        var /** @type {?} */ ast = new ReferenceAst(entry);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateChild = function (metadata, context) {
        context.depCount++;
        var /** @type {?} */ ast = new AnimateChildAst();
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateRef = function (metadata, context) {
        var /** @type {?} */ animation = this.visitReference(metadata.animation, context);
        var /** @type {?} */ ast = new AnimateRefAst(animation);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitQuery = function (metadata, context) {
        var /** @type {?} */ parentSelector = ((context.currentQuerySelector));
        var /** @type {?} */ options = ((metadata.options || {}));
        context.queryCount++;
        context.currentQuery = metadata;
        var _a = normalizeSelector(metadata.selector), selector = _a[0], includeSelf = _a[1];
        context.currentQuerySelector =
            parentSelector.length ? (parentSelector + ' ' + selector) : selector;
        getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        context.currentQuery = null;
        context.currentQuerySelector = parentSelector;
        var /** @type {?} */ ast = new QueryAst(selector, options.limit || 0, !!options.optional, includeSelf, entry);
        ast.originalSelector = metadata.selector;
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStagger = function (metadata, context) {
        if (!context.currentQuery) {
            context.errors.push("stagger() can only be used inside of query()");
        }
        var /** @type {?} */ timings = metadata.timings === 'full' ?
            { duration: 0, delay: 0, easing: 'full' } :
            resolveTiming(metadata.timings, context.errors, true);
        var /** @type {?} */ animation = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        return new StaggerAst(timings, animation);
    };
    return AnimationAstBuilderVisitor;
}());
/**
 * @param {?} selector
 * @return {?}
 */
function normalizeSelector(selector) {
    var /** @type {?} */ hasAmpersand = selector.split(/\s*,\s*/).find(function (token) { return token == SELF_TOKEN; }) ? true : false;
    if (hasAmpersand) {
        selector = selector.replace(SELF_TOKEN_REGEX, '');
    }
    selector = selector.replace(ENTER_TOKEN_REGEX, ENTER_SELECTOR)
        .replace(LEAVE_TOKEN_REGEX, LEAVE_SELECTOR)
        .replace(/@\*/g, NG_TRIGGER_SELECTOR)
        .replace(/@\w+/g, function (match) { return NG_TRIGGER_SELECTOR + '-' + match.substr(1); })
        .replace(/:animating/g, NG_ANIMATING_SELECTOR);
    return [selector, hasAmpersand];
}
/**
 * @param {?} obj
 * @return {?}
 */
function normalizeParams(obj) {
    return obj ? copyObj(obj) : null;
}
var AnimationAstBuilderContext = (function () {
    /**
     * @param {?} errors
     */
    function AnimationAstBuilderContext(errors) {
        this.errors = errors;
        this.queryCount = 0;
        this.depCount = 0;
        this.currentTransition = null;
        this.currentQuery = null;
        this.currentQuerySelector = null;
        this.currentAnimateTimings = null;
        this.currentTime = 0;
        this.collectedStyles = {};
        this.options = null;
    }
    return AnimationAstBuilderContext;
}());
/**
 * @param {?} styles
 * @return {?}
 */
function consumeOffset(styles) {
    if (typeof styles == 'string')
        return null;
    var /** @type {?} */ offset = null;
    if (Array.isArray(styles)) {
        styles.forEach(function (styleTuple) {
            if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
                var /** @type {?} */ obj = (styleTuple);
                offset = parseFloat(/** @type {?} */ (obj['offset']));
                delete obj['offset'];
            }
        });
    }
    else if (isObject(styles) && styles.hasOwnProperty('offset')) {
        var /** @type {?} */ obj = (styles);
        offset = parseFloat(/** @type {?} */ (obj['offset']));
        delete obj['offset'];
    }
    return offset;
}
/**
 * @param {?} value
 * @return {?}
 */
function isObject(value) {
    return !Array.isArray(value) && typeof value == 'object';
}
/**
 * @param {?} value
 * @param {?} errors
 * @return {?}
 */
function constructTimingAst(value, errors) {
    var /** @type {?} */ timings = null;
    if (value.hasOwnProperty('duration')) {
        timings = (value);
    }
    else if (typeof value == 'number') {
        var /** @type {?} */ duration = resolveTiming(/** @type {?} */ (value), errors).duration;
        return new TimingAst(/** @type {?} */ (value), 0, '');
    }
    var /** @type {?} */ strValue = (value);
    var /** @type {?} */ isDynamic = strValue.split(/\s+/).some(function (v) { return v.charAt(0) == '{' && v.charAt(1) == '{'; });
    if (isDynamic) {
        return new DynamicTimingAst(strValue);
    }
    timings = timings || resolveTiming(strValue, errors);
    return new TimingAst(timings.duration, timings.delay, timings.easing);
}
/**
 * @param {?} options
 * @return {?}
 */
function normalizeAnimationOptions(options) {
    if (options) {
        options = copyObj(options);
        if (options['params']) {
            options['params'] = ((normalizeParams(options['params'])));
        }
    }
    else {
        options = {};
    }
    return options;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} element
 * @param {?} keyframes
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?} duration
 * @param {?} delay
 * @param {?=} easing
 * @param {?=} subTimeline
 * @return {?}
 */
function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing, subTimeline) {
    if (easing === void 0) { easing = null; }
    if (subTimeline === void 0) { subTimeline = false; }
    return {
        type: 1 /* TimelineAnimation */,
        element: element,
        keyframes: keyframes,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        duration: duration,
        delay: delay,
        totalTime: duration + delay, easing: easing, subTimeline: subTimeline
    };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ElementInstructionMap = (function () {
    function ElementInstructionMap() {
        this._map = new Map();
    }
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.consume = function (element) {
        var /** @type {?} */ instructions = this._map.get(element);
        if (instructions) {
            this._map.delete(element);
        }
        else {
            instructions = [];
        }
        return instructions;
    };
    /**
     * @param {?} element
     * @param {?} instructions
     * @return {?}
     */
    ElementInstructionMap.prototype.append = function (element, instructions) {
        var /** @type {?} */ existingInstructions = this._map.get(element);
        if (!existingInstructions) {
            this._map.set(element, existingInstructions = []);
        }
        existingInstructions.push.apply(existingInstructions, instructions);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.has = function (element) { return this._map.has(element); };
    /**
     * @return {?}
     */
    ElementInstructionMap.prototype.clear = function () { this._map.clear(); };
    return ElementInstructionMap;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ONE_FRAME_IN_MILLISECONDS = 1;
/**
 * @param {?} driver
 * @param {?} rootElement
 * @param {?} ast
 * @param {?=} startingStyles
 * @param {?=} finalStyles
 * @param {?=} options
 * @param {?=} subInstructions
 * @param {?=} errors
 * @return {?}
 */
function buildAnimationTimelines(driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors) {
    if (startingStyles === void 0) { startingStyles = {}; }
    if (finalStyles === void 0) { finalStyles = {}; }
    if (errors === void 0) { errors = []; }
    return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors);
}
var AnimationTimelineBuilderVisitor = (function () {
    function AnimationTimelineBuilderVisitor() {
    }
    /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} startingStyles
     * @param {?} finalStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.buildKeyframes = function (driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors) {
        if (errors === void 0) { errors = []; }
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ context = new AnimationTimelineContext(driver, rootElement, subInstructions, errors, []);
        context.options = options;
        context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
        ast.visit(this, context);
        // this checks to see if an actual animation happened
        var /** @type {?} */ timelines = context.timelines.filter(function (timeline) { return timeline.containsAnimation(); });
        if (timelines.length && Object.keys(finalStyles).length) {
            var /** @type {?} */ tl = timelines[timelines.length - 1];
            if (!tl.allowOnlyTimelineStyles()) {
                tl.setStyles([finalStyles], null, context.errors, options);
            }
        }
        return timelines.length ? timelines.map(function (timeline) { return timeline.buildKeyframes(); }) :
            [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTrigger = function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitState = function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTransition = function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateChild = function (ast, context) {
        var /** @type {?} */ elementInstructions = context.subInstructions.consume(context.element);
        if (elementInstructions) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            var /** @type {?} */ startTime = context.currentTimeline.currentTime;
            var /** @type {?} */ endTime = this._visitSubInstructions(elementInstructions, innerContext, /** @type {?} */ (innerContext.options));
            if (startTime != endTime) {
                // we do this on the upper context because we created a sub context for
                // the sub child animations
                context.transformIntoNewTimeline(endTime);
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateRef = function (ast, context) {
        var /** @type {?} */ innerContext = context.createSubContext(ast.options);
        innerContext.transformIntoNewTimeline();
        this.visitReference(ast.animation, innerContext);
        context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} instructions
     * @param {?} context
     * @param {?} options
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype._visitSubInstructions = function (instructions, context, options) {
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ furthestTime = startTime;
        // this is a special-case for when a user wants to skip a sub
        // animation from being fired entirely.
        var /** @type {?} */ duration = options.duration != null ? resolveTimingValue(options.duration) : null;
        var /** @type {?} */ delay = options.delay != null ? resolveTimingValue(options.delay) : null;
        if (duration !== 0) {
            instructions.forEach(function (instruction) {
                var /** @type {?} */ instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
                furthestTime =
                    Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
            });
        }
        return furthestTime;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitReference = function (ast, context) {
        context.updateOptions(ast.options, true);
        ast.animation.visit(this, context);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitSequence = function (ast, context) {
        var _this = this;
        var /** @type {?} */ subContextCount = context.subContextCount;
        var /** @type {?} */ ctx = context;
        var /** @type {?} */ options = ast.options;
        if (options && (options.params || options.delay)) {
            ctx = context.createSubContext(options);
            ctx.transformIntoNewTimeline();
            if (options.delay != null) {
                if (ctx.previousNode instanceof StyleAst) {
                    ctx.currentTimeline.snapshotCurrentStyles();
                    ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
                }
                var /** @type {?} */ delay = resolveTimingValue(options.delay);
                ctx.delayNextStep(delay);
            }
        }
        if (ast.steps.length) {
            ast.steps.forEach(function (s) { return s.visit(_this, ctx); });
            // this is here just incase the inner steps only contain or end with a style() call
            ctx.currentTimeline.applyStylesToKeyframe();
            // this means that some animation function within the sequence
            // ended up creating a sub timeline (which means the current
            // timeline cannot overlap with the contents of the sequence)
            if (ctx.subContextCount > subContextCount) {
                ctx.transformIntoNewTimeline();
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitGroup = function (ast, context) {
        var _this = this;
        var /** @type {?} */ innerTimelines = [];
        var /** @type {?} */ furthestTime = context.currentTimeline.currentTime;
        var /** @type {?} */ delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
        ast.steps.forEach(function (s) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            s.visit(_this, innerContext);
            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
            innerTimelines.push(innerContext.currentTimeline);
        });
        // this operation is run after the AST loop because otherwise
        // if the parent timeline's collected styles were updated then
        // it would pass in invalid data into the new-to-be forked items
        innerTimelines.forEach(function (timeline) { return context.currentTimeline.mergeTimelineCollectedStyles(timeline); });
        context.transformIntoNewTimeline(furthestTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTiming = function (ast, context) {
        if (ast instanceof DynamicTimingAst) {
            var /** @type {?} */ strValue = context.params ?
                interpolateParams(ast.value, context.params, context.errors) :
                ast.value.toString();
            return resolveTiming(strValue, context.errors);
        }
        else {
            return { duration: ast.duration, delay: ast.delay, easing: ast.easing };
        }
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimate = function (ast, context) {
        var /** @type {?} */ timings = context.currentAnimateTimings = this.visitTiming(ast.timings, context);
        var /** @type {?} */ timeline = context.currentTimeline;
        if (timings.delay) {
            context.incrementTime(timings.delay);
            timeline.snapshotCurrentStyles();
        }
        var /** @type {?} */ style$$1 = ast.style;
        if (style$$1 instanceof KeyframesAst) {
            this.visitKeyframes(style$$1, context);
        }
        else {
            context.incrementTime(timings.duration);
            this.visitStyle(/** @type {?} */ (style$$1), context);
            timeline.applyStylesToKeyframe();
        }
        context.currentAnimateTimings = null;
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStyle = function (ast, context) {
        var /** @type {?} */ timeline = context.currentTimeline;
        var /** @type {?} */ timings = ((context.currentAnimateTimings));
        // this is a special case for when a style() call
        // directly follows  an animate() call (but not inside of an animate() call)
        if (!timings && timeline.getCurrentStyleProperties().length) {
            timeline.forwardFrame();
        }
        var /** @type {?} */ easing = (timings && timings.easing) || ast.easing;
        if (ast.isEmptyStep) {
            timeline.applyEmptyStep(easing);
        }
        else {
            timeline.setStyles(ast.styles, easing, context.errors, context.options);
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitKeyframes = function (ast, context) {
        var /** @type {?} */ currentAnimateTimings = ((context.currentAnimateTimings));
        var /** @type {?} */ startTime = (((context.currentTimeline))).duration;
        var /** @type {?} */ duration = currentAnimateTimings.duration;
        var /** @type {?} */ innerContext = context.createSubContext();
        var /** @type {?} */ innerTimeline = innerContext.currentTimeline;
        innerTimeline.easing = currentAnimateTimings.easing;
        ast.styles.forEach(function (step) {
            var /** @type {?} */ offset = step.offset || 0;
            innerTimeline.forwardTime(offset * duration);
            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
            innerTimeline.applyStylesToKeyframe();
        });
        // this will ensure that the parent timeline gets all the styles from
        // the child even if the new timeline below is not used
        context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
        // we do this because the window between this timeline and the sub timeline
        // should ensure that the styles within are exactly the same as they were before
        context.transformIntoNewTimeline(startTime + duration);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitQuery = function (ast, context) {
        var _this = this;
        // in the event that the first step before this is a style step we need
        // to ensure the styles are applied before the children are animated
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ options = ((ast.options || {}));
        var /** @type {?} */ delay = options.delay ? resolveTimingValue(options.delay) : 0;
        if (delay && (context.previousNode instanceof StyleAst ||
            (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {
            context.currentTimeline.snapshotCurrentStyles();
            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        var /** @type {?} */ furthestTime = startTime;
        var /** @type {?} */ elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
        context.currentQueryTotal = elms.length;
        var /** @type {?} */ sameElementTimeline = null;
        elms.forEach(function (element, i) {
            context.currentQueryIndex = i;
            var /** @type {?} */ innerContext = context.createSubContext(ast.options, element);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            if (element === context.element) {
                sameElementTimeline = innerContext.currentTimeline;
            }
            ast.animation.visit(_this, innerContext);
            // this is here just incase the inner steps only contain or end
            // with a style() call (which is here to signal that this is a preparatory
            // call to style an element before it is animated again)
            innerContext.currentTimeline.applyStylesToKeyframe();
            var /** @type {?} */ endTime = innerContext.currentTimeline.currentTime;
            furthestTime = Math.max(furthestTime, endTime);
        });
        context.currentQueryIndex = 0;
        context.currentQueryTotal = 0;
        context.transformIntoNewTimeline(furthestTime);
        if (sameElementTimeline) {
            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
            context.currentTimeline.snapshotCurrentStyles();
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStagger = function (ast, context) {
        var /** @type {?} */ parentContext = ((context.parentContext));
        var /** @type {?} */ tl = context.currentTimeline;
        var /** @type {?} */ timings = ast.timings;
        var /** @type {?} */ duration = Math.abs(timings.duration);
        var /** @type {?} */ maxTime = duration * (context.currentQueryTotal - 1);
        var /** @type {?} */ delay = duration * context.currentQueryIndex;
        var /** @type {?} */ staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;
        switch (staggerTransformer) {
            case 'reverse':
                delay = maxTime - delay;
                break;
            case 'full':
                delay = parentContext.currentStaggerTime;
                break;
        }
        var /** @type {?} */ timeline = context.currentTimeline;
        if (delay) {
            timeline.delayNextStep(delay);
        }
        var /** @type {?} */ startingTime = timeline.currentTime;
        ast.animation.visit(this, context);
        context.previousNode = ast;
        // time = duration + delay
        // the reason why this computation is so complex is because
        // the inner timeline may either have a delay value or a stretched
        // keyframe depending on if a subtimeline is not used or is used.
        parentContext.currentStaggerTime =
            (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);
    };
    return AnimationTimelineBuilderVisitor;
}());
var DEFAULT_NOOP_PREVIOUS_NODE = ({});
var AnimationTimelineContext = (function () {
    /**
     * @param {?} _driver
     * @param {?} element
     * @param {?} subInstructions
     * @param {?} errors
     * @param {?} timelines
     * @param {?=} initialTimeline
     */
    function AnimationTimelineContext(_driver, element, subInstructions, errors, timelines, initialTimeline) {
        this._driver = _driver;
        this.element = element;
        this.subInstructions = subInstructions;
        this.errors = errors;
        this.timelines = timelines;
        this.parentContext = null;
        this.currentAnimateTimings = null;
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.subContextCount = 0;
        this.options = {};
        this.currentQueryIndex = 0;
        this.currentQueryTotal = 0;
        this.currentStaggerTime = 0;
        this.currentTimeline = initialTimeline || new TimelineBuilder(element, 0);
        timelines.push(this.currentTimeline);
    }
    Object.defineProperty(AnimationTimelineContext.prototype, "params", {
        /**
         * @return {?}
         */
        get: function () { return this.options.params; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @param {?=} skipIfExists
     * @return {?}
     */
    AnimationTimelineContext.prototype.updateOptions = function (options, skipIfExists) {
        var _this = this;
        if (!options)
            return;
        var /** @type {?} */ newOptions = (options);
        var /** @type {?} */ optionsToUpdate = this.options;
        // NOTE: this will get patched up when other animation methods support duration overrides
        if (newOptions.duration != null) {
            ((optionsToUpdate)).duration = resolveTimingValue(newOptions.duration);
        }
        if (newOptions.delay != null) {
            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
        }
        var /** @type {?} */ newParams = newOptions.params;
        if (newParams) {
            var /** @type {?} */ paramsToUpdate_1 = ((optionsToUpdate.params));
            if (!paramsToUpdate_1) {
                paramsToUpdate_1 = this.options.params = {};
            }
            Object.keys(newParams).forEach(function (name) {
                if (!skipIfExists || !paramsToUpdate_1.hasOwnProperty(name)) {
                    paramsToUpdate_1[name] = interpolateParams(newParams[name], paramsToUpdate_1, _this.errors);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AnimationTimelineContext.prototype._copyOptions = function () {
        var /** @type {?} */ options = {};
        if (this.options) {
            var /** @type {?} */ oldParams_1 = this.options.params;
            if (oldParams_1) {
                var /** @type {?} */ params_1 = options['params'] = {};
                Object.keys(this.options.params).forEach(function (name) { params_1[name] = oldParams_1[name]; });
            }
        }
        return options;
    };
    /**
     * @param {?=} options
     * @param {?=} element
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.createSubContext = function (options, element, newTime) {
        if (options === void 0) { options = null; }
        var /** @type {?} */ target = element || this.element;
        var /** @type {?} */ context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
        context.previousNode = this.previousNode;
        context.currentAnimateTimings = this.currentAnimateTimings;
        context.options = this._copyOptions();
        context.updateOptions(options);
        context.currentQueryIndex = this.currentQueryIndex;
        context.currentQueryTotal = this.currentQueryTotal;
        context.parentContext = this;
        this.subContextCount++;
        return context;
    };
    /**
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.transformIntoNewTimeline = function (newTime) {
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
        this.timelines.push(this.currentTimeline);
        return this.currentTimeline;
    };
    /**
     * @param {?} instruction
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.appendInstructionToTimeline = function (instruction, duration, delay) {
        var /** @type {?} */ updatedTimings = {
            duration: duration != null ? duration : instruction.duration,
            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
            easing: ''
        };
        var /** @type {?} */ builder = new SubTimelineBuilder(instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
        this.timelines.push(builder);
        return updatedTimings;
    };
    /**
     * @param {?} time
     * @return {?}
     */
    AnimationTimelineContext.prototype.incrementTime = function (time) {
        this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
    };
    /**
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.delayNextStep = function (delay) {
        // negative delays are not yet supported
        if (delay > 0) {
            this.currentTimeline.delayNextStep(delay);
        }
    };
    /**
     * @param {?} selector
     * @param {?} originalSelector
     * @param {?} limit
     * @param {?} includeSelf
     * @param {?} optional
     * @param {?} errors
     * @return {?}
     */
    AnimationTimelineContext.prototype.invokeQuery = function (selector, originalSelector, limit, includeSelf, optional, errors) {
        var /** @type {?} */ results = [];
        if (includeSelf) {
            results.push(this.element);
        }
        if (selector.length > 0) {
            var /** @type {?} */ multi = limit != 1;
            results.push.apply(results, this._driver.query(this.element, selector, multi));
        }
        if (!optional && results.length == 0) {
            errors.push("`query(\"" + originalSelector + "\")` returned zero elements. (Use `query(\"" + originalSelector + "\", { optional: true })` if you wish to allow this.)");
        }
        return results;
    };
    return AnimationTimelineContext;
}());
var TimelineBuilder = (function () {
    /**
     * @param {?} element
     * @param {?} startTime
     * @param {?=} _elementTimelineStylesLookup
     */
    function TimelineBuilder(element, startTime, _elementTimelineStylesLookup) {
        this.element = element;
        this.startTime = startTime;
        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
        this.duration = 0;
        this._previousKeyframe = {};
        this._currentKeyframe = {};
        this._keyframes = new Map();
        this._styleSummary = {};
        this._pendingStyles = {};
        this._backFill = {};
        this._currentEmptyStepKeyframe = null;
        if (!this._elementTimelineStylesLookup) {
            this._elementTimelineStylesLookup = new Map();
        }
        this._localTimelineStyles = Object.create(this._backFill, {});
        this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);
        if (!this._globalTimelineStyles) {
            this._globalTimelineStyles = this._localTimelineStyles;
            this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
        }
        this._loadKeyframe();
    }
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.containsAnimation = function () {
        switch (this._keyframes.size) {
            case 0:
                return false;
            case 1:
                return this.getCurrentStyleProperties().length > 0;
            default:
                return true;
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getCurrentStyleProperties = function () { return Object.keys(this._currentKeyframe); };
    Object.defineProperty(TimelineBuilder.prototype, "currentTime", {
        /**
         * @return {?}
         */
        get: function () { return this.startTime + this.duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} delay
     * @return {?}
     */
    TimelineBuilder.prototype.delayNextStep = function (delay) {
        // in the event that a style() step is placed right before a stagger()
        // and that style() step is the very first style() value in the animation
        // then we need to make a copy of the keyframe [0, copy, 1] so that the delay
        // properly applies the style() values to work with the stagger...
        var /** @type {?} */ hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;
        if (this.duration || hasPreStyleStep) {
            this.forwardTime(this.currentTime + delay);
            if (hasPreStyleStep) {
                this.snapshotCurrentStyles();
            }
        }
        else {
            this.startTime += delay;
        }
    };
    /**
     * @param {?} element
     * @param {?=} currentTime
     * @return {?}
     */
    TimelineBuilder.prototype.fork = function (element, currentTime) {
        this.applyStylesToKeyframe();
        return new TimelineBuilder(element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype._loadKeyframe = function () {
        if (this._currentKeyframe) {
            this._previousKeyframe = this._currentKeyframe;
        }
        this._currentKeyframe = ((this._keyframes.get(this.duration)));
        if (!this._currentKeyframe) {
            this._currentKeyframe = Object.create(this._backFill, {});
            this._keyframes.set(this.duration, this._currentKeyframe);
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.forwardFrame = function () {
        this.duration += ONE_FRAME_IN_MILLISECONDS;
        this._loadKeyframe();
    };
    /**
     * @param {?} time
     * @return {?}
     */
    TimelineBuilder.prototype.forwardTime = function (time) {
        this.applyStylesToKeyframe();
        this.duration = time;
        this._loadKeyframe();
    };
    /**
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    TimelineBuilder.prototype._updateStyle = function (prop, value) {
        this._localTimelineStyles[prop] = value;
        this._globalTimelineStyles[prop] = value;
        this._styleSummary[prop] = { time: this.currentTime, value: value };
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.allowOnlyTimelineStyles = function () { return this._currentEmptyStepKeyframe !== this._currentKeyframe; };
    /**
     * @param {?} easing
     * @return {?}
     */
    TimelineBuilder.prototype.applyEmptyStep = function (easing) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        // special case for animate(duration):
        // all missing styles are filled with a `*` value then
        // if any destination styles are filled in later on the same
        // keyframe then they will override the overridden styles
        // We use `_globalTimelineStyles` here because there may be
        // styles in previous keyframes that are not present in this timeline
        Object.keys(this._globalTimelineStyles).forEach(function (prop) {
            _this._backFill[prop] = _this._globalTimelineStyles[prop] || __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"];
            _this._currentKeyframe[prop] = __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"];
        });
        this._currentEmptyStepKeyframe = this._currentKeyframe;
    };
    /**
     * @param {?} input
     * @param {?} easing
     * @param {?} errors
     * @param {?=} options
     * @return {?}
     */
    TimelineBuilder.prototype.setStyles = function (input, easing, errors, options) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        var /** @type {?} */ params = (options && options.params) || {};
        var /** @type {?} */ styles = flattenStyles(input, this._globalTimelineStyles);
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ val = interpolateParams(styles[prop], params, errors);
            _this._pendingStyles[prop] = val;
            if (!_this._localTimelineStyles.hasOwnProperty(prop)) {
                _this._backFill[prop] = _this._globalTimelineStyles.hasOwnProperty(prop) ?
                    _this._globalTimelineStyles[prop] :
                    __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"];
            }
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.applyStylesToKeyframe = function () {
        var _this = this;
        var /** @type {?} */ styles = this._pendingStyles;
        var /** @type {?} */ props = Object.keys(styles);
        if (props.length == 0)
            return;
        this._pendingStyles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ val = styles[prop];
            _this._currentKeyframe[prop] = val;
        });
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            if (!_this._currentKeyframe.hasOwnProperty(prop)) {
                _this._currentKeyframe[prop] = _this._localTimelineStyles[prop];
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.snapshotCurrentStyles = function () {
        var _this = this;
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            var /** @type {?} */ val = _this._localTimelineStyles[prop];
            _this._pendingStyles[prop] = val;
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getFinalKeyframe = function () { return this._keyframes.get(this.duration); };
    Object.defineProperty(TimelineBuilder.prototype, "properties", {
        /**
         * @return {?}
         */
        get: function () {
            var /** @type {?} */ properties = [];
            for (var /** @type {?} */ prop in this._currentKeyframe) {
                properties.push(prop);
            }
            return properties;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} timeline
     * @return {?}
     */
    TimelineBuilder.prototype.mergeTimelineCollectedStyles = function (timeline) {
        var _this = this;
        Object.keys(timeline._styleSummary).forEach(function (prop) {
            var /** @type {?} */ details0 = _this._styleSummary[prop];
            var /** @type {?} */ details1 = timeline._styleSummary[prop];
            if (!details0 || details1.time > details0.time) {
                _this._updateStyle(prop, details1.value);
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.buildKeyframes = function () {
        var _this = this;
        this.applyStylesToKeyframe();
        var /** @type {?} */ preStyleProps = new Set();
        var /** @type {?} */ postStyleProps = new Set();
        var /** @type {?} */ isEmpty = this._keyframes.size === 1 && this.duration === 0;
        var /** @type {?} */ finalKeyframes = [];
        this._keyframes.forEach(function (keyframe, time) {
            var /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);
            Object.keys(finalKeyframe).forEach(function (prop) {
                var /** @type {?} */ value = finalKeyframe[prop];
                if (value == __WEBPACK_IMPORTED_MODULE_1__angular_animations__["ɵPRE_STYLE"]) {
                    preStyleProps.add(prop);
                }
                else if (value == __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"]) {
                    postStyleProps.add(prop);
                }
            });
            if (!isEmpty) {
                finalKeyframe['offset'] = time / _this.duration;
            }
            finalKeyframes.push(finalKeyframe);
        });
        var /** @type {?} */ preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];
        var /** @type {?} */ postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
        // special case for a 0-second animation (which is designed just to place styles onscreen)
        if (isEmpty) {
            var /** @type {?} */ kf0 = finalKeyframes[0];
            var /** @type {?} */ kf1 = copyObj(kf0);
            kf0['offset'] = 0;
            kf1['offset'] = 1;
            finalKeyframes = [kf0, kf1];
        }
        return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
    };
    return TimelineBuilder;
}());
var SubTimelineBuilder = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](SubTimelineBuilder, _super);
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} preStyleProps
     * @param {?} postStyleProps
     * @param {?} timings
     * @param {?=} _stretchStartingKeyframe
     */
    function SubTimelineBuilder(element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe) {
        if (_stretchStartingKeyframe === void 0) { _stretchStartingKeyframe = false; }
        var _this = _super.call(this, element, timings.delay) || this;
        _this.element = element;
        _this.keyframes = keyframes;
        _this.preStyleProps = preStyleProps;
        _this.postStyleProps = postStyleProps;
        _this._stretchStartingKeyframe = _stretchStartingKeyframe;
        _this.timings = { duration: timings.duration, delay: timings.delay, easing: timings.easing };
        return _this;
    }
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.containsAnimation = function () { return this.keyframes.length > 1; };
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.buildKeyframes = function () {
        var /** @type {?} */ keyframes = this.keyframes;
        var _a = this.timings, delay = _a.delay, duration = _a.duration, easing = _a.easing;
        if (this._stretchStartingKeyframe && delay) {
            var /** @type {?} */ newKeyframes = [];
            var /** @type {?} */ totalTime = duration + delay;
            var /** @type {?} */ startingGap = delay / totalTime;
            // the original starting keyframe now starts once the delay is done
            var /** @type {?} */ newFirstKeyframe = copyStyles(keyframes[0], false);
            newFirstKeyframe['offset'] = 0;
            newKeyframes.push(newFirstKeyframe);
            var /** @type {?} */ oldFirstKeyframe = copyStyles(keyframes[0], false);
            oldFirstKeyframe['offset'] = roundOffset(startingGap);
            newKeyframes.push(oldFirstKeyframe);
            /*
              When the keyframe is stretched then it means that the delay before the animation
              starts is gone. Instead the first keyframe is placed at the start of the animation
              and it is then copied to where it starts when the original delay is over. This basically
              means nothing animates during that delay, but the styles are still renderered. For this
              to work the original offset values that exist in the original keyframes must be "warped"
              so that they can take the new keyframe + delay into account.
      
              delay=1000, duration=1000, keyframes = 0 .5 1
      
              turns into
      
              delay=0, duration=2000, keyframes = 0 .33 .66 1
             */
            // offsets between 1 ... n -1 are all warped by the keyframe stretch
            var /** @type {?} */ limit = keyframes.length - 1;
            for (var /** @type {?} */ i = 1; i <= limit; i++) {
                var /** @type {?} */ kf = copyStyles(keyframes[i], false);
                var /** @type {?} */ oldOffset = (kf['offset']);
                var /** @type {?} */ timeAtKeyframe = delay + oldOffset * duration;
                kf['offset'] = roundOffset(timeAtKeyframe / totalTime);
                newKeyframes.push(kf);
            }
            // the new starting keyframe should be added at the start
            duration = totalTime;
            delay = 0;
            easing = '';
            keyframes = newKeyframes;
        }
        return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
    };
    return SubTimelineBuilder;
}(TimelineBuilder));
/**
 * @param {?} offset
 * @param {?=} decimalPoints
 * @return {?}
 */
function roundOffset(offset, decimalPoints) {
    if (decimalPoints === void 0) { decimalPoints = 3; }
    var /** @type {?} */ mult = Math.pow(10, decimalPoints - 1);
    return Math.round(offset * mult) / mult;
}
/**
 * @param {?} input
 * @param {?} allStyles
 * @return {?}
 */
function flattenStyles(input, allStyles) {
    var /** @type {?} */ styles = {};
    var /** @type {?} */ allProperties;
    input.forEach(function (token) {
        if (token === '*') {
            allProperties = allProperties || Object.keys(allStyles);
            allProperties.forEach(function (prop) { styles[prop] = __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"]; });
        }
        else {
            copyStyles(/** @type {?} */ (token), false, styles);
        }
    });
    return styles;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var Animation = (function () {
    /**
     * @param {?} _driver
     * @param {?} input
     */
    function Animation(_driver, input) {
        this._driver = _driver;
        var errors = [];
        var ast = buildAnimationAst(input, errors);
        if (errors.length) {
            var errorMessage = "animation validation failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        this._animationAst = ast;
    }
    /**
     * @param {?} element
     * @param {?} startingStyles
     * @param {?} destinationStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @return {?}
     */
    Animation.prototype.buildTimelines = function (element, startingStyles, destinationStyles, options, subInstructions) {
        var /** @type {?} */ start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : (startingStyles);
        var /** @type {?} */ dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : (destinationStyles);
        var /** @type {?} */ errors = [];
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ result = buildAnimationTimelines(this._driver, element, this._animationAst, start, dest, options, subInstructions, errors);
        if (errors.length) {
            var /** @type {?} */ errorMessage = "animation building failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        return result;
    };
    return Animation;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @experimental Animation support is experimental.
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */ var AnimationStyleNormalizer = (function () {
    function AnimationStyleNormalizer() {
    }
    return AnimationStyleNormalizer;
}());
/**
 * @experimental Animation support is experimental.
 */
var NoopAnimationStyleNormalizer = (function () {
    function NoopAnimationStyleNormalizer() {
    }
    NoopAnimationStyleNormalizer.prototype.normalizePropertyName = function (propertyName, errors) { return propertyName; };
    NoopAnimationStyleNormalizer.prototype.normalizeStyleValue = function (userProvidedProperty, normalizedProperty, value, errors) {
        return value;
    };
    return NoopAnimationStyleNormalizer;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var WebAnimationsStyleNormalizer = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](WebAnimationsStyleNormalizer, _super);
    function WebAnimationsStyleNormalizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizePropertyName = function (propertyName, errors) {
        return dashCaseToCamelCase(propertyName);
    };
    /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizeStyleValue = function (userProvidedProperty, normalizedProperty, value, errors) {
        var /** @type {?} */ unit = '';
        var /** @type {?} */ strVal = value.toString().trim();
        if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {
            if (typeof value === 'number') {
                unit = 'px';
            }
            else {
                var /** @type {?} */ valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                    errors.push("Please provide a CSS unit value for " + userProvidedProperty + ":" + value);
                }
            }
        }
        return strVal + unit;
    };
    return WebAnimationsStyleNormalizer;
}(AnimationStyleNormalizer));
var DIMENSIONAL_PROP_MAP = makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'
    .split(','));
/**
 * @param {?} keys
 * @return {?}
 */
function makeBooleanMap(keys) {
    var /** @type {?} */ map = {};
    keys.forEach(function (key) { return map[key] = true; });
    return map;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} element
 * @param {?} triggerName
 * @param {?} fromState
 * @param {?} toState
 * @param {?} isRemovalTransition
 * @param {?} fromStyles
 * @param {?} toStyles
 * @param {?} timelines
 * @param {?} queriedElements
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?=} errors
 * @return {?}
 */
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, errors) {
    return {
        type: 0 /* TransitionAnimation */,
        element: element,
        triggerName: triggerName,
        isRemovalTransition: isRemovalTransition,
        fromState: fromState,
        fromStyles: fromStyles,
        toState: toState,
        toStyles: toStyles,
        timelines: timelines,
        queriedElements: queriedElements,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        errors: errors
    };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var AnimationTransitionFactory = (function () {
    /**
     * @param {?} _triggerName
     * @param {?} ast
     * @param {?} _stateStyles
     */
    function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {
        this._triggerName = _triggerName;
        this.ast = ast;
        this._stateStyles = _stateStyles;
    }
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTransitionFactory.prototype.match = function (currentState, nextState) {
        return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState);
    };
    /**
     * @param {?} driver
     * @param {?} element
     * @param {?} currentState
     * @param {?} nextState
     * @param {?=} options
     * @param {?=} subInstructions
     * @return {?}
     */
    AnimationTransitionFactory.prototype.build = function (driver, element, currentState, nextState, options, subInstructions) {
        var /** @type {?} */ animationOptions = mergeAnimationOptions(this.ast.options || {}, options || {});
        var /** @type {?} */ backupStateStyles = this._stateStyles['*'] || {};
        var /** @type {?} */ currentStateStyles = this._stateStyles[currentState] || backupStateStyles;
        var /** @type {?} */ nextStateStyles = this._stateStyles[nextState] || backupStateStyles;
        var /** @type {?} */ queriedElements = new Set();
        var /** @type {?} */ preStyleMap = new Map();
        var /** @type {?} */ postStyleMap = new Map();
        var /** @type {?} */ isRemoval = nextState === 'void';
        var /** @type {?} */ errors = [];
        var /** @type {?} */ timelines = buildAnimationTimelines(driver, element, this.ast.animation, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
        if (errors.length) {
            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, errors);
        }
        timelines.forEach(function (tl) {
            var /** @type {?} */ elm = tl.element;
            var /** @type {?} */ preProps = getOrSetAsInMap(preStyleMap, elm, {});
            tl.preStyleProps.forEach(function (prop) { return preProps[prop] = true; });
            var /** @type {?} */ postProps = getOrSetAsInMap(postStyleMap, elm, {});
            tl.postStyleProps.forEach(function (prop) { return postProps[prop] = true; });
            if (elm !== element) {
                queriedElements.add(elm);
            }
        });
        var /** @type {?} */ queriedElementsList = iteratorToArray(queriedElements.values());
        return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap);
    };
    return AnimationTransitionFactory;
}());
/**
 * @param {?} matchFns
 * @param {?} currentState
 * @param {?} nextState
 * @return {?}
 */
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState) {
    return matchFns.some(function (fn) { return fn(currentState, nextState); });
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} ast
 * @return {?}
 */
function buildTrigger(name, ast) {
    return new AnimationTrigger(name, ast);
}
/**
 * \@experimental Animation support is experimental.
 */
var AnimationTrigger = (function () {
    /**
     * @param {?} name
     * @param {?} ast
     */
    function AnimationTrigger(name, ast) {
        var _this = this;
        this.name = name;
        this.ast = ast;
        this.transitionFactories = [];
        this.states = {};
        ast.states.forEach(function (ast) {
            var obj = _this.states[ast.name] = {};
            ast.style.styles.forEach(function (styleTuple) {
                if (typeof styleTuple == 'object') {
                    copyStyles(styleTuple, false, obj);
                }
            });
        });
        balanceProperties(this.states, 'true', '1');
        balanceProperties(this.states, 'false', '0');
        ast.transitions.forEach(function (ast) {
            _this.transitionFactories.push(new AnimationTransitionFactory(name, ast, _this.states));
        });
        this.fallbackTransition = createFallbackTransition(name, this.states);
    }
    Object.defineProperty(AnimationTrigger.prototype, "containsQueries", {
        /**
         * @return {?}
         */
        get: function () { return this.ast.queryCount > 0; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTrigger.prototype.matchTransition = function (currentState, nextState) {
        var /** @type {?} */ entry = this.transitionFactories.find(function (f) { return f.match(currentState, nextState); });
        return entry || null;
    };
    return AnimationTrigger;
}());
/**
 * @param {?} triggerName
 * @param {?} states
 * @return {?}
 */
function createFallbackTransition(triggerName, states) {
    var /** @type {?} */ matchers = [function (fromState, toState) { return true; }];
    var /** @type {?} */ animation = new SequenceAst([]);
    var /** @type {?} */ transition = new TransitionAst(matchers, animation);
    return new AnimationTransitionFactory(triggerName, transition, states);
}
/**
 * @param {?} obj
 * @param {?} key1
 * @param {?} key2
 * @return {?}
 */
function balanceProperties(obj, key1, key2) {
    if (obj.hasOwnProperty(key1)) {
        if (!obj.hasOwnProperty(key2)) {
            obj[key2] = obj[key1];
        }
    }
    else if (obj.hasOwnProperty(key2)) {
        obj[key1] = obj[key2];
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();
var TimelineAnimationEngine = (function () {
    /**
     * @param {?} _driver
     * @param {?} _normalizer
     */
    function TimelineAnimationEngine(_driver, _normalizer) {
        this._driver = _driver;
        this._normalizer = _normalizer;
        this._animations = {};
        this._playersById = {};
        this.players = [];
    }
    /**
     * @param {?} id
     * @param {?} metadata
     * @return {?}
     */
    TimelineAnimationEngine.prototype.register = function (id, metadata) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = buildAnimationAst(metadata, errors);
        if (errors.length) {
            throw new Error("Unable to build the animation due to the following errors: " + errors.join("\n"));
        }
        else {
            this._animations[id] = ast;
        }
    };
    /**
     * @param {?} i
     * @param {?} preStyles
     * @param {?=} postStyles
     * @return {?}
     */
    TimelineAnimationEngine.prototype._buildPlayer = function (i, preStyles, postStyles) {
        var /** @type {?} */ element = i.element;
        var /** @type {?} */ keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);
        return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, []);
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    TimelineAnimationEngine.prototype.create = function (id, element, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = this._animations[id];
        var /** @type {?} */ instructions;
        var /** @type {?} */ autoStylesMap = new Map();
        if (ast) {
            instructions = buildAnimationTimelines(this._driver, element, ast, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);
            instructions.forEach(function (inst) {
                var /** @type {?} */ styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
                inst.postStyleProps.forEach(function (prop) { return styles[prop] = null; });
            });
        }
        else {
            errors.push('The requested animation doesn\'t exist or has already been destroyed');
            instructions = [];
        }
        if (errors.length) {
            throw new Error("Unable to create the animation due to the following errors: " + errors.join("\n"));
        }
        autoStylesMap.forEach(function (styles, element) {
            Object.keys(styles).forEach(function (prop) { styles[prop] = _this._driver.computeStyle(element, prop, __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"]); });
        });
        var /** @type {?} */ players = instructions.map(function (i) {
            var /** @type {?} */ styles = autoStylesMap.get(i.element);
            return _this._buildPlayer(i, {}, styles);
        });
        var /** @type {?} */ player = optimizeGroupPlayer(players);
        this._playersById[id] = player;
        player.onDestroy(function () { return _this.destroy(id); });
        this.players.push(player);
        return player;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype.destroy = function (id) {
        var /** @type {?} */ player = this._getPlayer(id);
        player.destroy();
        delete this._playersById[id];
        var /** @type {?} */ index = this.players.indexOf(player);
        if (index >= 0) {
            this.players.splice(index, 1);
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype._getPlayer = function (id) {
        var /** @type {?} */ player = this._playersById[id];
        if (!player) {
            throw new Error("Unable to find the timeline player referenced by " + id);
        }
        return player;
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    TimelineAnimationEngine.prototype.listen = function (id, element, eventName, callback) {
        // triggerName, fromState, toState are all ignored for timeline animations
        var /** @type {?} */ baseEvent = makeAnimationEvent(element, '', '', '');
        listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
        return function () { };
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} command
     * @param {?} args
     * @return {?}
     */
    TimelineAnimationEngine.prototype.command = function (id, element, command, args) {
        if (command == 'register') {
            this.register(id, /** @type {?} */ (args[0]));
            return;
        }
        if (command == 'create') {
            var /** @type {?} */ options = ((args[0] || {}));
            this.create(id, element, options);
            return;
        }
        var /** @type {?} */ player = this._getPlayer(id);
        switch (command) {
            case 'play':
                player.play();
                break;
            case 'pause':
                player.pause();
                break;
            case 'reset':
                player.reset();
                break;
            case 'restart':
                player.restart();
                break;
            case 'finish':
                player.finish();
                break;
            case 'init':
                player.init();
                break;
            case 'setPosition':
                player.setPosition(parseFloat(/** @type {?} */ (args[0])));
                break;
            case 'destroy':
                this.destroy(id);
                break;
        }
    };
    return TimelineAnimationEngine;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var QUEUED_CLASSNAME = 'ng-animate-queued';
var QUEUED_SELECTOR = '.ng-animate-queued';
var DISABLED_CLASSNAME = 'ng-animate-disabled';
var DISABLED_SELECTOR = '.ng-animate-disabled';
var EMPTY_PLAYER_ARRAY = [];
var NULL_REMOVAL_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: false
};
var NULL_REMOVED_QUERIED_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: true
};
var REMOVAL_FLAG = '__ng_removed';
var StateValue = (function () {
    /**
     * @param {?} input
     */
    function StateValue(input) {
        var isObj = input && input.hasOwnProperty('value');
        var value = isObj ? input['value'] : input;
        this.value = normalizeTriggerValue(value);
        if (isObj) {
            var options = copyObj(input);
            delete options['value'];
            this.options = options;
        }
        else {
            this.options = {};
        }
        if (!this.options.params) {
            this.options.params = {};
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    StateValue.prototype.absorbOptions = function (options) {
        var /** @type {?} */ newParams = options.params;
        if (newParams) {
            var /** @type {?} */ oldParams_2 = ((this.options.params));
            Object.keys(newParams).forEach(function (prop) {
                if (oldParams_2[prop] == null) {
                    oldParams_2[prop] = newParams[prop];
                }
            });
        }
    };
    return StateValue;
}());
var VOID_VALUE = 'void';
var DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);
var DELETED_STATE_VALUE = new StateValue('DELETED');
var AnimationTransitionNamespace = (function () {
    /**
     * @param {?} id
     * @param {?} hostElement
     * @param {?} _engine
     */
    function AnimationTransitionNamespace(id, hostElement, _engine) {
        this.id = id;
        this.hostElement = hostElement;
        this._engine = _engine;
        this.players = [];
        this._triggers = {};
        this._queue = [];
        this._elementListeners = new Map();
        this._hostClassName = 'ng-tns-' + id;
        addClass(hostElement, this._hostClassName);
    }
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.listen = function (element, name, phase, callback) {
        var _this = this;
        if (!this._triggers.hasOwnProperty(name)) {
            throw new Error("Unable to listen on the animation trigger event \"" + phase + "\" because the animation trigger \"" + name + "\" doesn't exist!");
        }
        if (phase == null || phase.length == 0) {
            throw new Error("Unable to listen on the animation trigger \"" + name + "\" because the provided event is undefined!");
        }
        if (!isTriggerEventValid(phase)) {
            throw new Error("The provided animation trigger event \"" + phase + "\" for the animation trigger \"" + name + "\" is not supported!");
        }
        var /** @type {?} */ listeners = getOrSetAsInMap(this._elementListeners, element, []);
        var /** @type {?} */ data = { name: name, phase: phase, callback: callback };
        listeners.push(data);
        var /** @type {?} */ triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
        if (!triggersWithStates.hasOwnProperty(name)) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);
            triggersWithStates[name] = null;
        }
        return function () {
            // the event listener is removed AFTER the flush has occurred such
            // that leave animations callbacks can fire (otherwise if the node
            // is removed in between then the listeners would be deregistered)
            _this._engine.afterFlush(function () {
                var /** @type {?} */ index = listeners.indexOf(data);
                if (index >= 0) {
                    listeners.splice(index, 1);
                }
                if (!_this._triggers[name]) {
                    delete triggersWithStates[name];
                }
            });
        };
    };
    /**
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.register = function (name, ast) {
        if (this._triggers[name]) {
            // throw
            return false;
        }
        else {
            this._triggers[name] = ast;
            return true;
        }
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._getTrigger = function (name) {
        var /** @type {?} */ trigger = this._triggers[name];
        if (!trigger) {
            throw new Error("The provided animation trigger \"" + name + "\" has not been registered!");
        }
        return trigger;
    };
    /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} value
     * @param {?=} defaultToFallback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.trigger = function (element, triggerName, value, defaultToFallback) {
        var _this = this;
        if (defaultToFallback === void 0) { defaultToFallback = true; }
        var /** @type {?} */ trigger = this._getTrigger(triggerName);
        var /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);
        var /** @type {?} */ triggersWithStates = this._engine.statesByElement.get(element);
        if (!triggersWithStates) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);
            this._engine.statesByElement.set(element, triggersWithStates = {});
        }
        var /** @type {?} */ fromState = triggersWithStates[triggerName];
        var /** @type {?} */ toState = new StateValue(value);
        var /** @type {?} */ isObj = value && value.hasOwnProperty('value');
        if (!isObj && fromState) {
            toState.absorbOptions(fromState.options);
        }
        triggersWithStates[triggerName] = toState;
        if (!fromState) {
            fromState = DEFAULT_STATE_VALUE;
        }
        else if (fromState === DELETED_STATE_VALUE) {
            return player;
        }
        var /** @type {?} */ isRemoval = toState.value === VOID_VALUE;
        // normally this isn't reached by here, however, if an object expression
        // is passed in then it may be a new object each time. Comparing the value
        // is important since that will stay the same despite there being a new object.
        // The removal arc here is special cased because the same element is triggered
        // twice in the event that it contains animations on the outer/inner portions
        // of the host container
        if (!isRemoval && fromState.value === toState.value)
            return;
        var /** @type {?} */ playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
        playersOnElement.forEach(function (player) {
            // only remove the player if it is queued on the EXACT same trigger/namespace
            // we only also deal with queued players here because if the animation has
            // started then we want to keep the player alive until the flush happens
            // (which is where the previousPlayers are passed into the new palyer)
            if (player.namespaceId == _this.id && player.triggerName == triggerName && player.queued) {
                player.destroy();
            }
        });
        var /** @type {?} */ transition = trigger.matchTransition(fromState.value, toState.value);
        var /** @type {?} */ isFallbackTransition = false;
        if (!transition) {
            if (!defaultToFallback)
                return;
            transition = trigger.fallbackTransition;
            isFallbackTransition = true;
        }
        this._engine.totalQueuedPlayers++;
        this._queue.push({ element: element, triggerName: triggerName, transition: transition, fromState: fromState, toState: toState, player: player, isFallbackTransition: isFallbackTransition });
        if (!isFallbackTransition) {
            addClass(element, QUEUED_CLASSNAME);
            player.onStart(function () { removeClass(element, QUEUED_CLASSNAME); });
        }
        player.onDone(function () {
            var /** @type {?} */ index = _this.players.indexOf(player);
            if (index >= 0) {
                _this.players.splice(index, 1);
            }
            var /** @type {?} */ players = _this._engine.playersByElement.get(element);
            if (players) {
                var /** @type {?} */ index_1 = players.indexOf(player);
                if (index_1 >= 0) {
                    players.splice(index_1, 1);
                }
            }
        });
        this.players.push(player);
        playersOnElement.push(player);
        return player;
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.deregister = function (name) {
        var _this = this;
        delete this._triggers[name];
        this._engine.statesByElement.forEach(function (stateMap, element) { delete stateMap[name]; });
        this._elementListeners.forEach(function (listeners, element) {
            _this._elementListeners.set(element, listeners.filter(function (entry) { return entry.name != name; }));
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.clearElementCache = function (element) {
        this._engine.statesByElement.delete(element);
        this._elementListeners.delete(element);
        var /** @type {?} */ elementPlayers = this._engine.playersByElement.get(element);
        if (elementPlayers) {
            elementPlayers.forEach(function (player) { return player.destroy(); });
            this._engine.playersByElement.delete(element);
        }
    };
    /**
     * @param {?} rootElement
     * @param {?} context
     * @param {?=} animate
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._destroyInnerNodes = function (rootElement, context, animate) {
        var _this = this;
        if (animate === void 0) { animate = false; }
        this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(function (elm) {
            if (animate && containsClass(elm, _this._hostClassName)) {
                var /** @type {?} */ innerNs = _this._engine.namespacesByHostElement.get(elm);
                // special case for a host element with animations on the same element
                if (innerNs) {
                    innerNs.removeNode(elm, context, true);
                }
                _this.removeNode(elm, context, true);
            }
            else {
                _this.clearElementCache(elm);
            }
        });
    };
    /**
     * @param {?} element
     * @param {?} context
     * @param {?=} doNotRecurse
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.removeNode = function (element, context, doNotRecurse) {
        var _this = this;
        var /** @type {?} */ engine = this._engine;
        if (!doNotRecurse && element.childElementCount) {
            this._destroyInnerNodes(element, context, true);
        }
        var /** @type {?} */ triggerStates = engine.statesByElement.get(element);
        if (triggerStates) {
            var /** @type {?} */ players_1 = [];
            Object.keys(triggerStates).forEach(function (triggerName) {
                // this check is here in the event that an element is removed
                // twice (both on the host level and the component level)
                if (_this._triggers[triggerName]) {
                    var /** @type {?} */ player = _this.trigger(element, triggerName, VOID_VALUE, false);
                    if (player) {
                        players_1.push(player);
                    }
                }
            });
            if (players_1.length) {
                engine.markElementAsRemoved(this.id, element, true, context);
                optimizeGroupPlayer(players_1).onDone(function () { return engine.processLeaveNode(element); });
                return;
            }
        }
        // find the player that is animating and make sure that the
        // removal is delayed until that player has completed
        var /** @type {?} */ containsPotentialParentTransition = false;
        if (engine.totalAnimations) {
            var /** @type {?} */ currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
            // when this `if statement` does not continue forward it means that
            // a previous animation query has selected the current element and
            // is animating it. In this situation want to continue fowards and
            // allow the element to be queued up for animation later.
            if (currentPlayers && currentPlayers.length) {
                containsPotentialParentTransition = true;
            }
            else {
                var /** @type {?} */ parent = element;
                while (parent = parent.parentNode) {
                    var /** @type {?} */ triggers = engine.statesByElement.get(parent);
                    if (triggers) {
                        containsPotentialParentTransition = true;
                        break;
                    }
                }
            }
        }
        // at this stage we know that the element will either get removed
        // during flush or will be picked up by a parent query. Either way
        // we need to fire the listeners for this element when it DOES get
        // removed (once the query parent animation is done or after flush)
        var /** @type {?} */ listeners = this._elementListeners.get(element);
        if (listeners) {
            var /** @type {?} */ visitedTriggers_1 = new Set();
            listeners.forEach(function (listener) {
                var /** @type {?} */ triggerName = listener.name;
                if (visitedTriggers_1.has(triggerName))
                    return;
                visitedTriggers_1.add(triggerName);
                var /** @type {?} */ trigger = _this._triggers[triggerName];
                var /** @type {?} */ transition = trigger.fallbackTransition;
                var /** @type {?} */ elementStates = ((engine.statesByElement.get(element)));
                var /** @type {?} */ fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;
                var /** @type {?} */ toState = new StateValue(VOID_VALUE);
                var /** @type {?} */ player = new TransitionAnimationPlayer(_this.id, triggerName, element);
                _this._engine.totalQueuedPlayers++;
                _this._queue.push({
                    element: element,
                    triggerName: triggerName,
                    transition: transition,
                    fromState: fromState,
                    toState: toState,
                    player: player,
                    isFallbackTransition: true
                });
            });
        }
        // whether or not a parent has an animation we need to delay the deferral of the leave
        // operation until we have more information (which we do after flush() has been called)
        if (containsPotentialParentTransition) {
            engine.markElementAsRemoved(this.id, element, false, context);
        }
        else {
            // we do this after the flush has occurred such
            // that the callbacks can be fired
            engine.afterFlush(function () { return _this.clearElementCache(element); });
            engine.destroyInnerAnimations(element);
            engine._onRemovalComplete(element, context);
        }
    };
    /**
     * @param {?} element
     * @param {?} parent
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.insertNode = function (element, parent) { addClass(element, this._hostClassName); };
    /**
     * @param {?} microtaskId
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.drainQueuedTransitions = function (microtaskId) {
        var _this = this;
        var /** @type {?} */ instructions = [];
        this._queue.forEach(function (entry) {
            var /** @type {?} */ player = entry.player;
            if (player.destroyed)
                return;
            var /** @type {?} */ element = entry.element;
            var /** @type {?} */ listeners = _this._elementListeners.get(element);
            if (listeners) {
                listeners.forEach(function (listener) {
                    if (listener.name == entry.triggerName) {
                        var /** @type {?} */ baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
                        ((baseEvent))['_data'] = microtaskId;
                        listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
                    }
                });
            }
            if (player.markedForDestroy) {
                _this._engine.afterFlush(function () {
                    // now we can destroy the element properly since the event listeners have
                    // been bound to the player
                    player.destroy();
                });
            }
            else {
                instructions.push(entry);
            }
        });
        this._queue = [];
        return instructions.sort(function (a, b) {
            // if depCount == 0 them move to front
            // otherwise if a contains b then move back
            var /** @type {?} */ d0 = a.transition.ast.depCount;
            var /** @type {?} */ d1 = b.transition.ast.depCount;
            if (d0 == 0 || d1 == 0) {
                return d0 - d1;
            }
            return _this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
        });
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.destroy = function (context) {
        this.players.forEach(function (p) { return p.destroy(); });
        this._destroyInnerNodes(this.hostElement, context);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.elementContainsData = function (element) {
        var /** @type {?} */ containsData = false;
        if (this._elementListeners.has(element))
            containsData = true;
        containsData =
            (this._queue.find(function (entry) { return entry.element === element; }) ? true : false) || containsData;
        return containsData;
    };
    return AnimationTransitionNamespace;
}());
var TransitionAnimationEngine = (function () {
    /**
     * @param {?} driver
     * @param {?} _normalizer
     */
    function TransitionAnimationEngine(driver, _normalizer) {
        this.driver = driver;
        this._normalizer = _normalizer;
        this.players = [];
        this.newHostElements = new Map();
        this.playersByElement = new Map();
        this.playersByQueriedElement = new Map();
        this.statesByElement = new Map();
        this.disabledNodes = new Set();
        this.totalAnimations = 0;
        this.totalQueuedPlayers = 0;
        this._namespaceLookup = {};
        this._namespaceList = [];
        this._flushFns = [];
        this._whenQuietFns = [];
        this.namespacesByHostElement = new Map();
        this.collectedEnterElements = [];
        this.collectedLeaveElements = [];
        this.onRemovalComplete = function (element, context) { };
    }
    /**
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype._onRemovalComplete = function (element, context) { this.onRemovalComplete(element, context); };
    Object.defineProperty(TransitionAnimationEngine.prototype, "queuedPlayers", {
        /**
         * @return {?}
         */
        get: function () {
            var /** @type {?} */ players = [];
            this._namespaceList.forEach(function (ns) {
                ns.players.forEach(function (player) {
                    if (player.queued) {
                        players.push(player);
                    }
                });
            });
            return players;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.createNamespace = function (namespaceId, hostElement) {
        var /** @type {?} */ ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
        if (hostElement.parentNode) {
            this._balanceNamespaceList(ns, hostElement);
        }
        else {
            // defer this later until flush during when the host element has
            // been inserted so that we know exactly where to place it in
            // the namespace list
            this.newHostElements.set(hostElement, ns);
            // given that this host element is apart of the animation code, it
            // may or may not be inserted by a parent node that is an of an
            // animation renderer type. If this happens then we can still have
            // access to this item when we query for :enter nodes. If the parent
            // is a renderer then the set data-structure will normalize the entry
            this.collectEnterElement(hostElement);
        }
        return this._namespaceLookup[namespaceId] = ns;
    };
    /**
     * @param {?} ns
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype._balanceNamespaceList = function (ns, hostElement) {
        var /** @type {?} */ limit = this._namespaceList.length - 1;
        if (limit >= 0) {
            var /** @type {?} */ found = false;
            for (var /** @type {?} */ i = limit; i >= 0; i--) {
                var /** @type {?} */ nextNamespace = this._namespaceList[i];
                if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {
                    this._namespaceList.splice(i + 1, 0, ns);
                    found = true;
                    break;
                }
            }
            if (!found) {
                this._namespaceList.splice(0, 0, ns);
            }
        }
        else {
            this._namespaceList.push(ns);
        }
        this.namespacesByHostElement.set(hostElement, ns);
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.register = function (namespaceId, hostElement) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (!ns) {
            ns = this.createNamespace(namespaceId, hostElement);
        }
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} name
     * @param {?} trigger
     * @return {?}
     */
    TransitionAnimationEngine.prototype.registerTrigger = function (namespaceId, name, trigger) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (ns && ns.register(name, trigger)) {
            this.totalAnimations++;
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroy = function (namespaceId, context) {
        var _this = this;
        if (!namespaceId)
            return;
        var /** @type {?} */ ns = this._fetchNamespace(namespaceId);
        this.afterFlush(function () {
            _this.namespacesByHostElement.delete(ns.hostElement);
            delete _this._namespaceLookup[namespaceId];
            var /** @type {?} */ index = _this._namespaceList.indexOf(ns);
            if (index >= 0) {
                _this._namespaceList.splice(index, 1);
            }
        });
        this.afterFlushAnimationsDone(function () { return ns.destroy(context); });
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TransitionAnimationEngine.prototype._fetchNamespace = function (id) { return this._namespaceLookup[id]; };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.trigger = function (namespaceId, element, name, value) {
        if (isElementNode(element)) {
            this._fetchNamespace(namespaceId).trigger(element, name, value);
            return true;
        }
        return false;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    TransitionAnimationEngine.prototype.insertNode = function (namespaceId, element, parent, insertBefore) {
        if (!isElementNode(element))
            return;
        // special case for when an element is removed and reinserted (move operation)
        // when this occurs we do not want to use the element for deletion later
        var /** @type {?} */ details = (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            details.setForRemoval = false;
        }
        // in the event that the namespaceId is blank then the caller
        // code does not contain any animation code in it, but it is
        // just being called so that the node is marked as being inserted
        if (namespaceId) {
            this._fetchNamespace(namespaceId).insertNode(element, parent);
        }
        // only *directives and host elements are inserted before
        if (insertBefore) {
            this.collectEnterElement(element);
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.collectEnterElement = function (element) { this.collectedEnterElements.push(element); };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsDisabled = function (element, value) {
        if (value) {
            if (!this.disabledNodes.has(element)) {
                this.disabledNodes.add(element);
                addClass(element, DISABLED_CLASSNAME);
            }
        }
        else if (this.disabledNodes.has(element)) {
            this.disabledNodes.delete(element);
            removeClass(element, DISABLED_CLASSNAME);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @param {?=} doNotRecurse
     * @return {?}
     */
    TransitionAnimationEngine.prototype.removeNode = function (namespaceId, element, context, doNotRecurse) {
        if (!isElementNode(element)) {
            this._onRemovalComplete(element, context);
            return;
        }
        var /** @type {?} */ ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
        if (ns) {
            ns.removeNode(element, context, doNotRecurse);
        }
        else {
            this.markElementAsRemoved(namespaceId, element, false, context);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?=} hasAnimation
     * @param {?=} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsRemoved = function (namespaceId, element, hasAnimation, context) {
        this.collectedLeaveElements.push(element);
        element[REMOVAL_FLAG] = {
            namespaceId: namespaceId,
            setForRemoval: context, hasAnimation: hasAnimation,
            removedBeforeQueried: false
        };
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.listen = function (namespaceId, element, name, phase, callback) {
        if (isElementNode(element)) {
            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
        }
        return function () { };
    };
    /**
     * @param {?} entry
     * @param {?} subTimelines
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildInstruction = function (entry, subTimelines) {
        return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, entry.toState.options, subTimelines);
    };
    /**
     * @param {?} containerElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroyInnerAnimations = function (containerElement) {
        var _this = this;
        var /** @type {?} */ elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
        elements.forEach(function (element) {
            var /** @type {?} */ players = _this.playersByElement.get(element);
            if (players) {
                players.forEach(function (player) {
                    // special case for when an element is set for destruction, but hasn't started.
                    // in this situation we want to delay the destruction until the flush occurs
                    // so that any event listeners attached to the player are triggered.
                    if (player.queued) {
                        player.markedForDestroy = true;
                    }
                    else {
                        player.destroy();
                    }
                });
            }
            var /** @type {?} */ stateMap = _this.statesByElement.get(element);
            if (stateMap) {
                Object.keys(stateMap).forEach(function (triggerName) { return stateMap[triggerName] = DELETED_STATE_VALUE; });
            }
        });
        if (this.playersByQueriedElement.size == 0)
            return;
        elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
        if (elements.length) {
            elements.forEach(function (element) {
                var /** @type {?} */ players = _this.playersByQueriedElement.get(element);
                if (players) {
                    players.forEach(function (player) { return player.finish(); });
                }
            });
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationEngine.prototype.whenRenderingDone = function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this.players.length) {
                return optimizeGroupPlayer(_this.players).onDone(function () { return resolve(); });
            }
            else {
                resolve();
            }
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.processLeaveNode = function (element) {
        var _this = this;
        var /** @type {?} */ details = (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            // this will prevent it from removing it twice
            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
            if (details.namespaceId) {
                this.destroyInnerAnimations(element);
                var /** @type {?} */ ns = this._fetchNamespace(details.namespaceId);
                if (ns) {
                    ns.clearElementCache(element);
                }
            }
            this._onRemovalComplete(element, details.setForRemoval);
        }
        if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {
            this.markElementAsDisabled(element, false);
        }
        this.driver.query(element, DISABLED_SELECTOR, true).forEach(function (node) {
            _this.markElementAsDisabled(element, false);
        });
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype.flush = function (microtaskId) {
        var _this = this;
        if (microtaskId === void 0) { microtaskId = -1; }
        var /** @type {?} */ players = [];
        if (this.newHostElements.size) {
            this.newHostElements.forEach(function (ns, element) { return _this._balanceNamespaceList(ns, element); });
            this.newHostElements.clear();
        }
        if (this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
            var /** @type {?} */ cleanupFns = [];
            try {
                players = this._flushAnimations(cleanupFns, microtaskId);
            }
            finally {
                for (var /** @type {?} */ i = 0; i < cleanupFns.length; i++) {
                    cleanupFns[i]();
                }
            }
        }
        else {
            for (var /** @type {?} */ i = 0; i < this.collectedLeaveElements.length; i++) {
                var /** @type {?} */ element = this.collectedLeaveElements[i];
                this.processLeaveNode(element);
            }
        }
        this.totalQueuedPlayers = 0;
        this.collectedEnterElements.length = 0;
        this.collectedLeaveElements.length = 0;
        this._flushFns.forEach(function (fn) { return fn(); });
        this._flushFns = [];
        if (this._whenQuietFns.length) {
            // we move these over to a variable so that
            // if any new callbacks are registered in another
            // flush they do not populate the existing set
            var /** @type {?} */ quietFns_1 = this._whenQuietFns;
            this._whenQuietFns = [];
            if (players.length) {
                optimizeGroupPlayer(players).onDone(function () { quietFns_1.forEach(function (fn) { return fn(); }); });
            }
            else {
                quietFns_1.forEach(function (fn) { return fn(); });
            }
        }
    };
    /**
     * @param {?} cleanupFns
     * @param {?} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype._flushAnimations = function (cleanupFns, microtaskId) {
        var _this = this;
        var /** @type {?} */ subTimelines = new ElementInstructionMap();
        var /** @type {?} */ skippedPlayers = [];
        var /** @type {?} */ skippedPlayersMap = new Map();
        var /** @type {?} */ queuedInstructions = [];
        var /** @type {?} */ queriedElements = new Map();
        var /** @type {?} */ allPreStyleElements = new Map();
        var /** @type {?} */ allPostStyleElements = new Map();
        var /** @type {?} */ disabledElementsSet = new Set();
        this.disabledNodes.forEach(function (node) {
            var /** @type {?} */ nodesThatAreDisabled = _this.driver.query(node, QUEUED_SELECTOR, true);
            for (var /** @type {?} */ i = 0; i < nodesThatAreDisabled.length; i++) {
                disabledElementsSet.add(nodesThatAreDisabled[i]);
            }
        });
        var /** @type {?} */ bodyNode = getBodyNode();
        var /** @type {?} */ allEnterNodes = this.collectedEnterElements.length ?
            this.collectedEnterElements.filter(createIsRootFilterFn(this.collectedEnterElements)) :
            [];
        // this must occur before the instructions are built below such that
        // the :enter queries match the elements (since the timeline queries
        // are fired during instruction building).
        for (var /** @type {?} */ i = 0; i < allEnterNodes.length; i++) {
            addClass(allEnterNodes[i], ENTER_CLASSNAME);
        }
        var /** @type {?} */ allLeaveNodes = [];
        var /** @type {?} */ leaveNodesWithoutAnimations = [];
        for (var /** @type {?} */ i = 0; i < this.collectedLeaveElements.length; i++) {
            var /** @type {?} */ element = this.collectedLeaveElements[i];
            var /** @type {?} */ details = (element[REMOVAL_FLAG]);
            if (details && details.setForRemoval) {
                addClass(element, LEAVE_CLASSNAME);
                allLeaveNodes.push(element);
                if (!details.hasAnimation) {
                    leaveNodesWithoutAnimations.push(element);
                }
            }
        }
        cleanupFns.push(function () {
            allEnterNodes.forEach(function (element) { return removeClass(element, ENTER_CLASSNAME); });
            allLeaveNodes.forEach(function (element) {
                removeClass(element, LEAVE_CLASSNAME);
                _this.processLeaveNode(element);
            });
        });
        var /** @type {?} */ allPlayers = [];
        var /** @type {?} */ erroneousTransitions = [];
        for (var /** @type {?} */ i = this._namespaceList.length - 1; i >= 0; i--) {
            var /** @type {?} */ ns = this._namespaceList[i];
            ns.drainQueuedTransitions(microtaskId).forEach(function (entry) {
                var /** @type {?} */ player = entry.player;
                allPlayers.push(player);
                var /** @type {?} */ element = entry.element;
                if (!bodyNode || !_this.driver.containsElement(bodyNode, element)) {
                    player.destroy();
                    return;
                }
                var /** @type {?} */ instruction = ((_this._buildInstruction(entry, subTimelines)));
                if (instruction.errors && instruction.errors.length) {
                    erroneousTransitions.push(instruction);
                    return;
                }
                // if a unmatched transition is queued to go then it SHOULD NOT render
                // an animation and cancel the previously running animations.
                if (entry.isFallbackTransition) {
                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });
                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                    skippedPlayers.push(player);
                    return;
                }
                // this means that if a parent animation uses this animation as a sub trigger
                // then it will instruct the timeline builder to not add a player delay, but
                // instead stretch the first keyframe gap up until the animation starts. The
                // reason this is important is to prevent extra initialization styles from being
                // required by the user in the animation.
                instruction.timelines.forEach(function (tl) { return tl.stretchStartingKeyframe = true; });
                subTimelines.append(element, instruction.timelines);
                var /** @type {?} */ tuple = { instruction: instruction, player: player, element: element };
                queuedInstructions.push(tuple);
                instruction.queriedElements.forEach(function (element) { return getOrSetAsInMap(queriedElements, element, []).push(player); });
                instruction.preStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    if (props.length) {
                        var /** @type {?} */ setVal_1 = ((allPreStyleElements.get(element)));
                        if (!setVal_1) {
                            allPreStyleElements.set(element, setVal_1 = new Set());
                        }
                        props.forEach(function (prop) { return setVal_1.add(prop); });
                    }
                });
                instruction.postStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    var /** @type {?} */ setVal = ((allPostStyleElements.get(element)));
                    if (!setVal) {
                        allPostStyleElements.set(element, setVal = new Set());
                    }
                    props.forEach(function (prop) { return setVal.add(prop); });
                });
            });
        }
        if (erroneousTransitions.length) {
            var /** @type {?} */ msg_1 = "Unable to process animations due to the following failed trigger transitions\n";
            erroneousTransitions.forEach(function (instruction) {
                msg_1 += "@" + instruction.triggerName + " has failed due to:\n"; /** @type {?} */
                ((instruction.errors)).forEach(function (error) { msg_1 += "- " + error + "\n"; });
            });
            allPlayers.forEach(function (player) { return player.destroy(); });
            throw new Error(msg_1);
        }
        // these can only be detected here since we have a map of all the elements
        // that have animations attached to them...
        var /** @type {?} */ enterNodesWithoutAnimations = [];
        for (var /** @type {?} */ i = 0; i < allEnterNodes.length; i++) {
            var /** @type {?} */ element = allEnterNodes[i];
            if (!subTimelines.has(element)) {
                enterNodesWithoutAnimations.push(element);
            }
        }
        var /** @type {?} */ allPreviousPlayersMap = new Map();
        var /** @type {?} */ sortedParentElements = [];
        queuedInstructions.forEach(function (entry) {
            var /** @type {?} */ element = entry.element;
            if (subTimelines.has(element)) {
                sortedParentElements.unshift(element);
                _this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
            }
        });
        skippedPlayers.forEach(function (player) {
            var /** @type {?} */ element = player.element;
            var /** @type {?} */ previousPlayers = _this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
            previousPlayers.forEach(function (prevPlayer) { getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer); });
        });
        allPreviousPlayersMap.forEach(function (players) { return players.forEach(function (player) { return player.destroy(); }); });
        // PRE STAGE: fill the ! styles
        var /** @type {?} */ preStylesMap = allPreStyleElements.size ?
            cloakAndComputeStyles(this.driver, enterNodesWithoutAnimations, allPreStyleElements, __WEBPACK_IMPORTED_MODULE_1__angular_animations__["ɵPRE_STYLE"]) :
            new Map();
        // POST STAGE: fill the * styles
        var /** @type {?} */ postStylesMap = cloakAndComputeStyles(this.driver, leaveNodesWithoutAnimations, allPostStyleElements, __WEBPACK_IMPORTED_MODULE_1__angular_animations__["AUTO_STYLE"]);
        var /** @type {?} */ rootPlayers = [];
        var /** @type {?} */ subPlayers = [];
        queuedInstructions.forEach(function (entry) {
            var element = entry.element, player = entry.player, instruction = entry.instruction;
            // this means that it was never consumed by a parent animation which
            // means that it is independent and therefore should be set for animation
            if (subTimelines.has(element)) {
                if (disabledElementsSet.has(element)) {
                    skippedPlayers.push(player);
                    return;
                }
                var /** @type {?} */ innerPlayer = _this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
                player.setRealPlayer(innerPlayer);
                var /** @type {?} */ parentHasPriority = null;
                for (var /** @type {?} */ i = 0; i < sortedParentElements.length; i++) {
                    var /** @type {?} */ parent = sortedParentElements[i];
                    if (parent === element)
                        break;
                    if (_this.driver.containsElement(parent, element)) {
                        parentHasPriority = parent;
                        break;
                    }
                }
                if (parentHasPriority) {
                    var /** @type {?} */ parentPlayers = _this.playersByElement.get(parentHasPriority);
                    if (parentPlayers && parentPlayers.length) {
                        player.parentPlayer = optimizeGroupPlayer(parentPlayers);
                    }
                    skippedPlayers.push(player);
                }
                else {
                    rootPlayers.push(player);
                }
            }
            else {
                eraseStyles(element, instruction.fromStyles);
                player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                subPlayers.push(player);
            }
        });
        subPlayers.forEach(function (player) {
            var /** @type {?} */ playersForElement = skippedPlayersMap.get(player.element);
            if (playersForElement && playersForElement.length) {
                var /** @type {?} */ innerPlayer = optimizeGroupPlayer(playersForElement);
                player.setRealPlayer(innerPlayer);
            }
        });
        // the reason why we don't actually play the animation is
        // because all that a skipped player is designed to do is to
        // fire the start/done transition callback events
        skippedPlayers.forEach(function (player) {
            if (player.parentPlayer) {
                player.parentPlayer.onDestroy(function () { return player.destroy(); });
            }
            else {
                player.destroy();
            }
        });
        // run through all of the queued removals and see if they
        // were picked up by a query. If not then perform the removal
        // operation right away unless a parent animation is ongoing.
        for (var /** @type {?} */ i = 0; i < allLeaveNodes.length; i++) {
            var /** @type {?} */ element = allLeaveNodes[i];
            var /** @type {?} */ details = (element[REMOVAL_FLAG]);
            removeClass(element, LEAVE_CLASSNAME);
            // this means the element has a removal animation that is being
            // taken care of and therefore the inner elements will hang around
            // until that animation is over (or the parent queried animation)
            if (details && details.hasAnimation)
                continue;
            var /** @type {?} */ players = [];
            // if this element is queried or if it contains queried children
            // then we want for the element not to be removed from the page
            // until the queried animations have finished
            if (queriedElements.size) {
                var /** @type {?} */ queriedPlayerResults = queriedElements.get(element);
                if (queriedPlayerResults && queriedPlayerResults.length) {
                    players.push.apply(players, queriedPlayerResults);
                }
                var /** @type {?} */ queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
                for (var /** @type {?} */ j = 0; j < queriedInnerElements.length; j++) {
                    var /** @type {?} */ queriedPlayers = queriedElements.get(queriedInnerElements[j]);
                    if (queriedPlayers && queriedPlayers.length) {
                        players.push.apply(players, queriedPlayers);
                    }
                }
            }
            if (players.length) {
                removeNodesAfterAnimationDone(this, element, players);
            }
            else {
                this.processLeaveNode(element);
            }
        }
        // this is required so the cleanup method doesn't remove them
        allLeaveNodes.length = 0;
        rootPlayers.forEach(function (player) {
            _this.players.push(player);
            player.onDone(function () {
                player.destroy();
                var /** @type {?} */ index = _this.players.indexOf(player);
                _this.players.splice(index, 1);
            });
            player.play();
        });
        return rootPlayers;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.elementContainsData = function (namespaceId, element) {
        var /** @type {?} */ containsData = false;
        var /** @type {?} */ details = (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval)
            containsData = true;
        if (this.playersByElement.has(element))
            containsData = true;
        if (this.playersByQueriedElement.has(element))
            containsData = true;
        if (this.statesByElement.has(element))
            containsData = true;
        return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlush = function (callback) { this._flushFns.push(callback); };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlushAnimationsDone = function (callback) { this._whenQuietFns.push(callback); };
    /**
     * @param {?} element
     * @param {?} isQueriedElement
     * @param {?=} namespaceId
     * @param {?=} triggerName
     * @param {?=} toStateValue
     * @return {?}
     */
    TransitionAnimationEngine.prototype._getPreviousPlayers = function (element, isQueriedElement, namespaceId, triggerName, toStateValue) {
        var /** @type {?} */ players = [];
        if (isQueriedElement) {
            var /** @type {?} */ queriedElementPlayers = this.playersByQueriedElement.get(element);
            if (queriedElementPlayers) {
                players = queriedElementPlayers;
            }
        }
        else {
            var /** @type {?} */ elementPlayers = this.playersByElement.get(element);
            if (elementPlayers) {
                var /** @type {?} */ isRemovalAnimation_1 = !toStateValue || toStateValue == VOID_VALUE;
                elementPlayers.forEach(function (player) {
                    if (player.queued)
                        return;
                    if (!isRemovalAnimation_1 && player.triggerName != triggerName)
                        return;
                    players.push(player);
                });
            }
        }
        if (namespaceId || triggerName) {
            players = players.filter(function (player) {
                if (namespaceId && namespaceId != player.namespaceId)
                    return false;
                if (triggerName && triggerName != player.triggerName)
                    return false;
                return true;
            });
        }
        return players;
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._beforeAnimationBuild = function (namespaceId, instruction, allPreviousPlayersMap) {
        var _this = this;
        // it's important to do this step before destroying the players
        // so that the onDone callback below won't fire before this
        eraseStyles(instruction.element, instruction.fromStyles);
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // when a removal animation occurs, ALL previous players are collected
        // and destroyed (even if they are outside of the current namespace)
        var /** @type {?} */ targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;
        var /** @type {?} */ targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;
        instruction.timelines.map(function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
            var /** @type {?} */ previousPlayers = _this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
            previousPlayers.forEach(function (player) {
                var /** @type {?} */ realPlayer = (player.getRealPlayer());
                if (realPlayer.beforeDestroy) {
                    realPlayer.beforeDestroy();
                }
                players.push(player);
            });
        });
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @param {?} skippedPlayersMap
     * @param {?} preStylesMap
     * @param {?} postStylesMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildAnimation = function (namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
        var _this = this;
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // we first run this so that the previous animation player
        // data can be passed into the successive animation players
        var /** @type {?} */ allQueriedPlayers = [];
        var /** @type {?} */ allConsumedElements = new Set();
        var /** @type {?} */ allSubElements = new Set();
        var /** @type {?} */ allNewPlayers = instruction.timelines.map(function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            allConsumedElements.add(element);
            // FIXME (matsko): make sure to-be-removed animations are removed properly
            var /** @type {?} */ details = element[REMOVAL_FLAG];
            if (details && details.removedBeforeQueried)
                return new __WEBPACK_IMPORTED_MODULE_1__angular_animations__["NoopAnimationPlayer"]();
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map(function (p) { return p.getRealPlayer(); }));
            var /** @type {?} */ preStyles = preStylesMap.get(element);
            var /** @type {?} */ postStyles = postStylesMap.get(element);
            var /** @type {?} */ keyframes = normalizeKeyframes(_this.driver, _this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);
            var /** @type {?} */ player = _this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
            // this means that this particular player belongs to a sub trigger. It is
            // important that we match this player up with the corresponding (@trigger.listener)
            if (timelineInstruction.subTimeline && skippedPlayersMap) {
                allSubElements.add(element);
            }
            if (isQueriedElement) {
                var /** @type {?} */ wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
                wrappedPlayer.setRealPlayer(player);
                allQueriedPlayers.push(wrappedPlayer);
            }
            return player;
        });
        allQueriedPlayers.forEach(function (player) {
            getOrSetAsInMap(_this.playersByQueriedElement, player.element, []).push(player);
            player.onDone(function () { return deleteOrUnsetInMap(_this.playersByQueriedElement, player.element, player); });
        });
        allConsumedElements.forEach(function (element) { return addClass(element, NG_ANIMATING_CLASSNAME); });
        var /** @type {?} */ player = optimizeGroupPlayer(allNewPlayers);
        player.onDestroy(function () {
            allConsumedElements.forEach(function (element) { return removeClass(element, NG_ANIMATING_CLASSNAME); });
            setStyles(rootElement, instruction.toStyles);
        });
        // this basically makes all of the callbacks for sub element animations
        // be dependent on the upper players for when they finish
        allSubElements.forEach(function (element) { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });
        return player;
    };
    /**
     * @param {?} instruction
     * @param {?} keyframes
     * @param {?} previousPlayers
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildPlayer = function (instruction, keyframes, previousPlayers) {
        if (keyframes.length > 0) {
            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
        }
        // special case for when an empty transition|definition is provided
        // ... there is no point in rendering an empty animation
        return new __WEBPACK_IMPORTED_MODULE_1__angular_animations__["NoopAnimationPlayer"]();
    };
    return TransitionAnimationEngine;
}());
var TransitionAnimationPlayer = (function () {
    /**
     * @param {?} namespaceId
     * @param {?} triggerName
     * @param {?} element
     */
    function TransitionAnimationPlayer(namespaceId, triggerName, element) {
        this.namespaceId = namespaceId;
        this.triggerName = triggerName;
        this.element = element;
        this._player = new __WEBPACK_IMPORTED_MODULE_1__angular_animations__["NoopAnimationPlayer"]();
        this._containsRealPlayer = false;
        this._queuedCallbacks = {};
        this._destroyed = false;
        this.markedForDestroy = false;
    }
    Object.defineProperty(TransitionAnimationPlayer.prototype, "queued", {
        /**
         * @return {?}
         */
        get: function () { return this._containsRealPlayer == false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransitionAnimationPlayer.prototype, "destroyed", {
        /**
         * @return {?}
         */
        get: function () { return this._destroyed; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} player
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setRealPlayer = function (player) {
        var _this = this;
        if (this._containsRealPlayer)
            return;
        this._player = player;
        Object.keys(this._queuedCallbacks).forEach(function (phase) {
            _this._queuedCallbacks[phase].forEach(function (callback) { return listenOnPlayer(player, phase, undefined, callback); });
        });
        this._queuedCallbacks = {};
        this._containsRealPlayer = true;
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getRealPlayer = function () { return this._player; };
    /**
     * @param {?} name
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationPlayer.prototype._queueEvent = function (name, callback) {
        getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDone = function (fn) {
        if (this.queued) {
            this._queueEvent('done', fn);
        }
        this._player.onDone(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onStart = function (fn) {
        if (this.queued) {
            this._queueEvent('start', fn);
        }
        this._player.onStart(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDestroy = function (fn) {
        if (this.queued) {
            this._queueEvent('destroy', fn);
        }
        this._player.onDestroy(fn);
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.init = function () { this._player.init(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.hasStarted = function () { return this.queued ? false : this._player.hasStarted(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.play = function () { !this.queued && this._player.play(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.pause = function () { !this.queued && this._player.pause(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.restart = function () { !this.queued && this._player.restart(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.finish = function () { this._player.finish(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.destroy = function () {
        this._destroyed = true;
        this._player.destroy();
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.reset = function () { !this.queued && this._player.reset(); };
    /**
     * @param {?} p
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setPosition = function (p) {
        if (!this.queued) {
            this._player.setPosition(p);
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getPosition = function () { return this.queued ? 0 : this._player.getPosition(); };
    Object.defineProperty(TransitionAnimationPlayer.prototype, "totalTime", {
        /**
         * @return {?}
         */
        get: function () { return this._player.totalTime; },
        enumerable: true,
        configurable: true
    });
    return TransitionAnimationPlayer;
}());
/**
 * @param {?} map
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
function deleteOrUnsetInMap(map, key, value) {
    var /** @type {?} */ currentValues;
    if (map instanceof Map) {
        currentValues = map.get(key);
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                map.delete(key);
            }
        }
    }
    else {
        currentValues = map[key];
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                delete map[key];
            }
        }
    }
    return currentValues;
}
/**
 * @param {?} value
 * @return {?}
 */
function normalizeTriggerValue(value) {
    switch (typeof value) {
        case 'boolean':
            return value ? '1' : '0';
        default:
            return value != null ? value.toString() : null;
    }
}
/**
 * @param {?} node
 * @return {?}
 */
function isElementNode(node) {
    return node && node['nodeType'] === 1;
}
/**
 * @param {?} eventName
 * @return {?}
 */
function isTriggerEventValid(eventName) {
    return eventName == 'start' || eventName == 'done';
}
/**
 * @param {?} element
 * @param {?=} value
 * @return {?}
 */
function cloakElement(element, value) {
    var /** @type {?} */ oldValue = element.style.display;
    element.style.display = value != null ? value : 'none';
    return oldValue;
}
/**
 * @param {?} driver
 * @param {?} elements
 * @param {?} elementPropsMap
 * @param {?} defaultStyle
 * @return {?}
 */
function cloakAndComputeStyles(driver, elements, elementPropsMap, defaultStyle) {
    var /** @type {?} */ cloakVals = elements.map(function (element) { return cloakElement(element); });
    var /** @type {?} */ valuesMap = new Map();
    elementPropsMap.forEach(function (props, element) {
        var /** @type {?} */ styles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
            // there is no easy way to detect this because a sub element could be removed
            // by a parent animation element being detached.
            if (!value || value.length == 0) {
                element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
            }
        });
        valuesMap.set(element, styles);
    });
    elements.forEach(function (element, i) { return cloakElement(element, cloakVals[i]); });
    return valuesMap;
}
/**
 * @param {?} nodes
 * @return {?}
 */
function createIsRootFilterFn(nodes) {
    var /** @type {?} */ nodeSet = new Set(nodes);
    var /** @type {?} */ knownRootContainer = new Set();
    var /** @type {?} */ isRoot;
    isRoot = function (node) {
        if (!node)
            return true;
        if (nodeSet.has(node.parentNode))
            return false;
        if (knownRootContainer.has(node.parentNode))
            return true;
        if (isRoot(node.parentNode)) {
            knownRootContainer.add(node);
            return true;
        }
        return false;
    };
    return isRoot;
}
var CLASSES_CACHE_KEY = '$$classes';
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function containsClass(element, className) {
    if (element.classList) {
        return element.classList.contains(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        return classes && classes[className];
    }
}
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function addClass(element, className) {
    if (element.classList) {
        element.classList.add(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (!classes) {
            classes = element[CLASSES_CACHE_KEY] = {};
        }
        classes[className] = true;
    }
}
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function removeClass(element, className) {
    if (element.classList) {
        element.classList.remove(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (classes) {
            delete classes[className];
        }
    }
}
/**
 * @return {?}
 */
function getBodyNode() {
    if (typeof document != 'undefined') {
        return document.body;
    }
    return null;
}
/**
 * @param {?} engine
 * @param {?} element
 * @param {?} players
 * @return {?}
 */
function removeNodesAfterAnimationDone(engine, element, players) {
    optimizeGroupPlayer(players).onDone(function () { return engine.processLeaveNode(element); });
}
/**
 * @param {?} players
 * @return {?}
 */
function flattenGroupPlayers(players) {
    var /** @type {?} */ finalPlayers = [];
    _flattenGroupPlayersRecur(players, finalPlayers);
    return finalPlayers;
}
/**
 * @param {?} players
 * @param {?} finalPlayers
 * @return {?}
 */
function _flattenGroupPlayersRecur(players, finalPlayers) {
    for (var /** @type {?} */ i = 0; i < players.length; i++) {
        var /** @type {?} */ player = players[i];
        if (player instanceof __WEBPACK_IMPORTED_MODULE_1__angular_animations__["ɵAnimationGroupPlayer"]) {
            _flattenGroupPlayersRecur(player.players, finalPlayers);
        }
        else {
            finalPlayers.push(/** @type {?} */ (player));
        }
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var AnimationEngine = (function () {
    /**
     * @param {?} driver
     * @param {?} normalizer
     */
    function AnimationEngine(driver, normalizer) {
        var _this = this;
        this._triggerCache = {};
        this.onRemovalComplete = function (element, context) { };
        this._transitionEngine = new TransitionAnimationEngine(driver, normalizer);
        this._timelineEngine = new TimelineAnimationEngine(driver, normalizer);
        this._transitionEngine.onRemovalComplete =
            function (element, context) { _this.onRemovalComplete(element, context); };
    }
    /**
     * @param {?} componentId
     * @param {?} namespaceId
     * @param {?} hostElement
     * @param {?} name
     * @param {?} metadata
     * @return {?}
     */
    AnimationEngine.prototype.registerTrigger = function (componentId, namespaceId, hostElement, name, metadata) {
        var /** @type {?} */ cacheKey = componentId + '-' + name;
        var /** @type {?} */ trigger = this._triggerCache[cacheKey];
        if (!trigger) {
            var /** @type {?} */ errors = [];
            var /** @type {?} */ ast = (buildAnimationAst(/** @type {?} */ (metadata), errors));
            if (errors.length) {
                throw new Error("The animation trigger \"" + name + "\" has failed to build due to the following errors:\n - " + errors.join("\n - "));
            }
            trigger = buildTrigger(name, ast);
            this._triggerCache[cacheKey] = trigger;
        }
        this._transitionEngine.registerTrigger(namespaceId, name, trigger);
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    AnimationEngine.prototype.register = function (namespaceId, hostElement) {
        this._transitionEngine.register(namespaceId, hostElement);
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.destroy = function (namespaceId, context) {
        this._transitionEngine.destroy(namespaceId, context);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    AnimationEngine.prototype.onInsert = function (namespaceId, element, parent, insertBefore) {
        this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.onRemove = function (namespaceId, element, context) {
        this._transitionEngine.removeNode(namespaceId, element, context);
    };
    /**
     * @param {?} element
     * @param {?} disable
     * @return {?}
     */
    AnimationEngine.prototype.disableAnimations = function (element, disable) {
        this._transitionEngine.markElementAsDisabled(element, disable);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    AnimationEngine.prototype.process = function (namespaceId, element, property, value) {
        if (property.charAt(0) == '@') {
            var _a = parseTimelineCommand(property), id = _a[0], action = _a[1];
            var /** @type {?} */ args = (value);
            this._timelineEngine.command(id, element, action, args);
        }
        else {
            this._transitionEngine.trigger(namespaceId, element, property, value);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventPhase
     * @param {?} callback
     * @return {?}
     */
    AnimationEngine.prototype.listen = function (namespaceId, element, eventName, eventPhase, callback) {
        // @@listen
        if (eventName.charAt(0) == '@') {
            var _a = parseTimelineCommand(eventName), id = _a[0], action = _a[1];
            return this._timelineEngine.listen(id, element, action, callback);
        }
        return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    AnimationEngine.prototype.flush = function (microtaskId) {
        if (microtaskId === void 0) { microtaskId = -1; }
        this._transitionEngine.flush(microtaskId);
    };
    Object.defineProperty(AnimationEngine.prototype, "players", {
        /**
         * @return {?}
         */
        get: function () {
            return ((this._transitionEngine.players))
                .concat(/** @type {?} */ (this._timelineEngine.players));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AnimationEngine.prototype.whenRenderingDone = function () { return this._transitionEngine.whenRenderingDone(); };
    return AnimationEngine;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var WebAnimationsPlayer = (function () {
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @param {?=} previousPlayers
     */
    function WebAnimationsPlayer(element, keyframes, options, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var _this = this;
        this.element = element;
        this.keyframes = keyframes;
        this.options = options;
        this.previousPlayers = previousPlayers;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._initialized = false;
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this.time = 0;
        this.parentPlayer = null;
        this.previousStyles = {};
        this.currentSnapshot = {};
        this._duration = options['duration'];
        this._delay = options['delay'] || 0;
        this.time = this._duration + this._delay;
        if (allowPreviousPlayerStylesMerge(this._duration, this._delay)) {
            previousPlayers.forEach(function (player) {
                var styles = player.currentSnapshot;
                Object.keys(styles).forEach(function (prop) { return _this.previousStyles[prop] = styles[prop]; });
            });
        }
    }
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._onFinish = function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.init = function () {
        this._buildPlayer();
        this._preparePlayerBeforeStart();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._buildPlayer = function () {
        var _this = this;
        if (this._initialized)
            return;
        this._initialized = true;
        var /** @type {?} */ keyframes = this.keyframes.map(function (styles) { return copyStyles(styles, false); });
        var /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);
        if (previousStyleProps.length) {
            var /** @type {?} */ startingKeyframe_1 = keyframes[0];
            var /** @type {?} */ missingStyleProps_1 = [];
            previousStyleProps.forEach(function (prop) {
                if (!startingKeyframe_1.hasOwnProperty(prop)) {
                    missingStyleProps_1.push(prop);
                }
                startingKeyframe_1[prop] = _this.previousStyles[prop];
            });
            if (missingStyleProps_1.length) {
                var /** @type {?} */ self_1 = this;
                var _loop_1 = function () {
                    var /** @type {?} */ kf = keyframes[i];
                    missingStyleProps_1.forEach(function (prop) {
                        kf[prop] = _computeStyle(self_1.element, prop);
                    });
                };
                // tslint:disable-next-line
                for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {
                    _loop_1();
                }
            }
        }
        this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
        this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};
        this._player.addEventListener('finish', function () { return _this._onFinish(); });
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._preparePlayerBeforeStart = function () {
        // this is required so that the player doesn't start to animate right away
        if (this._delay) {
            this._resetDomPlayerState();
        }
        else {
            this._player.pause();
        }
    };
    /**
     * \@internal
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {
        // jscompiler doesn't seem to know animate is a native property because it's not fully
        // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
        return (element['animate'](keyframes, options));
    };
    Object.defineProperty(WebAnimationsPlayer.prototype, "domPlayer", {
        /**
         * @return {?}
         */
        get: function () { return this._player; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.play = function () {
        this._buildPlayer();
        if (!this.hasStarted()) {
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
            this._started = true;
        }
        this._player.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.pause = function () {
        this.init();
        this._player.pause();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.finish = function () {
        this.init();
        this._onFinish();
        this._player.finish();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.reset = function () {
        this._resetDomPlayerState();
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._resetDomPlayerState = function () {
        if (this._player) {
            this._player.cancel();
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.restart = function () {
        this.reset();
        this.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.destroy = function () {
        if (!this._destroyed) {
            this._resetDomPlayerState();
            this._onFinish();
            this._destroyed = true;
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @param {?} p
     * @return {?}
     */
    WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.time; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.time; };
    Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
        /**
         * @return {?}
         */
        get: function () { return this._delay + this._duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.beforeDestroy = function () {
        var _this = this;
        var /** @type {?} */ styles = {};
        if (this.hasStarted()) {
            Object.keys(this._finalKeyframe).forEach(function (prop) {
                if (prop != 'offset') {
                    styles[prop] =
                        _this._finished ? _this._finalKeyframe[prop] : _computeStyle(_this.element, prop);
                }
            });
        }
        this.currentSnapshot = styles;
    };
    return WebAnimationsPlayer;
}());
/**
 * @param {?} element
 * @param {?} prop
 * @return {?}
 */
function _computeStyle(element, prop) {
    return ((window.getComputedStyle(element)))[prop];
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var WebAnimationsDriver = (function () {
    function WebAnimationsDriver() {
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    WebAnimationsDriver.prototype.matchesElement = function (element, selector) {
        return matchesElement(element, selector);
    };
    /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    WebAnimationsDriver.prototype.containsElement = function (elm1, elm2) { return containsElement(elm1, elm2); };
    /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    WebAnimationsDriver.prototype.query = function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    WebAnimationsDriver.prototype.computeStyle = function (element, prop, defaultValue) {
        return (((window.getComputedStyle(element)))[prop]);
    };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    WebAnimationsDriver.prototype.animate = function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var /** @type {?} */ fill = delay == 0 ? 'both' : 'forwards';
        var /** @type {?} */ playerOptions = { duration: duration, delay: delay, fill: fill };
        // we check for this to avoid having a null|undefined value be present
        // for the easing (which results in an error for certain browsers #9752)
        if (easing) {
            playerOptions['easing'] = easing;
        }
        var /** @type {?} */ previousWebAnimationPlayers = (previousPlayers.filter(function (player) { return player instanceof WebAnimationsPlayer; }));
        return new WebAnimationsPlayer(element, keyframes, playerOptions, previousWebAnimationPlayers);
    };
    return WebAnimationsDriver;
}());
/**
 * @return {?}
 */
function supportsWebAnimations() {
    return typeof Element !== 'undefined' && typeof ((Element)).prototype['animate'] === 'function';
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all animation APIs of the animation browser package.
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the animation package.
 */
/**
 * Generated bundle index. Do not edit.
 */

//# sourceMappingURL=browser.es5.js.map


/***/ }),

/***/ "./node_modules/@angular/platform-browser/@angular/platform-browser/animations.es5.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__("./node_modules/tslib/tslib.es6.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_animations__ = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__ = __webpack_require__("./node_modules/@angular/animations/@angular/animations/browser.es5.js");
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserAnimationsModule", function() { return BrowserAnimationsModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoopAnimationsModule", function() { return NoopAnimationsModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBrowserAnimationBuilder", function() { return BrowserAnimationBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵBrowserAnimationFactory", function() { return BrowserAnimationFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵAnimationRenderer", function() { return AnimationRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵAnimationRendererFactory", function() { return AnimationRendererFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return BaseAnimationRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf", function() { return BROWSER_ANIMATIONS_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg", function() { return BROWSER_NOOP_ANIMATIONS_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function() { return InjectableAnimationEngine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function() { return instantiateDefaultStyleNormalizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe", function() { return instantiateRendererFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function() { return instantiateSupportedAnimationDriver; });

/**
 * @license Angular v4.3.3
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */




/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var BrowserAnimationBuilder = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserAnimationBuilder, _super);
    /**
     * @param {?} rootRenderer
     */
    function BrowserAnimationBuilder(rootRenderer) {
        var _this = _super.call(this) || this;
        _this._nextAnimationId = 0;
        var typeData = {
            id: '0',
            encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewEncapsulation"].None,
            styles: [],
            data: { animation: [] }
        };
        _this._renderer = rootRenderer.createRenderer(document.body, typeData);
        return _this;
    }
    /**
     * @param {?} animation
     * @return {?}
     */
    BrowserAnimationBuilder.prototype.build = function (animation) {
        var /** @type {?} */ id = this._nextAnimationId.toString();
        this._nextAnimationId++;
        var /** @type {?} */ entry = Array.isArray(animation) ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["sequence"])(animation) : animation;
        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
        return new BrowserAnimationFactory(id, this._renderer);
    };
    return BrowserAnimationBuilder;
}(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationBuilder"]));
BrowserAnimationBuilder.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
BrowserAnimationBuilder.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"], },
]; };
var BrowserAnimationFactory = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](BrowserAnimationFactory, _super);
    /**
     * @param {?} _id
     * @param {?} _renderer
     */
    function BrowserAnimationFactory(_id, _renderer) {
        var _this = _super.call(this) || this;
        _this._id = _id;
        _this._renderer = _renderer;
        return _this;
    }
    /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    BrowserAnimationFactory.prototype.create = function (element, options) {
        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
    };
    return BrowserAnimationFactory;
}(__WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationFactory"]));
var RendererAnimationPlayer = (function () {
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} options
     * @param {?} _renderer
     */
    function RendererAnimationPlayer(id, element, options, _renderer) {
        this.id = id;
        this.element = element;
        this._renderer = _renderer;
        this.parentPlayer = null;
        this._started = false;
        this.totalTime = 0;
        this._command('create', options);
    }
    /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    RendererAnimationPlayer.prototype._listen = function (eventName, callback) {
        return this._renderer.listen(this.element, "@@" + this.id + ":" + eventName, callback);
    };
    /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    RendererAnimationPlayer.prototype._command = function (command) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDone = function (fn) { this._listen('done', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onStart = function (fn) { this._listen('start', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDestroy = function (fn) { this._listen('destroy', fn); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.init = function () { this._command('init'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.hasStarted = function () { return this._started; };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.play = function () {
        this._command('play');
        this._started = true;
    };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.pause = function () { this._command('pause'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.restart = function () { this._command('restart'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.finish = function () { this._command('finish'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.destroy = function () { this._command('destroy'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.reset = function () { this._command('reset'); };
    /**
     * @param {?} p
     * @return {?}
     */
    RendererAnimationPlayer.prototype.setPosition = function (p) { this._command('setPosition', p); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.getPosition = function () { return 0; };
    return RendererAnimationPlayer;
}());
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} id
 * @param {?} command
 * @param {?} args
 * @return {?}
 */
function issueAnimationCommand(renderer, element, id, command, args) {
    return renderer.setProperty(element, "@@" + id + ":" + command, args);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ANIMATION_PREFIX = '@';
var DISABLE_ANIMATIONS_FLAG = '@.disabled';
var AnimationRendererFactory = (function () {
    /**
     * @param {?} delegate
     * @param {?} engine
     * @param {?} _zone
     */
    function AnimationRendererFactory(delegate, engine, _zone) {
        this.delegate = delegate;
        this.engine = engine;
        this._zone = _zone;
        this._currentId = 0;
        this._microtaskId = 1;
        this._animationCallbacksBuffer = [];
        this._rendererCache = new Map();
        this._cdRecurDepth = 0;
        engine.onRemovalComplete = function (element, delegate) {
            // Note: if an component element has a leave animation, and the component
            // a host leave animation, the view engine will call `removeChild` for the parent
            // component renderer as well as for the child component renderer.
            // Therefore, we need to check if we already removed the element.
            if (delegate && delegate.parentNode(element)) {
                delegate.removeChild(element.parentNode, element);
            }
        };
    }
    /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    AnimationRendererFactory.prototype.createRenderer = function (hostElement, type) {
        var _this = this;
        var /** @type {?} */ EMPTY_NAMESPACE_ID = '';
        // cache the delegates to find out which cached delegate can
        // be used by which cached renderer
        var /** @type {?} */ delegate = this.delegate.createRenderer(hostElement, type);
        if (!hostElement || !type || !type.data || !type.data['animation']) {
            var /** @type {?} */ renderer = this._rendererCache.get(delegate);
            if (!renderer) {
                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);
                // only cache this result when the base renderer is used
                this._rendererCache.set(delegate, renderer);
            }
            return renderer;
        }
        var /** @type {?} */ componentId = type.id;
        var /** @type {?} */ namespaceId = type.id + '-' + this._currentId;
        this._currentId++;
        this.engine.register(namespaceId, hostElement);
        var /** @type {?} */ animationTriggers = (type.data['animation']);
        animationTriggers.forEach(function (trigger) { return _this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger); });
        return new AnimationRenderer(this, namespaceId, delegate, this.engine);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.begin = function () {
        this._cdRecurDepth++;
        if (this.delegate.begin) {
            this.delegate.begin();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype._scheduleCountTask = function () {
        var _this = this;
        Zone.current.scheduleMicroTask('incremenet the animation microtask', function () { return _this._microtaskId++; });
    };
    /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    AnimationRendererFactory.prototype.scheduleListenerCallback = function (count, fn, data) {
        var _this = this;
        if (count >= 0 && count < this._microtaskId) {
            this._zone.run(function () { return fn(data); });
            return;
        }
        if (this._animationCallbacksBuffer.length == 0) {
            Promise.resolve(null).then(function () {
                _this._zone.run(function () {
                    _this._animationCallbacksBuffer.forEach(function (tuple) {
                        var fn = tuple[0], data = tuple[1];
                        fn(data);
                    });
                    _this._animationCallbacksBuffer = [];
                });
            });
        }
        this._animationCallbacksBuffer.push([fn, data]);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.end = function () {
        var _this = this;
        this._cdRecurDepth--;
        // this is to prevent animations from running twice when an inner
        // component does CD when a parent component insted has inserted it
        if (this._cdRecurDepth == 0) {
            this._zone.runOutsideAngular(function () {
                _this._scheduleCountTask();
                _this.engine.flush(_this._microtaskId);
            });
        }
        if (this.delegate.end) {
            this.delegate.end();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.whenRenderingDone = function () { return this.engine.whenRenderingDone(); };
    return AnimationRendererFactory;
}());
AnimationRendererFactory.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
AnimationRendererFactory.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"], },
    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* ɵAnimationEngine */], },
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"], },
]; };
var BaseAnimationRenderer = (function () {
    /**
     * @param {?} namespaceId
     * @param {?} delegate
     * @param {?} engine
     */
    function BaseAnimationRenderer(namespaceId, delegate, engine) {
        this.namespaceId = namespaceId;
        this.delegate = delegate;
        this.engine = engine;
        this.destroyNode = this.delegate.destroyNode ? function (n) { return delegate.destroyNode(n); } : null;
    }
    Object.defineProperty(BaseAnimationRenderer.prototype, "data", {
        /**
         * @return {?}
         */
        get: function () { return this.delegate.data; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BaseAnimationRenderer.prototype.destroy = function () {
        this.engine.destroy(this.namespaceId, this.delegate);
        this.delegate.destroy();
    };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createElement = function (name, namespace) {
        return this.delegate.createElement(name, namespace);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createComment = function (value) { return this.delegate.createComment(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createText = function (value) { return this.delegate.createText(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.appendChild = function (parent, newChild) {
        this.delegate.appendChild(parent, newChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, false);
    };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.insertBefore = function (parent, newChild, refChild) {
        this.delegate.insertBefore(parent, newChild, refChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, true);
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeChild = function (parent, oldChild) {
        this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    };
    /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    BaseAnimationRenderer.prototype.selectRootElement = function (selectorOrNode) { return this.delegate.selectRootElement(selectorOrNode); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.parentNode = function (node) { return this.delegate.parentNode(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.nextSibling = function (node) { return this.delegate.nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setAttribute = function (el, name, value, namespace) {
        this.delegate.setAttribute(el, name, value, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeAttribute = function (el, name, namespace) {
        this.delegate.removeAttribute(el, name, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.addClass = function (el, name) { this.delegate.addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeClass = function (el, name) { this.delegate.removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setStyle = function (el, style, value, flags) {
        this.delegate.setStyle(el, style, value, flags);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeStyle = function (el, style, flags) {
        this.delegate.removeStyle(el, style, flags);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setProperty = function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
            this.disableAnimations(el, !!value);
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setValue = function (node, value) { this.delegate.setValue(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    BaseAnimationRenderer.prototype.listen = function (target, eventName, callback) {
        return this.delegate.listen(target, eventName, callback);
    };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.disableAnimations = function (element, value) {
        this.engine.disableAnimations(element, value);
    };
    return BaseAnimationRenderer;
}());
var AnimationRenderer = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](AnimationRenderer, _super);
    /**
     * @param {?} factory
     * @param {?} namespaceId
     * @param {?} delegate
     * @param {?} engine
     */
    function AnimationRenderer(factory, namespaceId, delegate, engine) {
        var _this = _super.call(this, namespaceId, delegate, engine) || this;
        _this.factory = factory;
        _this.namespaceId = namespaceId;
        return _this;
    }
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    AnimationRenderer.prototype.setProperty = function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX) {
            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
                this.disableAnimations(el, !!value);
            }
            else {
                this.engine.process(this.namespaceId, el, name.substr(1), value);
            }
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    AnimationRenderer.prototype.listen = function (target, eventName, callback) {
        var _this = this;
        if (eventName.charAt(0) == ANIMATION_PREFIX) {
            var /** @type {?} */ element = resolveElementFromTarget(target);
            var /** @type {?} */ name = eventName.substr(1);
            var /** @type {?} */ phase = '';
            // @listener.phase is for trigger animation callbacks
            // @@listener is for animation builder callbacks
            if (name.charAt(0) != ANIMATION_PREFIX) {
                _a = parseTriggerCallbackName(name), name = _a[0], phase = _a[1];
            }
            return this.engine.listen(this.namespaceId, element, name, phase, function (event) {
                var /** @type {?} */ countId = ((event))['_data'] || -1;
                _this.factory.scheduleListenerCallback(countId, callback, event);
            });
        }
        return this.delegate.listen(target, eventName, callback);
        var _a;
    };
    return AnimationRenderer;
}(BaseAnimationRenderer));
/**
 * @param {?} target
 * @return {?}
 */
function resolveElementFromTarget(target) {
    switch (target) {
        case 'body':
            return document.body;
        case 'document':
            return document;
        case 'window':
            return window;
        default:
            return target;
    }
}
/**
 * @param {?} triggerName
 * @return {?}
 */
function parseTriggerCallbackName(triggerName) {
    var /** @type {?} */ dotIndex = triggerName.indexOf('.');
    var /** @type {?} */ trigger = triggerName.substring(0, dotIndex);
    var /** @type {?} */ phase = triggerName.substr(dotIndex + 1);
    return [trigger, phase];
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var InjectableAnimationEngine = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](InjectableAnimationEngine, _super);
    /**
     * @param {?} driver
     * @param {?} normalizer
     */
    function InjectableAnimationEngine(driver, normalizer) {
        return _super.call(this, driver, normalizer) || this;
    }
    return InjectableAnimationEngine;
}(__WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* ɵAnimationEngine */]));
InjectableAnimationEngine.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"] },
];
/**
 * @nocollapse
 */
InjectableAnimationEngine.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* AnimationDriver */], },
    { type: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["c" /* ɵAnimationStyleNormalizer */], },
]; };
/**
 * @return {?}
 */
function instantiateSupportedAnimationDriver() {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["d" /* ɵsupportsWebAnimations */])()) {
        return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["e" /* ɵWebAnimationsDriver */]();
    }
    return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["f" /* ɵNoopAnimationDriver */]();
}
/**
 * @return {?}
 */
function instantiateDefaultStyleNormalizer() {
    return new __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["g" /* ɵWebAnimationsStyleNormalizer */]();
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateRendererFactory(renderer, engine, zone) {
    return new AnimationRendererFactory(renderer, engine, zone);
}
var SHARED_ANIMATION_PROVIDERS = [
    { provide: __WEBPACK_IMPORTED_MODULE_3__angular_animations__["AnimationBuilder"], useClass: BrowserAnimationBuilder },
    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["c" /* ɵAnimationStyleNormalizer */], useFactory: instantiateDefaultStyleNormalizer },
    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* ɵAnimationEngine */], useClass: InjectableAnimationEngine }, {
        provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__["RendererFactory2"],
        useFactory: instantiateRendererFactory,
        deps: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["ɵDomRendererFactory2"], __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["a" /* ɵAnimationEngine */], __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]]
    }
];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserModule.
 */
var BROWSER_ANIMATIONS_PROVIDERS = [
    { provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* AnimationDriver */], useFactory: instantiateSupportedAnimationDriver }
].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserTestingModule.
 */
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{ provide: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["b" /* AnimationDriver */], useClass: __WEBPACK_IMPORTED_MODULE_4__angular_animations_browser__["f" /* ɵNoopAnimationDriver */] }].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 */
var BrowserAnimationsModule = (function () {
    function BrowserAnimationsModule() {
    }
    return BrowserAnimationsModule;
}());
BrowserAnimationsModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                exports: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["BrowserModule"]],
                providers: BROWSER_ANIMATIONS_PROVIDERS,
            },] },
];
/**
 * @nocollapse
 */
BrowserAnimationsModule.ctorParameters = function () { return []; };
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationsModule = (function () {
    function NoopAnimationsModule() {
    }
    return NoopAnimationsModule;
}());
NoopAnimationsModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"], args: [{
                exports: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["BrowserModule"]],
                providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
            },] },
];
/**
 * @nocollapse
 */
NoopAnimationsModule.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all animation APIs of the animation browser package.
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the animation package.
 */
/**
 * Generated bundle index. Do not edit.
 */

//# sourceMappingURL=animations.es5.js.map


/***/ }),

/***/ "./node_modules/primeng/components/accordion/accordion.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var Accordion = (function () {
    function Accordion(el) {
        this.el = el;
        this.onClose = new core_1.EventEmitter();
        this.onOpen = new core_1.EventEmitter();
        this.tabs = [];
    }
    Accordion.prototype.addTab = function (tab) {
        this.tabs.push(tab);
    };
    Accordion.prototype.getBlockableElement = function () {
        return this.el.nativeElement.children[0];
    };
    Object.defineProperty(Accordion.prototype, "activeIndex", {
        get: function () {
            return this._activeIndex;
        },
        set: function (val) {
            this._activeIndex = val;
            if (this.tabs && this.tabs.length && this._activeIndex != null) {
                for (var i = 0; i < this.tabs.length; i++) {
                    var selected = this.multiple ? this._activeIndex.includes(i) : (i === this._activeIndex);
                    var changed = selected !== this.tabs[i].selected;
                    if (changed) {
                        this.tabs[i].animating = true;
                    }
                    this.tabs[i].selected = selected;
                    this.tabs[i].selectedChange.emit(selected);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return Accordion;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Accordion.prototype, "multiple", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Accordion.prototype, "onClose", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Accordion.prototype, "onOpen", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Accordion.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Accordion.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Accordion.prototype, "lazy", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], Accordion.prototype, "activeIndex", null);
Accordion = __decorate([
    core_1.Component({
        selector: 'p-accordion',
        template: "\n        <div [ngClass]=\"'ui-accordion ui-widget ui-helper-reset'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <ng-content></ng-content>\n        </div>\n    ",
    }),
    __metadata("design:paramtypes", [core_1.ElementRef])
], Accordion);
exports.Accordion = Accordion;
var AccordionTab = (function () {
    function AccordionTab(accordion) {
        this.accordion = accordion;
        this.selectedChange = new core_1.EventEmitter();
        this.accordion.addTab(this);
    }
    AccordionTab.prototype.toggle = function (event) {
        if (this.disabled || this.animating) {
            return false;
        }
        this.animating = true;
        var index = this.findTabIndex();
        if (this.selected) {
            this.selected = false;
            this.accordion.onClose.emit({ originalEvent: event, index: index });
        }
        else {
            if (!this.accordion.multiple) {
                for (var i = 0; i < this.accordion.tabs.length; i++) {
                    this.accordion.tabs[i].selected = false;
                    this.accordion.tabs[i].selectedChange.emit(false);
                }
            }
            this.selected = true;
            this.accordion.onOpen.emit({ originalEvent: event, index: index });
        }
        this.selectedChange.emit(this.selected);
        event.preventDefault();
    };
    AccordionTab.prototype.findTabIndex = function () {
        var index = -1;
        for (var i = 0; i < this.accordion.tabs.length; i++) {
            if (this.accordion.tabs[i] == this) {
                index = i;
                break;
            }
        }
        return index;
    };
    Object.defineProperty(AccordionTab.prototype, "lazy", {
        get: function () {
            return this.accordion.lazy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccordionTab.prototype, "hasHeaderFacet", {
        get: function () {
            return this.headerFacet && this.headerFacet.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    AccordionTab.prototype.onToggleDone = function (event) {
        this.animating = false;
    };
    AccordionTab.prototype.ngOnDestroy = function () {
        this.accordion.tabs.splice(this.findTabIndex(), 1);
    };
    return AccordionTab;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AccordionTab.prototype, "header", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], AccordionTab.prototype, "selected", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], AccordionTab.prototype, "disabled", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AccordionTab.prototype, "selectedChange", void 0);
__decorate([
    core_1.ContentChildren(shared_1.Header),
    __metadata("design:type", core_1.QueryList)
], AccordionTab.prototype, "headerFacet", void 0);
AccordionTab = __decorate([
    core_1.Component({
        selector: 'p-accordionTab',
        template: "\n        <div class=\"ui-accordion-header ui-state-default ui-corner-all\" [ngClass]=\"{'ui-state-active': selected,'ui-state-disabled':disabled}\"\n            (click)=\"toggle($event)\">\n            <span class=\"fa fa-fw\" [ngClass]=\"{'fa-caret-down': selected, 'fa-caret-right': !selected}\"></span>\n            <a href=\"#\" *ngIf=\"!hasHeaderFacet\" role=\"tab\" [attr.aria-expanded]=\"selected\" [attr.aria-selected]=\"selected\">{{header}}</a>\n            <a href=\"#\" *ngIf=\"hasHeaderFacet\" role=\"tab\" [attr.aria-expanded]=\"selected\" [attr.aria-selected]=\"selected\">\n                <ng-content select=\"p-header\"></ng-content>\n            </a>\n        </div>\n        <div class=\"ui-accordion-content-wrapper\" [@tabContent]=\"selected ? 'visible' : 'hidden'\" (@tabContent.done)=\"onToggleDone($event)\"\n            [ngClass]=\"{'ui-accordion-content-wrapper-overflown': !selected||animating}\" role=\"tabpanel\" [attr.aria-hidden]=\"!selected\">\n            <div class=\"ui-accordion-content ui-widget-content\" *ngIf=\"lazy ? selected : true\">\n                <ng-content></ng-content>\n            </div>\n        </div>\n    ",
        animations: [
            animations_1.trigger('tabContent', [
                animations_1.state('hidden', animations_1.style({
                    height: '0'
                })),
                animations_1.state('visible', animations_1.style({
                    height: '*'
                })),
                animations_1.transition('visible <=> hidden', animations_1.animate('400ms cubic-bezier(0.86, 0, 0.07, 1)'))
            ])
        ]
    }),
    __metadata("design:paramtypes", [Accordion])
], AccordionTab);
exports.AccordionTab = AccordionTab;
var AccordionModule = (function () {
    function AccordionModule() {
    }
    return AccordionModule;
}());
AccordionModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Accordion, AccordionTab],
        declarations: [Accordion, AccordionTab]
    })
], AccordionModule);
exports.AccordionModule = AccordionModule;
//# sourceMappingURL=accordion.js.map

/***/ }),

/***/ "./node_modules/primeng/components/autocomplete/autocomplete.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var inputtext_1 = __webpack_require__("./node_modules/primeng/components/inputtext/inputtext.js");
var button_1 = __webpack_require__("./node_modules/primeng/components/button/button.js");
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var objectutils_1 = __webpack_require__("./node_modules/primeng/components/utils/objectutils.js");
var forms_1 = __webpack_require__(4);
exports.AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return AutoComplete; }),
    multi: true
};
var AutoComplete = (function () {
    function AutoComplete(el, domHandler, renderer, objectUtils, cd, differs) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.objectUtils = objectUtils;
        this.cd = cd;
        this.differs = differs;
        this.minLength = 1;
        this.delay = 300;
        this.type = 'text';
        this.completeMethod = new core_1.EventEmitter();
        this.onSelect = new core_1.EventEmitter();
        this.onUnselect = new core_1.EventEmitter();
        this.onFocus = new core_1.EventEmitter();
        this.onBlur = new core_1.EventEmitter();
        this.onDropdownClick = new core_1.EventEmitter();
        this.onClear = new core_1.EventEmitter();
        this.onKeyUp = new core_1.EventEmitter();
        this.scrollHeight = '200px';
        this.immutable = true;
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
        this.panelVisible = false;
        this.focus = false;
        this.differ = differs.find([]).create(null);
    }
    Object.defineProperty(AutoComplete.prototype, "suggestions", {
        get: function () {
            return this._suggestions;
        },
        set: function (val) {
            this._suggestions = val;
            if (this.immutable) {
                this.handleSuggestionsChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    AutoComplete.prototype.ngDoCheck = function () {
        if (!this.immutable) {
            var changes = this.differ.diff(this.suggestions);
            if (changes) {
                this.handleSuggestionsChange();
            }
        }
    };
    AutoComplete.prototype.handleSuggestionsChange = function () {
        if (this.panelEL && this.panelEL.nativeElement) {
            if (this._suggestions && this._suggestions.length) {
                this.noResults = false;
                this.show();
                this.suggestionsUpdated = true;
                if (this.autoHighlight) {
                    this.highlightOption = this._suggestions[0];
                }
            }
            else {
                this.noResults = true;
                if (this.emptyMessage) {
                    this.show();
                    this.suggestionsUpdated = true;
                }
                else {
                    this.hide();
                }
            }
        }
    };
    AutoComplete.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                case 'selectedItem':
                    _this.selectedItemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    AutoComplete.prototype.ngAfterViewInit = function () {
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.panelEL.nativeElement);
            else
                this.domHandler.appendChild(this.panelEL.nativeElement, this.appendTo);
        }
    };
    AutoComplete.prototype.ngAfterViewChecked = function () {
        var _this = this;
        //Use timeouts as since Angular 4.2, AfterViewChecked is broken and not called after panel is updated
        if (this.suggestionsUpdated && this.panelEL.nativeElement && this.panelEL.nativeElement.offsetParent) {
            setTimeout(function () { return _this.align(); }, 1);
            this.suggestionsUpdated = false;
        }
        if (this.highlightOptionChanged) {
            setTimeout(function () {
                var listItem = _this.domHandler.findSingle(_this.panelEL.nativeElement, 'li.ui-state-highlight');
                if (listItem) {
                    _this.domHandler.scrollInView(_this.panelEL.nativeElement, listItem);
                }
            }, 1);
            this.highlightOptionChanged = false;
        }
    };
    AutoComplete.prototype.writeValue = function (value) {
        this.value = value;
        this.filled = this.value && this.value != '';
    };
    AutoComplete.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    AutoComplete.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    AutoComplete.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    AutoComplete.prototype.onInput = function (event) {
        var _this = this;
        if (!this.inputKeyDown) {
            return;
        }
        var value = event.target.value;
        if (!this.multiple) {
            this.onModelChange(value);
        }
        if (value.length === 0) {
            this.hide();
            this.onClear.emit(event);
        }
        if (value.length >= this.minLength) {
            //Cancel the search request if user types within the timeout
            if (this.timeout) {
                clearTimeout(this.timeout);
            }
            this.timeout = setTimeout(function () {
                _this.search(event, value);
            }, this.delay);
        }
        else {
            this.suggestions = null;
        }
        this.updateFilledState();
        this.inputKeyDown = false;
    };
    AutoComplete.prototype.onInputClick = function (event) {
        if (this.documentClickListener) {
            this.inputClick = true;
        }
    };
    AutoComplete.prototype.search = function (event, query) {
        //allow empty string but not undefined or null
        if (query === undefined || query === null) {
            return;
        }
        this.completeMethod.emit({
            originalEvent: event,
            query: query
        });
    };
    AutoComplete.prototype.selectItem = function (option) {
        if (this.multiple) {
            this.multiInputEL.nativeElement.value = '';
            this.value = this.value || [];
            if (!this.isSelected(option)) {
                this.value = this.value.concat([option]);
                this.onModelChange(this.value);
            }
        }
        else {
            this.inputEL.nativeElement.value = this.field ? this.objectUtils.resolveFieldData(option, this.field) || '' : option;
            this.value = option;
            this.onModelChange(this.value);
        }
        this.onSelect.emit(option);
        this.focusInput();
    };
    AutoComplete.prototype.show = function () {
        if (this.multiInputEL || this.inputEL) {
            var hasFocus = this.multiple ? document.activeElement == this.multiInputEL.nativeElement : document.activeElement == this.inputEL.nativeElement;
            if (!this.panelVisible && hasFocus) {
                this.panelVisible = true;
                this.panelEL.nativeElement.style.zIndex = ++domhandler_1.DomHandler.zindex;
                this.domHandler.fadeIn(this.panelEL.nativeElement, 200);
                this.bindDocumentClickListener();
            }
        }
    };
    AutoComplete.prototype.align = function () {
        if (this.appendTo)
            this.domHandler.absolutePosition(this.panelEL.nativeElement, (this.multiple ? this.multiContainerEL.nativeElement : this.inputEL.nativeElement));
        else
            this.domHandler.relativePosition(this.panelEL.nativeElement, (this.multiple ? this.multiContainerEL.nativeElement : this.inputEL.nativeElement));
    };
    AutoComplete.prototype.hide = function () {
        this.panelVisible = false;
        this.unbindDocumentClickListener();
    };
    AutoComplete.prototype.handleDropdownClick = function (event) {
        this.focusInput();
        var queryValue = this.multiple ? this.multiInputEL.nativeElement.value : this.inputEL.nativeElement.value;
        this.onDropdownClick.emit({
            originalEvent: event,
            query: queryValue
        });
    };
    AutoComplete.prototype.focusInput = function () {
        if (this.multiple)
            this.multiInputEL.nativeElement.focus();
        else
            this.inputEL.nativeElement.focus();
    };
    AutoComplete.prototype.removeItem = function (item) {
        var itemIndex = this.domHandler.index(item);
        var removedValue = this.value[itemIndex];
        this.value = this.value.filter(function (val, i) { return i != itemIndex; });
        this.onUnselect.emit(removedValue);
        this.onModelChange(this.value);
    };
    AutoComplete.prototype.onKeydown = function (event) {
        if (this.panelVisible) {
            var highlightItemIndex = this.findOptionIndex(this.highlightOption);
            switch (event.which) {
                //down
                case 40:
                    if (highlightItemIndex != -1) {
                        var nextItemIndex = highlightItemIndex + 1;
                        if (nextItemIndex != (this.suggestions.length)) {
                            this.highlightOption = this.suggestions[nextItemIndex];
                            this.highlightOptionChanged = true;
                        }
                    }
                    else {
                        this.highlightOption = this.suggestions[0];
                    }
                    event.preventDefault();
                    break;
                //up
                case 38:
                    if (highlightItemIndex > 0) {
                        var prevItemIndex = highlightItemIndex - 1;
                        this.highlightOption = this.suggestions[prevItemIndex];
                        this.highlightOptionChanged = true;
                    }
                    event.preventDefault();
                    break;
                //enter
                case 13:
                    if (this.highlightOption) {
                        this.selectItem(this.highlightOption);
                        this.hide();
                    }
                    event.preventDefault();
                    break;
                //escape
                case 27:
                    this.hide();
                    event.preventDefault();
                    break;
                //tab
                case 9:
                    if (this.highlightOption) {
                        this.selectItem(this.highlightOption);
                    }
                    this.hide();
                    break;
            }
        }
        else {
            if (event.which === 40 && this.suggestions) {
                this.search(event, event.target.value);
            }
        }
        if (this.multiple) {
            switch (event.which) {
                //backspace
                case 8:
                    if (this.value && this.value.length && !this.multiInputEL.nativeElement.value) {
                        this.value = this.value.slice();
                        var removedValue = this.value.pop();
                        this.onUnselect.emit(removedValue);
                        this.onModelChange(this.value);
                    }
                    break;
            }
        }
        this.inputKeyDown = true;
    };
    AutoComplete.prototype.onKeyup = function (event) {
        this.onKeyUp.emit(event);
    };
    AutoComplete.prototype.onInputFocus = function (event) {
        this.focus = true;
        this.onFocus.emit(event);
    };
    AutoComplete.prototype.onInputBlur = function (event) {
        this.focus = false;
        this.onModelTouched();
        this.onBlur.emit(event);
    };
    AutoComplete.prototype.isSelected = function (val) {
        var selected = false;
        if (this.value && this.value.length) {
            for (var i = 0; i < this.value.length; i++) {
                if (this.objectUtils.equals(this.value[i], val, this.dataKey)) {
                    selected = true;
                    break;
                }
            }
        }
        return selected;
    };
    AutoComplete.prototype.findOptionIndex = function (option) {
        var index = -1;
        if (this.suggestions) {
            for (var i = 0; i < this.suggestions.length; i++) {
                if (this.objectUtils.equals(option, this.suggestions[i])) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    AutoComplete.prototype.updateFilledState = function () {
        if (this.multiple)
            this.filled = (this.value && this.value.length) || (this.multiInputEL && this.multiInputEL.nativeElement && this.multiInputEL.nativeElement.value != '');
        else
            this.filled = this.inputEL && this.inputEL.nativeElement && this.inputEL.nativeElement.value != '';
    };
    AutoComplete.prototype.bindDocumentClickListener = function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'click', function (event) {
                if (event.which === 3) {
                    return;
                }
                if (_this.inputClick)
                    _this.inputClick = false;
                else
                    _this.hide();
                _this.cd.markForCheck();
            });
        }
    };
    AutoComplete.prototype.unbindDocumentClickListener = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    AutoComplete.prototype.ngOnDestroy = function () {
        this.unbindDocumentClickListener();
        if (this.appendTo) {
            this.el.nativeElement.appendChild(this.panelEL.nativeElement);
        }
    };
    return AutoComplete;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], AutoComplete.prototype, "minLength", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], AutoComplete.prototype, "delay", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], AutoComplete.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], AutoComplete.prototype, "inputStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "inputStyleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "placeholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], AutoComplete.prototype, "readonly", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], AutoComplete.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], AutoComplete.prototype, "maxlength", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], AutoComplete.prototype, "size", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], AutoComplete.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], AutoComplete.prototype, "autoHighlight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "type", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AutoComplete.prototype, "completeMethod", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AutoComplete.prototype, "onSelect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AutoComplete.prototype, "onUnselect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AutoComplete.prototype, "onFocus", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AutoComplete.prototype, "onBlur", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AutoComplete.prototype, "onDropdownClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AutoComplete.prototype, "onClear", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], AutoComplete.prototype, "onKeyUp", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "field", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "scrollHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], AutoComplete.prototype, "dropdown", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], AutoComplete.prototype, "multiple", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], AutoComplete.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "dataKey", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], AutoComplete.prototype, "emptyMessage", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], AutoComplete.prototype, "immutable", void 0);
__decorate([
    core_1.ViewChild('in'),
    __metadata("design:type", core_1.ElementRef)
], AutoComplete.prototype, "inputEL", void 0);
__decorate([
    core_1.ViewChild('multiIn'),
    __metadata("design:type", core_1.ElementRef)
], AutoComplete.prototype, "multiInputEL", void 0);
__decorate([
    core_1.ViewChild('panel'),
    __metadata("design:type", core_1.ElementRef)
], AutoComplete.prototype, "panelEL", void 0);
__decorate([
    core_1.ViewChild('multiContainer'),
    __metadata("design:type", core_1.ElementRef)
], AutoComplete.prototype, "multiContainerEL", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], AutoComplete.prototype, "templates", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], AutoComplete.prototype, "suggestions", null);
AutoComplete = __decorate([
    core_1.Component({
        selector: 'p-autoComplete',
        template: "\n        <span [ngClass]=\"{'ui-autocomplete ui-widget':true,'ui-autocomplete-dd':dropdown,'ui-autocomplete-multiple':multiple}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <input *ngIf=\"!multiple\" #in [attr.type]=\"type\" [attr.id]=\"inputId\" [ngStyle]=\"inputStyle\" [class]=\"inputStyleClass\" autocomplete=\"off\" \n            [ngClass]=\"'ui-inputtext ui-widget ui-state-default ui-corner-all ui-autocomplete-input'\" [value]=\"value ? (field ? objectUtils.resolveFieldData(value,field)||'' : value) : null\" \n            (click)=\"onInputClick($event)\" (input)=\"onInput($event)\" (keydown)=\"onKeydown($event)\" (keyup)=\"onKeyup($event)\" (focus)=\"onInputFocus($event)\" (blur)=\"onInputBlur($event)\"\n            [attr.placeholder]=\"placeholder\" [attr.size]=\"size\" [attr.maxlength]=\"maxlength\" [attr.tabindex]=\"tabindex\" [readonly]=\"readonly\" [disabled]=\"disabled\"\n            ><ul *ngIf=\"multiple\" #multiContainer class=\"ui-autocomplete-multiple-container ui-widget ui-inputtext ui-state-default ui-corner-all\" [ngClass]=\"{'ui-state-disabled':disabled,'ui-state-focus':focus}\" (click)=\"multiIn.focus()\">\n                <li #token *ngFor=\"let val of value\" class=\"ui-autocomplete-token ui-state-highlight ui-corner-all\">\n                    <span class=\"ui-autocomplete-token-icon fa fa-fw fa-close\" (click)=\"removeItem(token)\" *ngIf=\"!disabled\"></span>\n                    <span *ngIf=\"!selectedItemTemplate\" class=\"ui-autocomplete-token-label\">{{field ? val[field] : val}}</span>\n                    <ng-template *ngIf=\"selectedItemTemplate\" [pTemplateWrapper]=\"selectedItemTemplate\" [item]=\"val\"></ng-template>\n                </li>\n                <li class=\"ui-autocomplete-input-token\">\n                    <input #multiIn [attr.type]=\"type\" [attr.id]=\"inputId\" [disabled]=\"disabled\" [attr.placeholder]=\"(value&&value.length ? null : placeholder)\" [attr.tabindex]=\"tabindex\" (input)=\"onInput($event)\"  (click)=\"onInputClick($event)\"\n                            (keydown)=\"onKeydown($event)\" (keyup)=\"onKeyup($event)\" (focus)=\"onInputFocus($event)\" (blur)=\"onInputBlur($event)\" autocomplete=\"off\" [ngStyle]=\"inputStyle\" [class]=\"inputStyleClass\">\n                </li>\n            </ul\n            ><button type=\"button\" pButton icon=\"fa-fw fa-caret-down\" class=\"ui-autocomplete-dropdown\" [disabled]=\"disabled\"\n                (click)=\"handleDropdownClick($event)\" *ngIf=\"dropdown\"></button>\n            <div #panel class=\"ui-autocomplete-panel ui-widget-content ui-corner-all ui-shadow\" [style.display]=\"panelVisible ? 'block' : 'none'\" [style.width]=\"appendTo ? 'auto' : '100%'\" [style.max-height]=\"scrollHeight\">\n                <ul class=\"ui-autocomplete-items ui-autocomplete-list ui-widget-content ui-widget ui-corner-all ui-helper-reset\" *ngIf=\"panelVisible\">\n                    <li *ngFor=\"let option of suggestions; let idx = index\" [ngClass]=\"{'ui-autocomplete-list-item ui-corner-all':true,'ui-state-highlight':(highlightOption==option)}\"\n                        (mouseenter)=\"highlightOption=option\" (mouseleave)=\"highlightOption=null\" (click)=\"selectItem(option)\">\n                        <span *ngIf=\"!itemTemplate\">{{field ? option[field] : option}}</span>\n                        <ng-template *ngIf=\"itemTemplate\" [pTemplateWrapper]=\"itemTemplate\" [item]=\"option\" [index]=\"idx\"></ng-template>\n                    </li>\n                    <li *ngIf=\"noResults && emptyMessage\" class=\"ui-autocomplete-list-item ui-corner-all\">{{emptyMessage}}</li>\n                </ul>\n            </div>\n        </span>\n    ",
        host: {
            '[class.ui-inputwrapper-filled]': 'filled',
            '[class.ui-inputwrapper-focus]': 'focus'
        },
        providers: [domhandler_1.DomHandler, objectutils_1.ObjectUtils, exports.AUTOCOMPLETE_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, objectutils_1.ObjectUtils, core_1.ChangeDetectorRef, core_1.IterableDiffers])
], AutoComplete);
exports.AutoComplete = AutoComplete;
var AutoCompleteModule = (function () {
    function AutoCompleteModule() {
    }
    return AutoCompleteModule;
}());
AutoCompleteModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, inputtext_1.InputTextModule, button_1.ButtonModule, shared_1.SharedModule],
        exports: [AutoComplete, shared_1.SharedModule],
        declarations: [AutoComplete]
    })
], AutoCompleteModule);
exports.AutoCompleteModule = AutoCompleteModule;
//# sourceMappingURL=autocomplete.js.map

/***/ }),

/***/ "./node_modules/primeng/components/blockui/blockui.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var BlockUI = (function () {
    function BlockUI(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
    }
    Object.defineProperty(BlockUI.prototype, "blocked", {
        get: function () {
            return this._blocked;
        },
        set: function (val) {
            this._blocked = val;
            if (this.mask.nativeElement) {
                if (this._blocked)
                    this.block();
                else
                    this.unblock();
            }
        },
        enumerable: true,
        configurable: true
    });
    BlockUI.prototype.ngAfterViewInit = function () {
        if (this.target && !this.target.getBlockableElement) {
            throw 'Target of BlockUI must implement BlockableUI interface';
        }
    };
    BlockUI.prototype.block = function () {
        if (this.target) {
            this.target.getBlockableElement().appendChild(this.mask.nativeElement);
            var style = this.target.style || {};
            style.position = 'relative';
            this.target.style = style;
        }
        else {
            document.body.appendChild(this.mask.nativeElement);
        }
        this.mask.nativeElement.style.zIndex = String(++domhandler_1.DomHandler.zindex);
    };
    BlockUI.prototype.unblock = function () {
        this.el.nativeElement.appendChild(this.mask.nativeElement);
    };
    BlockUI.prototype.ngOnDestroy = function () {
    };
    return BlockUI;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], BlockUI.prototype, "target", void 0);
__decorate([
    core_1.ViewChild('mask'),
    __metadata("design:type", core_1.ElementRef)
], BlockUI.prototype, "mask", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], BlockUI.prototype, "blocked", null);
BlockUI = __decorate([
    core_1.Component({
        selector: 'p-blockUI',
        template: "\n        <div #mask class=\"ui-blockui ui-widget-overlay\" [ngClass]=\"{'ui-blockui-document':!target}\" [ngStyle]=\"{display: blocked ? 'block' : 'none'}\">\n            <ng-content></ng-content>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], BlockUI);
exports.BlockUI = BlockUI;
var BlockUIModule = (function () {
    function BlockUIModule() {
    }
    return BlockUIModule;
}());
BlockUIModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [BlockUI],
        declarations: [BlockUI]
    })
], BlockUIModule);
exports.BlockUIModule = BlockUIModule;
//# sourceMappingURL=blockui.js.map

/***/ }),

/***/ "./node_modules/primeng/components/breadcrumb/breadcrumb.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var router_1 = __webpack_require__(5);
var Breadcrumb = (function () {
    function Breadcrumb() {
    }
    Breadcrumb.prototype.itemClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
    };
    Breadcrumb.prototype.onHomeClick = function (event) {
        if (this.home) {
            this.itemClick(event, this.home);
        }
    };
    return Breadcrumb;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Breadcrumb.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Breadcrumb.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Breadcrumb.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Breadcrumb.prototype, "home", void 0);
Breadcrumb = __decorate([
    core_1.Component({
        selector: 'p-breadcrumb',
        template: "\n        <div [class]=\"styleClass\" [ngStyle]=\"style\" [ngClass]=\"'ui-breadcrumb ui-widget ui-widget-header ui-helper-clearfix ui-corner-all'\">\n            <ul>\n                <li class=\"ui-breadcrumb-home fa fa-home\" *ngIf=\"!home\"></li>\n                <li class=\"ui-breadcrumb-home\" *ngIf=\"home\">\n                    <a *ngIf=\"!home.routerLink\" [href]=\"home.url||'#'\" class=\"ui-menuitem-link\" (click)=\"itemClick($event, home)\" \n                        [ngClass]=\"{'ui-state-disabled':home.disabled}\" [attr.target]=\"home.target\">\n                        <span class=\"fa fa-home\"></span>\n                    </a>\n                    <a *ngIf=\"home.routerLink\" [routerLink]=\"home.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"home.routerLinkActiveOptions||{exact:false}\" class=\"ui-menuitem-link\" (click)=\"itemClick($event, home)\" \n                        [ngClass]=\"{'ui-state-disabled':home.disabled}\" [attr.target]=\"home.target\">\n                        <span class=\"fa fa-home\"></span>\n                    </a>\n                </li>\n                <li class=\"ui-breadcrumb-chevron fa fa-chevron-right\" *ngIf=\"model\"></li>\n                <ng-template ngFor let-item let-end=\"last\" [ngForOf]=\"model\">\n                    <li role=\"menuitem\">\n                        <a *ngIf=\"!item.routerLink\" [href]=\"item.url||'#'\" class=\"ui-menuitem-link\" (click)=\"itemClick($event, item)\" \n                            [ngClass]=\"{'ui-state-disabled':item.disabled}\" [attr.target]=\"item.target\">\n                            <span class=\"ui-menuitem-text\">{{item.label}}</span>\n                        </a>\n                        <a *ngIf=\"item.routerLink\" [routerLink]=\"item.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"item.routerLinkActiveOptions||{exact:false}\" class=\"ui-menuitem-link\" (click)=\"itemClick($event, item)\" \n                            [ngClass]=\"{'ui-state-disabled':item.disabled}\" [attr.target]=\"item.target\">\n                            <span class=\"ui-menuitem-text\">{{item.label}}</span>\n                        </a>\n                    </li>\n                    <li class=\"ui-breadcrumb-chevron fa fa-chevron-right\" *ngIf=\"!end\"></li>\n                </ng-template>\n            </ul>\n        </div>\n    "
    })
], Breadcrumb);
exports.Breadcrumb = Breadcrumb;
var BreadcrumbModule = (function () {
    function BreadcrumbModule() {
    }
    return BreadcrumbModule;
}());
BreadcrumbModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [Breadcrumb, router_1.RouterModule],
        declarations: [Breadcrumb]
    })
], BreadcrumbModule);
exports.BreadcrumbModule = BreadcrumbModule;
//# sourceMappingURL=breadcrumb.js.map

/***/ }),

/***/ "./node_modules/primeng/components/button/button.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var common_1 = __webpack_require__(1);
var Button = (function () {
    function Button(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.iconPos = 'left';
        this.cornerStyleClass = 'ui-corner-all';
    }
    Button.prototype.ngAfterViewInit = function () {
        this.domHandler.addMultipleClasses(this.el.nativeElement, this.getStyleClass());
        if (this.icon) {
            var iconElement = document.createElement("span");
            var iconPosClass = (this.iconPos == 'right') ? 'ui-button-icon-right' : 'ui-button-icon-left';
            iconElement.className = iconPosClass + ' ui-clickable fa fa-fw ' + this.icon;
            this.el.nativeElement.appendChild(iconElement);
        }
        var labelElement = document.createElement("span");
        labelElement.className = 'ui-button-text ui-clickable';
        labelElement.appendChild(document.createTextNode(this.label || 'ui-btn'));
        this.el.nativeElement.appendChild(labelElement);
        this.initialized = true;
    };
    Button.prototype.getStyleClass = function () {
        var styleClass = 'ui-button ui-widget ui-state-default ' + this.cornerStyleClass;
        if (this.icon) {
            if (this.label != null && this.label != undefined) {
                if (this.iconPos == 'left')
                    styleClass = styleClass + ' ui-button-text-icon-left';
                else
                    styleClass = styleClass + ' ui-button-text-icon-right';
            }
            else {
                styleClass = styleClass + ' ui-button-icon-only';
            }
        }
        else {
            styleClass = styleClass + ' ui-button-text-only';
        }
        return styleClass;
    };
    Object.defineProperty(Button.prototype, "label", {
        get: function () {
            return this._label;
        },
        set: function (val) {
            this._label = val;
            if (this.initialized) {
                this.domHandler.findSingle(this.el.nativeElement, '.ui-button-text').textContent = this._label;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "icon", {
        get: function () {
            return this._icon;
        },
        set: function (val) {
            this._icon = val;
            if (this.initialized) {
                var iconPosClass = (this.iconPos == 'right') ? 'ui-button-icon-right' : 'ui-button-icon-left';
                this.domHandler.findSingle(this.el.nativeElement, '.fa').className =
                    iconPosClass + ' ui-clickable fa fa-fw ' + this.icon;
            }
        },
        enumerable: true,
        configurable: true
    });
    Button.prototype.ngOnDestroy = function () {
        while (this.el.nativeElement.hasChildNodes()) {
            this.el.nativeElement.removeChild(this.el.nativeElement.lastChild);
        }
        this.initialized = false;
    };
    return Button;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Button.prototype, "iconPos", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Button.prototype, "cornerStyleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], Button.prototype, "label", null);
__decorate([
    core_1.Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], Button.prototype, "icon", null);
Button = __decorate([
    core_1.Directive({
        selector: '[pButton]',
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Button);
exports.Button = Button;
var ButtonModule = (function () {
    function ButtonModule() {
    }
    return ButtonModule;
}());
ButtonModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Button],
        declarations: [Button]
    })
], ButtonModule);
exports.ButtonModule = ButtonModule;
//# sourceMappingURL=button.js.map

/***/ }),

/***/ "./node_modules/primeng/components/calendar/calendar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var button_1 = __webpack_require__("./node_modules/primeng/components/button/button.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var forms_1 = __webpack_require__(4);
exports.CALENDAR_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Calendar; }),
    multi: true
};
exports.CALENDAR_VALIDATOR = {
    provide: forms_1.NG_VALIDATORS,
    useExisting: core_1.forwardRef(function () { return Calendar; }),
    multi: true
};
var Calendar = (function () {
    function Calendar(el, domHandler, renderer, cd) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.cd = cd;
        this.dateFormat = 'mm/dd/yy';
        this.inline = false;
        this.showOtherMonths = true;
        this.icon = 'fa-calendar';
        this.shortYearCutoff = '+10';
        this.hourFormat = '24';
        this.stepHour = 1;
        this.stepMinute = 1;
        this.stepSecond = 1;
        this.showSeconds = false;
        this.showOnFocus = true;
        this.dataType = 'date';
        this.onFocus = new core_1.EventEmitter();
        this.onBlur = new core_1.EventEmitter();
        this.onClose = new core_1.EventEmitter();
        this.onSelect = new core_1.EventEmitter();
        this.onInput = new core_1.EventEmitter();
        this._locale = {
            firstDayOfWeek: 0,
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        };
        this.closeOverlay = true;
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
        this.inputFieldValue = null;
        this._isValid = true;
    }
    Object.defineProperty(Calendar.prototype, "minDate", {
        get: function () {
            return this._minDate;
        },
        set: function (date) {
            this._minDate = date;
            this.createMonth(this.currentMonth, this.currentYear);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Calendar.prototype, "maxDate", {
        get: function () {
            return this._maxDate;
        },
        set: function (date) {
            this._maxDate = date;
            this.createMonth(this.currentMonth, this.currentYear);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Calendar.prototype, "locale", {
        get: function () {
            return this._locale;
        },
        set: function (newLocale) {
            this._locale = newLocale;
            this.createWeekDays();
            this.createMonth(this.currentMonth, this.currentYear);
        },
        enumerable: true,
        configurable: true
    });
    Calendar.prototype.ngOnInit = function () {
        var date = this.defaultDate || new Date();
        this.createWeekDays();
        this.currentMonth = date.getMonth();
        this.currentYear = date.getFullYear();
        this.pm = date.getHours() > 11;
        if (this.showTime) {
            this.currentMinute = date.getMinutes();
            this.currentSecond = date.getSeconds();
            if (this.hourFormat == '12')
                this.currentHour = date.getHours() == 0 ? 12 : date.getHours() % 12;
            else
                this.currentHour = date.getHours();
        }
        else if (this.timeOnly) {
            this.currentMinute = 0;
            this.currentHour = 0;
            this.currentSecond = 0;
        }
        this.createMonth(this.currentMonth, this.currentYear);
        this.ticksTo1970 = (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
            Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000);
        if (this.yearNavigator && this.yearRange) {
            this.yearOptions = [];
            var years = this.yearRange.split(':'), yearStart = parseInt(years[0]), yearEnd = parseInt(years[1]);
            for (var i = yearStart; i <= yearEnd; i++) {
                this.yearOptions.push(i);
            }
        }
    };
    Calendar.prototype.ngAfterViewInit = function () {
        if (!this.inline && this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.overlayViewChild.nativeElement);
            else
                this.domHandler.appendChild(this.overlayViewChild.nativeElement, this.appendTo);
        }
    };
    Calendar.prototype.ngAfterViewChecked = function () {
        if (this.overlayShown) {
            this.alignOverlay();
            this.overlayShown = false;
        }
    };
    Calendar.prototype.createWeekDays = function () {
        this.weekDays = [];
        var dayIndex = this.locale.firstDayOfWeek;
        for (var i = 0; i < 7; i++) {
            this.weekDays.push(this.locale.dayNamesMin[dayIndex]);
            dayIndex = (dayIndex == 6) ? 0 : ++dayIndex;
        }
    };
    Calendar.prototype.createMonth = function (month, year) {
        this.dates = [];
        this.currentMonth = month;
        this.currentYear = year;
        this.currentMonthText = this.locale.monthNames[month];
        var firstDay = this.getFirstDayOfMonthIndex(month, year);
        var daysLength = this.getDaysCountInMonth(month, year);
        var prevMonthDaysLength = this.getDaysCountInPrevMonth(month, year);
        var sundayIndex = this.getSundayIndex();
        var dayNo = 1;
        var today = new Date();
        for (var i = 0; i < 6; i++) {
            var week = [];
            if (i == 0) {
                for (var j = (prevMonthDaysLength - firstDay + 1); j <= prevMonthDaysLength; j++) {
                    var prev = this.getPreviousMonthAndYear(month, year);
                    week.push({ day: j, month: prev.month, year: prev.year, otherMonth: true,
                        today: this.isToday(today, j, prev.month, prev.year), selectable: this.isSelectable(j, prev.month, prev.year) });
                }
                var remainingDaysLength = 7 - week.length;
                for (var j = 0; j < remainingDaysLength; j++) {
                    week.push({ day: dayNo, month: month, year: year, today: this.isToday(today, dayNo, month, year),
                        selectable: this.isSelectable(dayNo, month, year) });
                    dayNo++;
                }
            }
            else {
                for (var j = 0; j < 7; j++) {
                    if (dayNo > daysLength) {
                        var next = this.getNextMonthAndYear(month, year);
                        week.push({ day: dayNo - daysLength, month: next.month, year: next.year, otherMonth: true,
                            today: this.isToday(today, dayNo - daysLength, next.month, next.year),
                            selectable: this.isSelectable((dayNo - daysLength), next.month, next.year) });
                    }
                    else {
                        week.push({ day: dayNo, month: month, year: year, today: this.isToday(today, dayNo, month, year),
                            selectable: this.isSelectable(dayNo, month, year) });
                    }
                    dayNo++;
                }
            }
            this.dates.push(week);
        }
    };
    Calendar.prototype.prevMonth = function (event) {
        if (this.disabled) {
            event.preventDefault();
            return;
        }
        if (this.currentMonth === 0) {
            this.currentMonth = 11;
            this.currentYear--;
            if (this.yearNavigator && this.currentYear < this.yearOptions[0]) {
                this.currentYear = this.yearOptions[this.yearOptions.length - 1];
            }
        }
        else {
            this.currentMonth--;
        }
        this.createMonth(this.currentMonth, this.currentYear);
        event.preventDefault();
    };
    Calendar.prototype.nextMonth = function (event) {
        if (this.disabled) {
            event.preventDefault();
            return;
        }
        if (this.currentMonth === 11) {
            this.currentMonth = 0;
            this.currentYear++;
            if (this.yearNavigator && this.currentYear > this.yearOptions[this.yearOptions.length - 1]) {
                this.currentYear = this.yearOptions[0];
            }
        }
        else {
            this.currentMonth++;
        }
        this.createMonth(this.currentMonth, this.currentYear);
        event.preventDefault();
    };
    Calendar.prototype.onDateSelect = function (event, dateMeta) {
        if (this.disabled || !dateMeta.selectable) {
            event.preventDefault();
            return;
        }
        if (dateMeta.otherMonth) {
            if (this.selectOtherMonths) {
                this.currentMonth = dateMeta.month;
                this.currentYear = dateMeta.year;
                this.createMonth(this.currentMonth, this.currentYear);
                this.selectDate(dateMeta);
            }
        }
        else {
            this.selectDate(dateMeta);
        }
        this.dateClick = true;
        this.updateInputfield();
        event.preventDefault();
    };
    Calendar.prototype.updateInputfield = function () {
        if (this.value) {
            var formattedValue = void 0;
            if (this.timeOnly) {
                formattedValue = this.formatTime(this.value);
            }
            else {
                formattedValue = this.formatDate(this.value, this.dateFormat);
                if (this.showTime) {
                    formattedValue += ' ' + this.formatTime(this.value);
                }
            }
            this.inputFieldValue = formattedValue;
        }
        else {
            this.inputFieldValue = '';
        }
        this.updateFilledState();
        if (this.inputfieldViewChild && this.inputfieldViewChild.nativeElement) {
            this.inputfieldViewChild.nativeElement.value = this.inputFieldValue;
        }
    };
    Calendar.prototype.selectDate = function (dateMeta) {
        if (this.utc)
            this.value = new Date(Date.UTC(dateMeta.year, dateMeta.month, dateMeta.day));
        else
            this.value = new Date(dateMeta.year, dateMeta.month, dateMeta.day);
        if (this.showTime) {
            if (this.hourFormat === '12' && this.pm && this.currentHour != 12)
                this.value.setHours(this.currentHour + 12);
            else
                this.value.setHours(this.currentHour);
            this.value.setMinutes(this.currentMinute);
            this.value.setSeconds(this.currentSecond);
        }
        this._isValid = true;
        this.updateModel();
        this.onSelect.emit(this.value);
    };
    Calendar.prototype.updateModel = function () {
        if (this.dataType == 'date') {
            this.onModelChange(this.value);
        }
        else if (this.dataType == 'string') {
            if (this.timeOnly)
                this.onModelChange(this.formatTime(this.value));
            else
                this.onModelChange(this.formatDate(this.value, this.dateFormat));
        }
    };
    Calendar.prototype.getFirstDayOfMonthIndex = function (month, year) {
        var day = new Date();
        day.setDate(1);
        day.setMonth(month);
        day.setFullYear(year);
        var dayIndex = day.getDay() + this.getSundayIndex();
        return dayIndex >= 7 ? dayIndex - 7 : dayIndex;
    };
    Calendar.prototype.getDaysCountInMonth = function (month, year) {
        return 32 - this.daylightSavingAdjust(new Date(year, month, 32)).getDate();
    };
    Calendar.prototype.getDaysCountInPrevMonth = function (month, year) {
        var prev = this.getPreviousMonthAndYear(month, year);
        return this.getDaysCountInMonth(prev.month, prev.year);
    };
    Calendar.prototype.getPreviousMonthAndYear = function (month, year) {
        var m, y;
        if (month === 0) {
            m = 11;
            y = year - 1;
        }
        else {
            m = month - 1;
            y = year;
        }
        return { 'month': m, 'year': y };
    };
    Calendar.prototype.getNextMonthAndYear = function (month, year) {
        var m, y;
        if (month === 11) {
            m = 0;
            y = year + 1;
        }
        else {
            m = month + 1;
            y = year;
        }
        return { 'month': m, 'year': y };
    };
    Calendar.prototype.getSundayIndex = function () {
        return this.locale.firstDayOfWeek > 0 ? 7 - this.locale.firstDayOfWeek : 0;
    };
    Calendar.prototype.isSelected = function (dateMeta) {
        if (this.value)
            return this.value.getDate() === dateMeta.day && this.value.getMonth() === dateMeta.month && this.value.getFullYear() === dateMeta.year;
        else
            return false;
    };
    Calendar.prototype.isToday = function (today, day, month, year) {
        return today.getDate() === day && today.getMonth() === month && today.getFullYear() === year;
    };
    Calendar.prototype.isSelectable = function (day, month, year) {
        var validMin = true;
        var validMax = true;
        var validDate = true;
        var validDay = true;
        if (this.minDate) {
            if (this.minDate.getFullYear() > year) {
                validMin = false;
            }
            else if (this.minDate.getFullYear() === year) {
                if (this.minDate.getMonth() > month) {
                    validMin = false;
                }
                else if (this.minDate.getMonth() === month) {
                    if (this.minDate.getDate() > day) {
                        validMin = false;
                    }
                }
            }
        }
        if (this.maxDate) {
            if (this.maxDate.getFullYear() < year) {
                validMax = false;
            }
            else if (this.maxDate.getFullYear() === year) {
                if (this.maxDate.getMonth() < month) {
                    validMax = false;
                }
                else if (this.maxDate.getMonth() === month) {
                    if (this.maxDate.getDate() < day) {
                        validMax = false;
                    }
                }
            }
        }
        if (this.disabledDates) {
            validDate = !this.isDateDisabled(day, month, year);
        }
        if (this.disabledDays) {
            validDay = !this.isDayDisabled(day, month, year);
        }
        return validMin && validMax && validDate && validDay;
    };
    Calendar.prototype.isDateDisabled = function (day, month, year) {
        if (this.disabledDates) {
            for (var _i = 0, _a = this.disabledDates; _i < _a.length; _i++) {
                var disabledDate = _a[_i];
                if (disabledDate.getFullYear() === year && disabledDate.getMonth() === month && disabledDate.getDate() === day) {
                    return true;
                }
            }
        }
        return false;
    };
    Calendar.prototype.isDayDisabled = function (day, month, year) {
        if (this.disabledDays) {
            var weekday = new Date(year, month, day);
            var weekdayNumber = weekday.getDay();
            return this.disabledDays.indexOf(weekdayNumber) !== -1;
        }
        return false;
    };
    Calendar.prototype.onInputFocus = function (event) {
        this.focus = true;
        if (this.showOnFocus) {
            this.showOverlay();
        }
        this.onFocus.emit(event);
    };
    Calendar.prototype.onInputBlur = function (event) {
        this.focus = false;
        this.onBlur.emit(event);
        this.updateInputfield();
        this.onModelTouched();
    };
    Calendar.prototype.onButtonClick = function (event, inputfield) {
        this.closeOverlay = false;
        if (!this.overlayViewChild.nativeElement.offsetParent || this.overlayViewChild.nativeElement.style.display === 'none') {
            inputfield.focus();
            this.showOverlay();
        }
        else
            this.closeOverlay = true;
    };
    Calendar.prototype.onInputKeydown = function (event) {
        this.isKeydown = true;
        if (event.keyCode === 9) {
            this.overlayVisible = false;
        }
    };
    Calendar.prototype.onMonthDropdownChange = function (m) {
        this.currentMonth = parseInt(m);
        this.createMonth(this.currentMonth, this.currentYear);
    };
    Calendar.prototype.onYearDropdownChange = function (y) {
        this.currentYear = parseInt(y);
        this.createMonth(this.currentMonth, this.currentYear);
    };
    Calendar.prototype.incrementHour = function (event) {
        var newHour = this.currentHour + this.stepHour;
        if (this.hourFormat == '24')
            this.currentHour = (newHour >= 24) ? (newHour - 24) : newHour;
        else if (this.hourFormat == '12')
            this.currentHour = (newHour >= 13) ? (newHour - 12) : newHour;
        this.updateTime();
        event.preventDefault();
    };
    Calendar.prototype.decrementHour = function (event) {
        var newHour = this.currentHour - this.stepHour;
        if (this.hourFormat == '24')
            this.currentHour = (newHour < 0) ? (24 + newHour) : newHour;
        else if (this.hourFormat == '12')
            this.currentHour = (newHour <= 0) ? (12 + newHour) : newHour;
        this.updateTime();
        event.preventDefault();
    };
    Calendar.prototype.incrementMinute = function (event) {
        var newMinute = this.currentMinute + this.stepMinute;
        this.currentMinute = (newMinute > 59) ? newMinute - 60 : newMinute;
        this.updateTime();
        event.preventDefault();
    };
    Calendar.prototype.decrementMinute = function (event) {
        var newMinute = this.currentMinute - this.stepMinute;
        this.currentMinute = (newMinute < 0) ? 60 + newMinute : newMinute;
        this.updateTime();
        event.preventDefault();
    };
    Calendar.prototype.incrementSecond = function (event) {
        var newSecond = this.currentSecond + this.stepSecond;
        this.currentSecond = (newSecond > 59) ? newSecond - 60 : newSecond;
        this.updateTime();
        event.preventDefault();
    };
    Calendar.prototype.decrementSecond = function (event) {
        var newSecond = this.currentSecond - this.stepSecond;
        this.currentSecond = (newSecond < 0) ? 60 + newSecond : newSecond;
        this.updateTime();
        event.preventDefault();
    };
    Calendar.prototype.updateTime = function () {
        this.value = this.value || new Date();
        if (this.hourFormat === '12' && this.pm && this.currentHour != 12)
            this.value.setHours(this.currentHour + 12);
        else
            this.value.setHours(this.currentHour);
        this.value.setMinutes(this.currentMinute);
        this.value.setSeconds(this.currentSecond);
        this.updateModel();
        this.onSelect.emit(this.value);
        this.updateInputfield();
    };
    Calendar.prototype.toggleAMPM = function (event) {
        this.pm = !this.pm;
        this.updateTime();
        event.preventDefault();
    };
    Calendar.prototype.onUserInput = function (event) {
        // IE 11 Workaround for input placeholder : https://github.com/primefaces/primeng/issues/2026
        if (!this.isKeydown) {
            return;
        }
        this.isKeydown = false;
        var val = event.target.value;
        try {
            this.value = this.parseValueFromString(val);
            this.updateUI();
            this._isValid = true;
        }
        catch (err) {
            //invalid date
            this.value = null;
            this._isValid = false;
        }
        this.filled = val != null && val.length;
        this.updateModel();
        this.onInput.emit(event);
    };
    Calendar.prototype.parseValueFromString = function (text) {
        if (!text || text.trim().length === 0) {
            return null;
        }
        var dateValue;
        var parts = text.split(' ');
        if (this.timeOnly) {
            dateValue = new Date();
            this.populateTime(dateValue, parts[0], parts[1]);
        }
        else {
            if (this.showTime) {
                dateValue = this.parseDate(parts[0], this.dateFormat);
                this.populateTime(dateValue, parts[1], parts[2]);
            }
            else {
                dateValue = this.parseDate(text, this.dateFormat);
            }
        }
        return dateValue;
    };
    Calendar.prototype.populateTime = function (value, timeString, ampm) {
        if (this.hourFormat == '12' && !ampm) {
            throw 'Invalid Time';
        }
        this.pm = (ampm === 'PM' || ampm === 'pm');
        var time = this.parseTime(timeString);
        value.setHours(time.hour);
        value.setMinutes(time.minute);
        value.setSeconds(time.second);
    };
    Calendar.prototype.updateUI = function () {
        var val = this.value || this.defaultDate || new Date();
        this.createMonth(val.getMonth(), val.getFullYear());
        if (this.showTime || this.timeOnly) {
            var hours = val.getHours();
            if (this.hourFormat == '12') {
                if (hours >= 12) {
                    this.currentHour = (hours == 12) ? 12 : hours - 12;
                }
                else {
                    this.currentHour = (hours == 0) ? 12 : hours;
                }
            }
            else {
                this.currentHour = val.getHours();
            }
            this.currentMinute = val.getMinutes();
            this.currentSecond = val.getSeconds();
        }
    };
    Calendar.prototype.onDatePickerClick = function (event) {
        this.closeOverlay = this.dateClick;
    };
    Calendar.prototype.showOverlay = function () {
        this.overlayVisible = true;
        this.overlayShown = true;
        this.overlayViewChild.nativeElement.style.zIndex = String(++domhandler_1.DomHandler.zindex);
        this.bindDocumentClickListener();
    };
    Calendar.prototype.alignOverlay = function () {
        if (this.appendTo)
            this.domHandler.absolutePosition(this.overlayViewChild.nativeElement, this.inputfieldViewChild.nativeElement);
        else
            this.domHandler.relativePosition(this.overlayViewChild.nativeElement, this.inputfieldViewChild.nativeElement);
    };
    Calendar.prototype.writeValue = function (value) {
        this.value = value;
        if (this.value && typeof this.value === 'string') {
            this.value = this.parseValueFromString(this.value);
        }
        this.updateInputfield();
        this.updateUI();
    };
    Calendar.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Calendar.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Calendar.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    // Ported from jquery-ui datepicker formatDate    
    Calendar.prototype.formatDate = function (date, format) {
        if (!date) {
            return "";
        }
        var iFormat, lookAhead = function (match) {
            var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
            if (matches) {
                iFormat++;
            }
            return matches;
        }, formatNumber = function (match, value, len) {
            var num = "" + value;
            if (lookAhead(match)) {
                while (num.length < len) {
                    num = "0" + num;
                }
            }
            return num;
        }, formatName = function (match, value, shortNames, longNames) {
            return (lookAhead(match) ? longNames[value] : shortNames[value]);
        }, output = "", literal = false;
        if (date) {
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'"))
                        literal = false;
                    else
                        output += format.charAt(iFormat);
                }
                else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                            output += formatNumber("d", date.getDate(), 2);
                            break;
                        case "D":
                            output += formatName("D", date.getDay(), this.locale.dayNamesShort, this.locale.dayNames);
                            break;
                        case "o":
                            output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                            break;
                        case "m":
                            output += formatNumber("m", date.getMonth() + 1, 2);
                            break;
                        case "M":
                            output += formatName("M", date.getMonth(), this.locale.monthNamesShort, this.locale.monthNames);
                            break;
                        case "y":
                            output += (lookAhead("y") ? date.getFullYear() :
                                (date.getFullYear() % 100 < 10 ? "0" : "") + date.getFullYear() % 100);
                            break;
                        case "@":
                            output += date.getTime();
                            break;
                        case "!":
                            output += date.getTime() * 10000 + this.ticksTo1970;
                            break;
                        case "'":
                            if (lookAhead("'"))
                                output += "'";
                            else
                                literal = true;
                            break;
                        default:
                            output += format.charAt(iFormat);
                    }
                }
            }
        }
        return output;
    };
    Calendar.prototype.formatTime = function (date) {
        if (!date) {
            return '';
        }
        var output = '';
        var hours = date.getHours();
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        if (this.hourFormat == '12' && hours > 11 && hours != 12) {
            hours -= 12;
        }
        output += (hours < 10) ? '0' + hours : hours;
        output += ':';
        output += (minutes < 10) ? '0' + minutes : minutes;
        if (this.showSeconds) {
            output += ':';
            output += (seconds < 10) ? '0' + seconds : seconds;
        }
        if (this.hourFormat == '12') {
            output += date.getHours() > 11 ? ' PM' : ' AM';
        }
        return output;
    };
    Calendar.prototype.parseTime = function (value) {
        var tokens = value.split(':');
        var validTokenLength = this.showSeconds ? 3 : 2;
        if (tokens.length !== validTokenLength) {
            throw "Invalid time";
        }
        var h = parseInt(tokens[0]);
        var m = parseInt(tokens[1]);
        var s = this.showSeconds ? parseInt(tokens[2]) : null;
        if (isNaN(h) || isNaN(m) || h > 23 || m > 59 || (this.hourFormat == '12' && h > 12) || (this.showSeconds && (isNaN(s) || s > 59))) {
            throw "Invalid time";
        }
        else {
            if (this.hourFormat == '12' && h !== 12 && this.pm) {
                h += 12;
            }
            return { hour: h, minute: m, second: s };
        }
    };
    // Ported from jquery-ui datepicker parseDate 
    Calendar.prototype.parseDate = function (value, format) {
        if (format == null || value == null) {
            throw "Invalid arguments";
        }
        value = (typeof value === "object" ? value.toString() : value + "");
        if (value === "") {
            return null;
        }
        var iFormat, dim, extra, iValue = 0, shortYearCutoff = (typeof this.shortYearCutoff !== "string" ? this.shortYearCutoff : new Date().getFullYear() % 100 + parseInt(this.shortYearCutoff, 10)), year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function (match) {
            var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
            if (matches) {
                iFormat++;
            }
            return matches;
        }, getNumber = function (match) {
            var isDoubled = lookAhead(match), size = (match === "@" ? 14 : (match === "!" ? 20 :
                (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))), minSize = (match === "y" ? size : 1), digits = new RegExp("^\\d{" + minSize + "," + size + "}"), num = value.substring(iValue).match(digits);
            if (!num) {
                throw "Missing number at position " + iValue;
            }
            iValue += num[0].length;
            return parseInt(num[0], 10);
        }, getName = function (match, shortNames, longNames) {
            var index = -1;
            var arr = lookAhead(match) ? longNames : shortNames;
            var names = [];
            for (var i = 0; i < arr.length; i++) {
                names.push([i, arr[i]]);
            }
            names.sort(function (a, b) {
                return -(a[1].length - b[1].length);
            });
            for (var i = 0; i < names.length; i++) {
                var name_1 = names[i][1];
                if (value.substr(iValue, name_1.length).toLowerCase() === name_1.toLowerCase()) {
                    index = names[i][0];
                    iValue += name_1.length;
                    break;
                }
            }
            if (index !== -1) {
                return index + 1;
            }
            else {
                throw "Unknown name at position " + iValue;
            }
        }, checkLiteral = function () {
            if (value.charAt(iValue) !== format.charAt(iFormat)) {
                throw "Unexpected literal at position " + iValue;
            }
            iValue++;
        };
        for (iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
                if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                    literal = false;
                }
                else {
                    checkLiteral();
                }
            }
            else {
                switch (format.charAt(iFormat)) {
                    case "d":
                        day = getNumber("d");
                        break;
                    case "D":
                        getName("D", this.locale.dayNamesShort, this.locale.dayNames);
                        break;
                    case "o":
                        doy = getNumber("o");
                        break;
                    case "m":
                        month = getNumber("m");
                        break;
                    case "M":
                        month = getName("M", this.locale.monthNamesShort, this.locale.monthNames);
                        break;
                    case "y":
                        year = getNumber("y");
                        break;
                    case "@":
                        date = new Date(getNumber("@"));
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;
                    case "!":
                        date = new Date((getNumber("!") - this.ticksTo1970) / 10000);
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;
                    case "'":
                        if (lookAhead("'")) {
                            checkLiteral();
                        }
                        else {
                            literal = true;
                        }
                        break;
                    default:
                        checkLiteral();
                }
            }
        }
        if (iValue < value.length) {
            extra = value.substr(iValue);
            if (!/^\s+/.test(extra)) {
                throw "Extra/unparsed characters found in date: " + extra;
            }
        }
        if (year === -1) {
            year = new Date().getFullYear();
        }
        else if (year < 100) {
            year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                (year <= shortYearCutoff ? 0 : -100);
        }
        if (doy > -1) {
            month = 1;
            day = doy;
            do {
                dim = this.getDaysCountInMonth(year, month - 1);
                if (day <= dim) {
                    break;
                }
                month++;
                day -= dim;
            } while (true);
        }
        date = this.daylightSavingAdjust(new Date(year, month - 1, day));
        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
            throw "Invalid date"; // E.g. 31/02/00
        }
        return date;
    };
    Calendar.prototype.daylightSavingAdjust = function (date) {
        if (!date) {
            return null;
        }
        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
        return date;
    };
    Calendar.prototype.updateFilledState = function () {
        this.filled = this.inputFieldValue && this.inputFieldValue != '';
    };
    Calendar.prototype.bindDocumentClickListener = function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'click', function (event) {
                if (_this.closeOverlay) {
                    _this.overlayVisible = false;
                    _this.onClose.emit(event);
                }
                _this.closeOverlay = true;
                _this.dateClick = false;
                _this.cd.detectChanges();
            });
        }
    };
    Calendar.prototype.unbindDocumentClickListener = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    Calendar.prototype.ngOnDestroy = function () {
        this.unbindDocumentClickListener();
        if (!this.inline && this.appendTo) {
            this.el.nativeElement.appendChild(this.overlayViewChild.nativeElement);
        }
    };
    Calendar.prototype.validate = function (c) {
        if (!this._isValid) {
            return { invalidDate: true };
        }
        return null;
    };
    return Calendar;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Date)
], Calendar.prototype, "defaultDate", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "inputStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "inputStyleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "placeholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Calendar.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "dateFormat", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "inline", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "showOtherMonths", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "selectOtherMonths", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "showIcon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "icon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Calendar.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "readonlyInput", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Calendar.prototype, "shortYearCutoff", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "monthNavigator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "yearNavigator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "yearRange", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "showTime", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "hourFormat", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "timeOnly", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Calendar.prototype, "stepHour", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Calendar.prototype, "stepMinute", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Calendar.prototype, "stepSecond", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "showSeconds", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "required", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "showOnFocus", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Calendar.prototype, "dataType", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Calendar.prototype, "disabledDates", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Calendar.prototype, "disabledDays", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Calendar.prototype, "utc", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Calendar.prototype, "onFocus", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Calendar.prototype, "onBlur", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Calendar.prototype, "onClose", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Calendar.prototype, "onSelect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Calendar.prototype, "onInput", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Calendar.prototype, "tabindex", void 0);
__decorate([
    core_1.ViewChild('datepicker'),
    __metadata("design:type", core_1.ElementRef)
], Calendar.prototype, "overlayViewChild", void 0);
__decorate([
    core_1.ViewChild('inputfield'),
    __metadata("design:type", core_1.ElementRef)
], Calendar.prototype, "inputfieldViewChild", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], Calendar.prototype, "minDate", null);
__decorate([
    core_1.Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], Calendar.prototype, "maxDate", null);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], Calendar.prototype, "locale", null);
Calendar = __decorate([
    core_1.Component({
        selector: 'p-calendar',
        template: "\n        <span [ngClass]=\"{'ui-calendar':true,'ui-calendar-w-btn':showIcon}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <ng-template [ngIf]=\"!inline\">\n                <input #inputfield type=\"text\" [attr.id]=\"inputId\" [attr.required]=\"required\" [value]=\"inputFieldValue\" (focus)=\"onInputFocus($event)\" (keydown)=\"onInputKeydown($event)\" (click)=\"closeOverlay=false\" (blur)=\"onInputBlur($event)\"\n                    [readonly]=\"readonlyInput\" (input)=\"onUserInput($event)\" [ngStyle]=\"inputStyle\" [class]=\"inputStyleClass\" [placeholder]=\"placeholder||''\" [disabled]=\"disabled\" [attr.tabindex]=\"tabindex\"\n                    [ngClass]=\"'ui-inputtext ui-widget ui-state-default ui-corner-all'\"\n                    ><button type=\"button\" [icon]=\"icon\" pButton *ngIf=\"showIcon\" (click)=\"onButtonClick($event,inputfield)\"\n                    [ngClass]=\"{'ui-datepicker-trigger':true,'ui-state-disabled':disabled}\" [disabled]=\"disabled\" tabindex=\"-1\"></button>\n            </ng-template>\n            <div #datepicker class=\"ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\" [ngClass]=\"{'ui-datepicker-inline':inline,'ui-shadow':!inline,'ui-state-disabled':disabled,'ui-datepicker-timeonly':timeOnly}\" \n                [ngStyle]=\"{'display': inline ? 'inline-block' : (overlayVisible ? 'block' : 'none')}\" (click)=\"onDatePickerClick($event)\" [@overlayState]=\"inline ? 'visible' : (overlayVisible ? 'visible' : 'hidden')\">\n\n                <div class=\"ui-datepicker-header ui-widget-header ui-helper-clearfix ui-corner-all\" *ngIf=\"!timeOnly && (overlayVisible || inline)\">\n                    <ng-content select=\"p-header\"></ng-content>\n                    <a class=\"ui-datepicker-prev ui-corner-all\" href=\"#\" (click)=\"prevMonth($event)\">\n                        <span class=\"fa fa-angle-left\"></span>\n                    </a>\n                    <a class=\"ui-datepicker-next ui-corner-all\" href=\"#\" (click)=\"nextMonth($event)\">\n                        <span class=\"fa fa-angle-right\"></span>\n                    </a>\n                    <div class=\"ui-datepicker-title\">\n                        <span class=\"ui-datepicker-month\" *ngIf=\"!monthNavigator\">{{locale.monthNames[currentMonth]}}</span>\n                        <select class=\"ui-datepicker-month\" *ngIf=\"monthNavigator\" (change)=\"onMonthDropdownChange($event.target.value)\">\n                            <option [value]=\"i\" *ngFor=\"let month of locale.monthNames;let i = index\" [selected]=\"i == currentMonth\">{{month}}</option>\n                        </select>\n                        <select class=\"ui-datepicker-year\" *ngIf=\"yearNavigator\" (change)=\"onYearDropdownChange($event.target.value)\">\n                            <option [value]=\"year\" *ngFor=\"let year of yearOptions\" [selected]=\"year == currentYear\">{{year}}</option>\n                        </select>\n                        <span class=\"ui-datepicker-year\" *ngIf=\"!yearNavigator\">{{currentYear}}</span>\n                    </div>\n                </div>\n                <table class=\"ui-datepicker-calendar\" *ngIf=\"!timeOnly && (overlayVisible || inline)\">\n                    <thead>\n                        <tr>\n                            <th scope=\"col\" *ngFor=\"let weekDay of weekDays;let begin = first; let end = last\">\n                                <span>{{weekDay}}</span>\n                            </th>\n                        </tr>\n                    </thead>\n                    <tbody>\n                        <tr *ngFor=\"let week of dates\">\n                            <td *ngFor=\"let date of week\" [ngClass]=\"{'ui-datepicker-other-month ui-state-disabled':date.otherMonth,\n                                'ui-datepicker-current-day':isSelected(date),'ui-datepicker-today':date.today}\">\n                                <a class=\"ui-state-default\" href=\"#\" *ngIf=\"date.otherMonth ? showOtherMonths : true\" \n                                    [ngClass]=\"{'ui-state-active':isSelected(date), 'ui-state-highlight':date.today, 'ui-state-disabled':!date.selectable}\"\n                                    (click)=\"onDateSelect($event,date)\">{{date.day}}</a>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n                <div class=\"ui-timepicker ui-widget-header ui-corner-all\" *ngIf=\"showTime||timeOnly\">\n                    <div class=\"ui-hour-picker\">\n                        <a href=\"#\" (click)=\"incrementHour($event)\">\n                            <span class=\"fa fa-angle-up\"></span>\n                        </a>\n                        <span [ngStyle]=\"{'display': currentHour < 10 ? 'inline': 'none'}\">0</span><span>{{currentHour}}</span>\n                        <a href=\"#\" (click)=\"decrementHour($event)\">\n                            <span class=\"fa fa-angle-down\"></span>\n                        </a>\n                    </div>\n                    <div class=\"ui-separator\">\n                        <a href=\"#\">\n                            <span class=\"fa fa-angle-up\"></span>\n                        </a>\n                        <span>:</span>\n                        <a href=\"#\">\n                            <span class=\"fa fa-angle-down\"></span>\n                        </a>\n                    </div>\n                    <div class=\"ui-minute-picker\">\n                        <a href=\"#\" (click)=\"incrementMinute($event)\">\n                            <span class=\"fa fa-angle-up\"></span>\n                        </a>\n                        <span [ngStyle]=\"{'display': currentMinute < 10 ? 'inline': 'none'}\">0</span><span>{{currentMinute}}</span>\n                        <a href=\"#\" (click)=\"decrementMinute($event)\">\n                            <span class=\"fa fa-angle-down\"></span>\n                        </a>\n                    </div>\n                    <div class=\"ui-separator\" *ngIf=\"showSeconds\">\n                        <a href=\"#\">\n                            <span class=\"fa fa-angle-up\"></span>\n                        </a>\n                        <span>:</span>\n                        <a href=\"#\">\n                            <span class=\"fa fa-angle-down\"></span>\n                        </a>\n                    </div>\n                    <div class=\"ui-second-picker\" *ngIf=\"showSeconds\">\n                        <a href=\"#\" (click)=\"incrementSecond($event)\">\n                            <span class=\"fa fa-angle-up\"></span>\n                        </a>\n                        <span [ngStyle]=\"{'display': currentSecond < 10 ? 'inline': 'none'}\">0</span><span>{{currentSecond}}</span>\n                        <a href=\"#\" (click)=\"decrementSecond($event)\">\n                            <span class=\"fa fa-angle-down\"></span>\n                        </a>\n                    </div>\n                    <div class=\"ui-ampm-picker\" *ngIf=\"hourFormat=='12'\">\n                        <a href=\"#\" (click)=\"toggleAMPM($event)\">\n                            <span class=\"fa fa-angle-up\"></span>\n                        </a>\n                        <span>{{pm ? 'PM' : 'AM'}}</span>\n                        <a href=\"#\" (click)=\"toggleAMPM($event)\">\n                            <span class=\"fa fa-angle-down\"></span>\n                        </a>\n                    </div>\n                </div>\n                <ng-content select=\"p-footer\"></ng-content>\n            </div>\n        </span>\n    ",
        animations: [
            animations_1.trigger('overlayState', [
                animations_1.state('hidden', animations_1.style({
                    opacity: 0
                })),
                animations_1.state('visible', animations_1.style({
                    opacity: 1
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms ease-in')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms ease-out'))
            ])
        ],
        host: {
            '[class.ui-inputwrapper-filled]': 'filled',
            '[class.ui-inputwrapper-focus]': 'focus'
        },
        providers: [domhandler_1.DomHandler, exports.CALENDAR_VALUE_ACCESSOR, exports.CALENDAR_VALIDATOR]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, core_1.ChangeDetectorRef])
], Calendar);
exports.Calendar = Calendar;
var CalendarModule = (function () {
    function CalendarModule() {
    }
    return CalendarModule;
}());
CalendarModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, button_1.ButtonModule],
        exports: [Calendar, button_1.ButtonModule],
        declarations: [Calendar]
    })
], CalendarModule);
exports.CalendarModule = CalendarModule;
//# sourceMappingURL=calendar.js.map

/***/ }),

/***/ "./node_modules/primeng/components/captcha/captcha.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var Captcha = (function () {
    function Captcha(el, _zone) {
        this.el = el;
        this._zone = _zone;
        this.siteKey = null;
        this.theme = 'light';
        this.type = 'image';
        this.size = 'normal';
        this.tabindex = 0;
        this.language = null;
        this.initCallback = "initRecaptcha";
        this.onResponse = new core_1.EventEmitter();
        this.onExpire = new core_1.EventEmitter();
        this._instance = null;
    }
    Captcha.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (window.grecaptcha) {
            this.init();
        }
        else {
            window[this.initCallback] = function () {
                _this.init();
            };
        }
    };
    Captcha.prototype.init = function () {
        var _this = this;
        this._instance = window.grecaptcha.render(this.el.nativeElement.children[0], {
            'sitekey': this.siteKey,
            'theme': this.theme,
            'type': this.type,
            'size': this.size,
            'tabindex': this.tabindex,
            'hl': this.language,
            'callback': function (response) { _this._zone.run(function () { return _this.recaptchaCallback(response); }); },
            'expired-callback': function () { _this._zone.run(function () { return _this.recaptchaExpiredCallback(); }); }
        });
    };
    Captcha.prototype.reset = function () {
        if (this._instance === null)
            return;
        window.grecaptcha.reset(this._instance);
    };
    Captcha.prototype.getResponse = function () {
        if (this._instance === null)
            return null;
        return window.grecaptcha.getResponse(this._instance);
    };
    Captcha.prototype.recaptchaCallback = function (response) {
        this.onResponse.emit({
            response: response
        });
    };
    Captcha.prototype.recaptchaExpiredCallback = function () {
        this.onExpire.emit();
    };
    Captcha.prototype.ngOnDestroy = function () {
        if (this._instance != null) {
            window.grecaptcha.reset(this._instance);
        }
    };
    return Captcha;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Captcha.prototype, "siteKey", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Captcha.prototype, "theme", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Captcha.prototype, "type", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Captcha.prototype, "size", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Captcha.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Captcha.prototype, "language", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Captcha.prototype, "initCallback", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Captcha.prototype, "onResponse", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Captcha.prototype, "onExpire", void 0);
Captcha = __decorate([
    core_1.Component({
        selector: 'p-captcha',
        template: "<div></div>"
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, core_1.NgZone])
], Captcha);
exports.Captcha = Captcha;
var CaptchaModule = (function () {
    function CaptchaModule() {
    }
    return CaptchaModule;
}());
CaptchaModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Captcha],
        declarations: [Captcha]
    })
], CaptchaModule);
exports.CaptchaModule = CaptchaModule;
//# sourceMappingURL=captcha.js.map

/***/ }),

/***/ "./node_modules/primeng/components/carousel/carousel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var common_1 = __webpack_require__(1);
var Carousel = (function () {
    function Carousel(el, domHandler, renderer, cd) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.cd = cd;
        this.numVisible = 3;
        this.firstVisible = 0;
        this.circular = false;
        this.breakpoint = 560;
        this.responsive = true;
        this.autoplayInterval = 0;
        this.effectDuration = '1s';
        this.easing = 'ease-out';
        this.pageLinks = 3;
        this.onPage = new core_1.EventEmitter();
        this.left = 0;
    }
    Carousel.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    Object.defineProperty(Carousel.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (val) {
            this._value = val;
            this.handleDataChange();
        },
        enumerable: true,
        configurable: true
    });
    Carousel.prototype.handleDataChange = function () {
        if (this.value && this.value.length) {
            if (this.value.length && this.firstVisible >= this.value.length) {
                this.setPage(this.totalPages - 1);
            }
        }
        else {
            this.setPage(0);
        }
        this.valuesChanged = true;
    };
    Carousel.prototype.ngAfterViewChecked = function () {
        if (this.valuesChanged && this.containerViewChild.nativeElement.offsetParent) {
            this.render();
            this.valuesChanged = false;
        }
    };
    Carousel.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.responsive) {
            this.documentResponsiveListener = this.renderer.listen('window', 'resize', function (event) {
                _this.updateState();
            });
        }
    };
    Carousel.prototype.updateLinks = function () {
        this.anchorPageLinks = [];
        for (var i = 0; i < this.totalPages; i++) {
            this.anchorPageLinks.push(i);
        }
    };
    Carousel.prototype.updateDropdown = function () {
        this.selectDropdownOptions = [];
        for (var i = 0; i < this.totalPages; i++) {
            this.selectDropdownOptions.push(i);
        }
    };
    Carousel.prototype.updateMobileDropdown = function () {
        this.mobileDropdownOptions = [];
        for (var i = 0; i < this.value.length; i++) {
            this.mobileDropdownOptions.push(i);
        }
    };
    Carousel.prototype.render = function () {
        if (this.autoplayInterval) {
            this.stopAutoplay();
        }
        this.items = this.domHandler.find(this.itemsViewChild.nativeElement, 'li');
        this.calculateColumns();
        this.calculateItemWidths();
        if (!this.responsive) {
            this.containerViewChild.nativeElement.style.width = (this.domHandler.width(this.containerViewChild.nativeElement)) + 'px';
        }
        if (this.autoplayInterval) {
            this.circular = true;
            this.startAutoplay();
        }
        this.updateMobileDropdown();
        this.updateLinks();
        this.updateDropdown();
        this.cd.detectChanges();
    };
    Carousel.prototype.calculateItemWidths = function () {
        var firstItem = (this.items && this.items.length) ? this.items[0] : null;
        if (firstItem) {
            for (var i = 0; i < this.items.length; i++) {
                this.items[i].style.width = ((this.domHandler.innerWidth(this.viewportViewChild.nativeElement) - (this.domHandler.getHorizontalMargin(firstItem) * this.columns)) / this.columns) + 'px';
            }
        }
    };
    Carousel.prototype.calculateColumns = function () {
        if (window.innerWidth <= this.breakpoint) {
            this.shrinked = true;
            this.columns = 1;
        }
        else {
            this.shrinked = false;
            this.columns = this.numVisible;
        }
        this.page = Math.floor(this.firstVisible / this.columns);
    };
    Carousel.prototype.onNextNav = function () {
        var lastPage = (this.page === (this.totalPages - 1));
        if (!lastPage)
            this.setPage(this.page + 1);
        else if (this.circular)
            this.setPage(0);
    };
    Carousel.prototype.onPrevNav = function () {
        if (this.page !== 0)
            this.setPage(this.page - 1);
        else if (this.circular)
            this.setPage(this.totalPages - 1);
    };
    Carousel.prototype.setPageWithLink = function (event, p) {
        this.setPage(p);
        event.preventDefault();
    };
    Carousel.prototype.setPage = function (p, enforce) {
        if (p !== this.page || enforce) {
            this.page = p;
            this.left = (-1 * (this.domHandler.innerWidth(this.viewportViewChild.nativeElement) * this.page));
            this.firstVisible = this.page * this.columns;
            this.onPage.emit({
                page: this.page
            });
        }
    };
    Carousel.prototype.onDropdownChange = function (val) {
        this.setPage(parseInt(val));
    };
    Object.defineProperty(Carousel.prototype, "displayPageLinks", {
        get: function () {
            return (this.totalPages <= this.pageLinks && !this.shrinked);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Carousel.prototype, "displayPageDropdown", {
        get: function () {
            return (this.totalPages > this.pageLinks && !this.shrinked);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Carousel.prototype, "totalPages", {
        get: function () {
            return (this.value && this.value.length) ? Math.ceil(this.value.length / this.columns) : 0;
        },
        enumerable: true,
        configurable: true
    });
    Carousel.prototype.routerDisplay = function () {
        var win = window;
        if (win.innerWidth <= this.breakpoint)
            return true;
        else
            return false;
    };
    Carousel.prototype.updateState = function () {
        var win = window;
        if (win.innerWidth <= this.breakpoint) {
            this.shrinked = true;
            this.columns = 1;
        }
        else if (this.shrinked) {
            this.shrinked = false;
            this.columns = this.numVisible;
            this.updateLinks();
            this.updateDropdown();
        }
        this.calculateItemWidths();
        this.setPage(Math.floor(this.firstVisible / this.columns), true);
    };
    Carousel.prototype.startAutoplay = function () {
        var _this = this;
        this.interval = setInterval(function () {
            if (_this.page === (_this.totalPages - 1))
                _this.setPage(0);
            else
                _this.setPage(_this.page + 1);
        }, this.autoplayInterval);
    };
    Carousel.prototype.stopAutoplay = function () {
        clearInterval(this.interval);
    };
    Carousel.prototype.ngOnDestroy = function () {
        if (this.documentResponsiveListener) {
            this.documentResponsiveListener();
        }
        if (this.autoplayInterval) {
            this.stopAutoplay();
        }
    };
    return Carousel;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Carousel.prototype, "numVisible", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Carousel.prototype, "firstVisible", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Carousel.prototype, "headerText", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Carousel.prototype, "circular", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Carousel.prototype, "breakpoint", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Carousel.prototype, "responsive", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Carousel.prototype, "autoplayInterval", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Carousel.prototype, "effectDuration", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Carousel.prototype, "easing", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Carousel.prototype, "pageLinks", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Carousel.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Carousel.prototype, "styleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Carousel.prototype, "onPage", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], Carousel.prototype, "templates", void 0);
__decorate([
    core_1.ViewChild('container'),
    __metadata("design:type", core_1.ElementRef)
], Carousel.prototype, "containerViewChild", void 0);
__decorate([
    core_1.ViewChild('viewport'),
    __metadata("design:type", core_1.ElementRef)
], Carousel.prototype, "viewportViewChild", void 0);
__decorate([
    core_1.ViewChild('items'),
    __metadata("design:type", core_1.ElementRef)
], Carousel.prototype, "itemsViewChild", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], Carousel.prototype, "value", null);
Carousel = __decorate([
    core_1.Component({
        selector: 'p-carousel',
        template: "\n        <div #container [ngClass]=\"{'ui-carousel ui-widget ui-widget-content ui-corner-all':true}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-carousel-header ui-widget-header ui-corner-all\">\n                <span class=\"ui-carousel-header-title\">{{headerText}}</span>\n                <span class=\"ui-carousel-button ui-carousel-next-button fa fa-arrow-circle-right\" (click)=\"onNextNav()\" \n                        [ngClass]=\"{'ui-state-disabled':(page === (totalPages-1)) && !circular}\" *ngIf=\"value&&value.length\"></span>\n                <span class=\"ui-carousel-button ui-carousel-prev-button fa fa-arrow-circle-left\" (click)=\"onPrevNav()\" \n                        [ngClass]=\"{'ui-state-disabled':(page === 0 && !circular)}\" *ngIf=\"value&&value.length\"></span>\n                <div *ngIf=\"displayPageLinks\" class=\"ui-carousel-page-links\">\n                    <a href=\"#\" (click)=\"setPageWithLink($event,i)\" class=\"ui-carousel-page-link fa fa-circle-o\" *ngFor=\"let links of anchorPageLinks;let i=index\" [ngClass]=\"{'fa-dot-circle-o':page===i}\"></a>\n                </div>\n                <select *ngIf=\"displayPageDropdown\" class=\"ui-carousel-dropdown ui-widget ui-state-default ui-corner-left\" [value]=\"page\" (change)=\"onDropdownChange($event.target.value)\">\n                    <option *ngFor=\"let option of selectDropdownOptions\" [value]=\"option\" [selected]=\"value == option\">{{option+1}}</option>\n                </select>\n                <select *ngIf=\"responsive&&value&&value.length\" class=\"ui-carousel-mobiledropdown ui-widget ui-state-default ui-corner-left\" [value]=\"page\" (change)=\"onDropdownChange($event.target.value)\"\n                    [style.display]=\"shrinked ? 'block' : 'none'\">\n                    <option *ngFor=\"let option of mobileDropdownOptions\" [value]=\"option\" [selected]=\"value == option\">{{option+1}}</option>\n                </select>\n            </div>\n            <div #viewport class=\"ui-carousel-viewport\">\n                <ul #items class=\"ui-carousel-items\" [style.left.px]=\"left\" [style.transitionProperty]=\"'left'\" \n                            [style.transitionDuration]=\"effectDuration\" [style.transitionTimingFunction]=\"easing\">\n                    <li *ngFor=\"let item of value\" class=\"ui-carousel-item ui-widget-content ui-corner-all\">\n                        <ng-template [pTemplateWrapper]=\"itemTemplate\" [item]=\"item\"></ng-template>\n                    </li>\n                </ul>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, core_1.ChangeDetectorRef])
], Carousel);
exports.Carousel = Carousel;
var CarouselModule = (function () {
    function CarouselModule() {
    }
    return CarouselModule;
}());
CarouselModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_1.SharedModule],
        exports: [Carousel, shared_1.SharedModule],
        declarations: [Carousel]
    })
], CarouselModule);
exports.CarouselModule = CarouselModule;
//# sourceMappingURL=carousel.js.map

/***/ }),

/***/ "./node_modules/primeng/components/chart/chart.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var UIChart = (function () {
    function UIChart(el) {
        this.el = el;
        this.onDataSelect = new core_1.EventEmitter();
    }
    Object.defineProperty(UIChart.prototype, "data", {
        get: function () {
            return this._data;
        },
        set: function (val) {
            this._data = val;
            this.reinit();
        },
        enumerable: true,
        configurable: true
    });
    UIChart.prototype.ngAfterViewInit = function () {
        this.initChart();
        this.initialized = true;
    };
    UIChart.prototype.onCanvasClick = function (event) {
        if (this.chart) {
            var element = this.chart.getElementAtEvent(event);
            var dataset = this.chart.getDatasetAtEvent(event);
            if (element && element[0] && dataset) {
                this.onDataSelect.emit({ originalEvent: event, element: element[0], dataset: dataset });
            }
        }
    };
    UIChart.prototype.initChart = function () {
        this.chart = new Chart(this.el.nativeElement.children[0].children[0], {
            type: this.type,
            data: this.data,
            options: this.options
        });
    };
    UIChart.prototype.getCanvas = function () {
        return this.el.nativeElement.children[0].children[0];
    };
    UIChart.prototype.getBase64Image = function () {
        return this.chart.toBase64Image();
    };
    UIChart.prototype.generateLegend = function () {
        if (this.chart) {
            this.chart.generateLegend();
        }
    };
    UIChart.prototype.refresh = function () {
        if (this.chart) {
            this.chart.update();
        }
    };
    UIChart.prototype.reinit = function () {
        if (this.chart) {
            this.chart.destroy();
            this.initChart();
        }
    };
    UIChart.prototype.ngOnDestroy = function () {
        if (this.chart) {
            this.chart.destroy();
            this.initialized = false;
            this.chart = null;
        }
    };
    return UIChart;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], UIChart.prototype, "type", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], UIChart.prototype, "options", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], UIChart.prototype, "width", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], UIChart.prototype, "height", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], UIChart.prototype, "onDataSelect", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], UIChart.prototype, "data", null);
UIChart = __decorate([
    core_1.Component({
        selector: 'p-chart',
        template: "\n        <div>\n            <canvas [attr.width]=\"width\" [attr.height]=\"height\" (click)=\"onCanvasClick($event)\"></canvas>\n        </div>\n    "
    }),
    __metadata("design:paramtypes", [core_1.ElementRef])
], UIChart);
exports.UIChart = UIChart;
var ChartModule = (function () {
    function ChartModule() {
    }
    return ChartModule;
}());
ChartModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [UIChart],
        declarations: [UIChart]
    })
], ChartModule);
exports.ChartModule = ChartModule;
//# sourceMappingURL=chart.js.map

/***/ }),

/***/ "./node_modules/primeng/components/checkbox/checkbox.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var forms_1 = __webpack_require__(4);
exports.CHECKBOX_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Checkbox; }),
    multi: true
};
var Checkbox = (function () {
    function Checkbox(cd) {
        this.cd = cd;
        this.onChange = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
        this.focused = false;
        this.checked = false;
    }
    Checkbox.prototype.onClick = function (event, checkbox, focus) {
        event.preventDefault();
        if (this.disabled) {
            return;
        }
        this.checked = !this.checked;
        this.updateModel();
        if (focus) {
            checkbox.focus();
        }
    };
    Checkbox.prototype.updateModel = function () {
        if (!this.binary) {
            if (this.checked)
                this.addValue();
            else
                this.removeValue();
            this.onModelChange(this.model);
        }
        else {
            this.onModelChange(this.checked);
        }
        this.onChange.emit(this.checked);
    };
    Checkbox.prototype.handleChange = function (event) {
        this.checked = event.target.checked;
        this.updateModel();
    };
    Checkbox.prototype.isChecked = function () {
        if (this.binary)
            return this.model;
        else
            return this.model && this.model.indexOf(this.value) > -1;
    };
    Checkbox.prototype.removeValue = function () {
        var _this = this;
        this.model = this.model.filter(function (val) { return val !== _this.value; });
    };
    Checkbox.prototype.addValue = function () {
        if (this.model)
            this.model = this.model.concat([this.value]);
        else
            this.model = [this.value];
    };
    Checkbox.prototype.onFocus = function (event) {
        this.focused = true;
    };
    Checkbox.prototype.onBlur = function (event) {
        this.focused = false;
        this.onModelTouched();
    };
    Checkbox.prototype.writeValue = function (model) {
        this.model = model;
        this.checked = this.isChecked();
        this.cd.markForCheck();
    };
    Checkbox.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Checkbox.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Checkbox.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    return Checkbox;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Checkbox.prototype, "value", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Checkbox.prototype, "name", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Checkbox.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Checkbox.prototype, "binary", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Checkbox.prototype, "label", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Checkbox.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Checkbox.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Checkbox.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Checkbox.prototype, "styleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Checkbox.prototype, "onChange", void 0);
Checkbox = __decorate([
    core_1.Component({
        selector: 'p-checkbox',
        template: "\n        <div [ngStyle]=\"style\" [ngClass]=\"'ui-chkbox ui-widget'\" [class]=\"styleClass\">\n            <div class=\"ui-helper-hidden-accessible\">\n                <input #cb type=\"checkbox\" [attr.id]=\"inputId\" [name]=\"name\" [value]=\"value\" [checked]=\"checked\" (focus)=\"onFocus($event)\" (blur)=\"onBlur($event)\"\n                [ngClass]=\"{'ui-state-focus':focused}\" (change)=\"handleChange($event)\" [disabled]=\"disabled\" [attr.tabindex]=\"tabindex\">\n            </div>\n            <div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\" (click)=\"onClick($event,cb,true)\"\n                        [ngClass]=\"{'ui-state-active':checked,'ui-state-disabled':disabled,'ui-state-focus':focused}\">\n                <span class=\"ui-chkbox-icon ui-clickable\" [ngClass]=\"{'fa fa-check':checked}\"></span>\n            </div>\n        </div>\n        <label class=\"ui-chkbox-label\" (click)=\"onClick($event,cb,true)\" *ngIf=\"label\">{{label}}</label>\n    ",
        providers: [exports.CHECKBOX_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ChangeDetectorRef])
], Checkbox);
exports.Checkbox = Checkbox;
var CheckboxModule = (function () {
    function CheckboxModule() {
    }
    return CheckboxModule;
}());
CheckboxModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Checkbox],
        declarations: [Checkbox]
    })
], CheckboxModule);
exports.CheckboxModule = CheckboxModule;
//# sourceMappingURL=checkbox.js.map

/***/ }),

/***/ "./node_modules/primeng/components/chips/chips.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var inputtext_1 = __webpack_require__("./node_modules/primeng/components/inputtext/inputtext.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var forms_1 = __webpack_require__(4);
exports.CHIPS_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Chips; }),
    multi: true
};
var Chips = (function () {
    function Chips(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.onAdd = new core_1.EventEmitter();
        this.onRemove = new core_1.EventEmitter();
        this.allowDuplicate = true;
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    Chips.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    Chips.prototype.writeValue = function (value) {
        this.value = value;
    };
    Chips.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Chips.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Chips.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    Chips.prototype.resolveFieldData = function (data, field) {
        if (data && field) {
            if (field.indexOf('.') == -1) {
                return data[field];
            }
            else {
                var fields = field.split('.');
                var value = data;
                for (var i = 0, len = fields.length; i < len; ++i) {
                    value = value[fields[i]];
                }
                return value;
            }
        }
        else {
            return null;
        }
    };
    Chips.prototype.onFocus = function () {
        this.focus = true;
    };
    Chips.prototype.onBlur = function () {
        this.focus = false;
        this.onModelTouched();
    };
    Chips.prototype.removeItem = function (event, index) {
        if (this.disabled) {
            return;
        }
        var removedItem = this.value[index];
        this.value = this.value.filter(function (val, i) { return i != index; });
        this.onModelChange(this.value);
        this.onRemove.emit({
            originalEvent: event,
            value: removedItem
        });
    };
    Chips.prototype.onKeydown = function (event, inputEL) {
        switch (event.which) {
            //backspace
            case 8:
                if (inputEL.value.length === 0 && this.value && this.value.length > 0) {
                    this.value = this.value.slice();
                    var removedItem = this.value.pop();
                    this.onModelChange(this.value);
                    this.onRemove.emit({
                        originalEvent: event,
                        value: removedItem
                    });
                }
                break;
            //enter
            case 13:
                this.value = this.value || [];
                if (inputEL.value && inputEL.value.trim().length && (!this.max || this.max > this.value.length)) {
                    if (this.allowDuplicate || !this.value.includes(inputEL.value)) {
                        this.value = this.value.concat([inputEL.value]);
                        this.onModelChange(this.value);
                        this.onAdd.emit({
                            originalEvent: event,
                            value: inputEL.value
                        });
                    }
                }
                inputEL.value = '';
                event.preventDefault();
                break;
            default:
                if (this.max && this.value && this.max === this.value.length) {
                    event.preventDefault();
                }
                break;
        }
    };
    Object.defineProperty(Chips.prototype, "maxedOut", {
        get: function () {
            return this.max && this.value && this.max === this.value.length;
        },
        enumerable: true,
        configurable: true
    });
    return Chips;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Chips.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Chips.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Chips.prototype, "disabled", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Chips.prototype, "onAdd", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Chips.prototype, "onRemove", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Chips.prototype, "field", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Chips.prototype, "placeholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Chips.prototype, "max", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Chips.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Chips.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Chips.prototype, "allowDuplicate", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Chips.prototype, "inputStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Chips.prototype, "inputStyleClass", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], Chips.prototype, "templates", void 0);
Chips = __decorate([
    core_1.Component({
        selector: 'p-chips',
        template: "\n        <div [ngClass]=\"'ui-chips ui-widget'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <ul [ngClass]=\"{'ui-inputtext ui-state-default ui-corner-all':true,'ui-state-focus':focus,'ui-state-disabled':disabled}\" (click)=\"inputtext.focus()\">\n                <li #token *ngFor=\"let item of value; let i = index;\" class=\"ui-chips-token ui-state-highlight ui-corner-all\">\n                    <span *ngIf=\"!disabled\" class=\"ui-chips-token-icon fa fa-fw fa-close\" (click)=\"removeItem($event,i)\"></span>\n                    <span *ngIf=\"!itemTemplate\" class=\"ui-chips-token-label\">{{field ? resolveFieldData(item,field) : item}}</span>\n                    <ng-template *ngIf=\"itemTemplate\" [pTemplateWrapper]=\"itemTemplate\" [item]=\"item\"></ng-template>\n                </li>\n                <li class=\"ui-chips-input-token\">\n                    <input #inputtext type=\"text\" [attr.id]=\"inputId\" [attr.placeholder]=\"placeholder\" [attr.tabindex]=\"tabindex\" (keydown)=\"onKeydown($event,inputtext)\" \n                        (focus)=\"onFocus()\" (blur)=\"onBlur()\" [disabled]=\"maxedOut||disabled\" [disabled]=\"disabled\" [ngStyle]=\"inputStyle\" [class]=\"inputStyleClass\">\n                </li>\n            </ul>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler, exports.CHIPS_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Chips);
exports.Chips = Chips;
var ChipsModule = (function () {
    function ChipsModule() {
    }
    return ChipsModule;
}());
ChipsModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, inputtext_1.InputTextModule, shared_1.SharedModule],
        exports: [Chips, inputtext_1.InputTextModule, shared_1.SharedModule],
        declarations: [Chips]
    })
], ChipsModule);
exports.ChipsModule = ChipsModule;
//# sourceMappingURL=chips.js.map

/***/ }),

/***/ "./node_modules/primeng/components/codehighlighter/codehighlighter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var CodeHighlighter = (function () {
    function CodeHighlighter(el) {
        this.el = el;
    }
    CodeHighlighter.prototype.ngOnInit = function () {
        Prism.highlightElement(this.el.nativeElement);
    };
    return CodeHighlighter;
}());
CodeHighlighter = __decorate([
    core_1.Directive({
        selector: '[pCode]'
    }),
    __metadata("design:paramtypes", [core_1.ElementRef])
], CodeHighlighter);
exports.CodeHighlighter = CodeHighlighter;
var CodeHighlighterModule = (function () {
    function CodeHighlighterModule() {
    }
    return CodeHighlighterModule;
}());
CodeHighlighterModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [CodeHighlighter],
        declarations: [CodeHighlighter]
    })
], CodeHighlighterModule);
exports.CodeHighlighterModule = CodeHighlighterModule;
//# sourceMappingURL=codehighlighter.js.map

/***/ }),

/***/ "./node_modules/primeng/components/colorpicker/colorpicker.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var forms_1 = __webpack_require__(4);
exports.COLORPICKER_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return ColorPicker; }),
    multi: true
};
var ColorPicker = (function () {
    function ColorPicker(el, domHandler, renderer, cd) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.cd = cd;
        this.format = 'hex';
        this.onChange = new core_1.EventEmitter();
        this.defaultColor = 'ff0000';
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    ColorPicker.prototype.ngAfterViewChecked = function () {
        if (this.shown) {
            this.onShow();
            this.shown = false;
        }
    };
    ColorPicker.prototype.onHueMousedown = function (event) {
        if (this.disabled) {
            return;
        }
        this.bindDocumentMousemoveListener();
        this.bindDocumentMouseupListener();
        this.hueDragging = true;
        this.pickHue(event);
    };
    ColorPicker.prototype.pickHue = function (event) {
        var top = this.hueViewChild.nativeElement.getBoundingClientRect().top + document.body.scrollTop;
        this.value = this.validateHSB({
            h: Math.floor(360 * (150 - Math.max(0, Math.min(150, (event.pageY - top)))) / 150),
            s: 100,
            b: 100
        });
        this.updateColorSelector();
        this.updateUI();
        this.updateModel();
        this.onChange.emit({ originalEvent: event, value: this.value });
    };
    ColorPicker.prototype.onColorMousedown = function (event) {
        if (this.disabled) {
            return;
        }
        this.bindDocumentMousemoveListener();
        this.bindDocumentMouseupListener();
        this.colorDragging = true;
        this.pickColor(event);
    };
    ColorPicker.prototype.pickColor = function (event) {
        var rect = this.colorSelectorViewChild.nativeElement.getBoundingClientRect();
        var top = rect.top + document.body.scrollTop;
        var left = rect.left + document.body.scrollLeft;
        var saturation = Math.floor(100 * (Math.max(0, Math.min(150, (event.pageX - left)))) / 150);
        var brightness = Math.floor(100 * (150 - Math.max(0, Math.min(150, (event.pageY - top)))) / 150);
        this.value = this.validateHSB({
            h: this.value.h,
            s: saturation,
            b: brightness
        });
        this.updateUI();
        this.updateModel();
        this.onChange.emit({ originalEvent: event, value: this.getValueToUpdate() });
    };
    ColorPicker.prototype.getValueToUpdate = function () {
        var val;
        switch (this.format) {
            case 'hex':
                val = '#' + this.HSBtoHEX(this.value);
                break;
            case 'rgb':
                val = this.HSBtoRGB(this.value);
                break;
            case 'hsb':
                val = this.value;
                break;
        }
        return val;
    };
    ColorPicker.prototype.updateModel = function () {
        this.onModelChange(this.getValueToUpdate());
    };
    ColorPicker.prototype.writeValue = function (value) {
        if (value) {
            switch (this.format) {
                case 'hex':
                    this.value = this.HEXtoHSB(value);
                    break;
                case 'rgb':
                    this.value = this.RGBtoHSB(value);
                    break;
                case 'hsb':
                    this.value = value;
                    break;
            }
        }
        else {
            this.value = this.HEXtoHSB(this.defaultColor);
        }
        this.updateColorSelector();
        this.updateUI();
    };
    ColorPicker.prototype.updateColorSelector = function () {
        this.colorSelectorViewChild.nativeElement.style.backgroundColor = '#' + this.HSBtoHEX(this.value);
    };
    ColorPicker.prototype.updateUI = function () {
        this.colorHandleViewChild.nativeElement.style.left = Math.floor(150 * this.value.s / 100) + 'px';
        this.colorHandleViewChild.nativeElement.style.top = Math.floor(150 * (100 - this.value.b) / 100) + 'px';
        this.hueHandleViewChild.nativeElement.style.top = Math.floor(150 - (150 * this.value.h / 360)) + 'px';
        this.inputBgColor = '#' + this.HSBtoHEX(this.value);
    };
    ColorPicker.prototype.onInputFocus = function () {
        this.onModelTouched();
    };
    ColorPicker.prototype.show = function () {
        this.panelViewChild.nativeElement.style.zIndex = String(++domhandler_1.DomHandler.zindex);
        this.panelVisible = true;
        this.shown = true;
    };
    ColorPicker.prototype.hide = function () {
        this.panelVisible = false;
        this.unbindDocumentClickListener();
    };
    ColorPicker.prototype.onShow = function () {
        this.alignPanel();
        this.bindDocumentClickListener();
    };
    ColorPicker.prototype.alignPanel = function () {
        if (this.appendTo)
            this.domHandler.absolutePosition(this.panelViewChild.nativeElement, this.inputViewChild.nativeElement);
        else
            this.domHandler.relativePosition(this.panelViewChild.nativeElement, this.inputViewChild.nativeElement);
    };
    ColorPicker.prototype.onInputClick = function () {
        this.selfClick = true;
        this.togglePanel();
    };
    ColorPicker.prototype.togglePanel = function () {
        if (!this.panelVisible)
            this.show();
        else
            this.hide();
    };
    ColorPicker.prototype.onInputKeydown = function (event) {
        switch (event.which) {
            //space
            case 32:
                this.togglePanel();
                event.preventDefault();
                break;
            //escape and tab
            case 27:
            case 9:
                this.hide();
                break;
        }
    };
    ColorPicker.prototype.onPanelClick = function () {
        this.selfClick = true;
    };
    ColorPicker.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    ColorPicker.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    ColorPicker.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    ColorPicker.prototype.bindDocumentClickListener = function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'click', function () {
                if (!_this.selfClick) {
                    _this.panelVisible = false;
                    _this.unbindDocumentClickListener();
                }
                _this.selfClick = false;
                _this.cd.markForCheck();
            });
        }
    };
    ColorPicker.prototype.unbindDocumentClickListener = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    ColorPicker.prototype.bindDocumentMousemoveListener = function () {
        var _this = this;
        if (!this.documentMousemoveListener) {
            this.documentMousemoveListener = this.renderer.listen('document', 'mousemove', function (event) {
                if (_this.colorDragging) {
                    _this.pickColor(event);
                }
                if (_this.hueDragging) {
                    _this.pickHue(event);
                }
            });
        }
    };
    ColorPicker.prototype.unbindDocumentMousemoveListener = function () {
        if (this.documentMousemoveListener) {
            this.documentMousemoveListener();
            this.documentMousemoveListener = null;
        }
    };
    ColorPicker.prototype.bindDocumentMouseupListener = function () {
        var _this = this;
        if (!this.documentMouseupListener) {
            this.documentMouseupListener = this.renderer.listen('document', 'mouseup', function () {
                _this.colorDragging = false;
                _this.hueDragging = false;
                _this.unbindDocumentMousemoveListener();
                _this.unbindDocumentMouseupListener();
            });
        }
    };
    ColorPicker.prototype.unbindDocumentMouseupListener = function () {
        if (this.documentMouseupListener) {
            this.documentMouseupListener();
            this.documentMouseupListener = null;
        }
    };
    ColorPicker.prototype.validateHSB = function (hsb) {
        return {
            h: Math.min(360, Math.max(0, hsb.h)),
            s: Math.min(100, Math.max(0, hsb.s)),
            b: Math.min(100, Math.max(0, hsb.b))
        };
    };
    ColorPicker.prototype.validateRGB = function (rgb) {
        return {
            r: Math.min(255, Math.max(0, rgb.r)),
            g: Math.min(255, Math.max(0, rgb.g)),
            b: Math.min(255, Math.max(0, rgb.b))
        };
    };
    ColorPicker.prototype.validateHEX = function (hex) {
        var len = 6 - hex.length;
        if (len > 0) {
            var o = [];
            for (var i = 0; i < len; i++) {
                o.push('0');
            }
            o.push(hex);
            hex = o.join('');
        }
        return hex;
    };
    ColorPicker.prototype.HEXtoRGB = function (hex) {
        var hexValue = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
        return { r: hexValue >> 16, g: (hexValue & 0x00FF00) >> 8, b: (hexValue & 0x0000FF) };
    };
    ColorPicker.prototype.HEXtoHSB = function (hex) {
        return this.RGBtoHSB(this.HEXtoRGB(hex));
    };
    ColorPicker.prototype.RGBtoHSB = function (rgb) {
        var hsb = {
            h: 0,
            s: 0,
            b: 0
        };
        var min = Math.min(rgb.r, rgb.g, rgb.b);
        var max = Math.max(rgb.r, rgb.g, rgb.b);
        var delta = max - min;
        hsb.b = max;
        if (max != 0) {
        }
        hsb.s = max != 0 ? 255 * delta / max : 0;
        if (hsb.s != 0) {
            if (rgb.r == max) {
                hsb.h = (rgb.g - rgb.b) / delta;
            }
            else if (rgb.g == max) {
                hsb.h = 2 + (rgb.b - rgb.r) / delta;
            }
            else {
                hsb.h = 4 + (rgb.r - rgb.g) / delta;
            }
        }
        else {
            hsb.h = -1;
        }
        hsb.h *= 60;
        if (hsb.h < 0) {
            hsb.h += 360;
        }
        hsb.s *= 100 / 255;
        hsb.b *= 100 / 255;
        return hsb;
    };
    ColorPicker.prototype.HSBtoRGB = function (hsb) {
        var rgb = {
            r: null, g: null, b: null
        };
        var h = Math.round(hsb.h);
        var s = Math.round(hsb.s * 255 / 100);
        var v = Math.round(hsb.b * 255 / 100);
        if (s == 0) {
            rgb = {
                r: v,
                g: v,
                b: v
            };
        }
        else {
            var t1 = v;
            var t2 = (255 - s) * v / 255;
            var t3 = (t1 - t2) * (h % 60) / 60;
            if (h == 360)
                h = 0;
            if (h < 60) {
                rgb.r = t1;
                rgb.b = t2;
                rgb.g = t2 + t3;
            }
            else if (h < 120) {
                rgb.g = t1;
                rgb.b = t2;
                rgb.r = t1 - t3;
            }
            else if (h < 180) {
                rgb.g = t1;
                rgb.r = t2;
                rgb.b = t2 + t3;
            }
            else if (h < 240) {
                rgb.b = t1;
                rgb.r = t2;
                rgb.g = t1 - t3;
            }
            else if (h < 300) {
                rgb.b = t1;
                rgb.g = t2;
                rgb.r = t2 + t3;
            }
            else if (h < 360) {
                rgb.r = t1;
                rgb.g = t2;
                rgb.b = t1 - t3;
            }
            else {
                rgb.r = 0;
                rgb.g = 0;
                rgb.b = 0;
            }
        }
        return { r: Math.round(rgb.r), g: Math.round(rgb.g), b: Math.round(rgb.b) };
    };
    ColorPicker.prototype.RGBtoHEX = function (rgb) {
        var hex = [
            rgb.r.toString(16),
            rgb.g.toString(16),
            rgb.b.toString(16)
        ];
        for (var key in hex) {
            if (hex[key].length == 1) {
                hex[key] = '0' + hex[key];
            }
        }
        return hex.join('');
    };
    ColorPicker.prototype.HSBtoHEX = function (hsb) {
        return this.RGBtoHEX(this.HSBtoRGB(hsb));
    };
    ColorPicker.prototype.ngOnDestroy = function () {
        this.unbindDocumentClickListener();
    };
    return ColorPicker;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColorPicker.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ColorPicker.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ColorPicker.prototype, "inline", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ColorPicker.prototype, "format", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ColorPicker.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ColorPicker.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ColorPicker.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ColorPicker.prototype, "inputId", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], ColorPicker.prototype, "onChange", void 0);
__decorate([
    core_1.ViewChild('panel'),
    __metadata("design:type", core_1.ElementRef)
], ColorPicker.prototype, "panelViewChild", void 0);
__decorate([
    core_1.ViewChild('colorSelector'),
    __metadata("design:type", core_1.ElementRef)
], ColorPicker.prototype, "colorSelectorViewChild", void 0);
__decorate([
    core_1.ViewChild('colorHandle'),
    __metadata("design:type", core_1.ElementRef)
], ColorPicker.prototype, "colorHandleViewChild", void 0);
__decorate([
    core_1.ViewChild('hue'),
    __metadata("design:type", core_1.ElementRef)
], ColorPicker.prototype, "hueViewChild", void 0);
__decorate([
    core_1.ViewChild('hueHandle'),
    __metadata("design:type", core_1.ElementRef)
], ColorPicker.prototype, "hueHandleViewChild", void 0);
__decorate([
    core_1.ViewChild('input'),
    __metadata("design:type", core_1.ElementRef)
], ColorPicker.prototype, "inputViewChild", void 0);
ColorPicker = __decorate([
    core_1.Component({
        selector: 'p-colorPicker',
        template: "\n        <div [ngStyle]=\"style\" [class]=\"styleClass\" [ngClass]=\"{'ui-colorpicker ui-widget':true,'ui-colorpicker-overlay':!inline,'ui-colorpicker-dragging':colorDragging||hueDragging}\">\n            <input #input type=\"text\" *ngIf=\"!inline\" class=\"ui-colorpicker-preview ui-inputtext ui-state-default ui-corner-all\" readonly=\"readonly\" [ngClass]=\"{'ui-state-disabled': disabled}\"\n                (focus)=\"onInputFocus()\" (click)=\"onInputClick()\" (keydown)=\"onInputKeydown($event)\" [attr.id]=\"inputId\" [attr.tabindex]=\"tabindex\" [disabled]=\"disabled\"\n                [style.backgroundColor]=\"inputBgColor\">\n            <div #panel [ngClass]=\"{'ui-colorpicker-panel ui-corner-all': true, 'ui-colorpicker-overlay-panel ui-shadow':!inline, 'ui-state-disabled': disabled}\" (click)=\"onPanelClick()\"\n                [@panelState]=\"inline ? 'visible' : (panelVisible ? 'visible' : 'hidden')\" [style.display]=\"inline ? 'block' : (panelVisible ? 'block' : 'none')\">\n                <div class=\"ui-colorpicker-content\">\n                    <div #colorSelector class=\"ui-colorpicker-color-selector\" (mousedown)=\"onColorMousedown($event)\">\n                        <div class=\"ui-colorpicker-color\">\n                            <div #colorHandle class=\"ui-colorpicker-color-handle\"></div>\n                        </div>\n                    </div>\n                    <div #hue class=\"ui-colorpicker-hue\" (mousedown)=\"onHueMousedown($event)\">\n                        <div #hueHandle class=\"ui-colorpicker-hue-handle\"></div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    ",
        animations: [
            animations_1.trigger('panelState', [
                animations_1.state('hidden', animations_1.style({
                    opacity: 0
                })),
                animations_1.state('visible', animations_1.style({
                    opacity: 1
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms ease-in')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms ease-out'))
            ])
        ],
        providers: [domhandler_1.DomHandler, exports.COLORPICKER_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, core_1.ChangeDetectorRef])
], ColorPicker);
exports.ColorPicker = ColorPicker;
var ColorPickerModule = (function () {
    function ColorPickerModule() {
    }
    return ColorPickerModule;
}());
ColorPickerModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [ColorPicker],
        declarations: [ColorPicker]
    })
], ColorPickerModule);
exports.ColorPickerModule = ColorPickerModule;
//# sourceMappingURL=colorpicker.js.map

/***/ }),

/***/ "./node_modules/primeng/components/common/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
exports.DomHandler = domhandler_1.DomHandler;
var treedragdropservice_1 = __webpack_require__("./node_modules/primeng/components/common/treedragdropservice.js");
exports.TreeDragDropService = treedragdropservice_1.TreeDragDropService;
var confirmationservice_1 = __webpack_require__("./node_modules/primeng/components/common/confirmationservice.js");
exports.ConfirmationService = confirmationservice_1.ConfirmationService;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/primeng/components/common/confirmationservice.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(8);
var ConfirmationService = (function () {
    function ConfirmationService() {
        this.requireConfirmationSource = new Subject_1.Subject();
        this.acceptConfirmationSource = new Subject_1.Subject();
        this.requireConfirmation$ = this.requireConfirmationSource.asObservable();
        this.accept = this.acceptConfirmationSource.asObservable();
    }
    ConfirmationService.prototype.confirm = function (confirmation) {
        this.requireConfirmationSource.next(confirmation);
        return this;
    };
    ConfirmationService.prototype.onAccept = function () {
        this.acceptConfirmationSource.next();
    };
    return ConfirmationService;
}());
ConfirmationService = __decorate([
    core_1.Injectable()
], ConfirmationService);
exports.ConfirmationService = ConfirmationService;
//# sourceMappingURL=confirmationservice.js.map

/***/ }),

/***/ "./node_modules/primeng/components/common/shared.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var core_2 = __webpack_require__(0);
var Header = (function () {
    function Header() {
    }
    return Header;
}());
Header = __decorate([
    core_2.Component({
        selector: 'p-header',
        template: '<ng-content></ng-content>'
    })
], Header);
exports.Header = Header;
var Footer = (function () {
    function Footer() {
    }
    return Footer;
}());
Footer = __decorate([
    core_2.Component({
        selector: 'p-footer',
        template: '<ng-content></ng-content>'
    })
], Footer);
exports.Footer = Footer;
var PrimeTemplate = (function () {
    function PrimeTemplate(template) {
        this.template = template;
    }
    PrimeTemplate.prototype.getType = function () {
        return this.name;
    };
    return PrimeTemplate;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PrimeTemplate.prototype, "type", void 0);
__decorate([
    core_1.Input('pTemplate'),
    __metadata("design:type", String)
], PrimeTemplate.prototype, "name", void 0);
PrimeTemplate = __decorate([
    core_1.Directive({
        selector: '[pTemplate]',
        host: {}
    }),
    __metadata("design:paramtypes", [core_1.TemplateRef])
], PrimeTemplate);
exports.PrimeTemplate = PrimeTemplate;
var TemplateWrapper = (function () {
    function TemplateWrapper(viewContainer) {
        this.viewContainer = viewContainer;
    }
    TemplateWrapper.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.templateRef, {
            '\$implicit': this.item,
            'index': this.index
        });
    };
    TemplateWrapper.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return TemplateWrapper;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TemplateWrapper.prototype, "item", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], TemplateWrapper.prototype, "index", void 0);
__decorate([
    core_1.Input('pTemplateWrapper'),
    __metadata("design:type", core_1.TemplateRef)
], TemplateWrapper.prototype, "templateRef", void 0);
TemplateWrapper = __decorate([
    core_1.Directive({
        selector: '[pTemplateWrapper]'
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], TemplateWrapper);
exports.TemplateWrapper = TemplateWrapper;
var Column = (function () {
    function Column() {
        this.filterType = 'text';
        this.sortFunction = new core_1.EventEmitter();
    }
    Column.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'header':
                    _this.headerTemplate = item.template;
                    break;
                case 'body':
                    _this.bodyTemplate = item.template;
                    break;
                case 'footer':
                    _this.footerTemplate = item.template;
                    break;
                case 'filter':
                    _this.filterTemplate = item.template;
                    break;
                case 'editor':
                    _this.editorTemplate = item.template;
                    break;
                default:
                    _this.bodyTemplate = item.template;
                    break;
            }
        });
    };
    return Column;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "field", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "colId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "sortField", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "header", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "footer", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Column.prototype, "sortable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Column.prototype, "editable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Column.prototype, "filter", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "filterMatchMode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "filterType", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Column.prototype, "rowspan", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Column.prototype, "colspan", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Column.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Column.prototype, "hidden", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Column.prototype, "expander", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "selectionMode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Column.prototype, "filterPlaceholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Column.prototype, "filterMaxlength", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Column.prototype, "frozen", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Column.prototype, "sortFunction", void 0);
__decorate([
    core_1.ContentChildren(PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], Column.prototype, "templates", void 0);
__decorate([
    core_1.ContentChild(core_1.TemplateRef),
    __metadata("design:type", core_1.TemplateRef)
], Column.prototype, "template", void 0);
Column = __decorate([
    core_2.Component({
        selector: 'p-column',
        template: ""
    })
], Column);
exports.Column = Column;
var Row = (function () {
    function Row() {
    }
    return Row;
}());
__decorate([
    core_1.ContentChildren(Column),
    __metadata("design:type", core_1.QueryList)
], Row.prototype, "columns", void 0);
Row = __decorate([
    core_2.Component({
        selector: 'p-row',
        template: ""
    })
], Row);
exports.Row = Row;
var HeaderColumnGroup = (function () {
    function HeaderColumnGroup() {
    }
    return HeaderColumnGroup;
}());
__decorate([
    core_1.ContentChildren(Row),
    __metadata("design:type", core_1.QueryList)
], HeaderColumnGroup.prototype, "rows", void 0);
HeaderColumnGroup = __decorate([
    core_2.Component({
        selector: 'p-headerColumnGroup',
        template: ""
    })
], HeaderColumnGroup);
exports.HeaderColumnGroup = HeaderColumnGroup;
var FooterColumnGroup = (function () {
    function FooterColumnGroup() {
    }
    return FooterColumnGroup;
}());
__decorate([
    core_1.ContentChildren(Row),
    __metadata("design:type", core_1.QueryList)
], FooterColumnGroup.prototype, "rows", void 0);
FooterColumnGroup = __decorate([
    core_2.Component({
        selector: 'p-footerColumnGroup',
        template: ""
    })
], FooterColumnGroup);
exports.FooterColumnGroup = FooterColumnGroup;
var ColumnBodyTemplateLoader = (function () {
    function ColumnBodyTemplateLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    ColumnBodyTemplateLoader.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.column.bodyTemplate, {
            '\$implicit': this.column,
            'rowData': this.rowData,
            'rowIndex': this.rowIndex
        });
    };
    ColumnBodyTemplateLoader.prototype.ngOnChanges = function (changes) {
        if (!this.view) {
            return;
        }
        if ('rowIndex' in changes) {
            this.view.context.rowIndex = changes['rowIndex'].currentValue;
        }
    };
    ColumnBodyTemplateLoader.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return ColumnBodyTemplateLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColumnBodyTemplateLoader.prototype, "column", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColumnBodyTemplateLoader.prototype, "rowData", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], ColumnBodyTemplateLoader.prototype, "rowIndex", void 0);
ColumnBodyTemplateLoader = __decorate([
    core_2.Component({
        selector: 'p-columnBodyTemplateLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], ColumnBodyTemplateLoader);
exports.ColumnBodyTemplateLoader = ColumnBodyTemplateLoader;
var ColumnHeaderTemplateLoader = (function () {
    function ColumnHeaderTemplateLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    ColumnHeaderTemplateLoader.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.column.headerTemplate, {
            '\$implicit': this.column
        });
    };
    ColumnHeaderTemplateLoader.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return ColumnHeaderTemplateLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColumnHeaderTemplateLoader.prototype, "column", void 0);
ColumnHeaderTemplateLoader = __decorate([
    core_2.Component({
        selector: 'p-columnHeaderTemplateLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], ColumnHeaderTemplateLoader);
exports.ColumnHeaderTemplateLoader = ColumnHeaderTemplateLoader;
var ColumnFooterTemplateLoader = (function () {
    function ColumnFooterTemplateLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    ColumnFooterTemplateLoader.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.column.footerTemplate, {
            '\$implicit': this.column
        });
    };
    ColumnFooterTemplateLoader.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return ColumnFooterTemplateLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColumnFooterTemplateLoader.prototype, "column", void 0);
ColumnFooterTemplateLoader = __decorate([
    core_2.Component({
        selector: 'p-columnFooterTemplateLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], ColumnFooterTemplateLoader);
exports.ColumnFooterTemplateLoader = ColumnFooterTemplateLoader;
var ColumnFilterTemplateLoader = (function () {
    function ColumnFilterTemplateLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    ColumnFilterTemplateLoader.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.column.filterTemplate, {
            '\$implicit': this.column
        });
    };
    ColumnFilterTemplateLoader.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return ColumnFilterTemplateLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColumnFilterTemplateLoader.prototype, "column", void 0);
ColumnFilterTemplateLoader = __decorate([
    core_2.Component({
        selector: 'p-columnFilterTemplateLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], ColumnFilterTemplateLoader);
exports.ColumnFilterTemplateLoader = ColumnFilterTemplateLoader;
var ColumnEditorTemplateLoader = (function () {
    function ColumnEditorTemplateLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    ColumnEditorTemplateLoader.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.column.editorTemplate, {
            '\$implicit': this.column,
            'rowData': this.rowData,
            'rowIndex': this.rowIndex
        });
    };
    ColumnEditorTemplateLoader.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return ColumnEditorTemplateLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColumnEditorTemplateLoader.prototype, "column", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColumnEditorTemplateLoader.prototype, "rowData", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ColumnEditorTemplateLoader.prototype, "rowIndex", void 0);
ColumnEditorTemplateLoader = __decorate([
    core_2.Component({
        selector: 'p-columnEditorTemplateLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], ColumnEditorTemplateLoader);
exports.ColumnEditorTemplateLoader = ColumnEditorTemplateLoader;
var TemplateLoader = (function () {
    function TemplateLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    TemplateLoader.prototype.ngOnInit = function () {
        if (this.template) {
            this.view = this.viewContainer.createEmbeddedView(this.template, {
                '\$implicit': this.data
            });
        }
    };
    TemplateLoader.prototype.ngOnDestroy = function () {
        if (this.view)
            this.view.destroy();
    };
    return TemplateLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", core_1.TemplateRef)
], TemplateLoader.prototype, "template", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TemplateLoader.prototype, "data", void 0);
TemplateLoader = __decorate([
    core_2.Component({
        selector: 'p-templateLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], TemplateLoader);
exports.TemplateLoader = TemplateLoader;
var SharedModule = (function () {
    function SharedModule() {
    }
    return SharedModule;
}());
SharedModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Header, Footer, Column, TemplateWrapper, ColumnHeaderTemplateLoader, ColumnBodyTemplateLoader, ColumnFooterTemplateLoader, ColumnFilterTemplateLoader, PrimeTemplate, TemplateLoader, Row, HeaderColumnGroup, FooterColumnGroup, ColumnEditorTemplateLoader],
        declarations: [Header, Footer, Column, TemplateWrapper, ColumnHeaderTemplateLoader, ColumnBodyTemplateLoader, ColumnFooterTemplateLoader, ColumnFilterTemplateLoader, PrimeTemplate, TemplateLoader, Row, HeaderColumnGroup, FooterColumnGroup, ColumnEditorTemplateLoader]
    })
], SharedModule);
exports.SharedModule = SharedModule;
//# sourceMappingURL=shared.js.map

/***/ }),

/***/ "./node_modules/primeng/components/common/treedragdropservice.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(8);
var TreeDragDropService = (function () {
    function TreeDragDropService() {
        this.dragStartSource = new Subject_1.Subject();
        this.dragStopSource = new Subject_1.Subject();
        this.dragStart$ = this.dragStartSource.asObservable();
        this.dragStop$ = this.dragStopSource.asObservable();
    }
    TreeDragDropService.prototype.startDrag = function (event) {
        this.dragStartSource.next(event);
    };
    TreeDragDropService.prototype.stopDrag = function (event) {
        this.dragStopSource.next(event);
    };
    return TreeDragDropService;
}());
TreeDragDropService = __decorate([
    core_1.Injectable()
], TreeDragDropService);
exports.TreeDragDropService = TreeDragDropService;
//# sourceMappingURL=treedragdropservice.js.map

/***/ }),

/***/ "./node_modules/primeng/components/confirmdialog/confirmdialog.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var button_1 = __webpack_require__("./node_modules/primeng/components/button/button.js");
var confirmationservice_1 = __webpack_require__("./node_modules/primeng/components/common/confirmationservice.js");
var ConfirmDialog = (function () {
    function ConfirmDialog(el, domHandler, renderer, confirmationService) {
        var _this = this;
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.confirmationService = confirmationService;
        this.acceptIcon = 'fa-check';
        this.acceptLabel = 'Yes';
        this.acceptVisible = true;
        this.rejectIcon = 'fa-close';
        this.rejectLabel = 'No';
        this.rejectVisible = true;
        this.closeOnEscape = true;
        this.closable = true;
        this.responsive = true;
        this.subscription = confirmationService.requireConfirmation$.subscribe(function (confirmation) {
            if (confirmation.key === _this.key) {
                _this.confirmation = confirmation;
                _this.message = _this.confirmation.message || _this.message;
                _this.icon = _this.confirmation.icon || _this.icon;
                _this.header = _this.confirmation.header || _this.header;
                _this.rejectVisible = _this.confirmation.rejectVisible == null ? _this.rejectVisible : _this.confirmation.rejectVisible;
                _this.acceptVisible = _this.confirmation.acceptVisible == null ? _this.acceptVisible : _this.confirmation.acceptVisible;
                if (_this.confirmation.accept) {
                    _this.confirmation.acceptEvent = new core_1.EventEmitter();
                    _this.confirmation.acceptEvent.subscribe(_this.confirmation.accept);
                }
                if (_this.confirmation.reject) {
                    _this.confirmation.rejectEvent = new core_1.EventEmitter();
                    _this.confirmation.rejectEvent.subscribe(_this.confirmation.reject);
                }
                _this.visible = true;
            }
        });
    }
    Object.defineProperty(ConfirmDialog.prototype, "visible", {
        get: function () {
            return this._visible;
        },
        set: function (val) {
            this._visible = val;
            if (this._visible) {
                if (!this.positionInitialized) {
                    this.center();
                    this.positionInitialized = true;
                }
                this.el.nativeElement.children[0].style.zIndex = ++domhandler_1.DomHandler.zindex;
                this.executePostShowActions = true;
            }
            if (this._visible)
                this.enableModality();
            else
                this.disableModality();
        },
        enumerable: true,
        configurable: true
    });
    ConfirmDialog.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.contentContainer = this.domHandler.findSingle(this.el.nativeElement, '.ui-dialog-content');
        if (this.responsive) {
            this.documentResponsiveListener = this.renderer.listen('window', 'resize', function (event) {
                _this.center();
            });
        }
        if (this.closeOnEscape && this.closable) {
            this.documentEscapeListener = this.renderer.listen('document', 'keydown', function (event) {
                if (event.which == 27) {
                    if (_this.el.nativeElement.children[0].style.zIndex == domhandler_1.DomHandler.zindex) {
                        _this.close(event);
                    }
                }
            });
        }
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.el.nativeElement);
            else
                this.domHandler.appendChild(this.el.nativeElement, this.appendTo);
        }
    };
    ConfirmDialog.prototype.ngAfterViewChecked = function () {
        if (this.executePostShowActions) {
            this.domHandler.findSingle(this.el.nativeElement.children[0], 'button').focus();
            this.executePostShowActions = false;
        }
    };
    ConfirmDialog.prototype.center = function () {
        var container = this.el.nativeElement.children[0];
        var elementWidth = this.domHandler.getOuterWidth(container);
        var elementHeight = this.domHandler.getOuterHeight(container);
        if (elementWidth == 0 && elementHeight == 0) {
            container.style.visibility = 'hidden';
            container.style.display = 'block';
            elementWidth = this.domHandler.getOuterWidth(container);
            elementHeight = this.domHandler.getOuterHeight(container);
            container.style.display = 'none';
            container.style.visibility = 'visible';
        }
        var viewport = this.domHandler.getViewport();
        var x = (viewport.width - elementWidth) / 2;
        var y = (viewport.height - elementHeight) / 2;
        container.style.left = x + 'px';
        container.style.top = y + 'px';
    };
    ConfirmDialog.prototype.enableModality = function () {
        if (!this.mask) {
            this.mask = document.createElement('div');
            this.mask.style.zIndex = this.el.nativeElement.children[0].style.zIndex - 1;
            this.domHandler.addMultipleClasses(this.mask, 'ui-widget-overlay ui-dialog-mask');
            document.body.appendChild(this.mask);
            this.domHandler.addClass(document.body, 'ui-overflow-hidden');
        }
    };
    ConfirmDialog.prototype.disableModality = function () {
        if (this.mask) {
            document.body.removeChild(this.mask);
            this.domHandler.removeClass(document.body, 'ui-overflow-hidden');
            this.mask = null;
        }
    };
    ConfirmDialog.prototype.close = function (event) {
        if (this.confirmation.rejectEvent) {
            this.confirmation.rejectEvent.emit();
        }
        this.hide();
        event.preventDefault();
    };
    ConfirmDialog.prototype.hide = function () {
        this.visible = false;
    };
    ConfirmDialog.prototype.moveOnTop = function () {
        this.el.nativeElement.children[0].style.zIndex = ++domhandler_1.DomHandler.zindex;
    };
    ConfirmDialog.prototype.ngOnDestroy = function () {
        this.disableModality();
        if (this.documentResponsiveListener) {
            this.documentResponsiveListener();
        }
        if (this.documentEscapeListener) {
            this.documentEscapeListener();
        }
        if (this.appendTo && this.appendTo === 'body') {
            document.body.removeChild(this.el.nativeElement);
        }
        this.subscription.unsubscribe();
    };
    ConfirmDialog.prototype.accept = function () {
        if (this.confirmation.acceptEvent) {
            this.confirmation.acceptEvent.emit();
        }
        this.hide();
        this.confirmation = null;
    };
    ConfirmDialog.prototype.reject = function () {
        if (this.confirmation.rejectEvent) {
            this.confirmation.rejectEvent.emit();
        }
        this.hide();
        this.confirmation = null;
    };
    return ConfirmDialog;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ConfirmDialog.prototype, "header", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ConfirmDialog.prototype, "icon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ConfirmDialog.prototype, "message", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ConfirmDialog.prototype, "acceptIcon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ConfirmDialog.prototype, "acceptLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ConfirmDialog.prototype, "acceptVisible", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ConfirmDialog.prototype, "rejectIcon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ConfirmDialog.prototype, "rejectLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ConfirmDialog.prototype, "rejectVisible", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ConfirmDialog.prototype, "width", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ConfirmDialog.prototype, "height", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ConfirmDialog.prototype, "closeOnEscape", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ConfirmDialog.prototype, "rtl", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ConfirmDialog.prototype, "closable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ConfirmDialog.prototype, "responsive", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ConfirmDialog.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ConfirmDialog.prototype, "key", void 0);
__decorate([
    core_1.ContentChild(shared_1.Footer),
    __metadata("design:type", Object)
], ConfirmDialog.prototype, "footer", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ConfirmDialog.prototype, "visible", null);
ConfirmDialog = __decorate([
    core_1.Component({
        selector: 'p-confirmDialog',
        template: "\n        <div [ngClass]=\"{'ui-dialog ui-confirmdialog ui-widget ui-widget-content ui-corner-all ui-shadow':true,'ui-dialog-rtl':rtl}\" \n            [style.display]=\"visible ? 'block' : 'none'\" [style.width.px]=\"width\" [style.height.px]=\"height\" (mousedown)=\"moveOnTop()\" [@dialogState]=\"visible ? 'visible' : 'hidden'\">\n            <div class=\"ui-dialog-titlebar ui-widget-header ui-helper-clearfix ui-corner-top\">\n                <span class=\"ui-dialog-title\" *ngIf=\"header\">{{header}}</span>\n                <a *ngIf=\"closable\" [ngClass]=\"{'ui-dialog-titlebar-icon ui-dialog-titlebar-close ui-corner-all':true}\" href=\"#\" role=\"button\" (click)=\"close($event)\">\n                    <span class=\"fa fa-fw fa-close\"></span>\n                </a>\n            </div>\n            <div class=\"ui-dialog-content ui-widget-content\">\n                <i [ngClass]=\"'fa'\" [class]=\"icon\"></i>\n                <span class=\"ui-confirmdialog-message\" [innerHTML]=\"message\"></span>\n            </div>\n            <div class=\"ui-dialog-footer ui-widget-content\" *ngIf=\"footer\">\n                <ng-content select=\"p-footer\"></ng-content>\n            </div>\n            <div class=\"ui-dialog-footer ui-widget-content\" *ngIf=\"!footer\">\n                <button type=\"button\" pButton [icon]=\"acceptIcon\" [label]=\"acceptLabel\" (click)=\"accept()\" *ngIf=\"acceptVisible\"></button>\n                <button type=\"button\" pButton [icon]=\"rejectIcon\" [label]=\"rejectLabel\" (click)=\"reject()\" *ngIf=\"rejectVisible\"></button>\n            </div>\n        </div>\n    ",
        animations: [
            animations_1.trigger('dialogState', [
                animations_1.state('hidden', animations_1.style({
                    opacity: 0
                })),
                animations_1.state('visible', animations_1.style({
                    opacity: 1
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms ease-in')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms ease-out'))
            ])
        ],
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler,
        core_1.Renderer2, confirmationservice_1.ConfirmationService])
], ConfirmDialog);
exports.ConfirmDialog = ConfirmDialog;
var ConfirmDialogModule = (function () {
    function ConfirmDialogModule() {
    }
    return ConfirmDialogModule;
}());
ConfirmDialogModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, button_1.ButtonModule],
        exports: [ConfirmDialog, button_1.ButtonModule, shared_1.SharedModule],
        declarations: [ConfirmDialog]
    })
], ConfirmDialogModule);
exports.ConfirmDialogModule = ConfirmDialogModule;
//# sourceMappingURL=confirmdialog.js.map

/***/ }),

/***/ "./node_modules/primeng/components/contextmenu/contextmenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var router_1 = __webpack_require__(5);
var ContextMenuSub = (function () {
    function ContextMenuSub(domHandler, contextMenu) {
        this.domHandler = domHandler;
        this.contextMenu = contextMenu;
    }
    ContextMenuSub.prototype.onItemMouseEnter = function (event, item, menuitem) {
        if (menuitem.disabled) {
            return;
        }
        this.activeItem = item;
        var nextElement = item.children[0].nextElementSibling;
        if (nextElement) {
            var sublist = nextElement.children[0];
            sublist.style.zIndex = ++domhandler_1.DomHandler.zindex;
            this.position(sublist, item);
        }
    };
    ContextMenuSub.prototype.onItemMouseLeave = function (event, link) {
        this.activeItem = null;
    };
    ContextMenuSub.prototype.itemClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
    };
    ContextMenuSub.prototype.listClick = function (event) {
        this.activeItem = null;
    };
    ContextMenuSub.prototype.position = function (sublist, item) {
        this.containerLeft = this.domHandler.getOffset(item.parentElement);
        var viewport = this.domHandler.getViewport();
        var sublistWidth = sublist.offsetParent ? sublist.offsetWidth : this.domHandler.getHiddenElementOuterWidth(sublist);
        var itemOuterWidth = this.domHandler.getOuterWidth(item.children[0]);
        sublist.style.top = '0px';
        if ((parseInt(this.containerLeft.left) + itemOuterWidth + sublistWidth) > (viewport.width - this.calculateScrollbarWidth())) {
            sublist.style.left = -sublistWidth + 'px';
        }
        else {
            sublist.style.left = itemOuterWidth + 'px';
        }
    };
    ContextMenuSub.prototype.calculateScrollbarWidth = function () {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "ui-scrollbar-measure";
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
    };
    return ContextMenuSub;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ContextMenuSub.prototype, "item", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ContextMenuSub.prototype, "root", void 0);
ContextMenuSub = __decorate([
    core_1.Component({
        selector: 'p-contextMenuSub',
        template: "\n        <ul [ngClass]=\"{'ui-helper-reset':root, 'ui-widget-content ui-corner-all ui-helper-clearfix ui-menu-child ui-shadow':!root}\" class=\"ui-menu-list\"\n            (click)=\"listClick($event)\">\n            <ng-template ngFor let-child [ngForOf]=\"(root ? item : item.items)\">\n                <li *ngIf=\"child.separator\" class=\"ui-menu-separator ui-widget-content\">\n                <li *ngIf=\"!child.separator\" #item [ngClass]=\"{'ui-menuitem ui-widget ui-corner-all':true,'ui-menu-parent':child.items,'ui-menuitem-active':item==activeItem}\"\n                    (mouseenter)=\"onItemMouseEnter($event,item,child)\" (mouseleave)=\"onItemMouseLeave($event,item)\" [style.display]=\"child.visible === false ? 'none' : 'block'\">\n                    <a *ngIf=\"!child.routerLink\" [href]=\"child.url||'#'\" [attr.target]=\"child.target\" (click)=\"itemClick($event, child)\"\n                        [ngClass]=\"{'ui-menuitem-link ui-corner-all':true,'ui-state-disabled':child.disabled}\" [ngStyle]=\"child.style\" [class]=\"child.styleClass\">\n                        <span class=\"ui-submenu-icon fa fa-fw fa-caret-right\" *ngIf=\"child.items\"></span>\n                        <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"child.icon\" [ngClass]=\"child.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{child.label}}</span>\n                    </a>\n                    <a *ngIf=\"child.routerLink\" [routerLink]=\"child.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"child.routerLinkActiveOptions||{exact:false}\" [attr.target]=\"child.target\"\n                        (click)=\"itemClick($event, child)\" [ngClass]=\"{'ui-menuitem-link ui-corner-all':true,'ui-state-disabled':child.disabled}\" [ngStyle]=\"child.style\" [class]=\"child.styleClass\">\n                        <span class=\"ui-submenu-icon fa fa-fw fa-caret-right\" *ngIf=\"child.items\"></span>\n                        <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"child.icon\" [ngClass]=\"child.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{child.label}}</span>\n                    </a>\n                    <p-contextMenuSub class=\"ui-submenu\" [item]=\"child\" *ngIf=\"child.items\"></p-contextMenuSub>\n                </li>\n            </ng-template>\n        </ul>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __param(1, core_1.Inject(core_1.forwardRef(function () { return ContextMenu; }))),
    __metadata("design:paramtypes", [domhandler_1.DomHandler, ContextMenu])
], ContextMenuSub);
exports.ContextMenuSub = ContextMenuSub;
var ContextMenu = (function () {
    function ContextMenu(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
    }
    ContextMenu.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.container = this.containerViewChild.nativeElement;
        this.documentClickListener = this.renderer.listen('document', 'click', function () {
            _this.hide();
        });
        if (this.global) {
            this.rightClickListener = this.renderer.listen('document', 'contextmenu', function (event) {
                _this.show(event);
                event.preventDefault();
            });
        }
        else if (this.target) {
            this.rightClickListener = this.renderer.listen(this.target, 'contextmenu', function (event) {
                _this.show(event);
                event.preventDefault();
                event.stopPropagation();
            });
        }
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.container);
            else
                this.domHandler.appendChild(this.container, this.appendTo);
        }
    };
    ContextMenu.prototype.show = function (event) {
        this.position(event);
        this.visible = true;
        this.domHandler.fadeIn(this.container, 250);
        if (event) {
            event.preventDefault();
        }
    };
    ContextMenu.prototype.hide = function () {
        this.visible = false;
    };
    ContextMenu.prototype.toggle = function (event) {
        if (this.visible)
            this.hide();
        else
            this.show(event);
    };
    ContextMenu.prototype.position = function (event) {
        if (event) {
            var left = event.pageX + 1;
            var top_1 = event.pageY + 1;
            var width = this.container.offsetParent ? this.container.offsetWidth : this.domHandler.getHiddenElementOuterWidth(this.container);
            var height = this.container.offsetParent ? this.container.offsetHeight : this.domHandler.getHiddenElementOuterHeight(this.container);
            var viewport = this.domHandler.getViewport();
            //flip
            if (left + width - document.body.scrollLeft > viewport.width) {
                left -= width;
            }
            //flip
            if (top_1 + height - document.body.scrollTop > viewport.height) {
                top_1 -= height;
            }
            //fit
            if (left < document.body.scrollLeft) {
                left = document.body.scrollLeft;
            }
            //fit
            if (top_1 < document.body.scrollTop) {
                top_1 = document.body.scrollTop;
            }
            this.container.style.left = left + 'px';
            this.container.style.top = top_1 + 'px';
        }
    };
    ContextMenu.prototype.ngOnDestroy = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
        if (this.rightClickListener) {
            this.rightClickListener();
        }
        if (this.appendTo) {
            this.el.nativeElement.appendChild(this.container);
        }
    };
    return ContextMenu;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], ContextMenu.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ContextMenu.prototype, "global", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ContextMenu.prototype, "target", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ContextMenu.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ContextMenu.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ContextMenu.prototype, "appendTo", void 0);
__decorate([
    core_1.ViewChild('container'),
    __metadata("design:type", core_1.ElementRef)
], ContextMenu.prototype, "containerViewChild", void 0);
ContextMenu = __decorate([
    core_1.Component({
        selector: 'p-contextMenu',
        template: "\n        <div #container [ngClass]=\"'ui-contextmenu ui-menu ui-widget ui-widget-content ui-corner-all ui-helper-clearfix ui-menu-dynamic ui-shadow'\" \n            [class]=\"styleClass\" [ngStyle]=\"style\" [style.display]=\"visible ? 'block' : 'none'\">\n            <p-contextMenuSub [item]=\"model\" root=\"root\"></p-contextMenuSub>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], ContextMenu);
exports.ContextMenu = ContextMenu;
var ContextMenuModule = (function () {
    function ContextMenuModule() {
    }
    return ContextMenuModule;
}());
ContextMenuModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [ContextMenu, router_1.RouterModule],
        declarations: [ContextMenu, ContextMenuSub]
    })
], ContextMenuModule);
exports.ContextMenuModule = ContextMenuModule;
//# sourceMappingURL=contextmenu.js.map

/***/ }),

/***/ "./node_modules/primeng/components/datagrid/datagrid.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var paginator_1 = __webpack_require__("./node_modules/primeng/components/paginator/paginator.js");
var DataGrid = (function () {
    function DataGrid(el, differs) {
        this.el = el;
        this.differs = differs;
        this.pageLinks = 5;
        this.emptyMessage = 'No records found';
        this.onLazyLoad = new core_1.EventEmitter();
        this.paginatorPosition = 'bottom';
        this.alwaysShowPaginator = true;
        this.trackBy = function (index, item) { return item; };
        this.immutable = true;
        this.onPage = new core_1.EventEmitter();
        this.first = 0;
        this.page = 0;
        this.differ = differs.find([]).create(null);
    }
    DataGrid.prototype.ngAfterViewInit = function () {
        if (this.lazy) {
            this.onLazyLoad.emit({
                first: this.first,
                rows: this.rows
            });
        }
    };
    DataGrid.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    Object.defineProperty(DataGrid.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (val) {
            this._value = val;
            if (this.immutable) {
                this.handleDataChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    DataGrid.prototype.handleDataChange = function () {
        if (this.paginator) {
            this.updatePaginator();
        }
        this.updateDataToRender(this.value);
    };
    DataGrid.prototype.ngDoCheck = function () {
        if (!this.immutable) {
            var changes = this.differ.diff(this.value);
            if (changes) {
                this.handleDataChange();
            }
        }
    };
    DataGrid.prototype.updatePaginator = function () {
        //total records
        this.totalRecords = this.lazy ? this.totalRecords : (this.value ? this.value.length : 0);
        //first
        if (this.totalRecords && this.first >= this.totalRecords) {
            var numberOfPages = Math.ceil(this.totalRecords / this.rows);
            this.first = Math.max((numberOfPages - 1) * this.rows, 0);
        }
    };
    DataGrid.prototype.paginate = function (event) {
        this.first = event.first;
        this.rows = event.rows;
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata());
        }
        else {
            this.updateDataToRender(this.value);
        }
        this.onPage.emit({
            first: this.first,
            rows: this.rows
        });
    };
    DataGrid.prototype.updateDataToRender = function (datasource) {
        if (this.paginator && datasource) {
            this.dataToRender = [];
            var startIndex = this.lazy ? 0 : this.first;
            for (var i = startIndex; i < (startIndex + this.rows); i++) {
                if (i >= datasource.length) {
                    break;
                }
                this.dataToRender.push(datasource[i]);
            }
        }
        else {
            this.dataToRender = datasource;
        }
    };
    DataGrid.prototype.isEmpty = function () {
        return !this.dataToRender || (this.dataToRender.length == 0);
    };
    DataGrid.prototype.createLazyLoadMetadata = function () {
        return {
            first: this.first,
            rows: this.rows
        };
    };
    DataGrid.prototype.getBlockableElement = function () {
        return this.el.nativeElement.children[0];
    };
    return DataGrid;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataGrid.prototype, "paginator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataGrid.prototype, "rows", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataGrid.prototype, "totalRecords", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataGrid.prototype, "pageLinks", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], DataGrid.prototype, "rowsPerPageOptions", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataGrid.prototype, "lazy", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataGrid.prototype, "emptyMessage", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataGrid.prototype, "onLazyLoad", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataGrid.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataGrid.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataGrid.prototype, "paginatorPosition", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataGrid.prototype, "alwaysShowPaginator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Function)
], DataGrid.prototype, "trackBy", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataGrid.prototype, "immutable", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataGrid.prototype, "onPage", void 0);
__decorate([
    core_1.ContentChild(shared_1.Header),
    __metadata("design:type", Object)
], DataGrid.prototype, "header", void 0);
__decorate([
    core_1.ContentChild(shared_1.Footer),
    __metadata("design:type", Object)
], DataGrid.prototype, "footer", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], DataGrid.prototype, "templates", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DataGrid.prototype, "value", null);
DataGrid = __decorate([
    core_1.Component({
        selector: 'p-dataGrid',
        template: "\n        <div [ngClass]=\"'ui-datagrid ui-widget'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-datagrid-header ui-widget-header ui-corner-top\" *ngIf=\"header\">\n                <ng-content select=\"p-header\"></ng-content>\n            </div>\n            <p-paginator [rows]=\"rows\" [first]=\"first\" [totalRecords]=\"totalRecords\" [pageLinkSize]=\"pageLinks\" [alwaysShow]=\"alwaysShowPaginator\"\n                (onPageChange)=\"paginate($event)\" styleClass=\"ui-paginator-bottom\" [rowsPerPageOptions]=\"rowsPerPageOptions\" *ngIf=\"paginator && paginatorPosition!='bottom' || paginatorPosition =='both'\"></p-paginator>\n            <div class=\"ui-datagrid-content ui-widget-content\">\n                <div class=\"ui-g\">\n                    <ng-template ngFor [ngForOf]=\"dataToRender\" [ngForTemplate]=\"itemTemplate\" [ngForTrackBy]=\"trackBy\"></ng-template>\n                    <div *ngIf=\"isEmpty()\" class=\"ui-widget-content ui-g-12\">{{emptyMessage}}</div>\n                </div>\n            </div>\n            <p-paginator [rows]=\"rows\" [first]=\"first\" [totalRecords]=\"totalRecords\" [pageLinkSize]=\"pageLinks\" [alwaysShow]=\"alwaysShowPaginator\"\n                (onPageChange)=\"paginate($event)\" styleClass=\"ui-paginator-bottom\" [rowsPerPageOptions]=\"rowsPerPageOptions\" *ngIf=\"paginator && paginatorPosition!='top' || paginatorPosition =='both'\"></p-paginator>\n            <div class=\"ui-datagrid-footer ui-widget-header ui-corner-top\" *ngIf=\"footer\">\n                <ng-content select=\"p-footer\"></ng-content>\n            </div>\n        </div>\n    "
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, core_1.IterableDiffers])
], DataGrid);
exports.DataGrid = DataGrid;
var DataGridModule = (function () {
    function DataGridModule() {
    }
    return DataGridModule;
}());
DataGridModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_1.SharedModule, paginator_1.PaginatorModule],
        exports: [DataGrid, shared_1.SharedModule],
        declarations: [DataGrid]
    })
], DataGridModule);
exports.DataGridModule = DataGridModule;
//# sourceMappingURL=datagrid.js.map

/***/ }),

/***/ "./node_modules/primeng/components/datalist/datalist.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var paginator_1 = __webpack_require__("./node_modules/primeng/components/paginator/paginator.js");
var DataList = (function () {
    function DataList(el, differs) {
        this.el = el;
        this.differs = differs;
        this.pageLinks = 5;
        this.onLazyLoad = new core_1.EventEmitter();
        this.paginatorPosition = 'bottom';
        this.emptyMessage = 'No records found';
        this.alwaysShowPaginator = true;
        this.trackBy = function (index, item) { return item; };
        this.immutable = true;
        this.onPage = new core_1.EventEmitter();
        this.first = 0;
        this.page = 0;
        this.differ = differs.find([]).create(null);
    }
    DataList.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    DataList.prototype.ngAfterViewInit = function () {
        if (this.lazy) {
            this.onLazyLoad.emit({
                first: this.first,
                rows: this.rows
            });
        }
    };
    Object.defineProperty(DataList.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (val) {
            this._value = val;
            if (this.immutable) {
                this.handleDataChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    DataList.prototype.handleDataChange = function () {
        if (this.paginator) {
            this.updatePaginator();
        }
        this.updateDataToRender(this.value);
    };
    DataList.prototype.ngDoCheck = function () {
        if (!this.immutable) {
            var changes = this.differ.diff(this.value);
            if (changes) {
                this.handleDataChange();
            }
        }
    };
    DataList.prototype.updatePaginator = function () {
        //total records
        this.totalRecords = this.lazy ? this.totalRecords : (this.value ? this.value.length : 0);
        //first
        if (this.totalRecords && this.first >= this.totalRecords) {
            var numberOfPages = Math.ceil(this.totalRecords / this.rows);
            this.first = Math.max((numberOfPages - 1) * this.rows, 0);
        }
    };
    DataList.prototype.paginate = function (event) {
        this.first = event.first;
        this.rows = event.rows;
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata());
        }
        else {
            this.updateDataToRender(this.value);
        }
        this.onPage.emit({
            first: this.first,
            rows: this.rows
        });
    };
    DataList.prototype.updateDataToRender = function (datasource) {
        if (this.paginator && datasource) {
            this.dataToRender = [];
            var startIndex = this.lazy ? 0 : this.first;
            for (var i = startIndex; i < (startIndex + this.rows); i++) {
                if (i >= datasource.length) {
                    break;
                }
                this.dataToRender.push(datasource[i]);
            }
        }
        else {
            this.dataToRender = datasource;
        }
    };
    DataList.prototype.isEmpty = function () {
        return !this.dataToRender || (this.dataToRender.length == 0);
    };
    DataList.prototype.createLazyLoadMetadata = function () {
        return {
            first: this.first,
            rows: this.rows
        };
    };
    DataList.prototype.getBlockableElement = function () {
        return this.el.nativeElement.children[0];
    };
    return DataList;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataList.prototype, "paginator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataList.prototype, "rows", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataList.prototype, "totalRecords", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataList.prototype, "pageLinks", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], DataList.prototype, "rowsPerPageOptions", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataList.prototype, "lazy", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataList.prototype, "onLazyLoad", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataList.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataList.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataList.prototype, "paginatorPosition", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataList.prototype, "emptyMessage", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataList.prototype, "alwaysShowPaginator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Function)
], DataList.prototype, "trackBy", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataList.prototype, "immutable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataList.prototype, "scrollable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataList.prototype, "scrollHeight", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataList.prototype, "onPage", void 0);
__decorate([
    core_1.ContentChild(shared_1.Header),
    __metadata("design:type", Object)
], DataList.prototype, "header", void 0);
__decorate([
    core_1.ContentChild(shared_1.Footer),
    __metadata("design:type", Object)
], DataList.prototype, "footer", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], DataList.prototype, "templates", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DataList.prototype, "value", null);
DataList = __decorate([
    core_1.Component({
        selector: 'p-dataList',
        template: "\n        <div [ngClass]=\"{'ui-datalist ui-widget': true, 'ui-datalist-scrollable': scrollable}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-datalist-header ui-widget-header ui-corner-top\" *ngIf=\"header\">\n                <ng-content select=\"p-header\"></ng-content>\n            </div>\n            <p-paginator [rows]=\"rows\" [first]=\"first\" [totalRecords]=\"totalRecords\" [pageLinkSize]=\"pageLinks\" [alwaysShow]=\"alwaysShowPaginator\"\n            (onPageChange)=\"paginate($event)\" styleClass=\"ui-paginator-bottom\" [rowsPerPageOptions]=\"rowsPerPageOptions\" *ngIf=\"paginator  && paginatorPosition!='bottom' || paginatorPosition =='both'\"></p-paginator>\n            <div class=\"ui-datalist-content ui-widget-content\" [ngStyle]=\"{'max-height': scrollHeight}\">\n                <div *ngIf=\"isEmpty()\" class=\"ui-datalist-emptymessage\">{{emptyMessage}}</div>\n                <ul class=\"ui-datalist-data\">\n                    <li *ngFor=\"let item of dataToRender;let i = index;trackBy: trackBy\">\n                        <ng-template [pTemplateWrapper]=\"itemTemplate\" [item]=\"item\" [index]=\"i\"></ng-template>\n                    </li>\n                </ul>\n            </div>\n            <p-paginator [rows]=\"rows\" [first]=\"first\" [totalRecords]=\"totalRecords\" [pageLinkSize]=\"pageLinks\" [alwaysShow]=\"alwaysShowPaginator\"\n            (onPageChange)=\"paginate($event)\" styleClass=\"ui-paginator-bottom\" [rowsPerPageOptions]=\"rowsPerPageOptions\" *ngIf=\"paginator  && paginatorPosition!='top' || paginatorPosition =='both'\"></p-paginator>\n            <div class=\"ui-datalist-footer ui-widget-header ui-corner-bottom\" *ngIf=\"footer\">\n                <ng-content select=\"p-footer\"></ng-content>\n            </div>\n        </div>\n    "
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, core_1.IterableDiffers])
], DataList);
exports.DataList = DataList;
var DataListModule = (function () {
    function DataListModule() {
    }
    return DataListModule;
}());
DataListModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_1.SharedModule, paginator_1.PaginatorModule],
        exports: [DataList, shared_1.SharedModule],
        declarations: [DataList]
    })
], DataListModule);
exports.DataListModule = DataListModule;
//# sourceMappingURL=datalist.js.map

/***/ }),

/***/ "./node_modules/primeng/components/datascroller/datascroller.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var DataScroller = (function () {
    function DataScroller(el, renderer, domHandler) {
        this.el = el;
        this.renderer = renderer;
        this.domHandler = domHandler;
        this.onLazyLoad = new core_1.EventEmitter();
        this.buffer = 0.9;
        this.dataToRender = [];
        this.first = 0;
    }
    DataScroller.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.lazy) {
            this.load();
        }
        if (this.loader) {
            this.scrollFunction = this.renderer.listen(this.loader, 'click', function () {
                _this.load();
            });
        }
        else {
            this.bindScrollListener();
        }
    };
    DataScroller.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    Object.defineProperty(DataScroller.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (val) {
            this._value = val;
            this.handleDataChange();
        },
        enumerable: true,
        configurable: true
    });
    DataScroller.prototype.handleDataChange = function () {
        if (this.lazy)
            this.dataToRender = this.value;
        else
            this.load();
    };
    DataScroller.prototype.load = function () {
        if (this.lazy) {
            this.onLazyLoad.emit({
                first: this.first,
                rows: this.rows
            });
            this.first = this.first + this.rows;
        }
        else {
            if (this.value) {
                for (var i = this.first; i < (this.first + this.rows); i++) {
                    if (i >= this.value.length) {
                        break;
                    }
                    this.dataToRender.push(this.value[i]);
                }
                this.first = this.first + this.rows;
            }
        }
    };
    DataScroller.prototype.reset = function () {
        this.first = 0;
        this.dataToRender = [];
        this.load();
    };
    DataScroller.prototype.isEmpty = function () {
        return !this.dataToRender || (this.dataToRender.length == 0);
    };
    DataScroller.prototype.createLazyLoadMetadata = function () {
        return {
            first: this.first,
            rows: this.rows
        };
    };
    DataScroller.prototype.bindScrollListener = function () {
        var _this = this;
        if (this.inline) {
            this.contentElement = this.contentViewChild.nativeElement;
            this.scrollFunction = this.renderer.listen(this.contentElement, 'scroll', function () {
                var scrollTop = _this.contentElement.scrollTop;
                var scrollHeight = _this.contentElement.scrollHeight;
                var viewportHeight = _this.contentElement.clientHeight;
                if ((scrollTop >= ((scrollHeight * _this.buffer) - (viewportHeight)))) {
                    _this.load();
                }
            });
        }
        else {
            this.scrollFunction = this.renderer.listen('window', 'scroll', function () {
                var docBody = document.body;
                var docElement = document.documentElement;
                var scrollTop = (window.pageYOffset || document.documentElement.scrollTop);
                var winHeight = docElement.clientHeight;
                var docHeight = Math.max(docBody.scrollHeight, docBody.offsetHeight, winHeight, docElement.scrollHeight, docElement.offsetHeight);
                if (scrollTop >= ((docHeight * _this.buffer) - winHeight)) {
                    _this.load();
                }
            });
        }
    };
    DataScroller.prototype.ngOnDestroy = function () {
        //unbind
        if (this.scrollFunction) {
            this.scrollFunction();
            this.contentElement = null;
        }
    };
    return DataScroller;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataScroller.prototype, "rows", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataScroller.prototype, "lazy", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataScroller.prototype, "onLazyLoad", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataScroller.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataScroller.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataScroller.prototype, "buffer", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataScroller.prototype, "inline", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataScroller.prototype, "scrollHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataScroller.prototype, "loader", void 0);
__decorate([
    core_1.ViewChild('content'),
    __metadata("design:type", core_1.ElementRef)
], DataScroller.prototype, "contentViewChild", void 0);
__decorate([
    core_1.ContentChild(shared_1.Header),
    __metadata("design:type", Object)
], DataScroller.prototype, "header", void 0);
__decorate([
    core_1.ContentChild(shared_1.Footer),
    __metadata("design:type", Object)
], DataScroller.prototype, "footer", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], DataScroller.prototype, "templates", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DataScroller.prototype, "value", null);
DataScroller = __decorate([
    core_1.Component({
        selector: 'p-dataScroller',
        template: "\n    <div [ngClass]=\"{'ui-datascroller ui-widget': true, 'ui-datascroller-inline': inline}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n        <div class=\"ui-datascroller-header ui-widget-header ui-corner-top\" *ngIf=\"header\">\n            <ng-content select=\"p-header\"></ng-content>\n        </div>\n        <div #content class=\"ui-datascroller-content ui-widget-content\" [ngStyle]=\"{'max-height': scrollHeight}\">\n            <ul class=\"ui-datascroller-list\">\n                <li *ngFor=\"let item of dataToRender\">\n                    <ng-template [pTemplateWrapper]=\"itemTemplate\" [item]=\"item\"></ng-template>\n                </li>\n            </ul>\n        </div>\n        <div class=\"ui-datascroller-footer ui-widget-header ui-corner-bottom\" *ngIf=\"footer\">\n            <ng-content select=\"p-footer\"></ng-content>\n        </div>\n    </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, core_1.Renderer2, domhandler_1.DomHandler])
], DataScroller);
exports.DataScroller = DataScroller;
var DataScrollerModule = (function () {
    function DataScrollerModule() {
    }
    return DataScrollerModule;
}());
DataScrollerModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_1.SharedModule],
        exports: [DataScroller, shared_1.SharedModule],
        declarations: [DataScroller]
    })
], DataScrollerModule);
exports.DataScrollerModule = DataScrollerModule;
//# sourceMappingURL=datascroller.js.map

/***/ }),

/***/ "./node_modules/primeng/components/datatable/datatable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var forms_1 = __webpack_require__(4);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var paginator_1 = __webpack_require__("./node_modules/primeng/components/paginator/paginator.js");
var shared_2 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var objectutils_1 = __webpack_require__("./node_modules/primeng/components/utils/objectutils.js");
var DTRadioButton = (function () {
    function DTRadioButton() {
        this.onClick = new core_1.EventEmitter();
    }
    DTRadioButton.prototype.handleClick = function (event) {
        this.onClick.emit(event);
    };
    return DTRadioButton;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DTRadioButton.prototype, "checked", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DTRadioButton.prototype, "onClick", void 0);
DTRadioButton = __decorate([
    core_1.Component({
        selector: 'p-dtRadioButton',
        template: "\n        <div class=\"ui-radiobutton ui-widget\">\n            <div class=\"ui-helper-hidden-accessible\">\n                <input type=\"radio\" [checked]=\"checked\">\n            </div>\n            <div class=\"ui-radiobutton-box ui-widget ui-radiobutton-relative ui-state-default\" (click)=\"handleClick($event)\"\n                        (mouseenter)=\"hover=true\" (mouseleave)=\"hover=false\"\n                        [ngClass]=\"{'ui-state-hover':hover,'ui-state-active':checked}\">\n                <span class=\"ui-radiobutton-icon ui-clickable\" [ngClass]=\"{'fa fa-circle':checked}\"></span>\n            </div>\n        </div>\n    "
    })
], DTRadioButton);
exports.DTRadioButton = DTRadioButton;
var DTCheckbox = (function () {
    function DTCheckbox() {
        this.onChange = new core_1.EventEmitter();
    }
    DTCheckbox.prototype.handleClick = function (event) {
        if (!this.disabled) {
            this.onChange.emit({ originalEvent: event, checked: !this.checked });
        }
    };
    return DTCheckbox;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DTCheckbox.prototype, "checked", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DTCheckbox.prototype, "disabled", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DTCheckbox.prototype, "onChange", void 0);
DTCheckbox = __decorate([
    core_1.Component({
        selector: 'p-dtCheckbox',
        template: "\n        <div class=\"ui-chkbox ui-widget\">\n            <div class=\"ui-helper-hidden-accessible\">\n                <input type=\"checkbox\" [checked]=\"checked\">\n            </div>\n            <div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\" (click)=\"handleClick($event)\"\n                        (mouseover)=\"hover=true\" (mouseout)=\"hover=false\" \n                        [ngClass]=\"{'ui-state-hover':hover&&!disabled,'ui-state-active':checked&&!disabled,'ui-state-disabled':disabled}\">\n                <span class=\"ui-chkbox-icon ui-clickable\" [ngClass]=\"{'fa fa-check':checked}\"></span>\n            </div>\n        </div>\n    "
    })
], DTCheckbox);
exports.DTCheckbox = DTCheckbox;
var RowExpansionLoader = (function () {
    function RowExpansionLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    RowExpansionLoader.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.template, {
            '\$implicit': this.rowData,
            'rowIndex': this.rowIndex
        });
    };
    RowExpansionLoader.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return RowExpansionLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", core_1.TemplateRef)
], RowExpansionLoader.prototype, "template", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], RowExpansionLoader.prototype, "rowData", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], RowExpansionLoader.prototype, "rowIndex", void 0);
RowExpansionLoader = __decorate([
    core_1.Component({
        selector: 'p-rowExpansionLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], RowExpansionLoader);
exports.RowExpansionLoader = RowExpansionLoader;
var ColumnHeaders = (function () {
    function ColumnHeaders(dt) {
        this.dt = dt;
    }
    return ColumnHeaders;
}());
__decorate([
    core_1.Input("pColumnHeaders"),
    __metadata("design:type", Array)
], ColumnHeaders.prototype, "columns", void 0);
ColumnHeaders = __decorate([
    core_1.Component({
        selector: '[pColumnHeaders]',
        template: "\n        <ng-template ngFor let-col [ngForOf]=\"columns\" let-lastCol=\"last\">\n            <th #headerCell [attr.id]=\"col.colId\" [ngStyle]=\"col.style\" [class]=\"col.styleClass\" [style.display]=\"col.hidden ? 'none' : 'table-cell'\" (click)=\"dt.sort($event,col)\" [attr.colspan]=\"col.colspan\" [attr.rowspan]=\"col.rowspan\"\n                [ngClass]=\"{'ui-state-default ui-unselectable-text':true, 'ui-sortable-column': col.sortable, 'ui-state-active': dt.isSorted(col), 'ui-resizable-column': dt.resizableColumns, 'ui-selection-column':col.selectionMode}\" \n                (dragstart)=\"dt.onColumnDragStart($event)\" (dragleave)=\"dt.onColumnDragleave($event)\" (drop)=\"dt.onColumnDrop($event)\" (mousedown)=\"dt.onHeaderMousedown($event,headerCell)\"\n                [attr.tabindex]=\"col.sortable ? tabindex : null\" (keydown)=\"dt.onHeaderKeydown($event,col)\">\n                <span class=\"ui-column-resizer ui-clickable\" *ngIf=\"dt.resizableColumns && ((dt.columnResizeMode == 'fit' && !lastCol) || dt.columnResizeMode == 'expand')\" (mousedown)=\"dt.initColumnResize($event)\"></span>\n                <span class=\"ui-column-title\" *ngIf=\"!col.selectionMode&&!col.headerTemplate\">{{col.header}}</span>\n                <span class=\"ui-column-title\" *ngIf=\"col.headerTemplate\">\n                    <p-columnHeaderTemplateLoader [column]=\"col\"></p-columnHeaderTemplateLoader>\n                </span>\n                <span class=\"ui-sortable-column-icon fa fa-fw fa-sort\" *ngIf=\"col.sortable\"\n                     [ngClass]=\"{'fa-sort-desc': (dt.getSortOrder(col) == -1),'fa-sort-asc': (dt.getSortOrder(col) == 1)}\"></span>\n                <input [attr.type]=\"col.filterType\" class=\"ui-column-filter ui-inputtext ui-widget ui-state-default ui-corner-all\" [attr.maxlength]=\"col.filterMaxlength\" [attr.placeholder]=\"col.filterPlaceholder\" *ngIf=\"col.filter&&!col.filterTemplate\" [value]=\"dt.filters[col.field] ? dt.filters[col.field].value : ''\" \n                    (click)=\"dt.onFilterInputClick($event)\" (input)=\"dt.onFilterKeyup($event.target.value, col.field, col.filterMatchMode)\"/>\n                <p-columnFilterTemplateLoader [column]=\"col\" *ngIf=\"col.filterTemplate\"></p-columnFilterTemplateLoader>\n                <p-dtCheckbox *ngIf=\"col.selectionMode=='multiple'\" (onChange)=\"dt.toggleRowsWithCheckbox($event)\" [checked]=\"dt.allSelected\" [disabled]=\"dt.isEmpty()\"></p-dtCheckbox>\n            </th>\n        </ng-template>\n    "
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return DataTable; }))),
    __metadata("design:paramtypes", [DataTable])
], ColumnHeaders);
exports.ColumnHeaders = ColumnHeaders;
var ColumnFooters = (function () {
    function ColumnFooters(dt) {
        this.dt = dt;
    }
    return ColumnFooters;
}());
__decorate([
    core_1.Input("pColumnFooters"),
    __metadata("design:type", Array)
], ColumnFooters.prototype, "columns", void 0);
ColumnFooters = __decorate([
    core_1.Component({
        selector: '[pColumnFooters]',
        template: "\n        <td *ngFor=\"let col of columns\" [ngStyle]=\"col.style\" [class]=\"col.styleClass\"\n            [attr.colspan]=\"col.colspan\" [attr.rowspan]=\"col.rowspan\"\n            [ngClass]=\"{'ui-state-default':true}\" [style.display]=\"col.hidden ? 'none' : 'table-cell'\">\n            <span class=\"ui-column-footer\" *ngIf=\"!col.footerTemplate\">{{col.footer}}</span>\n            <span class=\"ui-column-footer\" *ngIf=\"col.footerTemplate\">\n                <p-columnFooterTemplateLoader [column]=\"col\"></p-columnFooterTemplateLoader>\n            </span>\n        </td>\n    "
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return DataTable; }))),
    __metadata("design:paramtypes", [DataTable])
], ColumnFooters);
exports.ColumnFooters = ColumnFooters;
var TableBody = (function () {
    function TableBody(dt) {
        this.dt = dt;
    }
    TableBody.prototype.visibleColumns = function () {
        return this.columns ? this.columns.filter(function (c) { return !c.hidden; }) : [];
    };
    return TableBody;
}());
__decorate([
    core_1.Input("pTableBody"),
    __metadata("design:type", Array)
], TableBody.prototype, "columns", void 0);
TableBody = __decorate([
    core_1.Component({
        selector: '[pTableBody]',
        template: "\n        <ng-template ngFor let-rowData [ngForOf]=\"dt.dataToRender\" let-even=\"even\" let-odd=\"odd\" let-rowIndex=\"index\" [ngForTrackBy]=\"dt.rowTrackBy\">\n            <tr #rowGroupElement class=\"ui-widget-header ui-rowgroup-header\" \n                *ngIf=\"dt.rowGroupMode=='subheader' && (rowIndex === 0||(dt.resolveFieldData(rowData,dt.groupField) !== dt.resolveFieldData(dt.dataToRender[rowIndex - 1], dt.groupField)))\"\n                (click)=\"dt.onRowGroupClick($event)\" [ngStyle]=\"{'cursor': dt.sortableRowGroup ? 'pointer' : 'auto'}\">\n                <td [attr.colspan]=\"dt.visibleColumns().length\">\n                    <a href=\"#\" *ngIf=\"dt.expandableRowGroups\" (click)=\"dt.toggleRowGroup($event,rowData)\">\n                        <span class=\"fa fa-fw\" [ngClass]=\"{'fa-chevron-circle-down':dt.isRowGroupExpanded(rowData), 'fa-chevron-circle-right': !dt.isRowGroupExpanded(rowData)}\"></span>\n                    </a>\n                    <span class=\"ui-rowgroup-header-name\">\n                        <p-templateLoader [template]=\"dt.rowGroupHeaderTemplate\" [data]=\"rowData\"></p-templateLoader>\n                    </span>\n                </td>\n            </tr>\n            <tr #rowElement *ngIf=\"!dt.expandableRowGroups||dt.isRowGroupExpanded(rowData)\" [class]=\"dt.getRowStyleClass(rowData,rowIndex)\"\n                    (click)=\"dt.handleRowClick($event, rowData, rowIndex)\" (dblclick)=\"dt.rowDblclick($event,rowData)\" (contextmenu)=\"dt.onRowRightClick($event,rowData)\" (touchend)=\"dt.handleRowTouchEnd($event)\"\n                    [ngClass]=\"{'ui-datatable-even':even&&dt.rowGroupMode!='rowspan','ui-datatable-odd':odd&&dt.rowGroupMode!='rowspan','ui-state-highlight': dt.isSelected(rowData)}\">\n                <ng-template ngFor let-col [ngForOf]=\"columns\" let-colIndex=\"index\">\n                    <td #cell *ngIf=\"!dt.rowGroupMode || (dt.rowGroupMode == 'subheader') ||\n                        (dt.rowGroupMode=='rowspan' && ((dt.sortField==col.field && dt.rowGroupMetadata[dt.resolveFieldData(rowData,dt.sortField)].index == rowIndex) || (dt.sortField!=col.field)))\"\n                        [ngStyle]=\"col.style\" [class]=\"col.styleClass\" [style.display]=\"col.hidden ? 'none' : 'table-cell'\"\n                        [ngClass]=\"{'ui-editable-column':col.editable,'ui-selection-column':col.selectionMode}\"\n                        [attr.rowspan]=\"(dt.rowGroupMode=='rowspan' && dt.sortField == col.field && dt.rowGroupMetadata[dt.resolveFieldData(rowData,dt.sortField)].index == rowIndex) ? dt.rowGroupMetadata[dt.resolveFieldData(rowData,dt.sortField)].size : null\">\n                        <span class=\"ui-column-title\" *ngIf=\"dt.responsive\">{{col.header}}</span>\n                        <span class=\"ui-cell-data\" *ngIf=\"!col.bodyTemplate && !col.expander && !col.selectionMode\">{{dt.resolveFieldData(rowData,col.field)}}</span>\n                        <span class=\"ui-cell-data\" *ngIf=\"col.bodyTemplate\">\n                            <p-columnBodyTemplateLoader [column]=\"col\" [rowData]=\"rowData\" [rowIndex]=\"rowIndex + dt.first\"></p-columnBodyTemplateLoader>\n                        </span>\n                        <div class=\"ui-cell-editor\" *ngIf=\"col.editable\">\n                            <input *ngIf=\"!col.editorTemplate\" type=\"text\" [(ngModel)]=\"rowData[col.field]\" required=\"true\"\n                                (keydown)=\"dt.onCellEditorKeydown($event, col, rowData, rowIndex)\" class=\"ui-inputtext ui-widget ui-state-default ui-corner-all\"/>\n                            <a *ngIf=\"col.editorTemplate\" class=\"ui-cell-editor-proxy-focus\" href=\"#\" (focus)=\"dt.onCustomEditorFocusPrev($event, colIndex)\"></a>\n                            <p-columnEditorTemplateLoader *ngIf=\"col.editorTemplate\" [column]=\"col\" [rowData]=\"rowData\" [rowIndex]=\"rowIndex\"></p-columnEditorTemplateLoader>\n                            <a *ngIf=\"col.editorTemplate\" class=\"ui-cell-editor-proxy-focus\" href=\"#\" (focus)=\"dt.onCustomEditorFocusNext($event, colIndex)\"></a>\n                        </div>\n                        <a href=\"#\" *ngIf=\"col.expander\" (click)=\"dt.toggleRow(rowData,$event)\">\n                            <span class=\"ui-row-toggler fa fa-fw ui-clickable\" [ngClass]=\"{'fa-chevron-circle-down':dt.isRowExpanded(rowData), 'fa-chevron-circle-right': !dt.isRowExpanded(rowData)}\"></span>\n                        </a>\n                        <p-dtRadioButton *ngIf=\"col.selectionMode=='single'\" (onClick)=\"dt.selectRowWithRadio($event, rowData)\" [checked]=\"dt.isSelected(rowData)\"></p-dtRadioButton>\n                        <p-dtCheckbox *ngIf=\"col.selectionMode=='multiple'\" (onChange)=\"dt.toggleRowWithCheckbox($event,rowData)\" [checked]=\"dt.isSelected(rowData)\"></p-dtCheckbox>\n                    </td>\n                </ng-template>\n            </tr>\n            <tr class=\"ui-widget-header\" *ngIf=\"dt.rowGroupFooterTemplate && dt.rowGroupMode=='subheader' && ((rowIndex === dt.dataToRender.length - 1)||(dt.resolveFieldData(rowData,dt.groupField) !== dt.resolveFieldData(dt.dataToRender[rowIndex + 1],dt.groupField))) && (!dt.expandableRowGroups || dt.isRowGroupExpanded(rowData))\">\n                <p-templateLoader class=\"ui-helper-hidden\" [data]=\"rowData\" [template]=\"dt.rowGroupFooterTemplate\"></p-templateLoader>\n            </tr>\n            <tr *ngIf=\"dt.expandableRows && dt.isRowExpanded(rowData)\">\n                <td [attr.colspan]=\"dt.visibleColumns().length\">\n                    <p-rowExpansionLoader [rowData]=\"rowData\" [rowIndex]=\"rowIndex\" [template]=\"dt.rowExpansionTemplate\"></p-rowExpansionLoader>\n                </td>\n            </tr>\n        </ng-template>\n\n        <tr *ngIf=\"dt.isEmpty()\" class=\"ui-widget-content\">\n            <td [attr.colspan]=\"dt.visibleColumns().length\" class=\"ui-datatable-emptymessage\">{{dt.emptyMessage}}</td>\n        </tr>\n    "
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return DataTable; }))),
    __metadata("design:paramtypes", [DataTable])
], TableBody);
exports.TableBody = TableBody;
var ScrollableView = (function () {
    function ScrollableView(dt, domHandler, el, renderer, zone) {
        this.dt = dt;
        this.domHandler = domHandler;
        this.el = el;
        this.renderer = renderer;
        this.zone = zone;
        this.onVirtualScroll = new core_1.EventEmitter();
    }
    ScrollableView.prototype.ngAfterViewInit = function () {
        this.initScrolling();
    };
    ScrollableView.prototype.ngAfterViewChecked = function () {
        if (this.virtualScroll && !this.rowHeight) {
            var row = this.domHandler.findSingle(this.scrollTable, 'tr.ui-widget-content');
            if (row) {
                this.rowHeight = this.domHandler.getOuterHeight(row);
            }
        }
        if (!this.frozen) {
            this.alignScrollBar();
        }
    };
    ScrollableView.prototype.initScrolling = function () {
        var _this = this;
        this.scrollHeader = this.scrollHeaderViewChild.nativeElement;
        this.scrollHeaderBox = this.scrollHeaderBoxViewChild.nativeElement;
        this.scrollBody = this.scrollBodyViewChild.nativeElement;
        this.scrollTable = this.scrollTableViewChild.nativeElement;
        this.scrollTableWrapper = this.scrollTableWrapperViewChild.nativeElement;
        this.scrollFooter = this.scrollFooterViewChild ? this.scrollFooterViewChild.nativeElement : null;
        this.scrollFooterBox = this.scrollFooterBoxViewChild ? this.scrollFooterBoxViewChild.nativeElement : null;
        if (!this.frozen) {
            this.zone.runOutsideAngular(function () {
                _this.scrollHeader.addEventListener('scroll', _this.onHeaderScroll.bind(_this));
                _this.scrollBody.addEventListener('scroll', _this.onBodyScroll.bind(_this));
            });
        }
        if (!this.frozen)
            this.alignScrollBar();
        else
            this.scrollBody.style.paddingBottom = this.domHandler.calculateScrollbarWidth() + 'px';
    };
    ScrollableView.prototype.onBodyScroll = function (event) {
        var frozenView = this.el.nativeElement.previousElementSibling;
        if (frozenView) {
            var frozenScrollBody = this.domHandler.findSingle(frozenView, '.ui-datatable-scrollable-body');
        }
        this.scrollHeaderBox.style.marginLeft = -1 * this.scrollBody.scrollLeft + 'px';
        if (this.scrollFooterBox) {
            this.scrollFooterBox.style.marginLeft = -1 * this.scrollBody.scrollLeft + 'px';
        }
        if (frozenScrollBody) {
            frozenScrollBody.scrollTop = this.scrollBody.scrollTop;
        }
        if (this.virtualScroll) {
            var viewport = this.domHandler.getOuterHeight(this.scrollBody);
            var tableHeight = this.domHandler.getOuterHeight(this.scrollTable);
            var pageHeight = this.rowHeight * this.dt.rows;
            var virtualTableHeight = this.domHandler.getOuterHeight(this.scrollTableWrapper);
            var pageCount = (virtualTableHeight / pageHeight) || 1;
            if (this.scrollBody.scrollTop + viewport > parseFloat(this.scrollTable.style.top) + tableHeight || this.scrollBody.scrollTop < parseFloat(this.scrollTable.style.top)) {
                var page = Math.floor((this.scrollBody.scrollTop * pageCount) / (this.scrollBody.scrollHeight)) + 1;
                this.onVirtualScroll.emit({
                    page: page
                });
                this.scrollTable.style.top = ((page - 1) * pageHeight) + 'px';
            }
        }
    };
    ScrollableView.prototype.onHeaderScroll = function (event) {
        this.scrollHeader.scrollLeft = 0;
    };
    ScrollableView.prototype.hasVerticalOverflow = function () {
        return this.domHandler.getOuterHeight(this.scrollTable) > this.domHandler.getOuterHeight(this.scrollBody);
    };
    ScrollableView.prototype.alignScrollBar = function () {
        var scrollBarWidth = this.hasVerticalOverflow() ? this.domHandler.calculateScrollbarWidth() : 0;
        this.scrollHeaderBox.style.marginRight = scrollBarWidth + 'px';
        if (this.scrollFooterBox) {
            this.scrollFooterBox.style.marginRight = scrollBarWidth + 'px';
        }
    };
    ScrollableView.prototype.ngOnDestroy = function () {
        this.scrollHeader.removeEventListener('scroll', this.onHeaderScroll);
        this.scrollBody.removeEventListener('scroll', this.onBodyScroll);
    };
    return ScrollableView;
}());
__decorate([
    core_1.Input("pScrollableView"),
    __metadata("design:type", Array)
], ScrollableView.prototype, "columns", void 0);
__decorate([
    core_1.ViewChild('scrollHeader'),
    __metadata("design:type", core_1.ElementRef)
], ScrollableView.prototype, "scrollHeaderViewChild", void 0);
__decorate([
    core_1.ViewChild('scrollHeaderBox'),
    __metadata("design:type", core_1.ElementRef)
], ScrollableView.prototype, "scrollHeaderBoxViewChild", void 0);
__decorate([
    core_1.ViewChild('scrollBody'),
    __metadata("design:type", core_1.ElementRef)
], ScrollableView.prototype, "scrollBodyViewChild", void 0);
__decorate([
    core_1.ViewChild('scrollTable'),
    __metadata("design:type", core_1.ElementRef)
], ScrollableView.prototype, "scrollTableViewChild", void 0);
__decorate([
    core_1.ViewChild('scrollTableWrapper'),
    __metadata("design:type", core_1.ElementRef)
], ScrollableView.prototype, "scrollTableWrapperViewChild", void 0);
__decorate([
    core_1.ViewChild('scrollFooter'),
    __metadata("design:type", core_1.ElementRef)
], ScrollableView.prototype, "scrollFooterViewChild", void 0);
__decorate([
    core_1.ViewChild('scrollFooterBox'),
    __metadata("design:type", core_1.ElementRef)
], ScrollableView.prototype, "scrollFooterBoxViewChild", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ScrollableView.prototype, "frozen", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ScrollableView.prototype, "width", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ScrollableView.prototype, "virtualScroll", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], ScrollableView.prototype, "onVirtualScroll", void 0);
ScrollableView = __decorate([
    core_1.Component({
        selector: '[pScrollableView]',
        template: "\n        <div #scrollHeader class=\"ui-widget-header ui-datatable-scrollable-header\" [ngStyle]=\"{'width': width}\">\n            <div #scrollHeaderBox  class=\"ui-datatable-scrollable-header-box\">\n                <table [class]=\"dt.tableStyleClass\" [ngStyle]=\"dt.tableStyle\">\n                    <thead class=\"ui-datatable-thead\">\n                        <tr *ngIf=\"!dt.headerColumnGroup\" class=\"ui-state-default\" [pColumnHeaders]=\"columns\"></tr>\n                        <ng-template [ngIf]=\"dt.headerColumnGroup\">\n                            <tr *ngFor=\"let headerRow of dt.headerColumnGroup.rows\" class=\"ui-state-default\" [pColumnHeaders]=\"headerRow.columns\"></tr>\n                        </ng-template>\n                    </thead>\n                </table>\n            </div>\n        </div>\n        <div #scrollBody class=\"ui-datatable-scrollable-body\" [ngStyle]=\"{'width': width,'max-height':dt.scrollHeight}\">\n            <div #scrollTableWrapper class=\"ui-datatable-scrollable-table-wrapper\" style=\"position:relative\">\n                <table #scrollTable [class]=\"dt.tableStyleClass\" [ngStyle]=\"dt.tableStyle\" [ngClass]=\"{'ui-datatable-virtual-table':virtualScroll}\" style=\"top:0px\">\n                    <colgroup class=\"ui-datatable-scrollable-colgroup\">\n                        <col *ngFor=\"let col of columns\" [ngStyle]=\"col.style\"/>\n                    </colgroup>\n                    <tbody [ngClass]=\"{'ui-datatable-data ui-widget-content': true, 'ui-datatable-hoverable-rows': (dt.rowHover||dt.selectionMode)}\" [pTableBody]=\"columns\"></tbody>\n                </table>\n            </div>\n        </div>\n        <div #scrollFooter class=\"ui-widget-header ui-datatable-scrollable-footer\" [ngStyle]=\"{'width': width}\" *ngIf=\"dt.hasFooter()\">\n            <div #scrollFooterBox  class=\"ui-datatable-scrollable-footer-box\">\n                <table [class]=\"dt.tableStyleClass\" [ngStyle]=\"dt.tableStyle\">\n                    <tfoot class=\"ui-datatable-tfoot\">\n                        <tr *ngIf=\"!dt.footerColumnGroup\" [pColumnFooters]=\"columns\" class=\"ui-state-default\"></tr>\n                        <ng-template [ngIf]=\"dt.footerColumnGroup\">\n                            <tr *ngFor=\"let footerRow of dt.footerColumnGroup.rows\" class=\"ui-state-default\" [pColumnFooters]=\"footerRow.columns\"></tr>\n                        </ng-template>\n                    </tfoot>\n                </table>\n            </div>\n        </div>\n    "
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return DataTable; }))),
    __metadata("design:paramtypes", [DataTable, domhandler_1.DomHandler, core_1.ElementRef, core_1.Renderer2, core_1.NgZone])
], ScrollableView);
exports.ScrollableView = ScrollableView;
var DataTable = (function () {
    function DataTable(el, domHandler, differs, renderer, changeDetector, objectUtils, zone) {
        this.el = el;
        this.domHandler = domHandler;
        this.differs = differs;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        this.objectUtils = objectUtils;
        this.zone = zone;
        this.pageLinks = 5;
        this.selectionChange = new core_1.EventEmitter();
        this.onRowClick = new core_1.EventEmitter();
        this.onRowSelect = new core_1.EventEmitter();
        this.onRowUnselect = new core_1.EventEmitter();
        this.onRowDblclick = new core_1.EventEmitter();
        this.onHeaderCheckboxToggle = new core_1.EventEmitter();
        this.onContextMenuSelect = new core_1.EventEmitter();
        this.filterDelay = 300;
        this.onLazyLoad = new core_1.EventEmitter();
        this.columnResizeMode = 'fit';
        this.onColResize = new core_1.EventEmitter();
        this.onColReorder = new core_1.EventEmitter();
        this.sortMode = 'single';
        this.sortOrder = 1;
        this.csvSeparator = ',';
        this.exportFilename = 'download';
        this.emptyMessage = 'No records found';
        this.paginatorPosition = 'bottom';
        this.alwaysShowPaginator = true;
        this.metaKeySelection = true;
        this.rowTrackBy = function (index, item) { return item; };
        this.immutable = true;
        this.compareSelectionBy = 'deepEquals';
        this.onEditInit = new core_1.EventEmitter();
        this.onEditComplete = new core_1.EventEmitter();
        this.onEdit = new core_1.EventEmitter();
        this.onEditCancel = new core_1.EventEmitter();
        this.onPage = new core_1.EventEmitter();
        this.onSort = new core_1.EventEmitter();
        this.onFilter = new core_1.EventEmitter();
        this.rowExpandMode = 'multiple';
        this.tabindex = 1;
        this.sortableRowGroup = true;
        this.filters = {};
        this.loadingIcon = 'fa-circle-o-notch';
        this.firstChange = new core_1.EventEmitter();
        this.onRowExpand = new core_1.EventEmitter();
        this.onRowCollapse = new core_1.EventEmitter();
        this.onRowGroupExpand = new core_1.EventEmitter();
        this.onRowGroupCollapse = new core_1.EventEmitter();
        this.page = 0;
        this.columnsChanged = false;
        this._first = 0;
        this.filterConstraints = {
            startsWith: function (value, filter) {
                if (filter === undefined || filter === null || filter.trim() === '') {
                    return true;
                }
                if (value === undefined || value === null) {
                    return false;
                }
                var filterValue = filter.toLowerCase();
                return value.toString().toLowerCase().slice(0, filterValue.length) === filterValue;
            },
            contains: function (value, filter) {
                if (filter === undefined || filter === null || (typeof filter === 'string' && filter.trim() === '')) {
                    return true;
                }
                if (value === undefined || value === null) {
                    return false;
                }
                return value.toString().toLowerCase().indexOf(filter.toLowerCase()) !== -1;
            },
            endsWith: function (value, filter) {
                if (filter === undefined || filter === null || filter.trim() === '') {
                    return true;
                }
                if (value === undefined || value === null) {
                    return false;
                }
                var filterValue = filter.toString().toLowerCase();
                return value.toString().toLowerCase().indexOf(filterValue, value.toString().length - filterValue.length) !== -1;
            },
            equals: function (value, filter) {
                if (filter === undefined || filter === null || (typeof filter === 'string' && filter.trim() === '')) {
                    return true;
                }
                if (value === undefined || value === null) {
                    return false;
                }
                return value.toString().toLowerCase() == filter.toString().toLowerCase();
            },
            notEquals: function (value, filter) {
                if (filter === undefined || filter === null || (typeof filter === 'string' && filter.trim() === '')) {
                    return false;
                }
                if (value === undefined || value === null) {
                    return true;
                }
                return value.toString().toLowerCase() != filter.toString().toLowerCase();
            },
            in: function (value, filter) {
                if (filter === undefined || filter === null || filter.length === 0) {
                    return true;
                }
                if (value === undefined || value === null) {
                    return false;
                }
                for (var i = 0; i < filter.length; i++) {
                    if (filter[i] === value)
                        return true;
                }
                return false;
            }
        };
        this.differ = differs.find([]).create(null);
    }
    DataTable.prototype.ngOnInit = function () {
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata());
        }
    };
    DataTable.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.initColumns();
        this.columnsSubscription = this.cols.changes.subscribe(function (_) {
            _this.initColumns();
            _this.changeDetector.markForCheck();
        });
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'rowexpansion':
                    _this.rowExpansionTemplate = item.template;
                    break;
                case 'rowgroupheader':
                    _this.rowGroupHeaderTemplate = item.template;
                    break;
                case 'rowgroupfooter':
                    _this.rowGroupFooterTemplate = item.template;
                    break;
            }
        });
    };
    DataTable.prototype.ngAfterViewChecked = function () {
        if (this.columnsChanged && this.el.nativeElement.offsetParent) {
            if (this.resizableColumns) {
                this.initResizableColumns();
            }
            if (this.reorderableColumns) {
                this.initColumnReordering();
            }
            this.columnsChanged = false;
        }
        if (this.totalRecordsChanged && this.virtualScroll) {
            var scrollableTable = this.domHandler.findSingle(this.el.nativeElement, 'div.ui-datatable-scrollable-table-wrapper');
            var row = this.domHandler.findSingle(scrollableTable, 'tr.ui-widget-content');
            var rowHeight = this.domHandler.getOuterHeight(row);
            this.virtualTableHeight = this._totalRecords * rowHeight;
            scrollableTable.style.height = this.virtualTableHeight + 'px';
            this.totalRecordsChanged = true;
        }
    };
    DataTable.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.globalFilter) {
            this.globalFilterFunction = this.renderer.listen(this.globalFilter, 'keyup', function () {
                _this.filterTimeout = setTimeout(function () {
                    _this._filter();
                    _this.filterTimeout = null;
                }, _this.filterDelay);
            });
        }
    };
    Object.defineProperty(DataTable.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (val) {
            if (this.immutable) {
                this._value = val ? val.slice() : null;
                this.handleDataChange();
            }
            else {
                this._value = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTable.prototype, "first", {
        get: function () {
            return this._first;
        },
        set: function (val) {
            var shouldPaginate = this._first !== val;
            this._first = val;
            if (shouldPaginate) {
                this.paginate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTable.prototype, "totalRecords", {
        get: function () {
            return this._totalRecords;
        },
        set: function (val) {
            this._totalRecords = val;
            this.totalRecordsChanged = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTable.prototype, "selection", {
        get: function () {
            return this._selection;
        },
        set: function (val) {
            this._selection = val;
            if (this.dataKey && !this.preventSelectionKeysPropagation) {
                this.selectionKeys = {};
                if (this._selection) {
                    for (var _i = 0, _a = this._selection; _i < _a.length; _i++) {
                        var data = _a[_i];
                        this.selectionKeys[String(this.objectUtils.resolveFieldData(data, this.dataKey))] = 1;
                    }
                }
            }
            this.preventSelectionKeysPropagation = false;
        },
        enumerable: true,
        configurable: true
    });
    DataTable.prototype.ngDoCheck = function () {
        if (!this.immutable) {
            var changes = this.differ.diff(this.value);
            if (changes) {
                this.handleDataChange();
            }
        }
    };
    DataTable.prototype.handleDataChange = function () {
        var _this = this;
        if (this.paginator) {
            this.updatePaginator();
        }
        if (!this.lazy) {
            if (this.hasFilter()) {
                this._filter();
            }
            if (this.preventSortPropagation) {
                this.preventSortPropagation = false;
            }
            else if (this.sortField || this.multiSortMeta) {
                if (!this.sortColumn && this.columns) {
                    this.sortColumn = this.columns.find(function (col) { return col.field === _this.sortField && col.sortable === 'custom'; });
                }
                if (this.sortMode == 'single')
                    this.sortSingle();
                else if (this.sortMode == 'multiple')
                    this.sortMultiple();
            }
        }
        this.updateDataToRender(this.filteredValue || this.value);
    };
    DataTable.prototype.initColumns = function () {
        var _this = this;
        this.columns = this.cols.toArray();
        if (this.scrollable) {
            this.scrollableColumns = [];
            this.cols.forEach(function (col) {
                if (col.frozen) {
                    _this.frozenColumns = _this.frozenColumns || [];
                    _this.frozenColumns.push(col);
                }
                else {
                    _this.scrollableColumns.push(col);
                }
            });
        }
        this.columnsChanged = true;
    };
    DataTable.prototype.resolveFieldData = function (data, field) {
        if (data && field) {
            if (field.indexOf('.') == -1) {
                return data[field];
            }
            else {
                var fields = field.split('.');
                var value = data;
                for (var i = 0, len = fields.length; i < len; ++i) {
                    if (value == null) {
                        return null;
                    }
                    value = value[fields[i]];
                }
                return value;
            }
        }
        else {
            return null;
        }
    };
    DataTable.prototype.updateRowGroupMetadata = function () {
        this.rowGroupMetadata = {};
        if (this.dataToRender) {
            for (var i = 0; i < this.dataToRender.length; i++) {
                var rowData = this.dataToRender[i];
                var group = this.resolveFieldData(rowData, this.sortField);
                if (i == 0) {
                    this.rowGroupMetadata[group] = { index: 0, size: 1 };
                }
                else {
                    var previousRowData = this.dataToRender[i - 1];
                    var previousRowGroup = this.resolveFieldData(previousRowData, this.sortField);
                    if (group === previousRowGroup) {
                        this.rowGroupMetadata[group].size++;
                    }
                    else {
                        this.rowGroupMetadata[group] = { index: i, size: 1 };
                    }
                }
            }
        }
    };
    DataTable.prototype.updatePaginator = function () {
        //total records
        this.updateTotalRecords();
        //first
        if (this.totalRecords && this.first >= this.totalRecords) {
            var numberOfPages = Math.ceil(this.totalRecords / this.rows);
            this._first = Math.max((numberOfPages - 1) * this.rows, 0);
        }
    };
    DataTable.prototype.updateTotalRecords = function () {
        this.totalRecords = this.lazy ? this.totalRecords : (this.value ? this.value.length : 0);
    };
    DataTable.prototype.onPageChange = function (event) {
        this._first = event.first;
        this.firstChange.emit(this.first);
        this.rows = event.rows;
        this.paginate();
    };
    DataTable.prototype.paginate = function () {
        if (this.lazy)
            this.onLazyLoad.emit(this.createLazyLoadMetadata());
        else
            this.updateDataToRender(this.filteredValue || this.value);
        this.onPage.emit({
            first: this.first,
            rows: this.rows
        });
    };
    DataTable.prototype.updateDataToRender = function (datasource) {
        if ((this.paginator || this.virtualScroll) && datasource) {
            this.dataToRender = [];
            var startIndex = this.lazy ? 0 : this.first;
            var endIndex = this.virtualScroll ? this.first + this.rows * 2 : startIndex + this.rows;
            for (var i = startIndex; i < endIndex; i++) {
                if (i >= datasource.length) {
                    break;
                }
                this.dataToRender.push(datasource[i]);
            }
        }
        else {
            this.dataToRender = datasource;
        }
        if (this.rowGroupMode) {
            this.updateRowGroupMetadata();
        }
    };
    DataTable.prototype.onVirtualScroll = function (event) {
        this._first = (event.page - 1) * this.rows;
        if (this.lazy)
            this.onLazyLoad.emit(this.createLazyLoadMetadata());
        else
            this.updateDataToRender(this.filteredValue || this.value);
    };
    DataTable.prototype.onHeaderKeydown = function (event, column) {
        if (event.keyCode == 13) {
            this.sort(event, column);
            event.preventDefault();
        }
    };
    DataTable.prototype.onHeaderMousedown = function (event, header) {
        if (this.reorderableColumns) {
            if (event.target.nodeName !== 'INPUT') {
                header.draggable = true;
            }
            else if (event.target.nodeName === 'INPUT') {
                header.draggable = false;
            }
        }
    };
    DataTable.prototype.sort = function (event, column) {
        if (!column.sortable) {
            return;
        }
        var targetNode = event.target.nodeName;
        if ((targetNode == 'TH' && this.domHandler.hasClass(event.target, 'ui-sortable-column')) || ((targetNode == 'SPAN' || targetNode == 'DIV') && !this.domHandler.hasClass(event.target, 'ui-clickable'))) {
            if (!this.immutable) {
                this.preventSortPropagation = true;
            }
            var columnSortField = column.sortField || column.field;
            this.sortOrder = (this.sortField === columnSortField) ? this.sortOrder * -1 : 1;
            this.sortField = columnSortField;
            this.sortColumn = column;
            var metaKey = event.metaKey || event.ctrlKey;
            if (this.sortMode == 'multiple') {
                if (!this.multiSortMeta || !metaKey) {
                    this.multiSortMeta = [];
                }
                this.addSortMeta({ field: this.sortField, order: this.sortOrder });
            }
            if (this.lazy) {
                this._first = 0;
                this.onLazyLoad.emit(this.createLazyLoadMetadata());
            }
            else {
                if (this.sortMode == 'multiple')
                    this.sortMultiple();
                else
                    this.sortSingle();
            }
            this.onSort.emit({
                field: this.sortField,
                order: this.sortOrder,
                multisortmeta: this.multiSortMeta
            });
        }
        this.updateDataToRender(this.filteredValue || this.value);
    };
    DataTable.prototype.sortSingle = function () {
        var _this = this;
        if (this.value) {
            if (this.sortColumn && this.sortColumn.sortable === 'custom') {
                this.preventSortPropagation = true;
                this.sortColumn.sortFunction.emit({
                    field: this.sortField,
                    order: this.sortOrder
                });
            }
            else {
                this.value.sort(function (data1, data2) {
                    var value1 = _this.resolveFieldData(data1, _this.sortField);
                    var value2 = _this.resolveFieldData(data2, _this.sortField);
                    var result = null;
                    if (value1 == null && value2 != null)
                        result = -1;
                    else if (value1 != null && value2 == null)
                        result = 1;
                    else if (value1 == null && value2 == null)
                        result = 0;
                    else if (typeof value1 === 'string' && typeof value2 === 'string')
                        result = value1.localeCompare(value2);
                    else
                        result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
                    return (_this.sortOrder * result);
                });
            }
            this.first = 0;
            if (this.hasFilter()) {
                this._filter();
            }
        }
    };
    DataTable.prototype.sortMultiple = function () {
        var _this = this;
        if (this.value) {
            this.value.sort(function (data1, data2) {
                return _this.multisortField(data1, data2, _this.multiSortMeta, 0);
            });
            if (this.hasFilter()) {
                this._filter();
            }
        }
    };
    DataTable.prototype.multisortField = function (data1, data2, multiSortMeta, index) {
        var value1 = this.resolveFieldData(data1, multiSortMeta[index].field);
        var value2 = this.resolveFieldData(data2, multiSortMeta[index].field);
        var result = null;
        if (typeof value1 == 'string' || value1 instanceof String) {
            if (value1.localeCompare && (value1 != value2)) {
                return (multiSortMeta[index].order * value1.localeCompare(value2));
            }
        }
        else {
            result = (value1 < value2) ? -1 : 1;
        }
        if (value1 == value2) {
            return (multiSortMeta.length - 1) > (index) ? (this.multisortField(data1, data2, multiSortMeta, index + 1)) : 0;
        }
        return (multiSortMeta[index].order * result);
    };
    DataTable.prototype.addSortMeta = function (meta) {
        var index = -1;
        for (var i = 0; i < this.multiSortMeta.length; i++) {
            if (this.multiSortMeta[i].field === meta.field) {
                index = i;
                break;
            }
        }
        if (index >= 0)
            this.multiSortMeta[index] = meta;
        else
            this.multiSortMeta.push(meta);
    };
    DataTable.prototype.isSorted = function (column) {
        if (!column.sortable) {
            return false;
        }
        var columnSortField = column.sortField || column.field;
        if (this.sortMode === 'single') {
            return (this.sortField && columnSortField === this.sortField);
        }
        else if (this.sortMode === 'multiple') {
            var sorted = false;
            if (this.multiSortMeta) {
                for (var i = 0; i < this.multiSortMeta.length; i++) {
                    if (this.multiSortMeta[i].field == columnSortField) {
                        sorted = true;
                        break;
                    }
                }
            }
            return sorted;
        }
    };
    DataTable.prototype.getSortOrder = function (column) {
        var order = 0;
        var columnSortField = column.sortField || column.field;
        if (this.sortMode === 'single') {
            if (this.sortField && columnSortField === this.sortField) {
                order = this.sortOrder;
            }
        }
        else if (this.sortMode === 'multiple') {
            if (this.multiSortMeta) {
                for (var i = 0; i < this.multiSortMeta.length; i++) {
                    if (this.multiSortMeta[i].field == columnSortField) {
                        order = this.multiSortMeta[i].order;
                        break;
                    }
                }
            }
        }
        return order;
    };
    DataTable.prototype.onRowGroupClick = function (event) {
        if (this.rowGroupToggleClick) {
            this.rowGroupToggleClick = false;
            return;
        }
        if (this.sortableRowGroup) {
            var targetNode = event.target.nodeName;
            if ((targetNode == 'TD' || (targetNode == 'SPAN' && !this.domHandler.hasClass(event.target, 'ui-clickable')))) {
                if (this.sortField != this.groupField) {
                    this.sortField = this.groupField;
                    this.sortSingle();
                }
                else {
                    this.sortOrder = -1 * this.sortOrder;
                    this.sortSingle();
                }
            }
        }
    };
    DataTable.prototype.clearSelectionRange = function () {
        var rangeStart, rangeEnd;
        if (this.rangeRowIndex > this.anchorRowIndex) {
            rangeStart = this.anchorRowIndex;
            rangeEnd = this.rangeRowIndex;
        }
        else if (this.rangeRowIndex < this.anchorRowIndex) {
            rangeStart = this.rangeRowIndex;
            rangeEnd = this.anchorRowIndex;
        }
        else {
            rangeStart = this.rangeRowIndex;
            rangeEnd = this.rangeRowIndex;
        }
        var _loop_1 = function (i) {
            var rangeRowData = this_1.dataToRender[i];
            var selectionIndex = this_1.findIndexInSelection(rangeRowData);
            this_1._selection = this_1.selection.filter(function (val, i) { return i != selectionIndex; });
            var dataKeyValue = this_1.dataKey ? String(this_1.resolveFieldData(rangeRowData, this_1.dataKey)) : null;
            if (dataKeyValue) {
                delete this_1.selectionKeys[dataKeyValue];
            }
            this_1.onRowUnselect.emit({ originalEvent: event, data: rangeRowData, type: 'row' });
        };
        var this_1 = this;
        for (var i = rangeStart; i <= rangeEnd; i++) {
            _loop_1(i);
        }
    };
    DataTable.prototype.selectRange = function (rowIndex) {
        var rangeStart, rangeEnd;
        if (this.anchorRowIndex > rowIndex) {
            rangeStart = rowIndex;
            rangeEnd = this.anchorRowIndex;
        }
        else if (this.anchorRowIndex < rowIndex) {
            rangeStart = this.anchorRowIndex;
            rangeEnd = rowIndex;
        }
        else {
            rangeStart = rowIndex;
            rangeEnd = rowIndex;
        }
        for (var i = rangeStart; i <= rangeEnd; i++) {
            var rangeRowData = this.dataToRender[i];
            this._selection = this.selection.concat([rangeRowData]);
            this.selectionChange.emit(this.selection);
            var dataKeyValue = this.dataKey ? String(this.resolveFieldData(rangeRowData, this.dataKey)) : null;
            if (dataKeyValue) {
                this.selectionKeys[dataKeyValue] = 1;
            }
            this.onRowSelect.emit({ originalEvent: event, data: rangeRowData, type: 'row' });
        }
    };
    DataTable.prototype.handleRowClick = function (event, rowData, index) {
        if (this.preventRowClickPropagation) {
            this.preventRowClickPropagation = false;
            return;
        }
        var targetNode = event.target.nodeName;
        if (this.editable) {
            var cell = this.findCell(event.target);
            var column = this.columns[this.domHandler.index(cell)];
            if (column.editable) {
                this.switchCellToEditMode(cell, column, rowData);
                return;
            }
        }
        if (targetNode == 'INPUT' || targetNode == 'BUTTON' || targetNode == 'A' || (this.domHandler.hasClass(event.target, 'ui-clickable'))) {
            return;
        }
        this.onRowClick.next({ originalEvent: event, data: rowData });
        if (this.selectionMode) {
            if (this.isMultipleSelectionMode() && event.shiftKey && this.anchorRowIndex != null) {
                this.domHandler.clearSelection();
                if (this.rangeRowIndex != null) {
                    this.clearSelectionRange();
                }
                this.rangeRowIndex = index;
                this.selectRange(index);
            }
            else {
                var selected = this.isSelected(rowData);
                var metaSelection = this.rowTouched ? false : this.metaKeySelection;
                var dataKeyValue = this.dataKey ? String(this.resolveFieldData(rowData, this.dataKey)) : null;
                this.anchorRowIndex = index;
                this.rangeRowIndex = index;
                if (metaSelection) {
                    var metaKey = event.metaKey || event.ctrlKey;
                    if (selected && metaKey) {
                        if (this.isSingleSelectionMode()) {
                            this._selection = null;
                            this.selectionKeys = {};
                            this.selectionChange.emit(null);
                        }
                        else {
                            var selectionIndex_1 = this.findIndexInSelection(rowData);
                            this._selection = this.selection.filter(function (val, i) { return i != selectionIndex_1; });
                            this.selectionChange.emit(this.selection);
                            if (dataKeyValue) {
                                delete this.selectionKeys[dataKeyValue];
                            }
                        }
                        this.onRowUnselect.emit({ originalEvent: event, data: rowData, type: 'row' });
                    }
                    else {
                        if (this.isSingleSelectionMode()) {
                            this._selection = rowData;
                            this.selectionChange.emit(rowData);
                            if (dataKeyValue) {
                                this.selectionKeys = {};
                                this.selectionKeys[dataKeyValue] = 1;
                            }
                        }
                        else if (this.isMultipleSelectionMode()) {
                            if (metaKey) {
                                this._selection = this.selection || [];
                            }
                            else {
                                this._selection = [];
                                this.selectionKeys = {};
                            }
                            this._selection = this.selection.concat([rowData]);
                            this.selectionChange.emit(this.selection);
                            if (dataKeyValue) {
                                this.selectionKeys[dataKeyValue] = 1;
                            }
                        }
                        this.onRowSelect.emit({ originalEvent: event, data: rowData, type: 'row' });
                    }
                }
                else {
                    if (this.isSingleSelectionMode()) {
                        if (selected) {
                            this._selection = null;
                            this.selectionKeys = {};
                            this.onRowUnselect.emit({ originalEvent: event, data: rowData, type: 'row' });
                        }
                        else {
                            this._selection = rowData;
                            this.onRowSelect.emit({ originalEvent: event, data: rowData, type: 'row' });
                            if (dataKeyValue) {
                                this.selectionKeys = {};
                                this.selectionKeys[dataKeyValue] = 1;
                            }
                        }
                    }
                    else {
                        if (selected) {
                            var selectionIndex_2 = this.findIndexInSelection(rowData);
                            this._selection = this.selection.filter(function (val, i) { return i != selectionIndex_2; });
                            this.onRowUnselect.emit({ originalEvent: event, data: rowData, type: 'row' });
                            if (dataKeyValue) {
                                delete this.selectionKeys[dataKeyValue];
                            }
                        }
                        else {
                            this._selection = (this.selection || []).concat([rowData]);
                            this.onRowSelect.emit({ originalEvent: event, data: rowData, type: 'row' });
                            if (dataKeyValue) {
                                this.selectionKeys[dataKeyValue] = 1;
                            }
                        }
                    }
                    this.selectionChange.emit(this.selection);
                }
            }
            this.preventSelectionKeysPropagation = true;
        }
        this.rowTouched = false;
    };
    DataTable.prototype.handleRowTouchEnd = function (event) {
        this.rowTouched = true;
    };
    DataTable.prototype.selectRowWithRadio = function (event, rowData) {
        if (this.selection != rowData) {
            this._selection = rowData;
            this.selectionChange.emit(this.selection);
            this.onRowSelect.emit({ originalEvent: event, data: rowData, type: 'radiobutton' });
            if (this.dataKey) {
                this.selectionKeys = {};
                this.selectionKeys[String(this.resolveFieldData(rowData, this.dataKey))] = 1;
            }
        }
        else {
            this._selection = null;
            this.selectionChange.emit(this.selection);
            this.onRowUnselect.emit({ originalEvent: event, data: rowData, type: 'radiobutton' });
        }
        this.preventSelectionKeysPropagation = true;
        this.preventRowClickPropagation = true;
    };
    DataTable.prototype.toggleRowWithCheckbox = function (event, rowData) {
        var selectionIndex = this.findIndexInSelection(rowData);
        this.selection = this.selection || [];
        var dataKeyValue = this.dataKey ? String(this.resolveFieldData(rowData, this.dataKey)) : null;
        if (selectionIndex != -1) {
            this._selection = this.selection.filter(function (val, i) { return i != selectionIndex; });
            this.onRowUnselect.emit({ originalEvent: event, data: rowData, type: 'checkbox' });
            if (dataKeyValue) {
                delete this.selectionKeys[dataKeyValue];
            }
        }
        else {
            this._selection = this.selection.concat([rowData]);
            this.onRowSelect.emit({ originalEvent: event, data: rowData, type: 'checkbox' });
            if (dataKeyValue) {
                this.selectionKeys[dataKeyValue] = 1;
            }
        }
        this.selectionChange.emit(this.selection);
        this.preventSelectionKeysPropagation = true;
        this.preventRowClickPropagation = true;
    };
    DataTable.prototype.toggleRowsWithCheckbox = function (event) {
        if (event.checked)
            this.selection = this.headerCheckboxToggleAllPages ? this.value.slice() : this.dataToRender.slice();
        else
            this.selection = [];
        this.selectionChange.emit(this.selection);
        this.onHeaderCheckboxToggle.emit({ originalEvent: event, checked: event.checked });
    };
    DataTable.prototype.onRowRightClick = function (event, rowData) {
        if (this.contextMenu) {
            var selectionIndex = this.findIndexInSelection(rowData);
            var selected = selectionIndex != -1;
            var dataKeyValue = this.dataKey ? String(this.resolveFieldData(rowData, this.dataKey)) : null;
            if (!selected) {
                if (this.isSingleSelectionMode()) {
                    this.selection = rowData;
                    this.selectionChange.emit(rowData);
                }
                else if (this.isMultipleSelectionMode()) {
                    this.selection = [rowData];
                    this.selectionChange.emit(this.selection);
                }
                if (this.dataKey) {
                    this.selectionKeys[String(this.resolveFieldData(rowData, this.dataKey))] = 1;
                }
            }
            this.contextMenu.show(event);
            this.onContextMenuSelect.emit({ originalEvent: event, data: rowData });
        }
        this.preventSelectionKeysPropagation = true;
    };
    DataTable.prototype.rowDblclick = function (event, rowData) {
        this.onRowDblclick.emit({ originalEvent: event, data: rowData });
    };
    DataTable.prototype.isSingleSelectionMode = function () {
        return this.selectionMode === 'single';
    };
    DataTable.prototype.isMultipleSelectionMode = function () {
        return this.selectionMode === 'multiple';
    };
    DataTable.prototype.findIndexInSelection = function (rowData) {
        var index = -1;
        if (this.selection) {
            for (var i = 0; i < this.selection.length; i++) {
                if (this.equals(rowData, this.selection[i])) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    DataTable.prototype.isSelected = function (rowData) {
        if (rowData && this.selection) {
            if (this.dataKey) {
                return this.selectionKeys[this.objectUtils.resolveFieldData(rowData, this.dataKey)] !== undefined;
            }
            else {
                if (this.selection instanceof Array)
                    return this.findIndexInSelection(rowData) > -1;
                else
                    return this.equals(rowData, this.selection);
            }
        }
        return false;
    };
    DataTable.prototype.equals = function (data1, data2) {
        return this.compareSelectionBy === 'equals' ? (data1 === data2) : this.objectUtils.equals(data1, data2, this.dataKey);
    };
    Object.defineProperty(DataTable.prototype, "allSelected", {
        get: function () {
            if (this.headerCheckboxToggleAllPages) {
                return this.selection && this.value && this.selection.length === this.value.length;
            }
            else {
                var val = true;
                if (this.dataToRender && this.selection && (this.dataToRender.length <= this.selection.length)) {
                    for (var _i = 0, _a = this.dataToRender; _i < _a.length; _i++) {
                        var data = _a[_i];
                        if (!this.isSelected(data)) {
                            val = false;
                            break;
                        }
                    }
                }
                else {
                    val = false;
                }
                return val;
            }
        },
        enumerable: true,
        configurable: true
    });
    DataTable.prototype.onFilterKeyup = function (value, field, matchMode) {
        var _this = this;
        if (this.filterTimeout) {
            clearTimeout(this.filterTimeout);
        }
        this.filterTimeout = setTimeout(function () {
            _this.filter(value, field, matchMode);
            _this.filterTimeout = null;
        }, this.filterDelay);
    };
    DataTable.prototype.filter = function (value, field, matchMode) {
        if (!this.isFilterBlank(value))
            this.filters[field] = { value: value, matchMode: matchMode };
        else if (this.filters[field])
            delete this.filters[field];
        this._filter();
    };
    DataTable.prototype.isFilterBlank = function (filter) {
        if (filter !== null && filter !== undefined) {
            if ((typeof filter === 'string' && filter.trim().length == 0) || (filter instanceof Array && filter.length == 0))
                return true;
            else
                return false;
        }
        return true;
    };
    DataTable.prototype._filter = function () {
        this._first = 0;
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata());
        }
        else {
            this.filteredValue = [];
            for (var i = 0; i < this.value.length; i++) {
                var localMatch = true;
                var globalMatch = false;
                for (var j = 0; j < this.columns.length; j++) {
                    var col = this.columns[j], filterMeta = this.filters[col.field];
                    //local
                    if (filterMeta) {
                        var filterValue = filterMeta.value, filterField = col.field, filterMatchMode = filterMeta.matchMode || 'startsWith', dataFieldValue = this.resolveFieldData(this.value[i], filterField);
                        var filterConstraint = this.filterConstraints[filterMatchMode];
                        if (!filterConstraint(dataFieldValue, filterValue)) {
                            localMatch = false;
                        }
                        if (!localMatch) {
                            break;
                        }
                    }
                    //global
                    if (this.globalFilter && !globalMatch) {
                        globalMatch = this.filterConstraints['contains'](this.resolveFieldData(this.value[i], col.field), this.globalFilter.value);
                    }
                }
                var matches = localMatch;
                if (this.globalFilter) {
                    matches = localMatch && globalMatch;
                }
                if (matches) {
                    this.filteredValue.push(this.value[i]);
                }
            }
            if (this.filteredValue.length === this.value.length) {
                this.filteredValue = null;
            }
            if (this.paginator) {
                this.totalRecords = this.filteredValue ? this.filteredValue.length : this.value ? this.value.length : 0;
            }
            this.updateDataToRender(this.filteredValue || this.value);
        }
        this.onFilter.emit({
            filters: this.filters,
            filteredValue: this.filteredValue || this.value
        });
    };
    DataTable.prototype.hasFilter = function () {
        var empty = true;
        for (var prop in this.filters) {
            if (this.filters.hasOwnProperty(prop)) {
                empty = false;
                break;
            }
        }
        return !empty || (this.globalFilter && this.globalFilter.value && this.globalFilter.value.trim().length);
    };
    DataTable.prototype.onFilterInputClick = function (event) {
        event.stopPropagation();
    };
    DataTable.prototype.switchCellToEditMode = function (cell, column, rowData) {
        var _this = this;
        if (!this.selectionMode && this.editable && column.editable) {
            this.editorClick = true;
            this.bindDocumentEditListener();
            if (cell != this.editingCell) {
                if (this.editingCell && this.domHandler.find(this.editingCell, '.ng-invalid.ng-dirty').length == 0) {
                    this.domHandler.removeClass(this.editingCell, 'ui-cell-editing');
                }
                this.editingCell = cell;
                this.onEditInit.emit({ column: column, data: rowData });
                this.domHandler.addClass(cell, 'ui-cell-editing');
                var focusable_1 = this.domHandler.findSingle(cell, '.ui-cell-editor input');
                if (focusable_1) {
                    setTimeout(function () { return _this.domHandler.invokeElementMethod(focusable_1, 'focus'); }, 50);
                }
            }
        }
    };
    DataTable.prototype.switchCellToViewMode = function (element) {
        this.editingCell = null;
        var cell = this.findCell(element);
        this.domHandler.removeClass(this.editingCell, 'ui-cell-editing');
        this.unbindDocumentEditListener();
    };
    DataTable.prototype.closeCell = function () {
        if (this.editingCell) {
            this.domHandler.removeClass(this.editingCell, 'ui-cell-editing');
            this.editingCell = null;
            this.unbindDocumentEditListener();
        }
    };
    DataTable.prototype.bindDocumentEditListener = function () {
        var _this = this;
        if (!this.documentEditListener) {
            this.documentEditListener = this.renderer.listen('document', 'click', function (event) {
                if (!_this.editorClick) {
                    _this.closeCell();
                }
                _this.editorClick = false;
            });
        }
    };
    DataTable.prototype.unbindDocumentEditListener = function () {
        if (this.documentEditListener) {
            this.documentEditListener();
            this.documentEditListener = null;
        }
    };
    DataTable.prototype.onCellEditorKeydown = function (event, column, rowData, rowIndex) {
        if (this.editable) {
            this.onEdit.emit({ originalEvent: event, column: column, data: rowData, index: rowIndex });
            //enter
            if (event.keyCode == 13) {
                this.onEditComplete.emit({ column: column, data: rowData, index: rowIndex });
                this.domHandler.invokeElementMethod(event.target, 'blur');
                this.switchCellToViewMode(event.target);
                event.preventDefault();
            }
            else if (event.keyCode == 27) {
                this.onEditCancel.emit({ column: column, data: rowData, index: rowIndex });
                this.domHandler.invokeElementMethod(event.target, 'blur');
                this.switchCellToViewMode(event.target);
                event.preventDefault();
            }
            else if (event.keyCode == 9) {
                this.onEditComplete.emit({ column: column, data: rowData, index: rowIndex });
                if (event.shiftKey)
                    this.moveToPreviousCell(event);
                else
                    this.moveToNextCell(event);
            }
        }
    };
    DataTable.prototype.moveToPreviousCell = function (event) {
        var currentCell = this.findCell(event.target);
        var row = currentCell.parentElement;
        var targetCell = this.findPreviousEditableColumn(currentCell);
        if (targetCell) {
            this.domHandler.invokeElementMethod(targetCell, 'click');
            event.preventDefault();
        }
    };
    DataTable.prototype.moveToNextCell = function (event) {
        var currentCell = this.findCell(event.target);
        var row = currentCell.parentElement;
        var targetCell = this.findNextEditableColumn(currentCell);
        if (targetCell) {
            this.domHandler.invokeElementMethod(targetCell, 'click');
            event.preventDefault();
        }
    };
    DataTable.prototype.findPreviousEditableColumn = function (cell) {
        var prevCell = cell.previousElementSibling;
        if (!prevCell) {
            var previousRow = cell.parentElement.previousElementSibling;
            if (previousRow) {
                prevCell = previousRow.lastElementChild;
            }
        }
        if (prevCell) {
            if (this.domHandler.hasClass(prevCell, 'ui-editable-column'))
                return prevCell;
            else
                return this.findPreviousEditableColumn(prevCell);
        }
        else {
            return null;
        }
    };
    DataTable.prototype.findNextEditableColumn = function (cell) {
        var nextCell = cell.nextElementSibling;
        if (!nextCell) {
            var nextRow = cell.parentElement.nextElementSibling;
            if (nextRow) {
                nextCell = nextRow.firstElementChild;
            }
        }
        if (nextCell) {
            if (this.domHandler.hasClass(nextCell, 'ui-editable-column'))
                return nextCell;
            else
                return this.findNextEditableColumn(nextCell);
        }
        else {
            return null;
        }
    };
    DataTable.prototype.onCustomEditorFocusPrev = function (event) {
        this.moveToPreviousCell(event);
    };
    DataTable.prototype.onCustomEditorFocusNext = function (event) {
        this.moveToNextCell(event);
    };
    DataTable.prototype.findCell = function (element) {
        var cell = element;
        while (cell.tagName != 'TD') {
            cell = cell.parentElement;
        }
        return cell;
    };
    DataTable.prototype.initResizableColumns = function () {
        this.tbody = this.domHandler.findSingle(this.el.nativeElement, 'tbody.ui-datatable-data');
        this.resizerHelper = this.domHandler.findSingle(this.el.nativeElement, 'div.ui-column-resizer-helper');
        this.fixColumnWidths();
    };
    DataTable.prototype.onDocumentMouseMove = function (event) {
        if (this.columnResizing) {
            this.onColumnResize(event);
        }
    };
    DataTable.prototype.onDocumentMouseUp = function (event) {
        if (this.columnResizing) {
            this.columnResizing = false;
            this.onColumnResizeEnd(event);
        }
    };
    DataTable.prototype.bindColumnResizeEvents = function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            window.document.addEventListener('mousemove', _this.onDocumentMouseMove.bind(_this));
        });
        this.documentColumnResizeEndListener = this.renderer.listen('document', 'mouseup', function (event) {
            if (_this.columnResizing) {
                _this.columnResizing = false;
                _this.onColumnResizeEnd(event);
            }
        });
    };
    DataTable.prototype.unbindColumnResizeEvents = function () {
        window.document.removeEventListener('mousemove', this.onDocumentMouseMove);
        if (this.documentColumnResizeEndListener) {
            this.documentColumnResizeEndListener();
            this.documentColumnResizeEndListener = null;
        }
    };
    DataTable.prototype.initColumnResize = function (event) {
        this.bindColumnResizeEvents();
        var container = this.el.nativeElement.children[0];
        var containerLeft = this.domHandler.getOffset(container).left;
        this.resizeColumn = event.target.parentElement;
        this.columnResizing = true;
        this.lastResizerHelperX = (event.pageX - containerLeft + container.scrollLeft);
    };
    DataTable.prototype.onColumnResize = function (event) {
        var container = this.el.nativeElement.children[0];
        var containerLeft = this.domHandler.getOffset(container).left;
        this.domHandler.addClass(container, 'ui-unselectable-text');
        this.resizerHelper.style.height = container.offsetHeight + 'px';
        this.resizerHelper.style.top = 0 + 'px';
        this.resizerHelper.style.left = (event.pageX - containerLeft + container.scrollLeft) + 'px';
        this.resizerHelper.style.display = 'block';
    };
    DataTable.prototype.onColumnResizeEnd = function (event) {
        var delta = this.resizerHelper.offsetLeft - this.lastResizerHelperX;
        var columnWidth = this.resizeColumn.offsetWidth;
        var newColumnWidth = columnWidth + delta;
        var minWidth = this.resizeColumn.style.minWidth || 15;
        if (columnWidth + delta > parseInt(minWidth)) {
            if (this.columnResizeMode === 'fit') {
                var nextColumn = this.resizeColumn.nextElementSibling;
                var nextColumnWidth = nextColumn.offsetWidth - delta;
                if (newColumnWidth > 15 && nextColumnWidth > 15) {
                    this.resizeColumn.style.width = newColumnWidth + 'px';
                    if (nextColumn) {
                        nextColumn.style.width = nextColumnWidth + 'px';
                    }
                    if (this.scrollable) {
                        var colGroup = this.domHandler.findSingle(this.el.nativeElement, 'colgroup.ui-datatable-scrollable-colgroup');
                        var resizeColumnIndex = this.domHandler.index(this.resizeColumn);
                        colGroup.children[resizeColumnIndex].style.width = newColumnWidth + 'px';
                        if (nextColumn) {
                            colGroup.children[resizeColumnIndex + 1].style.width = nextColumnWidth + 'px';
                        }
                    }
                }
            }
            else if (this.columnResizeMode === 'expand') {
                this.tbody.parentElement.style.width = this.tbody.parentElement.offsetWidth + delta + 'px';
                this.resizeColumn.style.width = newColumnWidth + 'px';
                var containerWidth = this.tbody.parentElement.style.width;
                if (this.scrollable) {
                    this.domHandler.findSingle(this.el.nativeElement, '.ui-datatable-scrollable-header-box').children[0].style.width = containerWidth;
                    var colGroup = this.domHandler.findSingle(this.el.nativeElement, 'colgroup.ui-datatable-scrollable-colgroup');
                    var resizeColumnIndex = this.domHandler.index(this.resizeColumn);
                    colGroup.children[resizeColumnIndex].style.width = newColumnWidth + 'px';
                }
                else {
                    this.el.nativeElement.children[0].style.width = containerWidth;
                }
            }
            this.onColResize.emit({
                element: this.resizeColumn,
                delta: delta
            });
        }
        this.resizerHelper.style.display = 'none';
        this.resizeColumn = null;
        this.domHandler.removeClass(this.el.nativeElement.children[0], 'ui-unselectable-text');
        this.unbindColumnResizeEvents();
    };
    DataTable.prototype.fixColumnWidths = function () {
        var columns = this.domHandler.find(this.el.nativeElement, 'th.ui-resizable-column');
        var bodyCols;
        for (var i = 0; i < columns.length; i++) {
            columns[i].style.width = columns[i].offsetWidth + 'px';
        }
        if (this.scrollable) {
            var colGroup = this.domHandler.findSingle(this.el.nativeElement, 'colgroup.ui-datatable-scrollable-colgroup');
            bodyCols = colGroup.children;
            if (bodyCols) {
                for (var i = 0; i < columns.length; i++) {
                    bodyCols[i].style.width = columns[i].offsetWidth + 'px';
                }
            }
        }
    };
    DataTable.prototype.onColumnDragStart = function (event) {
        var _this = this;
        if (this.columnResizing) {
            event.preventDefault();
            return;
        }
        this.draggedColumn = this.findParentHeader(event.target);
        event.dataTransfer.setData('text', 'b'); // Firefox requires this to make dragging possible
        this.zone.runOutsideAngular(function () {
            window.document.addEventListener('dragover', _this.onColumnDragover.bind(_this));
        });
    };
    DataTable.prototype.onColumnDragover = function (event) {
        var dropHeader = this.findParentHeader(event.target);
        if (this.reorderableColumns && this.draggedColumn && dropHeader) {
            event.preventDefault();
            var container = this.el.nativeElement.children[0];
            var containerOffset = this.domHandler.getOffset(container);
            var dropHeaderOffset = this.domHandler.getOffset(dropHeader);
            if (this.draggedColumn != dropHeader) {
                var targetLeft = dropHeaderOffset.left - containerOffset.left;
                var targetTop = containerOffset.top - dropHeaderOffset.top;
                var columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
                this.reorderIndicatorUp.style.top = dropHeaderOffset.top - containerOffset.top - (this.iconHeight - 1) + 'px';
                this.reorderIndicatorDown.style.top = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 'px';
                if (event.pageX > columnCenter) {
                    this.reorderIndicatorUp.style.left = (targetLeft + dropHeader.offsetWidth - Math.ceil(this.iconWidth / 2)) + 'px';
                    this.reorderIndicatorDown.style.left = (targetLeft + dropHeader.offsetWidth - Math.ceil(this.iconWidth / 2)) + 'px';
                    this.dropPosition = 1;
                }
                else {
                    this.reorderIndicatorUp.style.left = (targetLeft - Math.ceil(this.iconWidth / 2)) + 'px';
                    this.reorderIndicatorDown.style.left = (targetLeft - Math.ceil(this.iconWidth / 2)) + 'px';
                    this.dropPosition = -1;
                }
                this.reorderIndicatorUp.style.display = 'block';
                this.reorderIndicatorDown.style.display = 'block';
            }
            else {
                event.dataTransfer.dropEffect = 'none';
            }
        }
    };
    DataTable.prototype.onColumnDragleave = function (event) {
        if (this.reorderableColumns && this.draggedColumn) {
            event.preventDefault();
            this.reorderIndicatorUp.style.display = 'none';
            this.reorderIndicatorDown.style.display = 'none';
            window.document.removeEventListener('dragover', this.onColumnDragover);
        }
    };
    DataTable.prototype.onColumnDrop = function (event) {
        event.preventDefault();
        if (this.draggedColumn) {
            var dragIndex = this.domHandler.index(this.draggedColumn);
            var dropIndex = this.domHandler.index(this.findParentHeader(event.target));
            var allowDrop = (dragIndex != dropIndex);
            if (allowDrop && ((dropIndex - dragIndex == 1 && this.dropPosition === -1) || (dragIndex - dropIndex == 1 && this.dropPosition === 1))) {
                allowDrop = false;
            }
            if (allowDrop) {
                this.columns.splice(dropIndex, 0, this.columns.splice(dragIndex, 1)[0]);
                this.onColReorder.emit({
                    dragIndex: dragIndex,
                    dropIndex: dropIndex,
                    columns: this.columns
                });
            }
            this.reorderIndicatorUp.style.display = 'none';
            this.reorderIndicatorDown.style.display = 'none';
            this.draggedColumn.draggable = false;
            this.draggedColumn = null;
            this.dropPosition = null;
        }
    };
    DataTable.prototype.initColumnReordering = function () {
        this.reorderIndicatorUp = this.domHandler.findSingle(this.el.nativeElement.children[0], 'span.ui-datatable-reorder-indicator-up');
        this.reorderIndicatorDown = this.domHandler.findSingle(this.el.nativeElement.children[0], 'span.ui-datatable-reorder-indicator-down');
        this.iconWidth = this.domHandler.getHiddenElementOuterWidth(this.reorderIndicatorUp);
        this.iconHeight = this.domHandler.getHiddenElementOuterHeight(this.reorderIndicatorUp);
    };
    DataTable.prototype.findParentHeader = function (element) {
        if (element.nodeName == 'TH') {
            return element;
        }
        else {
            var parent_1 = element.parentElement;
            while (parent_1.nodeName != 'TH') {
                parent_1 = parent_1.parentElement;
                if (!parent_1)
                    break;
            }
            return parent_1;
        }
    };
    DataTable.prototype.hasFooter = function () {
        if (this.footerColumnGroup) {
            return true;
        }
        else {
            if (this.columns) {
                for (var i = 0; i < this.columns.length; i++) {
                    if (this.columns[i].footer) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    DataTable.prototype.isEmpty = function () {
        return !this.dataToRender || (this.dataToRender.length == 0);
    };
    DataTable.prototype.createLazyLoadMetadata = function () {
        return {
            first: this.first,
            rows: this.virtualScroll ? this.rows * 2 : this.rows,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            filters: this.filters,
            globalFilter: this.globalFilter ? this.globalFilter.value : null,
            multiSortMeta: this.multiSortMeta
        };
    };
    DataTable.prototype.toggleRow = function (row, event) {
        if (!this.expandedRows) {
            this.expandedRows = [];
        }
        var expandedRowIndex = this.findExpandedRowIndex(row);
        if (expandedRowIndex != -1) {
            this.expandedRows.splice(expandedRowIndex, 1);
            this.onRowCollapse.emit({
                originalEvent: event,
                data: row
            });
        }
        else {
            if (this.rowExpandMode === 'single') {
                this.expandedRows = [];
            }
            this.expandedRows.push(row);
            this.onRowExpand.emit({
                originalEvent: event,
                data: row
            });
        }
        if (event) {
            event.preventDefault();
        }
    };
    DataTable.prototype.findExpandedRowIndex = function (row) {
        var index = -1;
        if (this.expandedRows) {
            for (var i = 0; i < this.expandedRows.length; i++) {
                if (this.expandedRows[i] == row) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    DataTable.prototype.isRowExpanded = function (row) {
        return this.findExpandedRowIndex(row) != -1;
    };
    DataTable.prototype.findExpandedRowGroupIndex = function (row) {
        var index = -1;
        if (this.expandedRowsGroups && this.expandedRowsGroups.length) {
            for (var i = 0; i < this.expandedRowsGroups.length; i++) {
                var group = this.expandedRowsGroups[i];
                var rowGroupField = this.resolveFieldData(row, this.groupField);
                if (rowGroupField === group) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    DataTable.prototype.isRowGroupExpanded = function (row) {
        return this.findExpandedRowGroupIndex(row) != -1;
    };
    DataTable.prototype.toggleRowGroup = function (event, row) {
        this.rowGroupToggleClick = true;
        var index = this.findExpandedRowGroupIndex(row);
        var rowGroupField = this.resolveFieldData(row, this.groupField);
        if (index >= 0) {
            this.expandedRowsGroups.splice(index, 1);
            this.onRowGroupCollapse.emit({
                originalEvent: event,
                group: rowGroupField
            });
        }
        else {
            this.expandedRowsGroups = this.expandedRowsGroups || [];
            this.expandedRowsGroups.push(rowGroupField);
            this.onRowGroupExpand.emit({
                originalEvent: event,
                group: rowGroupField
            });
        }
        event.preventDefault();
    };
    DataTable.prototype.reset = function () {
        this.sortField = null;
        this.sortOrder = 1;
        this.filteredValue = null;
        this.filters = {};
        this._first = 0;
        this.firstChange.emit(this._first);
        this.updateTotalRecords();
        if (this.lazy)
            this.onLazyLoad.emit(this.createLazyLoadMetadata());
        else
            this.updateDataToRender(this.value);
    };
    DataTable.prototype.exportCSV = function () {
        var _this = this;
        var data = this.filteredValue || this.value;
        var csv = '\ufeff';
        //headers
        for (var i = 0; i < this.columns.length; i++) {
            if (this.columns[i].field) {
                csv += '"' + (this.columns[i].header || this.columns[i].field) + '"';
                if (i < (this.columns.length - 1)) {
                    csv += this.csvSeparator;
                }
            }
        }
        //body        
        data.forEach(function (record, i) {
            csv += '\n';
            for (var i_1 = 0; i_1 < _this.columns.length; i_1++) {
                if (_this.columns[i_1].field) {
                    csv += '"' + _this.resolveFieldData(record, _this.columns[i_1].field) + '"';
                    if (i_1 < (_this.columns.length - 1)) {
                        csv += _this.csvSeparator;
                    }
                }
            }
        });
        var blob = new Blob([csv], {
            type: 'text/csv;charset=utf-8;'
        });
        if (window.navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, this.exportFilename + '.csv');
        }
        else {
            var link = document.createElement("a");
            link.style.display = 'none';
            document.body.appendChild(link);
            if (link.download !== undefined) {
                link.setAttribute('href', URL.createObjectURL(blob));
                link.setAttribute('download', this.exportFilename + '.csv');
                link.click();
            }
            else {
                csv = 'data:text/csv;charset=utf-8,' + csv;
                window.open(encodeURI(csv));
            }
            document.body.removeChild(link);
        }
    };
    DataTable.prototype.getBlockableElement = function () {
        return this.el.nativeElement.children[0];
    };
    DataTable.prototype.getRowStyleClass = function (rowData, rowIndex) {
        var styleClass = 'ui-widget-content';
        if (this.rowStyleClass) {
            var rowClass = this.rowStyleClass.call(this, rowData, rowIndex);
            if (rowClass) {
                styleClass += ' ' + rowClass;
            }
        }
        return styleClass;
    };
    DataTable.prototype.visibleColumns = function () {
        return this.columns ? this.columns.filter(function (c) { return !c.hidden; }) : [];
    };
    Object.defineProperty(DataTable.prototype, "containerWidth", {
        get: function () {
            if (this.scrollable) {
                if (this.scrollWidth) {
                    return this.scrollWidth;
                }
                else if (this.frozenWidth && this.unfrozenWidth) {
                    return parseFloat(this.frozenWidth) + parseFloat(this.unfrozenWidth) + 'px';
                }
            }
            else {
                return this.style ? this.style.width : null;
            }
        },
        enumerable: true,
        configurable: true
    });
    DataTable.prototype.ngOnDestroy = function () {
        //remove event listener
        if (this.globalFilterFunction) {
            this.globalFilterFunction();
        }
        if (this.resizableColumns) {
            this.unbindColumnResizeEvents();
        }
        this.unbindDocumentEditListener();
        if (this.columnsSubscription) {
            this.columnsSubscription.unsubscribe();
        }
    };
    return DataTable;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "paginator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataTable.prototype, "rows", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataTable.prototype, "pageLinks", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], DataTable.prototype, "rowsPerPageOptions", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "responsive", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "stacked", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "selectionMode", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "selectionChange", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "editable", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onRowClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onRowSelect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onRowUnselect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onRowDblclick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onHeaderCheckboxToggle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "headerCheckboxToggleAllPages", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onContextMenuSelect", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataTable.prototype, "filterDelay", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "lazy", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onLazyLoad", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "resizableColumns", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "columnResizeMode", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onColResize", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "reorderableColumns", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onColReorder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "scrollable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "virtualScroll", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "scrollHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "scrollWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "frozenWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "unfrozenWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "tableStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "tableStyleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "globalFilter", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "sortMode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "sortField", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataTable.prototype, "sortOrder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "groupField", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], DataTable.prototype, "multiSortMeta", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "contextMenu", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "csvSeparator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "exportFilename", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "emptyMessage", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "paginatorPosition", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "alwaysShowPaginator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "metaKeySelection", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Function)
], DataTable.prototype, "rowTrackBy", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "immutable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "compareSelectionBy", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onEditInit", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onEditComplete", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onEdit", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onEditCancel", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onPage", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onSort", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onFilter", void 0);
__decorate([
    core_1.ContentChild(shared_2.Header),
    __metadata("design:type", Object)
], DataTable.prototype, "header", void 0);
__decorate([
    core_1.ContentChild(shared_2.Footer),
    __metadata("design:type", Object)
], DataTable.prototype, "footer", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "expandableRows", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], DataTable.prototype, "expandedRows", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "expandableRowGroups", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "rowExpandMode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], DataTable.prototype, "expandedRowsGroups", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], DataTable.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Function)
], DataTable.prototype, "rowStyleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "rowGroupMode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "sortableRowGroup", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "sortFile", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "rowHover", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTable.prototype, "filters", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "dataKey", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTable.prototype, "loading", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTable.prototype, "loadingIcon", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "firstChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onRowExpand", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onRowCollapse", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onRowGroupExpand", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTable.prototype, "onRowGroupCollapse", void 0);
__decorate([
    core_1.ContentChildren(shared_2.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], DataTable.prototype, "templates", void 0);
__decorate([
    core_1.ContentChildren(shared_2.Column),
    __metadata("design:type", core_1.QueryList)
], DataTable.prototype, "cols", void 0);
__decorate([
    core_1.ContentChild(shared_2.HeaderColumnGroup),
    __metadata("design:type", shared_2.HeaderColumnGroup)
], DataTable.prototype, "headerColumnGroup", void 0);
__decorate([
    core_1.ContentChild(shared_2.FooterColumnGroup),
    __metadata("design:type", shared_2.FooterColumnGroup)
], DataTable.prototype, "footerColumnGroup", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], DataTable.prototype, "value", null);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], DataTable.prototype, "first", null);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], DataTable.prototype, "totalRecords", null);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DataTable.prototype, "selection", null);
DataTable = __decorate([
    core_1.Component({
        selector: 'p-dataTable',
        template: "\n        <div [ngStyle]=\"style\" [class]=\"styleClass\" [style.width]=\"containerWidth\"\n            [ngClass]=\"{'ui-datatable ui-widget':true,'ui-datatable-reflow':responsive,'ui-datatable-stacked':stacked,'ui-datatable-resizable':resizableColumns,'ui-datatable-scrollable':scrollable}\">\n            <div class=\"ui-datatable-loading ui-widget-overlay\" *ngIf=\"loading\"></div>\n            <div class=\"ui-datatable-loading-content\" *ngIf=\"loading\">\n                <i [class]=\"'fa fa-spin fa-2x ' + loadingIcon\"></i>\n            </div>\n            <div class=\"ui-datatable-header ui-widget-header\" *ngIf=\"header\">\n                <ng-content select=\"p-header\"></ng-content>\n            </div>\n            <p-paginator [rows]=\"rows\" [first]=\"first\" [totalRecords]=\"totalRecords\" [pageLinkSize]=\"pageLinks\" styleClass=\"ui-paginator-top\" [alwaysShow]=\"alwaysShowPaginator\"\n                (onPageChange)=\"onPageChange($event)\" [rowsPerPageOptions]=\"rowsPerPageOptions\" *ngIf=\"paginator && paginatorPosition =='top' || paginatorPosition =='both'\"></p-paginator>\n            <div class=\"ui-datatable-tablewrapper\" *ngIf=\"!scrollable\">\n                <table [class]=\"tableStyleClass\" [ngStyle]=\"tableStyle\">\n                    <thead class=\"ui-datatable-thead\">\n                        <tr *ngIf=\"!headerColumnGroup\" class=\"ui-state-default\" [pColumnHeaders]=\"columns\"></tr>\n                        <ng-template [ngIf]=\"headerColumnGroup\">\n                            <tr *ngFor=\"let headerRow of headerColumnGroup.rows\" class=\"ui-state-default\" [pColumnHeaders]=\"headerRow.columns\"></tr>\n                        </ng-template>\n                    </thead>\n                    <tfoot *ngIf=\"hasFooter()\" class=\"ui-datatable-tfoot\">\n                        <tr *ngIf=\"!footerColumnGroup\" class=\"ui-state-default\" [pColumnFooters]=\"columns\"></tr>\n                        <ng-template [ngIf]=\"footerColumnGroup\">\n                            <tr *ngFor=\"let footerRow of footerColumnGroup.rows\" class=\"ui-state-default\" [pColumnFooters]=\"footerRow.columns\"></tr>\n                        </ng-template>\n                    </tfoot>\n                    <tbody [ngClass]=\"{'ui-datatable-data ui-widget-content': true, 'ui-datatable-hoverable-rows': (rowHover||selectionMode)}\" [pTableBody]=\"columns\"></tbody>\n                </table>\n            </div>\n            \n            <ng-template [ngIf]=\"scrollable\">\n                <div class=\"ui-datatable-scrollable-wrapper ui-helper-clearfix\" [ngClass]=\"{'max-height':scrollHeight}\">\n                    <div *ngIf=\"frozenColumns\" [pScrollableView]=\"frozenColumns\" frozen=\"true\" \n                        [ngStyle]=\"{'width':this.frozenWidth}\" class=\"ui-datatable-scrollable-view ui-datatable-frozen-view\"></div>\n                    <div [pScrollableView]=\"scrollableColumns\" [ngStyle]=\"{'width':this.unfrozenWidth, 'left': this.frozenWidth}\"\n                        class=\"ui-datatable-scrollable-view\" [virtualScroll]=\"virtualScroll\" (onVirtualScroll)=\"onVirtualScroll($event)\"\n                        [ngClass]=\"{'ui-datatable-unfrozen-view': frozenColumns}\"></div>\n                </div>\n            </ng-template>\n            \n            <p-paginator [rows]=\"rows\" [first]=\"first\" [totalRecords]=\"totalRecords\" [pageLinkSize]=\"pageLinks\" styleClass=\"ui-paginator-bottom\" [alwaysShow]=\"alwaysShowPaginator\"\n                (onPageChange)=\"onPageChange($event)\" [rowsPerPageOptions]=\"rowsPerPageOptions\" *ngIf=\"paginator && paginatorPosition =='bottom' || paginatorPosition =='both'\"></p-paginator>\n            <div class=\"ui-datatable-footer ui-widget-header\" *ngIf=\"footer\">\n                <ng-content select=\"p-footer\"></ng-content>\n            </div>\n            \n            <div class=\"ui-column-resizer-helper ui-state-highlight\" style=\"display:none\"></div>\n            <span class=\"fa fa-arrow-down ui-datatable-reorder-indicator-up\" style=\"position: absolute; display: none;\"></span>\n            <span class=\"fa fa-arrow-up ui-datatable-reorder-indicator-down\" style=\"position: absolute; display: none;\"></span>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler, objectutils_1.ObjectUtils]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.IterableDiffers,
        core_1.Renderer2, core_1.ChangeDetectorRef, objectutils_1.ObjectUtils,
        core_1.NgZone])
], DataTable);
exports.DataTable = DataTable;
var DataTableModule = (function () {
    function DataTableModule() {
    }
    return DataTableModule;
}());
DataTableModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_1.SharedModule, paginator_1.PaginatorModule, forms_1.FormsModule],
        exports: [DataTable, shared_1.SharedModule],
        declarations: [DataTable, DTRadioButton, DTCheckbox, ColumnHeaders, ColumnFooters, TableBody, ScrollableView, RowExpansionLoader]
    })
], DataTableModule);
exports.DataTableModule = DataTableModule;
//# sourceMappingURL=datatable.js.map

/***/ }),

/***/ "./node_modules/primeng/components/defer/defer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var DeferredLoader = (function () {
    function DeferredLoader(el, domHandler, renderer, viewContainer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.viewContainer = viewContainer;
        this.onLoad = new core_1.EventEmitter();
    }
    DeferredLoader.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.shouldLoad()) {
            this.load();
        }
        this.documentScrollListener = this.renderer.listen('window', 'scroll', function () {
            if (_this.shouldLoad()) {
                _this.load();
                _this.documentScrollListener();
                _this.documentScrollListener = null;
            }
        });
    };
    DeferredLoader.prototype.shouldLoad = function () {
        var rect = this.el.nativeElement.getBoundingClientRect();
        var docElement = document.documentElement;
        var scrollTop = (window.pageYOffset || document.documentElement.scrollTop);
        var winHeight = docElement.clientHeight;
        return (winHeight >= rect.top);
    };
    DeferredLoader.prototype.load = function () {
        this.view = this.viewContainer.createEmbeddedView(this.template);
        this.onLoad.emit();
    };
    DeferredLoader.prototype.ngOnDestroy = function () {
        this.view = null;
        if (this.documentScrollListener) {
            this.documentScrollListener();
        }
    };
    return DeferredLoader;
}());
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DeferredLoader.prototype, "onLoad", void 0);
__decorate([
    core_1.ContentChild(core_1.TemplateRef),
    __metadata("design:type", core_1.TemplateRef)
], DeferredLoader.prototype, "template", void 0);
DeferredLoader = __decorate([
    core_1.Directive({
        selector: '[pDefer]',
        host: {},
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, core_1.ViewContainerRef])
], DeferredLoader);
exports.DeferredLoader = DeferredLoader;
var DeferModule = (function () {
    function DeferModule() {
    }
    return DeferModule;
}());
DeferModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [DeferredLoader],
        declarations: [DeferredLoader]
    })
], DeferModule);
exports.DeferModule = DeferModule;
//# sourceMappingURL=defer.js.map

/***/ }),

/***/ "./node_modules/primeng/components/dialog/dialog.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var Dialog = (function () {
    function Dialog(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.draggable = true;
        this.resizable = true;
        this.minWidth = 150;
        this.minHeight = 150;
        this.closeOnEscape = true;
        this.closable = true;
        this.responsive = true;
        this.showHeader = true;
        this.breakpoint = 640;
        this.blockScroll = false;
        this.onShow = new core_1.EventEmitter();
        this.onHide = new core_1.EventEmitter();
        this.visibleChange = new core_1.EventEmitter();
    }
    Object.defineProperty(Dialog.prototype, "visible", {
        get: function () {
            return this._visible;
        },
        set: function (val) {
            this._visible = val;
            if (this.initialized && this.containerViewChild && this.containerViewChild.nativeElement) {
                if (this._visible)
                    this.show();
                else {
                    if (this.preventVisibleChangePropagation)
                        this.preventVisibleChangePropagation = false;
                    else
                        this.hide();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Dialog.prototype.ngAfterViewChecked = function () {
        if (this.executePostDisplayActions) {
            this.onShow.emit({});
            this.positionOverlay();
            this.executePostDisplayActions = false;
        }
    };
    Dialog.prototype.show = function () {
        this.executePostDisplayActions = true;
        this.containerViewChild.nativeElement.style.zIndex = String(++domhandler_1.DomHandler.zindex);
        this.bindGlobalListeners();
        if (this.modal) {
            this.enableModality();
        }
    };
    Dialog.prototype.positionOverlay = function () {
        var viewport = this.domHandler.getViewport();
        if (this.domHandler.getOuterHeight(this.containerViewChild.nativeElement) > viewport.height) {
            this.contentViewChild.nativeElement.style.height = (viewport.height * .75) + 'px';
        }
        if (this.positionLeft >= 0 && this.positionTop >= 0) {
            this.containerViewChild.nativeElement.style.left = this.positionLeft + 'px';
            this.containerViewChild.nativeElement.style.top = this.positionTop + 'px';
        }
        else if (this.positionTop >= 0) {
            this.center();
            this.containerViewChild.nativeElement.style.top = this.positionTop + 'px';
        }
        else {
            this.center();
        }
    };
    Dialog.prototype.hide = function () {
        this.onHide.emit({});
        this.unbindMaskClickListener();
        this.unbindGlobalListeners();
        if (this.modal) {
            this.disableModality();
        }
    };
    Dialog.prototype.close = function (event) {
        this.preventVisibleChangePropagation = true;
        this.hide();
        this.visibleChange.emit(false);
        event.preventDefault();
    };
    Dialog.prototype.ngAfterViewInit = function () {
        this.initialized = true;
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.containerViewChild.nativeElement);
            else
                this.domHandler.appendChild(this.containerViewChild.nativeElement, this.appendTo);
        }
        if (this.visible) {
            this.show();
        }
    };
    Dialog.prototype.center = function () {
        var elementWidth = this.domHandler.getOuterWidth(this.containerViewChild.nativeElement);
        var elementHeight = this.domHandler.getOuterHeight(this.containerViewChild.nativeElement);
        if (elementWidth == 0 && elementHeight == 0) {
            this.containerViewChild.nativeElement.style.visibility = 'hidden';
            this.containerViewChild.nativeElement.style.display = 'block';
            elementWidth = this.domHandler.getOuterWidth(this.containerViewChild.nativeElement);
            elementHeight = this.domHandler.getOuterHeight(this.containerViewChild.nativeElement);
            this.containerViewChild.nativeElement.style.display = 'none';
            this.containerViewChild.nativeElement.style.visibility = 'visible';
        }
        var viewport = this.domHandler.getViewport();
        var x = Math.max((viewport.width - elementWidth) / 2, 0);
        var y = Math.max((viewport.height - elementHeight) / 2, 0);
        this.containerViewChild.nativeElement.style.left = x + 'px';
        this.containerViewChild.nativeElement.style.top = y + 'px';
    };
    Dialog.prototype.enableModality = function () {
        var _this = this;
        if (!this.mask) {
            this.mask = document.createElement('div');
            this.mask.style.zIndex = String(parseInt(this.containerViewChild.nativeElement.style.zIndex) - 1);
            this.domHandler.addMultipleClasses(this.mask, 'ui-widget-overlay ui-dialog-mask');
            if (this.closable && this.dismissableMask) {
                this.maskClickListener = this.renderer.listen(this.mask, 'click', function (event) {
                    _this.close(event);
                });
            }
            document.body.appendChild(this.mask);
            if (this.blockScroll) {
                this.domHandler.addClass(document.body, 'ui-overflow-hidden');
            }
        }
    };
    Dialog.prototype.disableModality = function () {
        if (this.mask) {
            document.body.removeChild(this.mask);
            if (this.blockScroll) {
                this.domHandler.removeClass(document.body, 'ui-overflow-hidden');
            }
            this.mask = null;
        }
    };
    Dialog.prototype.unbindMaskClickListener = function () {
        if (this.maskClickListener) {
            this.maskClickListener();
            this.maskClickListener = null;
        }
    };
    Dialog.prototype.moveOnTop = function () {
        this.containerViewChild.nativeElement.style.zIndex = String(++domhandler_1.DomHandler.zindex);
    };
    Dialog.prototype.onCloseMouseDown = function (event) {
        this.closeIconMouseDown = true;
    };
    Dialog.prototype.initDrag = function (event) {
        if (this.closeIconMouseDown) {
            this.closeIconMouseDown = false;
            return;
        }
        if (this.draggable) {
            this.dragging = true;
            this.lastPageX = event.pageX;
            this.lastPageY = event.pageY;
        }
    };
    Dialog.prototype.onDrag = function (event) {
        if (this.dragging) {
            var deltaX = event.pageX - this.lastPageX;
            var deltaY = event.pageY - this.lastPageY;
            var leftPos = parseInt(this.containerViewChild.nativeElement.style.left);
            var topPos = parseInt(this.containerViewChild.nativeElement.style.top);
            this.containerViewChild.nativeElement.style.left = leftPos + deltaX + 'px';
            this.containerViewChild.nativeElement.style.top = topPos + deltaY + 'px';
            this.lastPageX = event.pageX;
            this.lastPageY = event.pageY;
        }
    };
    Dialog.prototype.endDrag = function (event) {
        if (this.draggable) {
            this.dragging = false;
        }
    };
    Dialog.prototype.initResize = function (event) {
        if (this.resizable) {
            this.preWidth = null;
            this.resizing = true;
            this.lastPageX = event.pageX;
            this.lastPageY = event.pageY;
        }
    };
    Dialog.prototype.onResize = function (event) {
        if (this.resizing) {
            var deltaX = event.pageX - this.lastPageX;
            var deltaY = event.pageY - this.lastPageY;
            var containerWidth = this.domHandler.getOuterWidth(this.containerViewChild.nativeElement);
            var containerHeight = this.domHandler.getOuterHeight(this.containerViewChild.nativeElement);
            var contentHeight = this.domHandler.getOuterHeight(this.contentViewChild.nativeElement);
            var newWidth = containerWidth + deltaX;
            var newHeight = containerHeight + deltaY;
            if (newWidth > this.minWidth) {
                this.containerViewChild.nativeElement.style.width = newWidth + 'px';
            }
            if (newHeight > this.minHeight) {
                this.containerViewChild.nativeElement.style.height = newHeight + 'px';
                this.contentViewChild.nativeElement.style.height = contentHeight + deltaY + 'px';
            }
            this.lastPageX = event.pageX;
            this.lastPageY = event.pageY;
        }
    };
    Dialog.prototype.bindGlobalListeners = function () {
        if (this.draggable) {
            this.bindDocumentDragListener();
        }
        if (this.resizable) {
            this.bindDocumentResizeListeners();
        }
        if (this.responsive) {
            this.bindDocumentResponsiveListener();
        }
        if (this.closeOnEscape && this.closable) {
            this.bindDocumentEscapeListener();
        }
    };
    Dialog.prototype.unbindGlobalListeners = function () {
        this.unbindDocumentDragListener();
        this.unbindDocumentResizeListeners();
        this.unbindDocumentResponsiveListener();
        this.unbindDocumentEscapeListener();
    };
    Dialog.prototype.bindDocumentDragListener = function () {
        var _this = this;
        this.documentDragListener = this.renderer.listen('document', 'mousemove', function (event) {
            _this.onDrag(event);
        });
    };
    Dialog.prototype.unbindDocumentDragListener = function () {
        if (this.documentDragListener) {
            this.documentDragListener();
            this.documentDragListener = null;
        }
    };
    Dialog.prototype.bindDocumentResizeListeners = function () {
        var _this = this;
        this.documentResizeListener = this.renderer.listen('document', 'mousemove', function (event) {
            _this.onResize(event);
        });
        this.documentResizeEndListener = this.renderer.listen('document', 'mouseup', function (event) {
            if (_this.resizing) {
                _this.resizing = false;
            }
        });
    };
    Dialog.prototype.unbindDocumentResizeListeners = function () {
        if (this.documentResizeListener && this.documentResizeEndListener) {
            this.documentResizeListener();
            this.documentResizeEndListener();
            this.documentResizeListener = null;
            this.documentResizeEndListener = null;
        }
    };
    Dialog.prototype.bindDocumentResponsiveListener = function () {
        var _this = this;
        this.documentResponsiveListener = this.renderer.listen('window', 'resize', function (event) {
            var viewport = _this.domHandler.getViewport();
            var width = _this.domHandler.getOuterWidth(_this.containerViewChild.nativeElement);
            if (viewport.width <= _this.breakpoint) {
                if (!_this.preWidth) {
                    _this.preWidth = width;
                }
                _this.containerViewChild.nativeElement.style.left = '0px';
                _this.containerViewChild.nativeElement.style.width = '100%';
            }
            else {
                _this.containerViewChild.nativeElement.style.width = _this.preWidth + 'px';
                _this.positionOverlay();
            }
        });
    };
    Dialog.prototype.unbindDocumentResponsiveListener = function () {
        if (this.documentResponsiveListener) {
            this.documentResponsiveListener();
            this.documentResponsiveListener = null;
        }
    };
    Dialog.prototype.bindDocumentEscapeListener = function () {
        var _this = this;
        this.documentEscapeListener = this.renderer.listen('document', 'keydown', function (event) {
            if (event.which == 27) {
                if (parseInt(_this.containerViewChild.nativeElement.style.zIndex) == domhandler_1.DomHandler.zindex) {
                    _this.close(event);
                }
            }
        });
    };
    Dialog.prototype.unbindDocumentEscapeListener = function () {
        if (this.documentEscapeListener) {
            this.documentEscapeListener();
            this.documentEscapeListener = null;
        }
    };
    Dialog.prototype.ngOnDestroy = function () {
        this.initialized = false;
        this.disableModality();
        this.unbindGlobalListeners();
        if (this.appendTo) {
            this.el.nativeElement.appendChild(this.containerViewChild.nativeElement);
        }
        this.unbindMaskClickListener();
    };
    return Dialog;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dialog.prototype, "header", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "draggable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "resizable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Dialog.prototype, "minWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Dialog.prototype, "minHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Dialog.prototype, "width", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Dialog.prototype, "height", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Dialog.prototype, "positionLeft", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Dialog.prototype, "positionTop", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Dialog.prototype, "contentStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "modal", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "closeOnEscape", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "dismissableMask", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "rtl", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "closable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "responsive", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Dialog.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Dialog.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dialog.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "showHeader", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Dialog.prototype, "breakpoint", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dialog.prototype, "blockScroll", void 0);
__decorate([
    core_1.ContentChild(shared_1.Header),
    __metadata("design:type", Object)
], Dialog.prototype, "headerFacet", void 0);
__decorate([
    core_1.ContentChild(shared_1.Footer),
    __metadata("design:type", Object)
], Dialog.prototype, "footerFacet", void 0);
__decorate([
    core_1.ViewChild('container'),
    __metadata("design:type", core_1.ElementRef)
], Dialog.prototype, "containerViewChild", void 0);
__decorate([
    core_1.ViewChild('titlebar'),
    __metadata("design:type", core_1.ElementRef)
], Dialog.prototype, "headerViewChild", void 0);
__decorate([
    core_1.ViewChild('content'),
    __metadata("design:type", core_1.ElementRef)
], Dialog.prototype, "contentViewChild", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Dialog.prototype, "onShow", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Dialog.prototype, "onHide", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Dialog.prototype, "visibleChange", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], Dialog.prototype, "visible", null);
Dialog = __decorate([
    core_1.Component({
        selector: 'p-dialog',
        template: "\n        <div #container [ngClass]=\"{'ui-dialog ui-widget ui-widget-content ui-corner-all ui-shadow':true,'ui-dialog-rtl':rtl,'ui-dialog-draggable':draggable}\" [ngStyle]=\"style\" [class]=\"styleClass\"\n            [style.display]=\"visible ? 'block' : 'none'\" [style.width.px]=\"width\" [style.height.px]=\"height\" [style.minWidth.px]=\"minWidth\" (mousedown)=\"moveOnTop()\" [@dialogState]=\"visible ? 'visible' : 'hidden'\">\n            <div #titlebar class=\"ui-dialog-titlebar ui-widget-header ui-helper-clearfix ui-corner-top\"\n                (mousedown)=\"initDrag($event)\" (mouseup)=\"endDrag($event)\" *ngIf=\"showHeader\">\n                <span class=\"ui-dialog-title\" *ngIf=\"header\">{{header}}</span>\n                <span class=\"ui-dialog-title\" *ngIf=\"headerFacet\">\n                    <ng-content select=\"p-header\"></ng-content>\n                </span>\n                <a *ngIf=\"closable\" [ngClass]=\"{'ui-dialog-titlebar-icon ui-dialog-titlebar-close ui-corner-all':true}\" href=\"#\" role=\"button\" (click)=\"close($event)\" (mousedown)=\"onCloseMouseDown($event)\">\n                    <span class=\"fa fa-fw fa-close\"></span>\n                </a>\n            </div>\n            <div #content class=\"ui-dialog-content ui-widget-content\" [ngStyle]=\"contentStyle\">\n                <ng-content></ng-content>\n            </div>\n            <div class=\"ui-dialog-footer ui-widget-content\" *ngIf=\"footerFacet\">\n                <ng-content select=\"p-footer\"></ng-content>\n            </div>\n            <div *ngIf=\"resizable\" class=\"ui-resizable-handle ui-resizable-se ui-icon ui-icon-gripsmall-diagonal-se\" style=\"z-index: 90;\"\n                (mousedown)=\"initResize($event)\"></div>\n        </div>\n    ",
        animations: [
            animations_1.trigger('dialogState', [
                animations_1.state('hidden', animations_1.style({
                    opacity: 0
                })),
                animations_1.state('visible', animations_1.style({
                    opacity: 1
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms ease-in')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms ease-out'))
            ])
        ],
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], Dialog);
exports.Dialog = Dialog;
var DialogModule = (function () {
    function DialogModule() {
    }
    return DialogModule;
}());
DialogModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Dialog, shared_1.SharedModule],
        declarations: [Dialog]
    })
], DialogModule);
exports.DialogModule = DialogModule;
//# sourceMappingURL=dialog.js.map

/***/ }),

/***/ "./node_modules/primeng/components/dom/domhandler.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var DomHandler = (function () {
    function DomHandler() {
        this.calculatedScrollbarWidth = null;
    }
    DomHandler.prototype.addClass = function (element, className) {
        if (element.classList)
            element.classList.add(className);
        else
            element.className += ' ' + className;
    };
    DomHandler.prototype.addMultipleClasses = function (element, className) {
        if (element.classList) {
            var styles = className.split(' ');
            for (var i = 0; i < styles.length; i++) {
                element.classList.add(styles[i]);
            }
        }
        else {
            var styles = className.split(' ');
            for (var i = 0; i < styles.length; i++) {
                element.className += ' ' + styles[i];
            }
        }
    };
    DomHandler.prototype.removeClass = function (element, className) {
        if (element.classList)
            element.classList.remove(className);
        else
            element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
    };
    DomHandler.prototype.hasClass = function (element, className) {
        if (element.classList)
            return element.classList.contains(className);
        else
            return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
    };
    DomHandler.prototype.siblings = function (element) {
        return Array.prototype.filter.call(element.parentNode.children, function (child) {
            return child !== element;
        });
    };
    DomHandler.prototype.find = function (element, selector) {
        return element.querySelectorAll(selector);
    };
    DomHandler.prototype.findSingle = function (element, selector) {
        return element.querySelector(selector);
    };
    DomHandler.prototype.index = function (element) {
        var children = element.parentNode.childNodes;
        var num = 0;
        for (var i = 0; i < children.length; i++) {
            if (children[i] == element)
                return num;
            if (children[i].nodeType == 1)
                num++;
        }
        return -1;
    };
    DomHandler.prototype.relativePosition = function (element, target) {
        var elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : this.getHiddenElementDimensions(element);
        var targetHeight = target.offsetHeight;
        var targetWidth = target.offsetWidth;
        var targetOffset = target.getBoundingClientRect();
        var windowScrollTop = this.getWindowScrollTop();
        var viewport = this.getViewport();
        var top, left;
        if ((targetOffset.top + targetHeight + elementDimensions.height) > viewport.height) {
            top = -1 * (elementDimensions.height);
            if (targetOffset.top + top < 0) {
                top = 0;
            }
        }
        else {
            top = targetHeight;
        }
        if ((targetOffset.left + elementDimensions.width) > viewport.width)
            left = targetWidth - elementDimensions.width;
        else
            left = 0;
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    };
    DomHandler.prototype.absolutePosition = function (element, target) {
        var elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : this.getHiddenElementDimensions(element);
        var elementOuterHeight = elementDimensions.height;
        var elementOuterWidth = elementDimensions.width;
        var targetOuterHeight = target.offsetHeight;
        var targetOuterWidth = target.offsetWidth;
        var targetOffset = target.getBoundingClientRect();
        var windowScrollTop = this.getWindowScrollTop();
        var windowScrollLeft = this.getWindowScrollLeft();
        var viewport = this.getViewport();
        var top, left;
        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
            top = targetOffset.top + windowScrollTop - elementOuterHeight;
            if (top < 0) {
                top = 0 + windowScrollTop;
            }
        }
        else {
            top = targetOuterHeight + targetOffset.top + windowScrollTop;
        }
        if (targetOffset.left + targetOuterWidth + elementOuterWidth > viewport.width)
            left = targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth;
        else
            left = targetOffset.left + windowScrollLeft;
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    };
    DomHandler.prototype.getHiddenElementOuterHeight = function (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var elementHeight = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementHeight;
    };
    DomHandler.prototype.getHiddenElementOuterWidth = function (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var elementWidth = element.offsetWidth;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementWidth;
    };
    DomHandler.prototype.getHiddenElementDimensions = function (element) {
        var dimensions = {};
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        dimensions.width = element.offsetWidth;
        dimensions.height = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return dimensions;
    };
    DomHandler.prototype.scrollInView = function (container, item) {
        var borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
        var borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
        var paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
        var paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
        var containerRect = container.getBoundingClientRect();
        var itemRect = item.getBoundingClientRect();
        var offset = (itemRect.top + document.body.scrollTop) - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
        var scroll = container.scrollTop;
        var elementHeight = container.clientHeight;
        var itemHeight = this.getOuterHeight(item);
        if (offset < 0) {
            container.scrollTop = scroll + offset;
        }
        else if ((offset + itemHeight) > elementHeight) {
            container.scrollTop = scroll + offset - elementHeight + itemHeight;
        }
    };
    DomHandler.prototype.fadeIn = function (element, duration) {
        element.style.opacity = 0;
        var last = +new Date();
        var opacity = 0;
        var tick = function () {
            opacity = +element.style.opacity + (new Date().getTime() - last) / duration;
            element.style.opacity = opacity;
            last = +new Date();
            if (+opacity < 1) {
                (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
            }
        };
        tick();
    };
    DomHandler.prototype.fadeOut = function (element, ms) {
        var opacity = 1, interval = 50, duration = ms, gap = interval / duration;
        var fading = setInterval(function () {
            opacity = opacity - gap;
            if (opacity <= 0) {
                opacity = 0;
                clearInterval(fading);
            }
            element.style.opacity = opacity;
        }, interval);
    };
    DomHandler.prototype.getWindowScrollTop = function () {
        var doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    };
    DomHandler.prototype.getWindowScrollLeft = function () {
        var doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    };
    DomHandler.prototype.matches = function (element, selector) {
        var p = Element.prototype;
        var f = p['matches'] || p.webkitMatchesSelector || p['mozMatchesSelector'] || p.msMatchesSelector || function (s) {
            return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
        };
        return f.call(element, selector);
    };
    DomHandler.prototype.getOuterWidth = function (el, margin) {
        var width = el.offsetWidth;
        if (margin) {
            var style = getComputedStyle(el);
            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }
        return width;
    };
    DomHandler.prototype.getHorizontalPadding = function (el) {
        var style = getComputedStyle(el);
        return parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    };
    DomHandler.prototype.getHorizontalMargin = function (el) {
        var style = getComputedStyle(el);
        return parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    };
    DomHandler.prototype.innerWidth = function (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    };
    DomHandler.prototype.width = function (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    };
    DomHandler.prototype.getInnerHeight = function (el) {
        var height = el.offsetHeight;
        var style = getComputedStyle(el);
        height += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
        return height;
    };
    DomHandler.prototype.getOuterHeight = function (el, margin) {
        var height = el.offsetHeight;
        if (margin) {
            var style = getComputedStyle(el);
            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }
        return height;
    };
    DomHandler.prototype.getHeight = function (el) {
        var height = el.offsetHeight;
        var style = getComputedStyle(el);
        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
        return height;
    };
    DomHandler.prototype.getWidth = function (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
        return width;
    };
    DomHandler.prototype.getViewport = function () {
        var win = window, d = document, e = d.documentElement, g = d.getElementsByTagName('body')[0], w = win.innerWidth || e.clientWidth || g.clientWidth, h = win.innerHeight || e.clientHeight || g.clientHeight;
        return { width: w, height: h };
    };
    DomHandler.prototype.getOffset = function (el) {
        var rect = el.getBoundingClientRect();
        return {
            top: rect.top + document.body.scrollTop,
            left: rect.left + document.body.scrollLeft
        };
    };
    DomHandler.prototype.getUserAgent = function () {
        return navigator.userAgent;
    };
    DomHandler.prototype.isIE = function () {
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return true;
        }
        var trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            var rv = ua.indexOf('rv:');
            return true;
        }
        var edge = ua.indexOf('Edge/');
        if (edge > 0) {
            // Edge (IE 12+) => return version number
            return true;
        }
        // other browser
        return false;
    };
    DomHandler.prototype.appendChild = function (element, target) {
        if (this.isElement(target))
            target.appendChild(element);
        else if (target.el && target.el.nativeElement)
            target.el.nativeElement.appendChild(element);
        else
            throw 'Cannot append ' + target + ' to ' + element;
    };
    DomHandler.prototype.removeChild = function (element, target) {
        if (this.isElement(target))
            target.removeChild(element);
        else if (target.el && target.el.nativeElement)
            target.el.nativeElement.removeChild(element);
        else
            throw 'Cannot remove ' + element + ' from ' + target;
    };
    DomHandler.prototype.isElement = function (obj) {
        return (typeof HTMLElement === "object" ? obj instanceof HTMLElement :
            obj && typeof obj === "object" && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === "string");
    };
    DomHandler.prototype.calculateScrollbarWidth = function () {
        if (this.calculatedScrollbarWidth !== null)
            return this.calculatedScrollbarWidth;
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "ui-scrollbar-measure";
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        this.calculatedScrollbarWidth = scrollbarWidth;
        return scrollbarWidth;
    };
    DomHandler.prototype.invokeElementMethod = function (element, methodName, args) {
        element[methodName].apply(element, args);
    };
    DomHandler.prototype.clearSelection = function () {
        if (window.getSelection) {
            if (window.getSelection().empty) {
                window.getSelection().empty();
            }
            else if (window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0) {
                window.getSelection().removeAllRanges();
            }
        }
        else if (document['selection'] && document['selection'].empty) {
            try {
                document['selection'].empty();
            }
            catch (error) {
                //ignore IE bug
            }
        }
    };
    return DomHandler;
}());
DomHandler.zindex = 1000;
DomHandler = __decorate([
    core_1.Injectable()
], DomHandler);
exports.DomHandler = DomHandler;
//# sourceMappingURL=domhandler.js.map

/***/ }),

/***/ "./node_modules/primeng/components/dragdrop/dragdrop.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var Draggable = (function () {
    function Draggable(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.onDragStart = new core_1.EventEmitter();
        this.onDragEnd = new core_1.EventEmitter();
        this.onDrag = new core_1.EventEmitter();
    }
    Draggable.prototype.dragStart = function (event) {
        if (this.allowDrag()) {
            if (this.dragEffect) {
                event.dataTransfer.effectAllowed = this.dragEffect;
            }
            event.dataTransfer.setData('text', this.scope);
            this.onDragStart.emit(event);
        }
        else {
            event.preventDefault();
        }
    };
    Draggable.prototype.drag = function (event) {
        this.onDrag.emit(event);
    };
    Draggable.prototype.dragEnd = function (event) {
        this.onDragEnd.emit(event);
    };
    Draggable.prototype.mouseover = function (event) {
        this.handle = event.target;
    };
    Draggable.prototype.mouseleave = function (event) {
        this.handle = null;
    };
    Draggable.prototype.allowDrag = function () {
        if (this.dragHandle && this.handle)
            return this.domHandler.matches(this.handle, this.dragHandle);
        else
            return true;
    };
    return Draggable;
}());
__decorate([
    core_1.Input('pDraggable'),
    __metadata("design:type", String)
], Draggable.prototype, "scope", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Draggable.prototype, "dragEffect", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Draggable.prototype, "dragHandle", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Draggable.prototype, "onDragStart", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Draggable.prototype, "onDragEnd", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Draggable.prototype, "onDrag", void 0);
__decorate([
    core_1.HostListener('dragstart', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Draggable.prototype, "dragStart", null);
__decorate([
    core_1.HostListener('drag', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Draggable.prototype, "drag", null);
__decorate([
    core_1.HostListener('dragend', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Draggable.prototype, "dragEnd", null);
__decorate([
    core_1.HostListener('mouseover', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Draggable.prototype, "mouseover", null);
__decorate([
    core_1.HostListener('mouseleave', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Draggable.prototype, "mouseleave", null);
Draggable = __decorate([
    core_1.Directive({
        selector: '[pDraggable]',
        host: {
            '[draggable]': 'true'
        },
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Draggable);
exports.Draggable = Draggable;
var Droppable = (function () {
    function Droppable(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.onDragEnter = new core_1.EventEmitter();
        this.onDragLeave = new core_1.EventEmitter();
        this.onDrop = new core_1.EventEmitter();
        this.onDragOver = new core_1.EventEmitter();
    }
    Droppable.prototype.drop = function (event) {
        if (this.allowDrop(event)) {
            event.preventDefault();
            this.onDrop.emit(event);
        }
    };
    Droppable.prototype.dragEnter = function (event) {
        event.preventDefault();
        if (this.dropEffect) {
            event.dataTransfer.dropEffect = this.dropEffect;
        }
        this.onDragEnter.emit(event);
    };
    Droppable.prototype.dragLeave = function (event) {
        event.preventDefault();
        this.onDragLeave.emit(event);
    };
    Droppable.prototype.dragOver = function (event) {
        event.preventDefault();
        this.onDragOver.emit(event);
    };
    Droppable.prototype.allowDrop = function (event) {
        var dragScope = event.dataTransfer.getData('text');
        if (typeof (this.scope) == "string" && dragScope == this.scope) {
            return true;
        }
        else if (this.scope instanceof Array) {
            for (var j = 0; j < this.scope.length; j++) {
                if (dragScope == this.scope[j]) {
                    return true;
                }
            }
        }
        return false;
    };
    return Droppable;
}());
__decorate([
    core_1.Input('pDroppable'),
    __metadata("design:type", Object)
], Droppable.prototype, "scope", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Droppable.prototype, "dropEffect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Droppable.prototype, "onDragEnter", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Droppable.prototype, "onDragLeave", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Droppable.prototype, "onDrop", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Droppable.prototype, "onDragOver", void 0);
__decorate([
    core_1.HostListener('drop', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Droppable.prototype, "drop", null);
__decorate([
    core_1.HostListener('dragenter', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Droppable.prototype, "dragEnter", null);
__decorate([
    core_1.HostListener('dragleave', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Droppable.prototype, "dragLeave", null);
__decorate([
    core_1.HostListener('dragover', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Droppable.prototype, "dragOver", null);
Droppable = __decorate([
    core_1.Directive({
        selector: '[pDroppable]',
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Droppable);
exports.Droppable = Droppable;
var DragDropModule = (function () {
    function DragDropModule() {
    }
    return DragDropModule;
}());
DragDropModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Draggable, Droppable],
        declarations: [Draggable, Droppable]
    })
], DragDropModule);
exports.DragDropModule = DragDropModule;
//# sourceMappingURL=dragdrop.js.map

/***/ }),

/***/ "./node_modules/primeng/components/dropdown/dropdown.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var objectutils_1 = __webpack_require__("./node_modules/primeng/components/utils/objectutils.js");
var forms_1 = __webpack_require__(4);
exports.DROPDOWN_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Dropdown; }),
    multi: true
};
var Dropdown = (function () {
    function Dropdown(el, domHandler, renderer, cd, objectUtils) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.cd = cd;
        this.objectUtils = objectUtils;
        this.scrollHeight = '200px';
        this.autoWidth = true;
        this.filterBy = 'label';
        this.lazy = true;
        this.onChange = new core_1.EventEmitter();
        this.onFocus = new core_1.EventEmitter();
        this.onBlur = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
        this.panelVisible = false;
    }
    Dropdown.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    Dropdown.prototype.ngOnInit = function () {
        this.optionsToDisplay = this.options;
        this.updateSelectedOption(null);
    };
    Object.defineProperty(Dropdown.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (opts) {
            this._options = opts;
            this.optionsToDisplay = this._options;
            this.updateSelectedOption(this.value);
            this.optionsChanged = true;
            if (this.filterValue && this.filterValue.length) {
                this.activateFilter();
            }
        },
        enumerable: true,
        configurable: true
    });
    Dropdown.prototype.ngAfterViewInit = function () {
        this.container = this.containerViewChild.nativeElement;
        this.panel = this.panelViewChild.nativeElement;
        this.itemsWrapper = this.itemsWrapperViewChild.nativeElement;
        if (this.editable) {
            this.updateEditableLabel();
        }
        this.updateDimensions();
        this.initialized = true;
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.panel);
            else
                this.domHandler.appendChild(this.panel, this.appendTo);
        }
    };
    Object.defineProperty(Dropdown.prototype, "label", {
        get: function () {
            return (this.selectedOption ? this.selectedOption.label : this.placeholder);
        },
        enumerable: true,
        configurable: true
    });
    Dropdown.prototype.updateEditableLabel = function () {
        if (this.editableInputViewChild && this.editableInputViewChild.nativeElement) {
            this.editableInputViewChild.nativeElement.value = (this.selectedOption ? this.selectedOption.label : this.value || '');
        }
    };
    Dropdown.prototype.onItemClick = function (event, option) {
        this.itemClick = true;
        this.selectItem(event, option);
        this.focusViewChild.nativeElement.focus();
        this.hide();
    };
    Dropdown.prototype.selectItem = function (event, option) {
        if (this.selectedOption != option) {
            this.selectedOption = option;
            this.value = option.value;
            this.onModelChange(this.value);
            this.updateEditableLabel();
            this.onChange.emit({
                originalEvent: event,
                value: this.value
            });
        }
    };
    Dropdown.prototype.ngAfterViewChecked = function () {
        var _this = this;
        if (this.shown) {
            this.onShow();
            this.shown = false;
        }
        if (this.optionsChanged && this.panelVisible) {
            this.optionsChanged = false;
            setTimeout(function () { return _this.alignPanel(); }, 1);
        }
        if (this.selectedOptionUpdated && this.itemsWrapper) {
            var selectedItem = this.domHandler.findSingle(this.panel, 'li.ui-state-highlight');
            if (selectedItem) {
                this.domHandler.scrollInView(this.itemsWrapper, this.domHandler.findSingle(this.panel, 'li.ui-state-highlight'));
            }
            this.selectedOptionUpdated = false;
        }
    };
    Dropdown.prototype.writeValue = function (value) {
        if (this.filter) {
            this.resetFilter();
        }
        this.value = value;
        this.updateSelectedOption(value);
        this.updateEditableLabel();
        this.cd.markForCheck();
    };
    Dropdown.prototype.resetFilter = function () {
        if (this.filterViewChild && this.filterViewChild.nativeElement) {
            this.filterViewChild.nativeElement.value = '';
        }
        this.optionsToDisplay = this.options;
    };
    Dropdown.prototype.updateSelectedOption = function (val) {
        this.selectedOption = this.findOption(val, this.optionsToDisplay);
        if (!this.placeholder && !this.selectedOption && this.optionsToDisplay && this.optionsToDisplay.length && !this.editable) {
            this.selectedOption = this.optionsToDisplay[0];
        }
        this.selectedOptionUpdated = true;
    };
    Dropdown.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Dropdown.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Dropdown.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    Dropdown.prototype.updateDimensions = function () {
        if (this.autoWidth) {
            var select = this.domHandler.findSingle(this.el.nativeElement, 'select');
            if (!this.style || (!this.style['width'] && !this.style['min-width'])) {
                this.el.nativeElement.children[0].style.width = select.offsetWidth + 30 + 'px';
            }
        }
    };
    Dropdown.prototype.onMouseclick = function (event) {
        var _this = this;
        if (this.disabled || this.readonly) {
            return;
        }
        this.selfClick = true;
        if (!this.itemClick) {
            this.focusViewChild.nativeElement.focus();
            if (this.panelVisible)
                this.hide();
            else {
                this.show();
                if (this.filterViewChild != undefined) {
                    setTimeout(function () {
                        _this.filterViewChild.nativeElement.focus();
                    }, 200);
                }
            }
        }
    };
    Dropdown.prototype.onEditableInputClick = function (event) {
        this.itemClick = true;
        this.bindDocumentClickListener();
    };
    Dropdown.prototype.onEditableInputFocus = function (event) {
        this.focus = true;
        this.hide();
    };
    Dropdown.prototype.onEditableInputChange = function (event) {
        this.value = event.target.value;
        this.updateSelectedOption(this.value);
        this.onModelChange(this.value);
        this.onChange.emit({
            originalEvent: event,
            value: this.value
        });
    };
    Dropdown.prototype.onShow = function () {
        if (this.options && this.options.length) {
            this.alignPanel();
            this.bindDocumentClickListener();
            var selectedListItem = this.domHandler.findSingle(this.itemsWrapper, '.ui-dropdown-item.ui-state-highlight');
            if (selectedListItem) {
                this.domHandler.scrollInView(this.itemsWrapper, selectedListItem);
            }
        }
    };
    Dropdown.prototype.show = function () {
        if (this.appendTo) {
            this.panel.style.minWidth = this.domHandler.getWidth(this.container) + 'px';
        }
        this.panel.style.zIndex = String(++domhandler_1.DomHandler.zindex);
        this.panelVisible = true;
        this.shown = true;
    };
    Dropdown.prototype.hide = function () {
        this.panelVisible = false;
    };
    Dropdown.prototype.alignPanel = function () {
        if (this.appendTo)
            this.domHandler.absolutePosition(this.panel, this.container);
        else
            this.domHandler.relativePosition(this.panel, this.container);
    };
    Dropdown.prototype.onInputFocus = function (event) {
        this.focus = true;
        this.onFocus.emit(event);
    };
    Dropdown.prototype.onInputBlur = function (event) {
        this.focus = false;
        this.onModelTouched();
        this.onBlur.emit(event);
    };
    Dropdown.prototype.onKeydown = function (event) {
        if (this.readonly) {
            return;
        }
        var selectedItemIndex = this.selectedOption ? this.findOptionIndex(this.selectedOption.value, this.optionsToDisplay) : -1;
        switch (event.which) {
            //down
            case 40:
                if (!this.panelVisible && event.altKey) {
                    this.show();
                }
                else {
                    if (selectedItemIndex != -1) {
                        var nextItemIndex = selectedItemIndex + 1;
                        if (nextItemIndex != (this.optionsToDisplay.length)) {
                            this.selectedOption = this.optionsToDisplay[nextItemIndex];
                            this.selectedOptionUpdated = true;
                            this.selectItem(event, this.selectedOption);
                        }
                    }
                    else if (this.optionsToDisplay) {
                        this.selectedOption = this.optionsToDisplay[0];
                    }
                }
                event.preventDefault();
                break;
            //up
            case 38:
                if (selectedItemIndex > 0) {
                    var prevItemIndex = selectedItemIndex - 1;
                    this.selectedOption = this.optionsToDisplay[prevItemIndex];
                    this.selectedOptionUpdated = true;
                    this.selectItem(event, this.selectedOption);
                }
                event.preventDefault();
                break;
            //space
            case 32:
                this.show();
                event.preventDefault();
                break;
            //enter
            case 13:
                this.hide();
                event.preventDefault();
                break;
            //escape and tab
            case 27:
            case 9:
                this.hide();
                break;
        }
    };
    Dropdown.prototype.findOptionIndex = function (val, opts) {
        var index = -1;
        if (opts) {
            for (var i = 0; i < opts.length; i++) {
                if ((val == null && opts[i].value == null) || this.objectUtils.equals(val, opts[i].value, this.dataKey)) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    Dropdown.prototype.findOption = function (val, opts) {
        var index = this.findOptionIndex(val, opts);
        return (index != -1) ? opts[index] : null;
    };
    Dropdown.prototype.onFilter = function (event) {
        var inputValue = event.target.value.toLowerCase();
        if (inputValue && inputValue.length) {
            this.filterValue = inputValue;
            this.activateFilter();
        }
        else {
            this.filterValue = null;
            this.optionsToDisplay = this.options;
        }
        this.optionsChanged = true;
    };
    Dropdown.prototype.activateFilter = function () {
        var searchFields = this.filterBy.split(',');
        if (this.options && this.options.length) {
            this.optionsToDisplay = this.objectUtils.filter(this.options, searchFields, this.filterValue);
            this.optionsChanged = true;
        }
    };
    Dropdown.prototype.applyFocus = function () {
        if (this.editable)
            this.domHandler.findSingle(this.el.nativeElement, '.ui-dropdown-label.ui-inputtext').focus();
        else
            this.domHandler.findSingle(this.el.nativeElement, 'input[readonly]').focus();
    };
    Dropdown.prototype.bindDocumentClickListener = function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'click', function () {
                if (!_this.selfClick && !_this.itemClick) {
                    _this.panelVisible = false;
                    _this.unbindDocumentClickListener();
                }
                _this.selfClick = false;
                _this.itemClick = false;
                _this.cd.markForCheck();
            });
        }
    };
    Dropdown.prototype.unbindDocumentClickListener = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    Dropdown.prototype.ngOnDestroy = function () {
        this.initialized = false;
        this.unbindDocumentClickListener();
        if (this.appendTo) {
            this.el.nativeElement.appendChild(this.panel);
        }
    };
    return Dropdown;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dropdown.prototype, "scrollHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dropdown.prototype, "filter", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Dropdown.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Dropdown.prototype, "panelStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dropdown.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dropdown.prototype, "panelStyleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dropdown.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dropdown.prototype, "readonly", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dropdown.prototype, "autoWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dropdown.prototype, "required", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dropdown.prototype, "editable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Dropdown.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Dropdown.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dropdown.prototype, "placeholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dropdown.prototype, "filterPlaceholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dropdown.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dropdown.prototype, "dataKey", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Dropdown.prototype, "filterBy", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Dropdown.prototype, "lazy", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Dropdown.prototype, "onChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Dropdown.prototype, "onFocus", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Dropdown.prototype, "onBlur", void 0);
__decorate([
    core_1.ViewChild('container'),
    __metadata("design:type", core_1.ElementRef)
], Dropdown.prototype, "containerViewChild", void 0);
__decorate([
    core_1.ViewChild('panel'),
    __metadata("design:type", core_1.ElementRef)
], Dropdown.prototype, "panelViewChild", void 0);
__decorate([
    core_1.ViewChild('itemswrapper'),
    __metadata("design:type", core_1.ElementRef)
], Dropdown.prototype, "itemsWrapperViewChild", void 0);
__decorate([
    core_1.ViewChild('filter'),
    __metadata("design:type", core_1.ElementRef)
], Dropdown.prototype, "filterViewChild", void 0);
__decorate([
    core_1.ViewChild('in'),
    __metadata("design:type", core_1.ElementRef)
], Dropdown.prototype, "focusViewChild", void 0);
__decorate([
    core_1.ViewChild('editableInput'),
    __metadata("design:type", core_1.ElementRef)
], Dropdown.prototype, "editableInputViewChild", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], Dropdown.prototype, "templates", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], Dropdown.prototype, "options", null);
Dropdown = __decorate([
    core_1.Component({
        selector: 'p-dropdown',
        template: "\n         <div #container [ngClass]=\"{'ui-dropdown ui-widget ui-state-default ui-corner-all ui-helper-clearfix':true,\n            'ui-state-disabled':disabled,'ui-dropdown-open':panelVisible,'ui-state-focus':focus}\"\n            (click)=\"onMouseclick($event)\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-helper-hidden-accessible\" *ngIf=\"autoWidth\">\n                <select [required]=\"required\" name=\"options\" [attr.aria-label]=\"selectedOption ? selectedOption.label : ' '\" tabindex=\"-1\" aria-hidden=\"true\">\n                    <option *ngFor=\"let option of options\" [value]=\"option.value\" [selected]=\"selectedOption == option\">{{option.label}}</option>\n                </select>\n            </div>\n            <div class=\"ui-helper-hidden-accessible\">\n                <input #in [attr.id]=\"inputId\" type=\"text\" [attr.aria-label]=\"selectedOption ? selectedOption.label : ' '\" readonly (focus)=\"onInputFocus($event)\" (blur)=\"onInputBlur($event)\" (keydown)=\"onKeydown($event)\" [disabled]=\"disabled\" [attr.tabindex]=\"tabindex\">\n            </div>\n            <label [ngClass]=\"{'ui-dropdown-label ui-inputtext ui-corner-all':true,'ui-dropdown-label-empty':!label}\" *ngIf=\"!editable\">{{label||'empty'}}</label>\n            <input #editableInput type=\"text\" [attr.aria-label]=\"selectedOption ? selectedOption.label : ' '\" class=\"ui-dropdown-label ui-inputtext ui-corner-all\" *ngIf=\"editable\" [disabled]=\"disabled\" [attr.placeholder]=\"placeholder\"\n                        (click)=\"onEditableInputClick($event)\" (input)=\"onEditableInputChange($event)\" (focus)=\"onEditableInputFocus($event)\" (blur)=\"onInputBlur($event)\">\n            <div class=\"ui-dropdown-trigger ui-state-default ui-corner-right\">\n                <span class=\"fa fa-fw fa-caret-down ui-clickable\"></span>\n            </div>\n            <div #panel [ngClass]=\"'ui-dropdown-panel ui-widget-content ui-corner-all ui-helper-hidden ui-shadow'\" [@panelState]=\"panelVisible ? 'visible' : 'hidden'\"\n                [style.display]=\"panelVisible ? 'block' : 'none'\" [ngStyle]=\"panelStyle\" [class]=\"panelStyleClass\">\n                <div *ngIf=\"filter\" class=\"ui-dropdown-filter-container\" (input)=\"onFilter($event)\" (click)=\"$event.stopPropagation()\">\n                    <input #filter type=\"text\" autocomplete=\"off\" class=\"ui-dropdown-filter ui-inputtext ui-widget ui-state-default ui-corner-all\" [attr.placeholder]=\"filterPlaceholder\"\n                    (keydown.enter)=\"$event.preventDefault()\">\n                    <span class=\"fa fa-search\"></span>\n                </div>\n                <div #itemswrapper class=\"ui-dropdown-items-wrapper\" [style.max-height]=\"scrollHeight||'auto'\">\n                    <ul class=\"ui-dropdown-items ui-dropdown-list ui-widget-content ui-widget ui-corner-all ui-helper-reset\" *ngIf=\"lazy ? panelVisible : true\">\n                        <li *ngFor=\"let option of optionsToDisplay;let i=index\" \n                            [ngClass]=\"{'ui-dropdown-item ui-corner-all':true, 'ui-state-highlight':(selectedOption == option), \n                            'ui-dropdown-item-empty':!option.label||option.label.length === 0}\"\n                            (click)=\"onItemClick($event, option)\">\n                            <span *ngIf=\"!itemTemplate\">{{option.label||'empty'}}</span>\n                            <ng-template [pTemplateWrapper]=\"itemTemplate\" [item]=\"option\" *ngIf=\"itemTemplate\"></ng-template>\n                        </li>\n                    </ul>\n                </div>\n            </div>\n        </div>\n    ",
        animations: [
            animations_1.trigger('panelState', [
                animations_1.state('hidden', animations_1.style({
                    opacity: 0
                })),
                animations_1.state('visible', animations_1.style({
                    opacity: 1
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms ease-in')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms ease-out'))
            ])
        ],
        providers: [domhandler_1.DomHandler, objectutils_1.ObjectUtils, exports.DROPDOWN_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, core_1.ChangeDetectorRef, objectutils_1.ObjectUtils])
], Dropdown);
exports.Dropdown = Dropdown;
var DropdownModule = (function () {
    function DropdownModule() {
    }
    return DropdownModule;
}());
DropdownModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_1.SharedModule],
        exports: [Dropdown, shared_1.SharedModule],
        declarations: [Dropdown]
    })
], DropdownModule);
exports.DropdownModule = DropdownModule;
//# sourceMappingURL=dropdown.js.map

/***/ }),

/***/ "./node_modules/primeng/components/editor/editor.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var forms_1 = __webpack_require__(4);
exports.EDITOR_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Editor; }),
    multi: true
};
var Editor = (function () {
    function Editor(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.onTextChange = new core_1.EventEmitter();
        this.onSelectionChange = new core_1.EventEmitter();
        this.onInit = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    Editor.prototype.ngAfterViewInit = function () {
        var _this = this;
        var editorElement = this.domHandler.findSingle(this.el.nativeElement, 'div.ui-editor-content');
        var toolbarElement = this.domHandler.findSingle(this.el.nativeElement, 'div.ui-editor-toolbar');
        this.quill = new Quill(editorElement, {
            modules: {
                toolbar: toolbarElement
            },
            placeholder: this.placeholder,
            readOnly: this.readonly,
            theme: 'snow',
            formats: this.formats
        });
        if (this.value) {
            this.quill.pasteHTML(this.value);
        }
        this.quill.on('text-change', function (delta, oldContents, source) {
            var html = editorElement.children[0].innerHTML;
            var text = _this.quill.getText();
            if (html == '<p><br></p>') {
                html = null;
            }
            _this.onTextChange.emit({
                htmlValue: html,
                textValue: text,
                delta: delta,
                source: source
            });
            _this.onModelChange(html);
            if (source === 'user') {
                _this.onModelTouched();
            }
        });
        this.quill.on('selection-change', function (range, oldRange, source) {
            _this.onSelectionChange.emit({
                range: range,
                oldRange: oldRange,
                source: source
            });
        });
        this.onInit.emit({
            editor: this.quill
        });
    };
    Editor.prototype.writeValue = function (value) {
        this.value = value;
        if (this.quill) {
            if (value)
                this.quill.pasteHTML(value);
            else
                this.quill.setText('');
        }
    };
    Editor.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Editor.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Editor.prototype.getQuill = function () {
        return this.quill;
    };
    return Editor;
}());
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Editor.prototype, "onTextChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Editor.prototype, "onSelectionChange", void 0);
__decorate([
    core_1.ContentChild(shared_1.Header),
    __metadata("design:type", Object)
], Editor.prototype, "toolbar", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Editor.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Editor.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Editor.prototype, "placeholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Editor.prototype, "readonly", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Editor.prototype, "formats", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Editor.prototype, "onInit", void 0);
Editor = __decorate([
    core_1.Component({
        selector: 'p-editor',
        template: "\n        <div [ngClass]=\"'ui-widget ui-editor-container ui-corner-all'\" [class]=\"styleClass\">\n            <div class=\"ui-editor-toolbar ui-widget-header ui-corner-top\" *ngIf=\"toolbar\">\n                <ng-content select=\"p-header\"></ng-content>\n            </div>\n            <div class=\"ui-editor-toolbar ui-widget-header ui-corner-top\" *ngIf=\"!toolbar\">\n                <span class=\"ql-formats\">\n                    <select class=\"ql-header\">\n                      <option value=\"1\">Heading</option>\n                      <option value=\"2\">Subheading</option>\n                      <option selected>Normal</option>\n                    </select>\n                    <select class=\"ql-font\">\n                      <option selected>Sans Serif</option>\n                      <option value=\"serif\">Serif</option>\n                      <option value=\"monospace\">Monospace</option>\n                    </select>\n                </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                    <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                    <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                </span>\n                <span class=\"ql-formats\">\n                    <select class=\"ql-color\"></select>\n                    <select class=\"ql-background\"></select>\n                </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-list\" value=\"ordered\" aria-label=\"Ordered List\"></button>\n                    <button class=\"ql-list\" value=\"bullet\" aria-label=\"Unordered List\"></button>\n                    <select class=\"ql-align\">\n                        <option selected></option>\n                        <option value=\"center\"></option>\n                        <option value=\"right\"></option>\n                        <option value=\"justify\"></option>\n                    </select>\n                </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-link\" aria-label=\"Insert Link\"></button>\n                    <button class=\"ql-image\" aria-label=\"Insert Image\"></button>\n                    <button class=\"ql-code-block\" aria-label=\"Insert Code Block\"></button>\n                </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-clean\" aria-label=\"Remove Styles\"></button>\n                </span>\n            </div>\n            <div class=\"ui-editor-content\" [ngStyle]=\"style\"></div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler, exports.EDITOR_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Editor);
exports.Editor = Editor;
var EditorModule = (function () {
    function EditorModule() {
    }
    return EditorModule;
}());
EditorModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Editor, shared_1.SharedModule],
        declarations: [Editor]
    })
], EditorModule);
exports.EditorModule = EditorModule;
//# sourceMappingURL=editor.js.map

/***/ }),

/***/ "./node_modules/primeng/components/fieldset/fieldset.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var Fieldset = (function () {
    function Fieldset(el) {
        this.el = el;
        this.collapsed = false;
        this.onBeforeToggle = new core_1.EventEmitter();
        this.onAfterToggle = new core_1.EventEmitter();
    }
    Fieldset.prototype.toggle = function (event) {
        if (this.toggleable) {
            if (this.animating) {
                return false;
            }
            this.animating = true;
            this.onBeforeToggle.emit({ originalEvent: event, collapsed: this.collapsed });
            if (this.collapsed)
                this.expand(event);
            else
                this.collapse(event);
            this.onAfterToggle.emit({ originalEvent: event, collapsed: this.collapsed });
        }
    };
    Fieldset.prototype.expand = function (event) {
        this.collapsed = false;
    };
    Fieldset.prototype.collapse = function (event) {
        this.collapsed = true;
    };
    Fieldset.prototype.getBlockableElement = function () {
        return this.el.nativeElement.children[0];
    };
    Fieldset.prototype.onToggleDone = function (event) {
        this.animating = false;
    };
    return Fieldset;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Fieldset.prototype, "legend", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Fieldset.prototype, "toggleable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Fieldset.prototype, "collapsed", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Fieldset.prototype, "onBeforeToggle", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Fieldset.prototype, "onAfterToggle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Fieldset.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Fieldset.prototype, "styleClass", void 0);
Fieldset = __decorate([
    core_1.Component({
        selector: 'p-fieldset',
        template: "\n        <fieldset [ngClass]=\"{'ui-fieldset ui-widget ui-widget-content ui-corner-all': true, 'ui-fieldset-toggleable': toggleable}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <legend class=\"ui-fieldset-legend ui-corner-all ui-state-default ui-unselectable-text\" (click)=\"toggle($event)\">\n                <span *ngIf=\"toggleable\" class=\"ui-fieldset-toggler fa fa-w\" [ngClass]=\"{'fa-minus': !collapsed,'fa-plus':collapsed}\"></span>\n                {{legend}}\n                <ng-content select=\"p-header\"></ng-content>\n            </legend>\n            <div class=\"ui-fieldset-content-wrapper\" [@fieldsetContent]=\"collapsed ? 'hidden' : 'visible'\" \n                        [ngClass]=\"{'ui-fieldset-content-wrapper-overflown': collapsed||animating}\"\n                         (@fieldsetContent.done)=\"onToggleDone($event)\">\n                <div class=\"ui-fieldset-content\">\n                    <ng-content></ng-content>\n                </div>\n            </div>\n        </fieldset>\n    ",
        animations: [
            animations_1.trigger('fieldsetContent', [
                animations_1.state('hidden', animations_1.style({
                    height: '0px'
                })),
                animations_1.state('visible', animations_1.style({
                    height: '*'
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms cubic-bezier(0.86, 0, 0.07, 1)'))
            ])
        ]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef])
], Fieldset);
exports.Fieldset = Fieldset;
var FieldsetModule = (function () {
    function FieldsetModule() {
    }
    return FieldsetModule;
}());
FieldsetModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Fieldset, shared_1.SharedModule],
        declarations: [Fieldset]
    })
], FieldsetModule);
exports.FieldsetModule = FieldsetModule;
//# sourceMappingURL=fieldset.js.map

/***/ }),

/***/ "./node_modules/primeng/components/fileupload/fileupload.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var platform_browser_1 = __webpack_require__(7);
var button_1 = __webpack_require__("./node_modules/primeng/components/button/button.js");
var messages_1 = __webpack_require__("./node_modules/primeng/components/messages/messages.js");
var progressbar_1 = __webpack_require__("./node_modules/primeng/components/progressbar/progressbar.js");
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var FileUpload = (function () {
    function FileUpload(sanitizer) {
        this.sanitizer = sanitizer;
        this.method = 'POST';
        this.invalidFileSizeMessageSummary = '{0}: Invalid file size, ';
        this.invalidFileSizeMessageDetail = 'maximum upload size is {0}.';
        this.invalidFileTypeMessageSummary = '{0}: Invalid file type, ';
        this.invalidFileTypeMessageDetail = 'allowed file types: {0}.';
        this.previewWidth = 50;
        this.chooseLabel = 'Choose';
        this.uploadLabel = 'Upload';
        this.cancelLabel = 'Cancel';
        this.showUploadButton = true;
        this.showCancelButton = true;
        this.mode = 'advanced';
        this.onBeforeUpload = new core_1.EventEmitter();
        this.onBeforeSend = new core_1.EventEmitter();
        this.onUpload = new core_1.EventEmitter();
        this.onError = new core_1.EventEmitter();
        this.onClear = new core_1.EventEmitter();
        this.onRemove = new core_1.EventEmitter();
        this.onSelect = new core_1.EventEmitter();
        this.onProgress = new core_1.EventEmitter();
        this.uploadHandler = new core_1.EventEmitter();
        this.progress = 0;
    }
    FileUpload.prototype.ngOnInit = function () {
        this.files = [];
    };
    FileUpload.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'file':
                    _this.fileTemplate = item.template;
                    break;
                case 'content':
                    _this.contentTemplate = item.template;
                    break;
                case 'toolbar':
                    _this.toolbarTemplate = item.template;
                    break;
                default:
                    _this.fileTemplate = item.template;
                    break;
            }
        });
    };
    FileUpload.prototype.onFileSelect = function (event) {
        this.msgs = [];
        if (!this.multiple) {
            this.files = [];
        }
        var files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
        for (var i = 0; i < files.length; i++) {
            var file = files[i];
            if (this.validate(file)) {
                if (this.isImage(file)) {
                    file.objectURL = this.sanitizer.bypassSecurityTrustUrl((window.URL.createObjectURL(files[i])));
                }
                this.files.push(files[i]);
            }
        }
        this.onSelect.emit({ originalEvent: event, files: files });
        if (this.hasFiles() && this.auto) {
            this.upload();
        }
    };
    FileUpload.prototype.validate = function (file) {
        if (this.accept && !this.isFileTypeValid(file)) {
            this.msgs.push({
                severity: 'error',
                summary: this.invalidFileTypeMessageSummary.replace('{0}', file.name),
                detail: this.invalidFileTypeMessageDetail.replace('{0}', this.accept)
            });
            return false;
        }
        if (this.maxFileSize && file.size > this.maxFileSize) {
            this.msgs.push({
                severity: 'error',
                summary: this.invalidFileSizeMessageSummary.replace('{0}', file.name),
                detail: this.invalidFileSizeMessageDetail.replace('{0}', this.formatSize(this.maxFileSize))
            });
            return false;
        }
        return true;
    };
    FileUpload.prototype.isFileTypeValid = function (file) {
        var acceptableTypes = this.accept.split(',');
        for (var _i = 0, acceptableTypes_1 = acceptableTypes; _i < acceptableTypes_1.length; _i++) {
            var type = acceptableTypes_1[_i];
            var acceptable = this.isWildcard(type) ? this.getTypeClass(file.type) === this.getTypeClass(type)
                : file.type == type || this.getFileExtension(file) === type;
            if (acceptable) {
                return true;
            }
        }
        return false;
    };
    FileUpload.prototype.getTypeClass = function (fileType) {
        return fileType.substring(0, fileType.indexOf('/'));
    };
    FileUpload.prototype.isWildcard = function (fileType) {
        return fileType.indexOf('*') !== -1;
    };
    FileUpload.prototype.getFileExtension = function (file) {
        return '.' + file.name.split('.').pop();
    };
    FileUpload.prototype.isImage = function (file) {
        return /^image\//.test(file.type);
    };
    FileUpload.prototype.onImageLoad = function (img) {
        window.URL.revokeObjectURL(img.src);
    };
    FileUpload.prototype.upload = function () {
        var _this = this;
        if (this.customUpload) {
            this.uploadHandler.emit({
                files: this.files
            });
        }
        else {
            this.msgs = [];
            var xhr_1 = new XMLHttpRequest(), formData = new FormData();
            this.onBeforeUpload.emit({
                'xhr': xhr_1,
                'formData': formData
            });
            for (var i = 0; i < this.files.length; i++) {
                formData.append(this.name, this.files[i], this.files[i].name);
            }
            xhr_1.upload.addEventListener('progress', function (e) {
                if (e.lengthComputable) {
                    _this.progress = Math.round((e.loaded * 100) / e.total);
                }
                _this.onProgress.emit({ originalEvent: e, progress: _this.progress });
            }, false);
            xhr_1.onreadystatechange = function () {
                if (xhr_1.readyState == 4) {
                    _this.progress = 0;
                    if (xhr_1.status >= 200 && xhr_1.status < 300)
                        _this.onUpload.emit({ xhr: xhr_1, files: _this.files });
                    else
                        _this.onError.emit({ xhr: xhr_1, files: _this.files });
                    _this.clear();
                }
            };
            xhr_1.open(this.method, this.url, true);
            this.onBeforeSend.emit({
                'xhr': xhr_1,
                'formData': formData
            });
            xhr_1.withCredentials = this.withCredentials;
            xhr_1.send(formData);
        }
    };
    FileUpload.prototype.clear = function () {
        this.files = [];
        this.onClear.emit();
    };
    FileUpload.prototype.remove = function (event, index) {
        this.onRemove.emit({ originalEvent: event, file: this.files[index] });
        this.files.splice(index, 1);
    };
    FileUpload.prototype.hasFiles = function () {
        return this.files && this.files.length > 0;
    };
    FileUpload.prototype.onDragEnter = function (e) {
        if (!this.disabled) {
            e.stopPropagation();
            e.preventDefault();
        }
    };
    FileUpload.prototype.onDragOver = function (e) {
        if (!this.disabled) {
            this.dragHighlight = true;
            e.stopPropagation();
            e.preventDefault();
        }
    };
    FileUpload.prototype.onDragLeave = function (event) {
        if (!this.disabled) {
            this.dragHighlight = false;
        }
    };
    FileUpload.prototype.onDrop = function (event) {
        if (!this.disabled) {
            this.dragHighlight = false;
            event.stopPropagation();
            event.preventDefault();
            var files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
            var allowDrop = this.multiple || (files && files.length === 1);
            if (allowDrop) {
                this.onFileSelect(event);
            }
        }
    };
    FileUpload.prototype.onFocus = function () {
        this.focus = true;
    };
    FileUpload.prototype.onBlur = function () {
        this.focus = false;
    };
    FileUpload.prototype.formatSize = function (bytes) {
        if (bytes == 0) {
            return '0 B';
        }
        var k = 1000, dm = 3, sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    };
    FileUpload.prototype.onSimpleUploaderClick = function (event) {
        if (this.hasFiles()) {
            this.upload();
        }
    };
    return FileUpload;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "name", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "url", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "method", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], FileUpload.prototype, "multiple", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "accept", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], FileUpload.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], FileUpload.prototype, "auto", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], FileUpload.prototype, "withCredentials", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], FileUpload.prototype, "maxFileSize", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "invalidFileSizeMessageSummary", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "invalidFileSizeMessageDetail", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "invalidFileTypeMessageSummary", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "invalidFileTypeMessageDetail", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], FileUpload.prototype, "previewWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "chooseLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "uploadLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "cancelLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], FileUpload.prototype, "showUploadButton", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], FileUpload.prototype, "showCancelButton", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], FileUpload.prototype, "mode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], FileUpload.prototype, "customUpload", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "onBeforeUpload", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "onBeforeSend", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "onUpload", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "onError", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "onClear", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "onRemove", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "onSelect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "onProgress", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], FileUpload.prototype, "uploadHandler", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], FileUpload.prototype, "templates", void 0);
FileUpload = __decorate([
    core_1.Component({
        selector: 'p-fileUpload',
        template: "\n        <div [ngClass]=\"'ui-fileupload ui-widget'\" [ngStyle]=\"style\" [class]=\"styleClass\" *ngIf=\"mode === 'advanced'\">\n            <div class=\"ui-fileupload-buttonbar ui-widget-header ui-corner-top\">\n                <span class=\"ui-fileupload-choose\" [label]=\"chooseLabel\" icon=\"fa-plus\" pButton  [ngClass]=\"{'ui-fileupload-choose-selected': hasFiles(),'ui-state-focus': focus}\" [attr.disabled]=\"disabled\" > \n                    <input #fileinput type=\"file\" (change)=\"onFileSelect($event)\" [multiple]=\"multiple\" [accept]=\"accept\" [disabled]=\"disabled\" (focus)=\"onFocus()\" (blur)=\"onBlur()\">\n                </span>\n\n                <button *ngIf=\"!auto&&showUploadButton\" type=\"button\" [label]=\"uploadLabel\" icon=\"fa-upload\" pButton (click)=\"upload()\" [disabled]=\"!hasFiles()\"></button>\n                <button *ngIf=\"!auto&&showCancelButton\" type=\"button\" [label]=\"cancelLabel\" icon=\"fa-close\" pButton (click)=\"clear()\" [disabled]=\"!hasFiles()\"></button>\n            \n                <p-templateLoader [template]=\"toolbarTemplate\"></p-templateLoader>\n            </div>\n            <div [ngClass]=\"{'ui-fileupload-content ui-widget-content ui-corner-bottom':true,'ui-fileupload-highlight':dragHighlight}\" \n                (dragenter)=\"onDragEnter($event)\" (dragover)=\"onDragOver($event)\" (dragleave)=\"onDragLeave($event)\" (drop)=\"onDrop($event)\">\n                <p-progressBar [value]=\"progress\" [showValue]=\"false\" *ngIf=\"hasFiles()\"></p-progressBar>\n                \n                <p-messages [value]=\"msgs\"></p-messages>\n                \n                <div class=\"ui-fileupload-files\" *ngIf=\"hasFiles()\">\n                    <div *ngIf=\"!fileTemplate\">\n                        <div class=\"ui-fileupload-row\" *ngFor=\"let file of files; let i = index;\">\n                            <div><img [src]=\"file.objectURL\" *ngIf=\"isImage(file)\" [width]=\"previewWidth\" /></div>\n                            <div>{{file.name}}</div>\n                            <div>{{formatSize(file.size)}}</div>\n                            <div><button type=\"button\" icon=\"fa-close\" pButton (click)=\"remove($event,i)\"></button></div>\n                        </div>\n                    </div>\n                    <div *ngIf=\"fileTemplate\">\n                        <ng-template ngFor [ngForOf]=\"files\" [ngForTemplate]=\"fileTemplate\"></ng-template>\n                    </div>\n                </div>\n                <p-templateLoader [template]=\"contentTemplate\"></p-templateLoader>\n            </div>\n        </div>\n        <span class=\"ui-button ui-fileupload-choose ui-widget ui-state-default ui-corner-all ui-button-text-icon-left\" *ngIf=\"mode === 'basic'\" \n        (mouseup)=\"onSimpleUploaderClick($event)\"\n        [ngClass]=\"{'ui-fileupload-choose-selected': hasFiles(),'ui-state-focus': focus}\">\n            <span class=\"ui-button-icon-left fa\" [ngClass]=\"{'fa-plus': !hasFiles()||auto, 'fa-upload': hasFiles()&&!auto}\"></span>\n            <span class=\"ui-button-text ui-clickable\">{{auto ? chooseLabel : hasFiles() ? files[0].name : chooseLabel}}</span>\n            <input type=\"file\" [accept]=\"accept\" [multiple]=\"multiple\" [disabled]=\"disabled\"\n                (change)=\"onFileSelect($event)\" *ngIf=\"!hasFiles()\" (focus)=\"onFocus()\" (blur)=\"onBlur()\">\n        </span>\n    "
    }),
    __metadata("design:paramtypes", [platform_browser_1.DomSanitizer])
], FileUpload);
exports.FileUpload = FileUpload;
var FileUploadModule = (function () {
    function FileUploadModule() {
    }
    return FileUploadModule;
}());
FileUploadModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_1.SharedModule, button_1.ButtonModule, progressbar_1.ProgressBarModule, messages_1.MessagesModule],
        exports: [FileUpload, shared_1.SharedModule, button_1.ButtonModule, progressbar_1.ProgressBarModule, messages_1.MessagesModule],
        declarations: [FileUpload]
    })
], FileUploadModule);
exports.FileUploadModule = FileUploadModule;
//# sourceMappingURL=fileupload.js.map

/***/ }),

/***/ "./node_modules/primeng/components/galleria/galleria.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var Galleria = (function () {
    function Galleria(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.panelWidth = 600;
        this.panelHeight = 400;
        this.frameWidth = 60;
        this.frameHeight = 40;
        this.activeIndex = 0;
        this.showFilmstrip = true;
        this.autoPlay = true;
        this.transitionInterval = 4000;
        this.showCaption = true;
        this.onImageClicked = new core_1.EventEmitter();
        this.stripLeft = 0;
    }
    Galleria.prototype.ngAfterViewChecked = function () {
        if (this.imagesChanged) {
            this.stopSlideshow();
            this.render();
            this.imagesChanged = false;
        }
    };
    Object.defineProperty(Galleria.prototype, "images", {
        get: function () {
            return this._images;
        },
        set: function (value) {
            this._images = value;
            this.activeIndex = 0;
            this.imagesChanged = true;
        },
        enumerable: true,
        configurable: true
    });
    Galleria.prototype.ngAfterViewInit = function () {
        this.container = this.el.nativeElement.children[0];
        this.panelWrapper = this.domHandler.findSingle(this.el.nativeElement, 'ul.ui-galleria-panel-wrapper');
        this.initialized = true;
        if (this.showFilmstrip) {
            this.stripWrapper = this.domHandler.findSingle(this.container, 'div.ui-galleria-filmstrip-wrapper');
            this.strip = this.domHandler.findSingle(this.stripWrapper, 'ul.ui-galleria-filmstrip');
        }
        if (this.images && this.images.length) {
            this.render();
        }
    };
    Galleria.prototype.render = function () {
        this.panels = this.domHandler.find(this.panelWrapper, 'li.ui-galleria-panel');
        if (this.showFilmstrip) {
            this.frames = this.domHandler.find(this.strip, 'li.ui-galleria-frame');
            this.stripWrapper.style.width = this.domHandler.width(this.panelWrapper) - 50 + 'px';
            this.stripWrapper.style.height = this.frameHeight + 'px';
        }
        if (this.showCaption) {
            this.caption = this.domHandler.findSingle(this.container, 'div.ui-galleria-caption');
            this.caption.style.bottom = this.showFilmstrip ? this.domHandler.getOuterHeight(this.stripWrapper, true) + 'px' : 0 + 'px';
            this.caption.style.width = this.domHandler.width(this.panelWrapper) + 'px';
        }
        if (this.autoPlay) {
            this.startSlideshow();
        }
        this.container.style.visibility = 'visible';
    };
    Galleria.prototype.startSlideshow = function () {
        var _this = this;
        this.interval = setInterval(function () {
            _this.next();
        }, this.transitionInterval);
        this.slideshowActive = true;
    };
    Galleria.prototype.stopSlideshow = function () {
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.slideshowActive = false;
    };
    Galleria.prototype.clickNavRight = function () {
        if (this.slideshowActive) {
            this.stopSlideshow();
        }
        this.next();
    };
    Galleria.prototype.clickNavLeft = function () {
        if (this.slideshowActive) {
            this.stopSlideshow();
        }
        this.prev();
    };
    Galleria.prototype.frameClick = function (frame) {
        if (this.slideshowActive) {
            this.stopSlideshow();
        }
        this.select(this.domHandler.index(frame), false);
    };
    Galleria.prototype.prev = function () {
        if (this.activeIndex !== 0) {
            this.select(this.activeIndex - 1, true);
        }
    };
    Galleria.prototype.next = function () {
        if (this.activeIndex !== (this.panels.length - 1)) {
            this.select(this.activeIndex + 1, true);
        }
        else {
            this.select(0, false);
            this.stripLeft = 0;
        }
    };
    Galleria.prototype.select = function (index, reposition) {
        if (index !== this.activeIndex) {
            var oldPanel = this.panels[this.activeIndex], newPanel = this.panels[index];
            this.domHandler.fadeIn(newPanel, 500);
            if (this.showFilmstrip) {
                var oldFrame = this.frames[this.activeIndex], newFrame = this.frames[index];
                if (reposition === undefined || reposition === true) {
                    var frameLeft = newFrame.offsetLeft, stepFactor = this.frameWidth + parseInt(getComputedStyle(newFrame)['margin-right'], 10), stripLeft = this.strip.offsetLeft, frameViewportLeft = frameLeft + stripLeft, frameViewportRight = frameViewportLeft + this.frameWidth;
                    if (frameViewportRight > this.domHandler.width(this.stripWrapper))
                        this.stripLeft -= stepFactor;
                    else if (frameViewportLeft < 0)
                        this.stripLeft += stepFactor;
                }
            }
            this.activeIndex = index;
        }
    };
    Galleria.prototype.clickImage = function (event, image, i) {
        this.onImageClicked.emit({ originalEvent: event, image: image, index: i });
    };
    Galleria.prototype.ngOnDestroy = function () {
        this.stopSlideshow();
    };
    return Galleria;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Galleria.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Galleria.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Galleria.prototype, "panelWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Galleria.prototype, "panelHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Galleria.prototype, "frameWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Galleria.prototype, "frameHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Galleria.prototype, "activeIndex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Galleria.prototype, "showFilmstrip", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Galleria.prototype, "autoPlay", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Galleria.prototype, "transitionInterval", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Galleria.prototype, "showCaption", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", Object)
], Galleria.prototype, "onImageClicked", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], Galleria.prototype, "images", null);
Galleria = __decorate([
    core_1.Component({
        selector: 'p-galleria',
        template: "\n        <div [ngClass]=\"{'ui-galleria ui-widget ui-widget-content ui-corner-all':true}\" [ngStyle]=\"style\" [class]=\"styleClass\" [style.width.px]=\"panelWidth\">\n            <ul class=\"ui-galleria-panel-wrapper\" [style.width.px]=\"panelWidth\" [style.height.px]=\"panelHeight\">\n                <li *ngFor=\"let image of images;let i=index\" class=\"ui-galleria-panel\" [ngClass]=\"{'ui-helper-hidden':i!=activeIndex}\"\n                    [style.width.px]=\"panelWidth\" [style.height.px]=\"panelHeight\" (click)=\"clickImage($event,image,i)\">\n                    <img class=\"ui-panel-images\" [src]=\"image.source\" [alt]=\"image.alt\" [title]=\"image.title\"/>\n                </li>\n            </ul>\n            <div [ngClass]=\"{'ui-galleria-filmstrip-wrapper':true}\" *ngIf=\"showFilmstrip\">\n                <ul class=\"ui-galleria-filmstrip\" style=\"transition:left 1s\" [style.left.px]=\"stripLeft\">\n                    <li #frame *ngFor=\"let image of images;let i=index\" [ngClass]=\"{'ui-galleria-frame-active':i==activeIndex}\" class=\"ui-galleria-frame\" (click)=\"frameClick(frame)\"\n                        [style.width.px]=\"frameWidth\" [style.height.px]=\"frameHeight\" [style.transition]=\"'opacity 0.75s ease'\">\n                        <div class=\"ui-galleria-frame-content\">\n                            <img [src]=\"image.source\" [alt]=\"image.alt\" [title]=\"image.title\" class=\"ui-galleria-frame-image\"\n                                [style.width.px]=\"frameWidth\" [style.height.px]=\"frameHeight\">\n                        </div>\n                    </li>\n                </ul>\n            </div>\n            <div class=\"ui-galleria-nav-prev fa fa-fw fa-chevron-circle-left\" (click)=\"clickNavLeft()\" [style.bottom.px]=\"frameHeight/2\" *ngIf=\"activeIndex !== 0\"></div>\n            <div class=\"ui-galleria-nav-next fa fa-fw fa-chevron-circle-right\" (click)=\"clickNavRight()\" [style.bottom.px]=\"frameHeight/2\"></div>\n            <div class=\"ui-galleria-caption\" *ngIf=\"showCaption&&images\" style=\"display:block\">\n                <h4>{{images[activeIndex]?.title}}</h4><p>{{images[activeIndex]?.alt}}</p>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Galleria);
exports.Galleria = Galleria;
var GalleriaModule = (function () {
    function GalleriaModule() {
    }
    return GalleriaModule;
}());
GalleriaModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Galleria],
        declarations: [Galleria]
    })
], GalleriaModule);
exports.GalleriaModule = GalleriaModule;
//# sourceMappingURL=galleria.js.map

/***/ }),

/***/ "./node_modules/primeng/components/gmap/gmap.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var GMap = (function () {
    function GMap(el, differs, cd, zone) {
        this.el = el;
        this.cd = cd;
        this.zone = zone;
        this.onMapClick = new core_1.EventEmitter();
        this.onOverlayClick = new core_1.EventEmitter();
        this.onOverlayDragStart = new core_1.EventEmitter();
        this.onOverlayDrag = new core_1.EventEmitter();
        this.onOverlayDragEnd = new core_1.EventEmitter();
        this.onMapReady = new core_1.EventEmitter();
        this.onMapDragEnd = new core_1.EventEmitter();
        this.onZoomChanged = new core_1.EventEmitter();
        this.differ = differs.find([]).create(null);
    }
    GMap.prototype.ngAfterViewChecked = function () {
        if (!this.map && this.el.nativeElement.offsetParent) {
            this.initialize();
        }
    };
    GMap.prototype.initialize = function () {
        var _this = this;
        this.map = new google.maps.Map(this.el.nativeElement.children[0], this.options);
        this.onMapReady.emit({
            map: this.map
        });
        if (this.overlays) {
            for (var _i = 0, _a = this.overlays; _i < _a.length; _i++) {
                var overlay = _a[_i];
                overlay.setMap(this.map);
                this.bindOverlayEvents(overlay);
            }
        }
        this.map.addListener('click', function (event) {
            _this.zone.run(function () {
                _this.onMapClick.emit(event);
            });
        });
        this.map.addListener('dragend', function (event) {
            _this.zone.run(function () {
                _this.onMapDragEnd.emit(event);
            });
        });
        this.map.addListener('zoom_changed', function (event) {
            _this.zone.run(function () {
                _this.onZoomChanged.emit(event);
            });
        });
    };
    GMap.prototype.bindOverlayEvents = function (overlay) {
        var _this = this;
        overlay.addListener('click', function (event) {
            _this.zone.run(function () {
                _this.onOverlayClick.emit({
                    originalEvent: event,
                    'overlay': overlay,
                    map: _this.map
                });
            });
        });
        if (overlay.getDraggable()) {
            this.bindDragEvents(overlay);
        }
    };
    GMap.prototype.ngDoCheck = function () {
        var _this = this;
        var changes = this.differ.diff(this.overlays);
        if (changes && this.map) {
            changes.forEachRemovedItem(function (record) { record.item.setMap(null); });
            changes.forEachAddedItem(function (record) {
                record.item.setMap(_this.map);
                record.item.addListener('click', function (event) {
                    _this.zone.run(function () {
                        _this.onOverlayClick.emit({
                            originalEvent: event,
                            overlay: record.item,
                            map: _this.map
                        });
                    });
                });
                if (record.item.getDraggable()) {
                    _this.bindDragEvents(record.item);
                }
            });
        }
    };
    GMap.prototype.bindDragEvents = function (overlay) {
        var _this = this;
        overlay.addListener('dragstart', function (event) {
            _this.zone.run(function () {
                _this.onOverlayDragStart.emit({
                    originalEvent: event,
                    overlay: overlay,
                    map: _this.map
                });
            });
        });
        overlay.addListener('drag', function (event) {
            _this.zone.run(function () {
                _this.onOverlayDrag.emit({
                    originalEvent: event,
                    overlay: overlay,
                    map: _this.map
                });
            });
        });
        overlay.addListener('dragend', function (event) {
            _this.zone.run(function () {
                _this.onOverlayDragEnd.emit({
                    originalEvent: event,
                    overlay: overlay,
                    map: _this.map
                });
            });
        });
    };
    GMap.prototype.getMap = function () {
        return this.map;
    };
    return GMap;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], GMap.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], GMap.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], GMap.prototype, "options", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], GMap.prototype, "overlays", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GMap.prototype, "onMapClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GMap.prototype, "onOverlayClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GMap.prototype, "onOverlayDragStart", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GMap.prototype, "onOverlayDrag", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GMap.prototype, "onOverlayDragEnd", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GMap.prototype, "onMapReady", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GMap.prototype, "onMapDragEnd", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], GMap.prototype, "onZoomChanged", void 0);
GMap = __decorate([
    core_1.Component({
        selector: 'p-gmap',
        template: "<div [ngStyle]=\"style\" [class]=\"styleClass\"></div>"
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, core_1.IterableDiffers, core_1.ChangeDetectorRef, core_1.NgZone])
], GMap);
exports.GMap = GMap;
var GMapModule = (function () {
    function GMapModule() {
    }
    return GMapModule;
}());
GMapModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [GMap],
        declarations: [GMap]
    })
], GMapModule);
exports.GMapModule = GMapModule;
//# sourceMappingURL=gmap.js.map

/***/ }),

/***/ "./node_modules/primeng/components/growl/growl.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var Growl = (function () {
    function Growl(el, domHandler, differs) {
        this.el = el;
        this.domHandler = domHandler;
        this.differs = differs;
        this.life = 3000;
        this.immutable = true;
        this.onClick = new core_1.EventEmitter();
        this.onClose = new core_1.EventEmitter();
        this.valueChange = new core_1.EventEmitter();
        this.zIndex = domhandler_1.DomHandler.zindex;
        this.differ = differs.find([]).create(null);
    }
    Growl.prototype.ngAfterViewInit = function () {
        this.container = this.containerViewChild.nativeElement;
        if (this.value && this.value.length) {
            this.clearTrigger();
        }
    };
    Object.defineProperty(Growl.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (val) {
            this._value = val;
            if (this.container && this.immutable) {
                this.handleValueChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    Growl.prototype.ngDoCheck = function () {
        if (!this.immutable && this.container) {
            var changes = this.differ.diff(this.value);
            if (changes) {
                this.handleValueChange();
            }
        }
    };
    Growl.prototype.handleValueChange = function () {
        if (this.preventRerender) {
            this.preventRerender = false;
            return;
        }
        this.zIndex = ++domhandler_1.DomHandler.zindex;
        this.domHandler.fadeIn(this.container, 250);
        this.clearTrigger();
    };
    Growl.prototype.clearTrigger = function () {
        var _this = this;
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(function () {
            _this.removeAll();
        }, this.life);
    };
    Growl.prototype.remove = function (index, msgel) {
        var _this = this;
        this.domHandler.fadeOut(msgel, 250);
        setTimeout(function () {
            _this.preventRerender = true;
            _this.onClose.emit({ message: _this.value[index] });
            if (_this.immutable) {
                _this._value = _this.value.filter(function (val, i) { return i != index; });
                _this.valueChange.emit(_this._value);
            }
            else {
                _this._value.splice(index, 1);
            }
        }, 250);
    };
    Growl.prototype.removeAll = function () {
        var _this = this;
        if (this.value && this.value.length) {
            this.domHandler.fadeOut(this.container, 250);
            setTimeout(function () {
                _this.value.forEach(function (msg, index) { return _this.onClose.emit({ message: _this.value[index] }); });
                if (_this.immutable) {
                    _this.value = [];
                    _this.valueChange.emit(_this.value);
                }
                else {
                    _this.value.splice(0, _this.value.length);
                }
            }, 250);
        }
    };
    Growl.prototype.onMessageClick = function (i) {
        this.onClick.emit({ message: this.value[i] });
    };
    Growl.prototype.ngOnDestroy = function () {
        if (!this.sticky) {
            clearTimeout(this.timeout);
        }
    };
    return Growl;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Growl.prototype, "sticky", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Growl.prototype, "life", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Growl.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Growl.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Growl.prototype, "immutable", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Growl.prototype, "onClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Growl.prototype, "onClose", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Growl.prototype, "valueChange", void 0);
__decorate([
    core_1.ViewChild('container'),
    __metadata("design:type", core_1.ElementRef)
], Growl.prototype, "containerViewChild", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], Growl.prototype, "value", null);
Growl = __decorate([
    core_1.Component({
        selector: 'p-growl',
        template: "\n        <div #container [ngClass]=\"'ui-growl ui-widget'\" [style.zIndex]=\"zIndex\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div #msgel *ngFor=\"let msg of value;let i = index\" class=\"ui-growl-item-container ui-state-highlight ui-corner-all ui-shadow\" aria-live=\"polite\"\n                [ngClass]=\"{'ui-growl-message-info':msg.severity == 'info','ui-growl-message-warn':msg.severity == 'warn',\n                    'ui-growl-message-error':msg.severity == 'error','ui-growl-message-success':msg.severity == 'success'}\" (click)=\"onMessageClick(i)\">\n                <div class=\"ui-growl-item\">\n                     <div class=\"ui-growl-icon-close fa fa-close\" (click)=\"remove(i,msgel)\"></div>\n                     <span class=\"ui-growl-image fa fa-2x\"\n                        [ngClass]=\"{'fa-info-circle':msg.severity == 'info','fa-exclamation-circle':msg.severity == 'warn',\n                                'fa-close':msg.severity == 'error','fa-check':msg.severity == 'success'}\"></span>\n                     <div class=\"ui-growl-message\">\n                        <span class=\"ui-growl-title\">{{msg.summary}}</span>\n                        <p [innerHTML]=\"msg.detail\"></p>\n                     </div>\n                     <div style=\"clear: both;\"></div>\n                </div>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.IterableDiffers])
], Growl);
exports.Growl = Growl;
var GrowlModule = (function () {
    function GrowlModule() {
    }
    return GrowlModule;
}());
GrowlModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Growl],
        declarations: [Growl]
    })
], GrowlModule);
exports.GrowlModule = GrowlModule;
//# sourceMappingURL=growl.js.map

/***/ }),

/***/ "./node_modules/primeng/components/inplace/inplace.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var button_1 = __webpack_require__("./node_modules/primeng/components/button/button.js");
var InplaceDisplay = (function () {
    function InplaceDisplay() {
    }
    return InplaceDisplay;
}());
InplaceDisplay = __decorate([
    core_1.Component({
        selector: 'p-inplaceDisplay',
        template: '<ng-content></ng-content>'
    })
], InplaceDisplay);
exports.InplaceDisplay = InplaceDisplay;
var InplaceContent = (function () {
    function InplaceContent() {
    }
    return InplaceContent;
}());
InplaceContent = __decorate([
    core_1.Component({
        selector: 'p-inplaceContent',
        template: '<ng-content></ng-content>'
    })
], InplaceContent);
exports.InplaceContent = InplaceContent;
var Inplace = (function () {
    function Inplace() {
        this.onActivate = new core_1.EventEmitter();
        this.onDeactivate = new core_1.EventEmitter();
    }
    Inplace.prototype.activate = function (event) {
        if (!this.disabled) {
            this.active = true;
            this.onActivate.emit(event);
        }
    };
    Inplace.prototype.deactivate = function (event) {
        if (!this.disabled) {
            this.active = false;
            this.hover = false;
            this.onDeactivate.emit(event);
        }
    };
    return Inplace;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Inplace.prototype, "active", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Inplace.prototype, "closable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Inplace.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Inplace.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Inplace.prototype, "styleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Inplace.prototype, "onActivate", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Inplace.prototype, "onDeactivate", void 0);
Inplace = __decorate([
    core_1.Component({
        selector: 'p-inplace',
        template: "\n        <div [ngClass]=\"'ui-inplace ui-widget'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-inplace-display\" (click)=\"activate($event)\"\n                [ngClass]=\"{'ui-state-disabled':disabled}\" *ngIf=\"!active\">\n                <ng-content select=\"[pInplaceDisplay]\"></ng-content>\n            </div>\n            <div class=\"ui-inplace-content\" *ngIf=\"active\">\n                <ng-content select=\"[pInplaceContent]\"></ng-content>\n                <button type=\"button\" icon=\"fa-close\" pButton (click)=\"deactivate($event)\" *ngIf=\"closable\"></button>\n            </div>\n        </div>\n    "
    })
], Inplace);
exports.Inplace = Inplace;
var InplaceModule = (function () {
    function InplaceModule() {
    }
    return InplaceModule;
}());
InplaceModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, button_1.ButtonModule],
        exports: [Inplace, InplaceDisplay, InplaceContent, button_1.ButtonModule],
        declarations: [Inplace, InplaceDisplay, InplaceContent]
    })
], InplaceModule);
exports.InplaceModule = InplaceModule;
//# sourceMappingURL=inplace.js.map

/***/ }),

/***/ "./node_modules/primeng/components/inputmask/inputmask.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
    Port of jQuery MaskedInput by DigitalBush as a Native Angular2 Component in Typescript without jQuery
    https://github.com/digitalBush/jquery.maskedinput/
    
    Copyright (c) 2007-2014 Josh Bush (digitalbush.com)

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
*/
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var inputtext_1 = __webpack_require__("./node_modules/primeng/components/inputtext/inputtext.js");
var forms_1 = __webpack_require__(4);
exports.INPUTMASK_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return InputMask; }),
    multi: true
};
var InputMask = (function () {
    function InputMask(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.type = 'text';
        this.slotChar = '_';
        this.autoClear = true;
        this.onComplete = new core_1.EventEmitter();
        this.onFocus = new core_1.EventEmitter();
        this.onBlur = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    InputMask.prototype.ngOnInit = function () {
        this.tests = [];
        this.partialPosition = this.mask.length;
        this.len = this.mask.length;
        this.firstNonMaskPos = null;
        this.defs = {
            '9': '[0-9]',
            'a': '[A-Za-z]',
            '*': '[A-Za-z0-9]'
        };
        var ua = this.domHandler.getUserAgent();
        this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);
        var maskTokens = this.mask.split('');
        for (var i = 0; i < maskTokens.length; i++) {
            var c = maskTokens[i];
            if (c == '?') {
                this.len--;
                this.partialPosition = i;
            }
            else if (this.defs[c]) {
                this.tests.push(new RegExp(this.defs[c]));
                if (this.firstNonMaskPos === null) {
                    this.firstNonMaskPos = this.tests.length - 1;
                }
                if (i < this.partialPosition) {
                    this.lastRequiredNonMaskPos = this.tests.length - 1;
                }
            }
            else {
                this.tests.push(null);
            }
        }
        this.buffer = [];
        for (var i = 0; i < maskTokens.length; i++) {
            var c = maskTokens[i];
            if (c != '?') {
                if (this.defs[c])
                    this.buffer.push(this.getPlaceholder(i));
                else
                    this.buffer.push(c);
            }
        }
        this.defaultBuffer = this.buffer.join('');
    };
    InputMask.prototype.writeValue = function (value) {
        this.value = value;
        if (this.inputViewChild.nativeElement) {
            if (this.value == undefined || this.value == null)
                this.inputViewChild.nativeElement.value = '';
            else
                this.inputViewChild.nativeElement.value = this.value;
            this.checkVal();
            this.focusText = this.inputViewChild.nativeElement.value;
            this.updateFilledState();
        }
    };
    InputMask.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    InputMask.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    InputMask.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    InputMask.prototype.caret = function (first, last) {
        var range, begin, end;
        if (!this.inputViewChild.nativeElement.offsetParent || this.inputViewChild.nativeElement !== document.activeElement) {
            return;
        }
        if (typeof first == 'number') {
            begin = first;
            end = (typeof last === 'number') ? last : begin;
            if (this.inputViewChild.nativeElement.setSelectionRange) {
                this.inputViewChild.nativeElement.setSelectionRange(begin, end);
            }
            else if (this.inputViewChild.nativeElement['createTextRange']) {
                range = this.inputViewChild.nativeElement['createTextRange']();
                range.collapse(true);
                range.moveEnd('character', end);
                range.moveStart('character', begin);
                range.select();
            }
        }
        else {
            if (this.inputViewChild.nativeElement.setSelectionRange) {
                begin = this.inputViewChild.nativeElement.selectionStart;
                end = this.inputViewChild.nativeElement.selectionEnd;
            }
            else if (document['selection'] && document['selection'].createRange) {
                range = document['selection'].createRange();
                begin = 0 - range.duplicate().moveStart('character', -100000);
                end = begin + range.text.length;
            }
            return { begin: begin, end: end };
        }
    };
    InputMask.prototype.isCompleted = function () {
        var completed;
        for (var i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {
            if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {
                return false;
            }
        }
        return true;
    };
    InputMask.prototype.getPlaceholder = function (i) {
        if (i < this.slotChar.length) {
            return this.slotChar.charAt(i);
        }
        return this.slotChar.charAt(0);
    };
    InputMask.prototype.seekNext = function (pos) {
        while (++pos < this.len && !this.tests[pos])
            ;
        return pos;
    };
    InputMask.prototype.seekPrev = function (pos) {
        while (--pos >= 0 && !this.tests[pos])
            ;
        return pos;
    };
    InputMask.prototype.shiftL = function (begin, end) {
        var i, j;
        if (begin < 0) {
            return;
        }
        for (i = begin, j = this.seekNext(end); i < this.len; i++) {
            if (this.tests[i]) {
                if (j < this.len && this.tests[i].test(this.buffer[j])) {
                    this.buffer[i] = this.buffer[j];
                    this.buffer[j] = this.getPlaceholder(j);
                }
                else {
                    break;
                }
                j = this.seekNext(j);
            }
        }
        this.writeBuffer();
        this.caret(Math.max(this.firstNonMaskPos, begin));
    };
    InputMask.prototype.shiftR = function (pos) {
        var i, c, j, t;
        for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {
            if (this.tests[i]) {
                j = this.seekNext(i);
                t = this.buffer[i];
                this.buffer[i] = c;
                if (j < this.len && this.tests[j].test(t)) {
                    c = t;
                }
                else {
                    break;
                }
            }
        }
    };
    InputMask.prototype.handleAndroidInput = function (e) {
        var _this = this;
        var curVal = this.inputViewChild.nativeElement.value;
        var pos = this.caret();
        if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {
            // a deletion or backspace happened
            this.checkVal(true);
            while (pos.begin > 0 && !this.tests[pos.begin - 1])
                pos.begin--;
            if (pos.begin === 0) {
                while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin])
                    pos.begin++;
            }
            this.caret(pos.begin, pos.begin);
        }
        else {
            this.checkVal(true);
            while (pos.begin < this.len && !this.tests[pos.begin - 1])
                pos.begin++;
            setTimeout(function () { return _this.caret(pos.begin, pos.begin); });
        }
        if (this.isCompleted()) {
            this.onComplete.emit();
        }
    };
    InputMask.prototype.onInputBlur = function (e) {
        this.focus = false;
        this.onModelTouched();
        this.checkVal();
        this.updateModel(e);
        this.updateFilledState();
        this.onBlur.emit(e);
        if (this.inputViewChild.nativeElement.value != this.focusText) {
            var event_1 = document.createEvent('HTMLEvents');
            event_1.initEvent('change', true, false);
            this.inputViewChild.nativeElement.dispatchEvent(event_1);
        }
    };
    InputMask.prototype.onKeyDown = function (e) {
        if (this.readonly) {
            return;
        }
        var k = e.which || e.keyCode, pos, begin, end;
        var iPhone = /iphone/i.test(this.domHandler.getUserAgent());
        this.oldVal = this.inputViewChild.nativeElement.value;
        //backspace, delete, and escape get special treatment
        if (k === 8 || k === 46 || (iPhone && k === 127)) {
            pos = this.caret();
            begin = pos.begin;
            end = pos.end;
            if (end - begin === 0) {
                begin = k !== 46 ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));
                end = k === 46 ? this.seekNext(end) : end;
            }
            this.clearBuffer(begin, end);
            this.shiftL(begin, end - 1);
            this.updateModel(e);
            e.preventDefault();
        }
        else if (k === 13) {
            this.onInputBlur(e);
            this.updateModel(e);
        }
        else if (k === 27) {
            this.inputViewChild.nativeElement.value = this.focusText;
            this.caret(0, this.checkVal());
            this.updateModel(e);
            e.preventDefault();
        }
    };
    InputMask.prototype.onKeyPress = function (e) {
        var _this = this;
        if (this.readonly) {
            return;
        }
        var k = e.which || e.keyCode, pos = this.caret(), p, c, next, completed;
        if (e.ctrlKey || e.altKey || e.metaKey || k < 32) {
            return;
        }
        else if (k && k !== 13) {
            if (pos.end - pos.begin !== 0) {
                this.clearBuffer(pos.begin, pos.end);
                this.shiftL(pos.begin, pos.end - 1);
            }
            p = this.seekNext(pos.begin - 1);
            if (p < this.len) {
                c = String.fromCharCode(k);
                if (this.tests[p].test(c)) {
                    this.shiftR(p);
                    this.buffer[p] = c;
                    this.writeBuffer();
                    next = this.seekNext(p);
                    if (/android/i.test(this.domHandler.getUserAgent())) {
                        //Path for CSP Violation on FireFox OS 1.1
                        var proxy = function () {
                            _this.caret(next);
                        };
                        setTimeout(proxy, 0);
                    }
                    else {
                        this.caret(next);
                    }
                    if (pos.begin <= this.lastRequiredNonMaskPos) {
                        completed = this.isCompleted();
                    }
                }
            }
            e.preventDefault();
        }
        this.updateModel(e);
        this.updateFilledState();
        if (completed) {
            this.onComplete.emit();
        }
    };
    InputMask.prototype.clearBuffer = function (start, end) {
        var i;
        for (i = start; i < end && i < this.len; i++) {
            if (this.tests[i]) {
                this.buffer[i] = this.getPlaceholder(i);
            }
        }
    };
    InputMask.prototype.writeBuffer = function () {
        this.inputViewChild.nativeElement.value = this.buffer.join('');
    };
    InputMask.prototype.checkVal = function (allow) {
        //try to place characters where they belong
        var test = this.inputViewChild.nativeElement.value, lastMatch = -1, i, c, pos;
        for (i = 0, pos = 0; i < this.len; i++) {
            if (this.tests[i]) {
                this.buffer[i] = this.getPlaceholder(i);
                while (pos++ < test.length) {
                    c = test.charAt(pos - 1);
                    if (this.tests[i].test(c)) {
                        this.buffer[i] = c;
                        lastMatch = i;
                        break;
                    }
                }
                if (pos > test.length) {
                    this.clearBuffer(i + 1, this.len);
                    break;
                }
            }
            else {
                if (this.buffer[i] === test.charAt(pos)) {
                    pos++;
                }
                if (i < this.partialPosition) {
                    lastMatch = i;
                }
            }
        }
        if (allow) {
            this.writeBuffer();
        }
        else if (lastMatch + 1 < this.partialPosition) {
            if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {
                // Invalid value. Remove it and replace it with the
                // mask, which is the default behavior.
                if (this.inputViewChild.nativeElement.value)
                    this.inputViewChild.nativeElement.value = '';
                this.clearBuffer(0, this.len);
            }
            else {
                // Invalid value, but we opt to show the value to the
                // user and allow them to correct their mistake.
                this.writeBuffer();
            }
        }
        else {
            this.writeBuffer();
            this.inputViewChild.nativeElement.value = this.inputViewChild.nativeElement.value.substring(0, lastMatch + 1);
        }
        return (this.partialPosition ? i : this.firstNonMaskPos);
    };
    InputMask.prototype.onInputFocus = function (event) {
        var _this = this;
        if (this.readonly) {
            return;
        }
        this.focus = true;
        clearTimeout(this.caretTimeoutId);
        var pos;
        this.focusText = this.inputViewChild.nativeElement.value;
        pos = this.checkVal();
        this.caretTimeoutId = setTimeout(function () {
            if (_this.inputViewChild.nativeElement !== document.activeElement) {
                return;
            }
            _this.writeBuffer();
            if (pos == _this.mask.replace("?", "").length) {
                _this.caret(0, pos);
            }
            else {
                _this.caret(pos);
            }
        }, 10);
        this.onFocus.emit(event);
    };
    InputMask.prototype.onInput = function (event) {
        if (this.androidChrome)
            this.handleAndroidInput(event);
        else
            this.handleInputChange(event);
    };
    InputMask.prototype.handleInputChange = function (event) {
        var _this = this;
        if (this.readonly) {
            return;
        }
        setTimeout(function () {
            var pos = _this.checkVal(true);
            _this.caret(pos);
            _this.updateModel(event);
            if (_this.isCompleted()) {
                _this.onComplete.emit();
            }
        }, 0);
    };
    InputMask.prototype.getUnmaskedValue = function () {
        var unmaskedBuffer = [];
        for (var i = 0; i < this.buffer.length; i++) {
            var c = this.buffer[i];
            if (this.tests[i] && c != this.getPlaceholder(i)) {
                unmaskedBuffer.push(c);
            }
        }
        return unmaskedBuffer.join('');
    };
    InputMask.prototype.updateModel = function (e) {
        this.onModelChange(this.unmask ? this.getUnmaskedValue() : e.target.value);
    };
    InputMask.prototype.updateFilledState = function () {
        this.filled = this.inputViewChild.nativeElement && this.inputViewChild.nativeElement.value != '';
    };
    InputMask.prototype.ngOnDestroy = function () {
    };
    return InputMask;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "mask", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "type", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "slotChar", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], InputMask.prototype, "autoClear", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "placeholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], InputMask.prototype, "size", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], InputMask.prototype, "maxlength", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], InputMask.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], InputMask.prototype, "readonly", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], InputMask.prototype, "unmask", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputMask.prototype, "name", void 0);
__decorate([
    core_1.ViewChild('input'),
    __metadata("design:type", core_1.ElementRef)
], InputMask.prototype, "inputViewChild", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], InputMask.prototype, "onComplete", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], InputMask.prototype, "onFocus", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], InputMask.prototype, "onBlur", void 0);
InputMask = __decorate([
    core_1.Component({
        selector: 'p-inputMask',
        template: "<input #input pInputText [attr.id]=\"inputId\" [attr.type]=\"type\" [attr.name]=\"name\" [ngStyle]=\"style\" [ngClass]=\"styleClass\" [attr.placeholder]=\"placeholder\"\n        [attr.size]=\"size\" [attr.maxlength]=\"maxlength\" [attr.tabindex]=\"tabindex\" [disabled]=\"disabled\" [readonly]=\"readonly\"\n        (focus)=\"onInputFocus($event)\" (blur)=\"onInputBlur($event)\" (keydown)=\"onKeyDown($event)\" (keypress)=\"onKeyPress($event)\"\n        (input)=\"onInput($event)\" (paste)=\"handleInputChange($event)\">",
        host: {
            '[class.ui-inputwrapper-filled]': 'filled',
            '[class.ui-inputwrapper-focus]': 'focus'
        },
        providers: [exports.INPUTMASK_VALUE_ACCESSOR, domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], InputMask);
exports.InputMask = InputMask;
var InputMaskModule = (function () {
    function InputMaskModule() {
    }
    return InputMaskModule;
}());
InputMaskModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, inputtext_1.InputTextModule],
        exports: [InputMask],
        declarations: [InputMask]
    })
], InputMaskModule);
exports.InputMaskModule = InputMaskModule;
//# sourceMappingURL=inputmask.js.map

/***/ }),

/***/ "./node_modules/primeng/components/inputswitch/inputswitch.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var forms_1 = __webpack_require__(4);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
exports.INPUTSWITCH_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return InputSwitch; }),
    multi: true
};
var InputSwitch = (function () {
    function InputSwitch(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.onLabel = 'On';
        this.offLabel = 'Off';
        this.ariaLabelTemplate = "InputSwitch {0}";
        this.onChange = new core_1.EventEmitter();
        this.checked = false;
        this.focused = false;
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
        this.initialized = false;
    }
    InputSwitch.prototype.ngAfterViewInit = function () {
        this.container = this.el.nativeElement.children[0];
        this.handle = this.domHandler.findSingle(this.el.nativeElement, 'div.ui-inputswitch-handle');
        this.onContainer = this.domHandler.findSingle(this.container, 'div.ui-inputswitch-on');
        this.offContainer = this.domHandler.findSingle(this.container, 'div.ui-inputswitch-off');
        this.onLabelChild = this.domHandler.findSingle(this.onContainer, 'span.ui-inputswitch-onlabel');
        this.offLabelChild = this.domHandler.findSingle(this.offContainer, 'span.ui-inputswitch-offlabel');
    };
    InputSwitch.prototype.ngAfterViewChecked = function () {
        if (this.container.offsetParent && !this.initialized) {
            this.render();
        }
    };
    InputSwitch.prototype.render = function () {
        var onContainerWidth = this.domHandler.width(this.onContainer), offContainerWidth = this.domHandler.width(this.offContainer), spanPadding = this.domHandler.innerWidth(this.offLabelChild) - this.domHandler.width(this.offLabelChild), handleMargins = this.domHandler.getOuterWidth(this.handle) - this.domHandler.innerWidth(this.handle);
        var containerWidth = (onContainerWidth > offContainerWidth) ? onContainerWidth : offContainerWidth, handleWidth = containerWidth;
        this.handle.style.width = handleWidth + 'px';
        handleWidth = this.domHandler.width(this.handle);
        containerWidth = containerWidth + handleWidth + 6;
        var labelWidth = containerWidth - handleWidth - spanPadding - handleMargins;
        this.container.style.width = containerWidth + 'px';
        this.onLabelChild.style.width = labelWidth + 'px';
        this.offLabelChild.style.width = labelWidth + 'px';
        //position
        this.offContainer.style.width = (this.domHandler.width(this.container) - 5) + 'px';
        this.offset = this.domHandler.width(this.container) - this.domHandler.getOuterWidth(this.handle);
        //default value
        if (this.checked) {
            this.handle.style.left = this.offset + 'px';
            this.onContainer.style.width = this.offset + 'px';
            this.offLabelChild.style.marginRight = -this.offset + 'px';
        }
        else {
            this.onContainer.style.width = 0 + 'px';
            this.onLabelChild.style.marginLeft = -this.offset + 'px';
        }
        this.initialized = true;
    };
    InputSwitch.prototype.toggle = function (event, checkbox) {
        if (!this.disabled) {
            if (this.checked) {
                this.checked = false;
                this.uncheckUI();
            }
            else {
                this.checked = true;
                this.checkUI();
            }
            this.onModelChange(this.checked);
            this.onChange.emit({
                originalEvent: event,
                checked: this.checked
            });
            checkbox.focus();
        }
    };
    InputSwitch.prototype.checkUI = function () {
        this.onContainer.style.width = this.offset + 'px';
        this.onLabelChild.style.marginLeft = 0 + 'px';
        this.offLabelChild.style.marginRight = -this.offset + 'px';
        this.handle.style.left = this.offset + 'px';
        this.updateAriaLabel();
    };
    InputSwitch.prototype.uncheckUI = function () {
        this.onContainer.style.width = 0 + 'px';
        this.onLabelChild.style.marginLeft = -this.offset + 'px';
        this.offLabelChild.style.marginRight = 0 + 'px';
        this.handle.style.left = 0 + 'px';
        this.updateAriaLabel();
    };
    InputSwitch.prototype.onFocus = function (event) {
        this.focused = true;
    };
    InputSwitch.prototype.onBlur = function (event) {
        this.focused = false;
        this.onModelTouched();
    };
    InputSwitch.prototype.writeValue = function (checked) {
        this.checked = checked;
        if (this.initialized) {
            if (this.checked === true)
                this.checkUI();
            else
                this.uncheckUI();
        }
    };
    InputSwitch.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    InputSwitch.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    InputSwitch.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    InputSwitch.prototype.updateAriaLabel = function () {
        var pattern = /{(.*?)}/, value = this.checked ? this.onLabel : this.offLabel;
        this.ariaLabel = this.ariaLabelTemplate.replace(this.ariaLabelTemplate.match(pattern)[0], value);
    };
    return InputSwitch;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputSwitch.prototype, "onLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputSwitch.prototype, "offLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], InputSwitch.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], InputSwitch.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputSwitch.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], InputSwitch.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputSwitch.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], InputSwitch.prototype, "ariaLabelTemplate", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], InputSwitch.prototype, "onChange", void 0);
InputSwitch = __decorate([
    core_1.Component({
        selector: 'p-inputSwitch',
        template: "\n        <div [ngClass]=\"{'ui-inputswitch ui-widget ui-widget-content ui-corner-all': true,\n            'ui-state-disabled': disabled,'ui-inputswitch-checked':checked, 'ui-state-focus':focused}\" (click)=\"toggle($event, in)\"\n            [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-inputswitch-off\">\n                <span class=\"ui-inputswitch-offlabel\">{{offLabel}}</span>\n            </div>\n            <div class=\"ui-inputswitch-on\">\n                <span class=\"ui-inputswitch-onlabel\">{{onLabel}}</span>\n            </div>\n            <div [ngClass]=\"{'ui-inputswitch-handle ui-state-default':true, 'ui-state-focus':focused}\"></div>\n            <div class=\"ui-helper-hidden-accessible\">\n                <input #in type=\"checkbox\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledBy\" aria-live=\"polite\" [attr.id]=\"inputId\" (focus)=\"onFocus($event)\" (blur)=\"onBlur($event)\" readonly=\"readonly\" [attr.tabindex]=\"tabindex\"/>\n            </div>\n        </div>\n    ",
        providers: [exports.INPUTSWITCH_VALUE_ACCESSOR, domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], InputSwitch);
exports.InputSwitch = InputSwitch;
var InputSwitchModule = (function () {
    function InputSwitchModule() {
    }
    return InputSwitchModule;
}());
InputSwitchModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [InputSwitch],
        declarations: [InputSwitch]
    })
], InputSwitchModule);
exports.InputSwitchModule = InputSwitchModule;
//# sourceMappingURL=inputswitch.js.map

/***/ }),

/***/ "./node_modules/primeng/components/inputtext/inputtext.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var InputText = (function () {
    function InputText(el) {
        this.el = el;
    }
    InputText.prototype.ngDoCheck = function () {
        this.updateFilledState();
    };
    //To trigger change detection to manage ui-state-filled for material labels when there is no value binding
    InputText.prototype.onInput = function (e) {
        this.updateFilledState();
    };
    InputText.prototype.updateFilledState = function () {
        this.filled = this.el.nativeElement.value && this.el.nativeElement.value.length;
    };
    return InputText;
}());
__decorate([
    core_1.HostListener('input', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], InputText.prototype, "onInput", null);
InputText = __decorate([
    core_1.Directive({
        selector: '[pInputText]',
        host: {
            '[class.ui-inputtext]': 'true',
            '[class.ui-corner-all]': 'true',
            '[class.ui-state-default]': 'true',
            '[class.ui-widget]': 'true',
            '[class.ui-state-filled]': 'filled'
        }
    }),
    __metadata("design:paramtypes", [core_1.ElementRef])
], InputText);
exports.InputText = InputText;
var InputTextModule = (function () {
    function InputTextModule() {
    }
    return InputTextModule;
}());
InputTextModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [InputText],
        declarations: [InputText]
    })
], InputTextModule);
exports.InputTextModule = InputTextModule;
//# sourceMappingURL=inputtext.js.map

/***/ }),

/***/ "./node_modules/primeng/components/inputtextarea/inputtextarea.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var InputTextarea = (function () {
    function InputTextarea(el) {
        this.el = el;
        this.onResize = new core_1.EventEmitter();
    }
    InputTextarea.prototype.ngOnInit = function () {
        this.rowsDefault = this.rows;
        this.colsDefault = this.cols;
    };
    InputTextarea.prototype.ngDoCheck = function () {
        this.updateFilledState();
    };
    //To trigger change detection to manage ui-state-filled for material labels when there is no value binding
    InputTextarea.prototype.onInput = function (e) {
        this.updateFilledState();
    };
    InputTextarea.prototype.updateFilledState = function () {
        this.filled = this.el.nativeElement.value && this.el.nativeElement.value.length;
    };
    InputTextarea.prototype.onFocus = function (e) {
        if (this.autoResize) {
            this.resize(e);
        }
    };
    InputTextarea.prototype.onBlur = function (e) {
        if (this.autoResize) {
            this.resize(e);
        }
    };
    InputTextarea.prototype.onKeyup = function (e) {
        if (this.autoResize) {
            this.resize(e);
        }
    };
    InputTextarea.prototype.resize = function (event) {
        var linesCount = 0, lines = this.el.nativeElement.value.split('\n');
        for (var i = lines.length - 1; i >= 0; --i) {
            linesCount += Math.floor((lines[i].length / this.colsDefault) + 1);
        }
        this.rows = (linesCount >= this.rowsDefault) ? (linesCount + 1) : this.rowsDefault;
        this.onResize.emit(event || {});
    };
    return InputTextarea;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], InputTextarea.prototype, "autoResize", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], InputTextarea.prototype, "rows", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], InputTextarea.prototype, "cols", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], InputTextarea.prototype, "onResize", void 0);
__decorate([
    core_1.HostListener('input', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], InputTextarea.prototype, "onInput", null);
__decorate([
    core_1.HostListener('focus', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], InputTextarea.prototype, "onFocus", null);
__decorate([
    core_1.HostListener('blur', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], InputTextarea.prototype, "onBlur", null);
__decorate([
    core_1.HostListener('keyup', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], InputTextarea.prototype, "onKeyup", null);
InputTextarea = __decorate([
    core_1.Directive({
        selector: '[pInputTextarea]',
        host: {
            '[class.ui-inputtext]': 'true',
            '[class.ui-corner-all]': 'true',
            '[class.ui-state-default]': 'true',
            '[class.ui-widget]': 'true',
            '[class.ui-state-filled]': 'filled',
            '[attr.rows]': 'rows',
            '[attr.cols]': 'cols'
        }
    }),
    __metadata("design:paramtypes", [core_1.ElementRef])
], InputTextarea);
exports.InputTextarea = InputTextarea;
var InputTextareaModule = (function () {
    function InputTextareaModule() {
    }
    return InputTextareaModule;
}());
InputTextareaModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [InputTextarea],
        declarations: [InputTextarea]
    })
], InputTextareaModule);
exports.InputTextareaModule = InputTextareaModule;
//# sourceMappingURL=inputtextarea.js.map

/***/ }),

/***/ "./node_modules/primeng/components/lightbox/lightbox.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var Lightbox = (function () {
    function Lightbox(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.type = 'image';
        this.effectDuration = '500ms';
    }
    Lightbox.prototype.onImageClick = function (event, image, i, content) {
        this.index = i;
        this.loading = true;
        content.style.width = 32 + 'px';
        content.style.height = 32 + 'px';
        this.show();
        this.displayImage(image);
        this.preventDocumentClickListener = true;
        event.preventDefault();
    };
    Lightbox.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.panel = this.domHandler.findSingle(this.el.nativeElement, '.ui-lightbox ');
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.panel);
            else
                this.domHandler.appendChild(this.panel, this.appendTo);
        }
        this.documentClickListener = this.renderer.listen('document', 'click', function (event) {
            if (!_this.preventDocumentClickListener && _this.visible) {
                _this.hide(event);
            }
            _this.preventDocumentClickListener = false;
        });
    };
    Lightbox.prototype.onLinkClick = function (event, content) {
        this.show();
        this.preventDocumentClickListener = true;
        event.preventDefault();
    };
    Lightbox.prototype.displayImage = function (image) {
        var _this = this;
        setTimeout(function () {
            _this.currentImage = image;
            _this.captionText = image.title;
            _this.center();
        }, 1000);
    };
    Lightbox.prototype.show = function () {
        this.mask = document.createElement('div');
        this.mask.style.zIndex = ++domhandler_1.DomHandler.zindex;
        this.domHandler.addMultipleClasses(this.mask, 'ui-widget-overlay ui-dialog-mask');
        document.body.appendChild(this.mask);
        this.zindex = ++domhandler_1.DomHandler.zindex;
        this.center();
        this.visible = true;
    };
    Lightbox.prototype.hide = function (event) {
        this.captionText = null;
        this.index = null;
        this.currentImage = null;
        this.visible = false;
        this.panel.style.left = 'auto';
        this.panel.style.top = 'auto';
        if (this.mask) {
            document.body.removeChild(this.mask);
            this.mask = null;
        }
        event.preventDefault();
    };
    Lightbox.prototype.center = function () {
        var elementWidth = this.domHandler.getOuterWidth(this.panel);
        var elementHeight = this.domHandler.getOuterHeight(this.panel);
        if (elementWidth == 0 && elementHeight == 0) {
            this.panel.style.visibility = 'hidden';
            this.panel.style.display = 'block';
            elementWidth = this.domHandler.getOuterWidth(this.panel);
            elementHeight = this.domHandler.getOuterHeight(this.panel);
            this.panel.style.display = 'none';
            this.panel.style.visibility = 'visible';
        }
        var viewport = this.domHandler.getViewport();
        var x = (viewport.width - elementWidth) / 2;
        var y = (viewport.height - elementHeight) / 2;
        this.panel.style.left = x + 'px';
        this.panel.style.top = y + 'px';
    };
    Lightbox.prototype.onImageLoad = function (event, content) {
        var _this = this;
        var image = event.target;
        image.style.visibility = 'hidden';
        image.style.display = 'block';
        var imageWidth = this.domHandler.getOuterWidth(image);
        var imageHeight = this.domHandler.getOuterHeight(image);
        image.style.display = 'none';
        image.style.visibility = 'visible';
        content.style.width = imageWidth + 'px';
        content.style.height = imageHeight + 'px';
        this.panel.style.left = parseInt(this.panel.style.left) + (this.domHandler.getOuterWidth(this.panel) - imageWidth) / 2 + 'px';
        this.panel.style.top = parseInt(this.panel.style.top) + (this.domHandler.getOuterHeight(this.panel) - imageHeight) / 2 + 'px';
        setTimeout(function () {
            _this.domHandler.fadeIn(image, 500);
            image.style.display = 'block';
            //this.captionText = this.currentImage.title;
            _this.loading = false;
        }, parseInt(this.effectDuration));
    };
    Lightbox.prototype.prev = function (placeholder) {
        this.captionText = null;
        this.loading = true;
        placeholder.style.display = 'none';
        if (this.index > 0) {
            this.displayImage(this.images[--this.index]);
        }
    };
    Lightbox.prototype.next = function (placeholder) {
        this.captionText = null;
        this.loading = true;
        placeholder.style.display = 'none';
        if (this.index <= (this.images.length - 1)) {
            this.displayImage(this.images[++this.index]);
        }
    };
    Object.defineProperty(Lightbox.prototype, "leftVisible", {
        get: function () {
            return this.images && this.images.length && this.index != 0 && !this.loading;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Lightbox.prototype, "rightVisible", {
        get: function () {
            return this.images && this.images.length && this.index < (this.images.length - 1) && !this.loading;
        },
        enumerable: true,
        configurable: true
    });
    Lightbox.prototype.ngOnDestroy = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
        if (this.appendTo) {
            this.el.nativeElement.appendChild(this.panel);
        }
    };
    return Lightbox;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Lightbox.prototype, "images", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Lightbox.prototype, "type", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Lightbox.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Lightbox.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Lightbox.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Lightbox.prototype, "easing", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Lightbox.prototype, "effectDuration", void 0);
Lightbox = __decorate([
    core_1.Component({
        selector: 'p-lightbox',
        template: "\n        <div [ngStyle]=\"style\" [class]=\"styleClass\" *ngIf=\"(type == 'image')\">\n            <a *ngFor=\"let image of images; let i = index;\" [href]=\"image.source\" (click)=\"onImageClick($event,image,i,content)\">\n                <img [src]=\"image.thumbnail\" [title]=\"image.title\" [alt]=\"image.alt\">\n            </a>\n        </div>\n        <span [ngStyle]=\"style\" [class]=\"styleClass\" *ngIf=\"(type == 'content')\" (click)=\"onLinkClick($event,content)\">\n            <ng-content select=\"a\"></ng-content>\n        </span>\n        <div class=\"ui-lightbox ui-widget ui-helper-hidden ui-corner-all ui-shadow\" [style.display]=\"visible ? 'block' : 'none'\" [style.zIndex]=\"zindex\"\n            [ngClass]=\"{'ui-lightbox-loading': loading}\"\n            [style.transitionProperty]=\"'all'\" [style.transitionDuration]=\"effectDuration\" [style.transitionTimingFunction]=\"easing\" (click)=\"preventDocumentClickListener=true\">\n           <div class=\"ui-lightbox-content-wrapper\">\n              <a class=\"ui-state-default ui-lightbox-nav-left ui-corner-right\" [style.zIndex]=\"zindex + 1\" (click)=\"prev(img)\"\n                [ngClass]=\"{'ui-helper-hidden':!leftVisible}\"><span class=\"fa fa-fw fa-caret-left\"></span></a>\n              <div #content class=\"ui-lightbox-content ui-corner-all\" #content \n                [style.transitionProperty]=\"'width,height'\" [style.transitionDuration]=\"effectDuration\" [style.transitionTimingFunction]=\"easing\">\n                <img #img [src]=\"currentImage ? currentImage.source||'' : ''\" (load)=\"onImageLoad($event,content)\" style=\"display:none\">\n                <ng-content></ng-content>\n              </div>\n              <a class=\"ui-state-default ui-lightbox-nav-right ui-corner-left ui-helper-hidden\" [style.zIndex]=\"zindex + 1\" (click)=\"next(img)\"\n                [ngClass]=\"{'ui-helper-hidden':!rightVisible}\"><span class=\"fa fa-fw fa-caret-right\"></span></a>\n           </div>\n           <div class=\"ui-lightbox-caption ui-widget-header\" [style.display]=\"captionText ? 'block' : 'none'\">\n              <span class=\"ui-lightbox-caption-text\">{{captionText}}</span><a class=\"ui-lightbox-close ui-corner-all\" href=\"#\" (click)=\"hide($event)\"><span class=\"fa fa-fw fa-close\"></span></a>\n              <div style=\"clear:both\"></div>\n           </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], Lightbox);
exports.Lightbox = Lightbox;
var LightboxModule = (function () {
    function LightboxModule() {
    }
    return LightboxModule;
}());
LightboxModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Lightbox],
        declarations: [Lightbox]
    })
], LightboxModule);
exports.LightboxModule = LightboxModule;
//# sourceMappingURL=lightbox.js.map

/***/ }),

/***/ "./node_modules/primeng/components/listbox/listbox.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var objectutils_1 = __webpack_require__("./node_modules/primeng/components/utils/objectutils.js");
var forms_1 = __webpack_require__(4);
exports.LISTBOX_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Listbox; }),
    multi: true
};
var Listbox = (function () {
    function Listbox(el, domHandler, objectUtils) {
        this.el = el;
        this.domHandler = domHandler;
        this.objectUtils = objectUtils;
        this.checkbox = false;
        this.filter = false;
        this.metaKeySelection = true;
        this.onChange = new core_1.EventEmitter();
        this.onDblClick = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    Listbox.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    Listbox.prototype.writeValue = function (value) {
        this.value = value;
    };
    Listbox.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Listbox.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Listbox.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    Listbox.prototype.onOptionClick = function (event, option) {
        if (this.disabled) {
            return;
        }
        if (!this.checkboxClick) {
            if (this.multiple)
                this.onOptionClickMultiple(event, option);
            else
                this.onOptionClickSingle(event, option);
        }
        else {
            this.checkboxClick = false;
        }
        this.optionTouched = false;
    };
    Listbox.prototype.onOptionTouchEnd = function (event, option) {
        if (this.disabled) {
            return;
        }
        this.optionTouched = true;
    };
    Listbox.prototype.onOptionClickSingle = function (event, option) {
        var selected = this.isSelected(option);
        var valueChanged = false;
        var metaSelection = this.optionTouched ? false : this.metaKeySelection;
        if (metaSelection) {
            var metaKey = (event.metaKey || event.ctrlKey);
            if (selected) {
                if (metaKey) {
                    this.value = null;
                    valueChanged = true;
                }
            }
            else {
                this.value = option.value;
                valueChanged = true;
            }
        }
        else {
            this.value = selected ? null : option.value;
            valueChanged = true;
        }
        if (valueChanged) {
            this.onModelChange(this.value);
            this.onChange.emit({
                originalEvent: event,
                value: this.value
            });
        }
    };
    Listbox.prototype.onOptionClickMultiple = function (event, option) {
        var selected = this.isSelected(option);
        var valueChanged = false;
        var metaSelection = this.optionTouched ? false : this.metaKeySelection;
        if (metaSelection) {
            var metaKey = (event.metaKey || event.ctrlKey);
            if (selected) {
                if (metaKey) {
                    this.removeOption(option);
                }
                else {
                    this.value = [option.value];
                }
                valueChanged = true;
            }
            else {
                this.value = (metaKey) ? this.value || [] : [];
                this.value = this.value.concat([option.value]);
                valueChanged = true;
            }
        }
        else {
            if (selected) {
                this.removeOption(option);
            }
            else {
                this.value = (this.value || []).concat([option.value]);
            }
            valueChanged = true;
        }
        if (valueChanged) {
            this.onModelChange(this.value);
            this.onChange.emit({
                originalEvent: event,
                value: this.value
            });
        }
    };
    Listbox.prototype.removeOption = function (option) {
        var _this = this;
        this.value = this.value.filter(function (val) { return !_this.objectUtils.equals(val, option.value, _this.dataKey); });
    };
    Listbox.prototype.isSelected = function (option) {
        var selected = false;
        if (this.multiple) {
            if (this.value) {
                for (var _i = 0, _a = this.value; _i < _a.length; _i++) {
                    var val = _a[_i];
                    if (this.objectUtils.equals(val, option.value, this.dataKey)) {
                        selected = true;
                        break;
                    }
                }
            }
        }
        else {
            selected = this.objectUtils.equals(this.value, option.value, this.dataKey);
        }
        return selected;
    };
    Object.defineProperty(Listbox.prototype, "allChecked", {
        get: function () {
            if (this.filterValue && this.filterValue.trim().length)
                return this.allFilteredSelected();
            else
                return this.value && this.options && (this.value.length == this.options.length);
        },
        enumerable: true,
        configurable: true
    });
    Listbox.prototype.allFilteredSelected = function () {
        var allSelected;
        if (this.value && this.visibleOptions && this.visibleOptions.length) {
            allSelected = true;
            for (var _i = 0, _a = this.visibleOptions; _i < _a.length; _i++) {
                var opt = _a[_i];
                var selected = void 0;
                for (var _b = 0, _c = this.value; _b < _c.length; _b++) {
                    var val = _c[_b];
                    if (this.objectUtils.equals(val, opt.value, this.dataKey)) {
                        selected = true;
                    }
                }
                if (!selected) {
                    allSelected = false;
                    break;
                }
            }
        }
        return allSelected;
    };
    Listbox.prototype.onFilter = function (event) {
        this.filterValue = event.target.value.trim().toLowerCase();
        this.visibleOptions = [];
        for (var i = 0; i < this.options.length; i++) {
            var option = this.options[i];
            if (option.label.toLowerCase().indexOf(this.filterValue.toLowerCase()) > -1) {
                this.visibleOptions.push(option);
            }
        }
        this.filtered = true;
    };
    Listbox.prototype.toggleAll = function (event, checkbox) {
        if (this.disabled || (this.filterValue && this.filterValue.trim().length && (!this.visibleOptions || this.visibleOptions.length === 0))) {
            return;
        }
        if (checkbox.checked) {
            this.value = [];
        }
        else {
            var opts = (this.visibleOptions && this.visibleOptions.length) ? this.visibleOptions : this.options;
            if (opts) {
                this.value = [];
                for (var i = 0; i < opts.length; i++) {
                    this.value.push(opts[i].value);
                }
            }
        }
        checkbox.checked = !checkbox.checked;
        this.onModelChange(this.value);
        this.onChange.emit({ originalEvent: event, value: this.value });
    };
    Listbox.prototype.isItemVisible = function (option) {
        if (this.filterValue && this.filterValue.trim().length) {
            for (var i = 0; i < this.visibleOptions.length; i++) {
                if (this.visibleOptions[i].value == option.value) {
                    return true;
                }
            }
        }
        else {
            return true;
        }
    };
    Listbox.prototype.onDoubleClick = function (event, option) {
        if (this.disabled) {
            return;
        }
        this.onDblClick.emit({
            originalEvent: event,
            value: this.value
        });
    };
    Listbox.prototype.onCheckboxClick = function (event, option) {
        if (this.disabled) {
            return;
        }
        this.checkboxClick = true;
        var selected = this.isSelected(option);
        if (selected) {
            this.removeOption(option);
        }
        else {
            this.value = this.value ? this.value : [];
            this.value = this.value.concat([option.value]);
        }
        this.onModelChange(this.value);
        this.onChange.emit({
            originalEvent: event,
            value: this.value
        });
    };
    return Listbox;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Listbox.prototype, "options", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Listbox.prototype, "multiple", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Listbox.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Listbox.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Listbox.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Listbox.prototype, "checkbox", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Listbox.prototype, "filter", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Listbox.prototype, "metaKeySelection", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Listbox.prototype, "dataKey", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Listbox.prototype, "onChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Listbox.prototype, "onDblClick", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], Listbox.prototype, "templates", void 0);
Listbox = __decorate([
    core_1.Component({
        selector: 'p-listbox',
        template: "\n        <div [ngClass]=\"{'ui-listbox ui-inputtext ui-widget ui-widget-content ui-corner-all':true,'ui-state-disabled':disabled}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-widget-header ui-corner-all ui-listbox-header ui-helper-clearfix\" *ngIf=\"(checkbox && multiple) || filter\" [ngClass]=\"{'ui-listbox-header-w-checkbox': checkbox}\">\n                <div class=\"ui-chkbox ui-widget\" *ngIf=\"checkbox && multiple\">\n                    <div class=\"ui-helper-hidden-accessible\">\n                        <input #cb type=\"checkbox\" readonly=\"readonly\" [checked]=\"allChecked\">\n                    </div>\n                    <div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\" [ngClass]=\"{'ui-state-active':allChecked}\" (click)=\"toggleAll($event,cb)\">\n                        <span class=\"ui-chkbox-icon ui-clickable\" [ngClass]=\"{'fa fa-check':allChecked}\"></span>\n                    </div>\n                </div>\n                <div class=\"ui-listbox-filter-container\" *ngIf=\"filter\">\n                    <input type=\"text\" role=\"textbox\" (input)=\"onFilter($event)\" class=\"ui-inputtext ui-widget ui-state-default ui-corner-all\" [disabled]=\"disabled\">\n                    <span class=\"fa fa-search\"></span>\n                </div>\n            </div>\n            <ul class=\"ui-listbox-list\">\n                <li *ngFor=\"let option of options; let i = index;\" [style.display]=\"isItemVisible(option) ? 'block' : 'none'\"\n                    [ngClass]=\"{'ui-listbox-item ui-corner-all':true,'ui-state-highlight':isSelected(option)}\"\n                    (click)=\"onOptionClick($event,option)\" (dblclick)=\"onDoubleClick($event,option)\" (touchend)=\"onOptionTouchEnd($event,option)\">\n                    <div class=\"ui-chkbox ui-widget\" *ngIf=\"checkbox && multiple\" (click)=\"onCheckboxClick($event,option)\">\n                        <div class=\"ui-helper-hidden-accessible\">\n                            <input type=\"checkbox\" [checked]=\"isSelected(option)\" [disabled]=\"disabled\">\n                        </div>\n                        <div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\" [ngClass]=\"{'ui-state-active':isSelected(option)}\">\n                            <span class=\"ui-chkbox-icon ui-clickable\" [ngClass]=\"{'fa fa-check':isSelected(option)}\"></span>\n                        </div>\n                    </div>\n                    <span *ngIf=\"!itemTemplate\">{{option.label}}</span>\n                    <ng-template *ngIf=\"itemTemplate\" [pTemplateWrapper]=\"itemTemplate\" [item]=\"option\" [index]=\"i\"></ng-template>\n                </li>\n            </ul>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler, objectutils_1.ObjectUtils, exports.LISTBOX_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, objectutils_1.ObjectUtils])
], Listbox);
exports.Listbox = Listbox;
var ListboxModule = (function () {
    function ListboxModule() {
    }
    return ListboxModule;
}());
ListboxModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_1.SharedModule],
        exports: [Listbox, shared_1.SharedModule],
        declarations: [Listbox]
    })
], ListboxModule);
exports.ListboxModule = ListboxModule;
//# sourceMappingURL=listbox.js.map

/***/ }),

/***/ "./node_modules/primeng/components/megamenu/megamenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var router_1 = __webpack_require__(5);
var MegaMenu = (function () {
    function MegaMenu(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.orientation = 'horizontal';
    }
    MegaMenu.prototype.onItemMouseEnter = function (event, item, menuitem) {
        if (menuitem.disabled) {
            return;
        }
        this.activeItem = item;
        var submenu = item.children[0].nextElementSibling;
        if (submenu) {
            submenu.style.zIndex = ++domhandler_1.DomHandler.zindex;
            if (this.orientation === 'horizontal') {
                submenu.style.top = this.domHandler.getOuterHeight(item.children[0]) + 'px';
                submenu.style.left = '0px';
            }
            else if (this.orientation === 'vertical') {
                submenu.style.top = '0px';
                submenu.style.left = this.domHandler.getOuterWidth(item.children[0]) + 'px';
            }
        }
    };
    MegaMenu.prototype.onItemMouseLeave = function (event, link) {
        this.activeItem = null;
    };
    MegaMenu.prototype.itemClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
        this.activeItem = null;
    };
    MegaMenu.prototype.getColumnClass = function (menuitem) {
        var length = menuitem.items ? menuitem.items.length : 0;
        var columnClass;
        switch (length) {
            case 2:
                columnClass = 'ui-g-6';
                break;
            case 3:
                columnClass = 'ui-g-4';
                break;
            case 4:
                columnClass = 'ui-g-3';
                break;
            case 6:
                columnClass = 'ui-g-2';
                break;
            default:
                columnClass = 'ui-g-12';
                break;
        }
        return columnClass;
    };
    return MegaMenu;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], MegaMenu.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], MegaMenu.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], MegaMenu.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], MegaMenu.prototype, "orientation", void 0);
MegaMenu = __decorate([
    core_1.Component({
        selector: 'p-megaMenu',
        template: "\n        <div [class]=\"styleClass\" [ngStyle]=\"style\"\n            [ngClass]=\"{'ui-menu ui-menubar ui-megamenu ui-widget ui-widget-content ui-corner-all ui-helper-clearfix':true,'ui-megamenu-vertical': orientation == 'vertical'}\">\n            <ul class=\"ui-menu-list ui-helper-reset ui-menubar-root-list\">\n                <ng-template ngFor let-category [ngForOf]=\"model\">\n                    <li *ngIf=\"category.separator\" class=\"ui-menu-separator ui-widget-content\">\n                    <li *ngIf=\"!category.separator\" #item [ngClass]=\"{'ui-menuitem ui-widget ui-corner-all':true,'ui-menu-parent':category.items,'ui-menuitem-active':item==activeItem}\"\n                        (mouseenter)=\"onItemMouseEnter($event, item, category)\" (mouseleave)=\"onItemMouseLeave($event, item)\">\n                        <a class=\"ui-menuitem-link ui-corner-all ui-submenu-link\" [ngClass]=\"{'ui-state-disabled':category.disabled}\">\n                            <span class=\"ui-menuitem-icon fa fa-fw\" [ngClass]=\"category.icon\"></span>\n                            <span class=\"ui-menuitem-text\">{{category.label}}</span>\n                            <span class=\"ui-submenu-icon fa fa-fw\" [ngClass]=\"{'fa-caret-down':orientation=='horizontal','fa-caret-right':orientation=='vertical'}\"></span>\n                        </a>\n                        <div class=\"ui-megamenu-panel ui-widget-content ui-menu-list ui-corner-all ui-helper-clearfix ui-menu-child ui-shadow\">\n                            <div class=\"ui-g\">\n                                <ng-template ngFor let-column [ngForOf]=\"category.items\">\n                                    <div [class]=\"getColumnClass(category)\">\n                                        <ng-template ngFor let-submenu [ngForOf]=\"column\">\n                                            <ul class=\"ui-menu-list ui-helper-reset\">\n                                                <li class=\"ui-widget-header ui-corner-all\"><h3>{{submenu.label}}</h3></li>\n                                                <ng-template ngFor let-item [ngForOf]=\"submenu.items\">\n                                                    <li *ngIf=\"item.separator\" class=\"ui-menu-separator ui-widget-content\">\n                                                    <li *ngIf=\"!item.separator\" class=\"ui-menuitem ui-widget ui-corner-all\">\n                                                        <a *ngIf=\"!item.routerLink\" [href]=\"item.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"item.target\"\n                                                            [ngClass]=\"{'ui-state-disabled':item.disabled}\" (click)=\"itemClick($event, item)\">\n                                                            <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"item.icon\" [ngClass]=\"item.icon\"></span>\n                                                            <span class=\"ui-menuitem-text\">{{item.label}}</span>\n                                                        </a>\n                                                        <a *ngIf=\"item.routerLink\" [routerLink]=\"item.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"item.routerLinkActiveOptions||{exact:false}\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"item.target\"\n                                                            [ngClass]=\"{'ui-state-disabled':item.disabled}\" (click)=\"itemClick($event, item)\">\n                                                            <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"item.icon\" [ngClass]=\"item.icon\"></span>\n                                                            <span class=\"ui-menuitem-text\">{{item.label}}</span>\n                                                        </a>\n                                                    </li>\n                                                </ng-template>\n                                            </ul>\n                                        </ng-template>\n                                    </div>\n                                </ng-template>\n                            </div>\n                        </div>\n                    </li>\n                </ng-template>\n                <li class=\"ui-menuitem ui-menuitem-custom ui-widget ui-corner-all\" *ngIf=\"orientation === 'horizontal'\">\n                    <ng-content></ng-content>\n                </li>\n            </ul>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], MegaMenu);
exports.MegaMenu = MegaMenu;
var MegaMenuModule = (function () {
    function MegaMenuModule() {
    }
    return MegaMenuModule;
}());
MegaMenuModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [MegaMenu, router_1.RouterModule],
        declarations: [MegaMenu]
    })
], MegaMenuModule);
exports.MegaMenuModule = MegaMenuModule;
//# sourceMappingURL=megamenu.js.map

/***/ }),

/***/ "./node_modules/primeng/components/menu/menu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var router_1 = __webpack_require__(5);
var MenuItemContent = (function () {
    function MenuItemContent(menu) {
        this.menu = menu;
    }
    return MenuItemContent;
}());
__decorate([
    core_1.Input("pMenuItemContent"),
    __metadata("design:type", Object)
], MenuItemContent.prototype, "item", void 0);
MenuItemContent = __decorate([
    core_1.Component({
        selector: '[pMenuItemContent]',
        template: "\n        <a *ngIf=\"!item.routerLink\" [href]=\"item.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"item.target\"\n            [ngClass]=\"{'ui-state-disabled':item.disabled}\" (click)=\"menu.itemClick($event, item)\">\n            <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"item.icon\" [ngClass]=\"item.icon\"></span>\n            <span class=\"ui-menuitem-text\">{{item.label}}</span>\n        </a>\n        <a *ngIf=\"item.routerLink\" [routerLink]=\"item.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"item.routerLinkActiveOptions||{exact:false}\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"item.target\"\n            [ngClass]=\"{'ui-state-disabled':item.disabled}\" (click)=\"menu.itemClick($event, item)\">\n            <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"item.icon\" [ngClass]=\"item.icon\"></span>\n            <span class=\"ui-menuitem-text\">{{item.label}}</span>\n        </a>\n    "
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return Menu; }))),
    __metadata("design:paramtypes", [Menu])
], MenuItemContent);
exports.MenuItemContent = MenuItemContent;
var Menu = (function () {
    function Menu(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
    }
    Menu.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.container = this.containerViewChild.nativeElement;
        if (this.popup) {
            if (this.appendTo) {
                if (this.appendTo === 'body')
                    document.body.appendChild(this.container);
                else
                    this.domHandler.appendChild(this.container, this.appendTo);
            }
            this.documentClickListener = this.renderer.listen('document', 'click', function () {
                if (!_this.preventDocumentDefault) {
                    _this.hide();
                }
                _this.preventDocumentDefault = false;
            });
        }
    };
    Menu.prototype.toggle = function (event) {
        if (this.container.offsetParent)
            this.hide();
        else
            this.show(event);
        this.preventDocumentDefault = true;
    };
    Menu.prototype.onResize = function (event) {
        if (this.onResizeTarget && this.container.offsetParent) {
            this.domHandler.absolutePosition(this.container, this.onResizeTarget);
        }
    };
    Menu.prototype.show = function (event) {
        var target = event.currentTarget;
        this.onResizeTarget = event.currentTarget;
        this.container.style.display = 'block';
        this.domHandler.absolutePosition(this.container, target);
        this.domHandler.fadeIn(this.container, 250);
        this.preventDocumentDefault = true;
    };
    Menu.prototype.hide = function () {
        this.container.style.display = 'none';
    };
    Menu.prototype.itemClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
        if (this.popup) {
            this.hide();
        }
    };
    Menu.prototype.ngOnDestroy = function () {
        if (this.popup) {
            if (this.documentClickListener) {
                this.documentClickListener();
            }
            if (this.appendTo) {
                this.el.nativeElement.appendChild(this.container);
            }
        }
    };
    Menu.prototype.hasSubMenu = function () {
        if (this.model) {
            for (var _i = 0, _a = this.model; _i < _a.length; _i++) {
                var item = _a[_i];
                if (item.items) {
                    return true;
                }
            }
        }
        return false;
    };
    return Menu;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Menu.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Menu.prototype, "popup", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Menu.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Menu.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Menu.prototype, "appendTo", void 0);
__decorate([
    core_1.ViewChild('container'),
    __metadata("design:type", core_1.ElementRef)
], Menu.prototype, "containerViewChild", void 0);
Menu = __decorate([
    core_1.Component({
        selector: 'p-menu',
        template: "\n        <div #container [ngClass]=\"{'ui-menu ui-widget ui-widget-content ui-corner-all ui-helper-clearfix':true,'ui-menu-dynamic ui-shadow':popup}\" \n            [class]=\"styleClass\" [ngStyle]=\"style\" (click)=\"preventDocumentDefault=true\">\n            <ul class=\"ui-menu-list ui-helper-reset\">\n                <ng-template ngFor let-submenu [ngForOf]=\"model\" *ngIf=\"hasSubMenu()\">\n                    <li class=\"ui-menu-separator ui-widget-content\" *ngIf=\"submenu.separator\">\n                    <li class=\"ui-widget-header ui-corner-all\" *ngIf=\"!submenu.separator\"><h3>{{submenu.label}}</h3></li>\n                    <ng-template ngFor let-item [ngForOf]=\"submenu.items\">\n                        <li class=\"ui-menu-separator ui-widget-content\" *ngIf=\"item.separator\">\n                        <li class=\"ui-menuitem ui-widget ui-corner-all\" *ngIf=\"!item.separator\" [pMenuItemContent]=\"item\"></li>\n                    </ng-template>\n                </ng-template>\n                <ng-template ngFor let-item [ngForOf]=\"model\" *ngIf=\"!hasSubMenu()\">\n                    <li class=\"ui-menu-separator ui-widget-content\" *ngIf=\"item.separator\">\n                    <li class=\"ui-menuitem ui-widget ui-corner-all\" *ngIf=\"!item.separator\" [pMenuItemContent]=\"item\"></li>\n                </ng-template>\n            </ul>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler],
        host: { '(window:resize)': 'onResize($event)' }
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], Menu);
exports.Menu = Menu;
var MenuModule = (function () {
    function MenuModule() {
    }
    return MenuModule;
}());
MenuModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [Menu, router_1.RouterModule],
        declarations: [Menu, MenuItemContent]
    })
], MenuModule);
exports.MenuModule = MenuModule;
//# sourceMappingURL=menu.js.map

/***/ }),

/***/ "./node_modules/primeng/components/menubar/menubar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var router_1 = __webpack_require__(5);
var MenubarSub = (function () {
    function MenubarSub(domHandler) {
        this.domHandler = domHandler;
    }
    MenubarSub.prototype.onItemMouseEnter = function (event, item, menuitem) {
        if (menuitem.disabled) {
            return;
        }
        this.activeItem = item;
        var nextElement = item.children[0].nextElementSibling;
        if (nextElement) {
            var sublist = nextElement.children[0];
            sublist.style.zIndex = String(++domhandler_1.DomHandler.zindex);
            if (this.root) {
                sublist.style.top = this.domHandler.getOuterHeight(item.children[0]) + 'px';
                sublist.style.left = '0px';
            }
            else {
                sublist.style.top = '0px';
                sublist.style.left = this.domHandler.getOuterWidth(item.children[0]) + 'px';
            }
        }
    };
    MenubarSub.prototype.onItemMouseLeave = function (event) {
        this.activeItem = null;
    };
    MenubarSub.prototype.itemClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
        this.activeItem = null;
    };
    MenubarSub.prototype.listClick = function (event) {
        this.activeItem = null;
    };
    return MenubarSub;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], MenubarSub.prototype, "item", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], MenubarSub.prototype, "root", void 0);
MenubarSub = __decorate([
    core_1.Component({
        selector: 'p-menubarSub',
        template: "\n        <ul [ngClass]=\"{'ui-menubar-root-list ui-helper-clearfix':root, 'ui-widget-content ui-corner-all ui-helper-clearfix ui-menu-child ui-shadow':!root}\" class=\"ui-menu-list\"\n            (click)=\"listClick($event)\">\n            <ng-template ngFor let-child [ngForOf]=\"(root ? item : item.items)\">\n                <li *ngIf=\"child.separator\" class=\"ui-menu-separator ui-widget-content\">\n                <li *ngIf=\"!child.separator\" #listItem [ngClass]=\"{'ui-menuitem ui-widget ui-corner-all':true,'ui-menu-parent':child.items,'ui-menuitem-active':listItem==activeItem}\"\n                    (mouseenter)=\"onItemMouseEnter($event,listItem,child)\" (mouseleave)=\"onItemMouseLeave($event)\">\n                    <a *ngIf=\"!child.routerLink\" [href]=\"child.url||'#'\" [attr.target]=\"child.target\" (click)=\"itemClick($event, child)\"\n                         [ngClass]=\"{'ui-menuitem-link ui-corner-all':true,'ui-state-disabled':child.disabled}\" [ngStyle]=\"child.style\" [class]=\"child.styleClass\">\n                        <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"child.icon\" [ngClass]=\"child.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{child.label}}</span>\n                        <span class=\"ui-submenu-icon fa fa-fw\" *ngIf=\"child.items\" [ngClass]=\"{'fa-caret-down':root,'fa-caret-right':!root}\"></span>\n                    </a>\n                    <a *ngIf=\"child.routerLink\" [routerLink]=\"child.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"child.routerLinkActiveOptions||{exact:false}\" [attr.target]=\"child.target\"\n                        (click)=\"itemClick($event, child)\" [ngClass]=\"{'ui-menuitem-link ui-corner-all':true,'ui-state-disabled':child.disabled}\" [ngStyle]=\"child.style\" [class]=\"child.styleClass\">\n                        <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"child.icon\" [ngClass]=\"child.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{child.label}}</span>\n                        <span class=\"ui-submenu-icon fa fa-fw\" *ngIf=\"child.items\" [ngClass]=\"{'fa-caret-down':root,'fa-caret-right':!root}\"></span>\n                    </a>\n                    <p-menubarSub class=\"ui-submenu\" [item]=\"child\" *ngIf=\"child.items\"></p-menubarSub>\n                </li>\n            </ng-template>\n            <li class=\"ui-menuitem ui-menuitem-custom ui-widget ui-corner-all\">\n                <ng-content></ng-content>\n            </li>\n        </ul>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [domhandler_1.DomHandler])
], MenubarSub);
exports.MenubarSub = MenubarSub;
var Menubar = (function () {
    function Menubar(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
    }
    return Menubar;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Menubar.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Menubar.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Menubar.prototype, "styleClass", void 0);
Menubar = __decorate([
    core_1.Component({
        selector: 'p-menubar',
        template: "\n        <div [ngClass]=\"{'ui-menubar ui-menu ui-widget ui-widget-content ui-corner-all ui-helper-clearfix':true}\" \n            [class]=\"styleClass\" [ngStyle]=\"style\">\n            <p-menubarSub [item]=\"model\" root=\"root\">\n                <ng-content></ng-content>\n            </p-menubarSub>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], Menubar);
exports.Menubar = Menubar;
var MenubarModule = (function () {
    function MenubarModule() {
    }
    return MenubarModule;
}());
MenubarModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [Menubar, router_1.RouterModule],
        declarations: [Menubar, MenubarSub]
    })
], MenubarModule);
exports.MenubarModule = MenubarModule;
//# sourceMappingURL=menubar.js.map

/***/ }),

/***/ "./node_modules/primeng/components/messages/messages.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var Messages = (function () {
    function Messages() {
        this.closable = true;
        this.valueChange = new core_1.EventEmitter();
    }
    Messages.prototype.hasMessages = function () {
        return this.value && this.value.length > 0;
    };
    Messages.prototype.getSeverityClass = function () {
        return this.value[0].severity;
    };
    Messages.prototype.clear = function (event) {
        this.value = [];
        this.valueChange.emit(this.value);
        event.preventDefault();
    };
    Object.defineProperty(Messages.prototype, "icon", {
        get: function () {
            var icon = null;
            if (this.hasMessages()) {
                var msg = this.value[0];
                switch (msg.severity) {
                    case 'success':
                        icon = 'fa-check';
                        break;
                    case 'info':
                        icon = 'fa-info-circle';
                        break;
                    case 'error':
                        icon = 'fa-close';
                        break;
                    case 'warn':
                        icon = 'fa-warning';
                        break;
                    case 'success':
                        icon = 'fa-check';
                        break;
                    default:
                        icon = 'fa-info-circle';
                        break;
                }
            }
            return icon;
        },
        enumerable: true,
        configurable: true
    });
    return Messages;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Messages.prototype, "value", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Messages.prototype, "closable", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Messages.prototype, "valueChange", void 0);
Messages = __decorate([
    core_1.Component({
        selector: 'p-messages',
        template: "\n        <div *ngIf=\"hasMessages()\" class=\"ui-messages ui-widget ui-corner-all\" style=\"display:block\"\n                    [ngClass]=\"{'ui-messages-info':(value[0].severity === 'info'),\n                    'ui-messages-warn':(value[0].severity === 'warn'),\n                    'ui-messages-error':(value[0].severity === 'error'),\n                    'ui-messages-success':(value[0].severity === 'success')}\">\n            <a href=\"#\" class=\"ui-messages-close\" (click)=\"clear($event)\" *ngIf=\"closable\">\n                <i class=\"fa fa-close\"></i>\n            </a>\n            <span class=\"ui-messages-icon fa fa-fw fa-2x\" [ngClass]=\"icon\"></span>\n            <ul>\n                <li *ngFor=\"let msg of value\">\n                    <span class=\"ui-messages-summary\">{{msg.summary}}</span>\n                    <span class=\"ui-messages-detail\">{{msg.detail}}</span>\n                </li>\n            </ul>\n        </div>\n    "
    })
], Messages);
exports.Messages = Messages;
var MessagesModule = (function () {
    function MessagesModule() {
    }
    return MessagesModule;
}());
MessagesModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Messages],
        declarations: [Messages]
    })
], MessagesModule);
exports.MessagesModule = MessagesModule;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/primeng/components/multiselect/multiselect.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var objectutils_1 = __webpack_require__("./node_modules/primeng/components/utils/objectutils.js");
var forms_1 = __webpack_require__(4);
exports.MULTISELECT_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return MultiSelect; }),
    multi: true
};
var MultiSelect = (function () {
    function MultiSelect(el, domHandler, renderer, differs, objectUtils, cd) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.objectUtils = objectUtils;
        this.cd = cd;
        this.onChange = new core_1.EventEmitter();
        this.onBlur = new core_1.EventEmitter();
        this.scrollHeight = '200px';
        this.defaultLabel = 'Choose';
        this.filter = true;
        this.displaySelectedLabel = true;
        this.maxSelectedLabels = 3;
        this.selectedItemsLabel = '{0} items selected';
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
        this.valueDiffer = differs.find([]).create(null);
        this.optionsDiffer = differs.find([]).create(null);
    }
    MultiSelect.prototype.ngOnInit = function () {
        this.updateLabel();
    };
    MultiSelect.prototype.ngAfterViewInit = function () {
        this.container = this.containerViewChild.nativeElement;
        this.panel = this.panelViewChild.nativeElement;
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.panel);
            else
                this.domHandler.appendChild(this.panel, this.appendTo);
        }
        if (this.overlayVisible) {
            this.show();
        }
    };
    MultiSelect.prototype.ngAfterViewChecked = function () {
        if (this.filtered) {
            if (this.appendTo)
                this.domHandler.absolutePosition(this.panel, this.container);
            else
                this.domHandler.relativePosition(this.panel, this.container);
            this.filtered = false;
        }
    };
    MultiSelect.prototype.ngDoCheck = function () {
        var valueChanges = this.valueDiffer.diff(this.value);
        var optionChanges = this.optionsDiffer.diff(this.options);
        if (valueChanges || optionChanges) {
            this.updateLabel();
        }
    };
    MultiSelect.prototype.writeValue = function (value) {
        this.value = value;
        this.updateLabel();
        this.cd.markForCheck();
    };
    MultiSelect.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    MultiSelect.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    MultiSelect.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    MultiSelect.prototype.onItemClick = function (event, value) {
        var selectionIndex = this.findSelectionIndex(value);
        if (selectionIndex != -1)
            this.value = this.value.filter(function (val, i) { return i != selectionIndex; });
        else
            this.value = (this.value || []).concat([value]);
        this.onModelChange(this.value);
        this.onChange.emit({ originalEvent: event, value: this.value });
    };
    MultiSelect.prototype.isSelected = function (value) {
        return this.findSelectionIndex(value) != -1;
    };
    MultiSelect.prototype.findSelectionIndex = function (val) {
        var index = -1;
        if (this.value) {
            for (var i = 0; i < this.value.length; i++) {
                if (this.objectUtils.equals(this.value[i], val, this.dataKey)) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    MultiSelect.prototype.toggleAll = function (event, checkbox) {
        if (checkbox.checked) {
            this.value = [];
        }
        else {
            var opts = this.getVisibleOptions();
            if (opts) {
                this.value = [];
                for (var i = 0; i < opts.length; i++) {
                    this.value.push(opts[i].value);
                }
            }
        }
        checkbox.checked = !checkbox.checked;
        this.onModelChange(this.value);
        this.onChange.emit({ originalEvent: event, value: this.value });
    };
    MultiSelect.prototype.isAllChecked = function () {
        if (this.filterValue && this.filterValue.trim().length)
            return this.value && this.visibleOptions && this.visibleOptions.length && (this.value.length == this.visibleOptions.length);
        else
            return this.value && this.options && (this.value.length == this.options.length);
    };
    MultiSelect.prototype.show = function () {
        this.overlayVisible = true;
        this.panel.style.zIndex = String(++domhandler_1.DomHandler.zindex);
        this.bindDocumentClickListener();
        if (this.appendTo)
            this.domHandler.absolutePosition(this.panel, this.container);
        else
            this.domHandler.relativePosition(this.panel, this.container);
        this.domHandler.fadeIn(this.panel, 250);
    };
    MultiSelect.prototype.hide = function () {
        this.overlayVisible = false;
        this.unbindDocumentClickListener();
    };
    MultiSelect.prototype.close = function (event) {
        this.hide();
        event.preventDefault();
        event.stopPropagation();
    };
    MultiSelect.prototype.onMouseclick = function (event, input) {
        if (this.disabled) {
            return;
        }
        if (!this.panelClick) {
            if (this.overlayVisible) {
                this.hide();
            }
            else {
                input.focus();
                this.show();
            }
        }
        this.selfClick = true;
    };
    MultiSelect.prototype.onFocus = function (event) {
        this.focus = true;
    };
    MultiSelect.prototype.onInputBlur = function (event) {
        this.focus = false;
        this.onBlur.emit({ originalEvent: event });
        this.onModelTouched();
    };
    MultiSelect.prototype.updateLabel = function () {
        if (this.value && this.options && this.value.length && this.displaySelectedLabel) {
            var label = '';
            for (var i = 0; i < this.value.length; i++) {
                if (i != 0) {
                    label = label + ', ';
                }
                label = label + this.findLabelByValue(this.value[i]);
            }
            if (this.value.length <= this.maxSelectedLabels) {
                this.valuesAsString = label;
            }
            else {
                var pattern = /{(.*?)}/, newSelectedItemsLabel = this.selectedItemsLabel.replace(this.selectedItemsLabel.match(pattern)[0], this.value.length + '');
                this.valuesAsString = newSelectedItemsLabel;
            }
        }
        else {
            this.valuesAsString = this.defaultLabel;
        }
    };
    MultiSelect.prototype.findLabelByValue = function (val) {
        var label = null;
        for (var i = 0; i < this.options.length; i++) {
            var option = this.options[i];
            if (val == null && option.value == null || this.objectUtils.equals(val, option.value, this.dataKey)) {
                label = option.label;
                break;
            }
        }
        return label;
    };
    MultiSelect.prototype.onFilter = function (event) {
        this.filterValue = event.target.value.trim().toLowerCase();
        this.visibleOptions = [];
        for (var i = 0; i < this.options.length; i++) {
            var option = this.options[i];
            if (option.label.toLowerCase().indexOf(this.filterValue.toLowerCase()) > -1) {
                this.visibleOptions.push(option);
            }
        }
        this.filtered = true;
    };
    MultiSelect.prototype.isItemVisible = function (option) {
        if (this.filterValue && this.filterValue.trim().length) {
            for (var i = 0; i < this.visibleOptions.length; i++) {
                if (this.visibleOptions[i].value == option.value) {
                    return true;
                }
            }
        }
        else {
            return true;
        }
    };
    MultiSelect.prototype.getVisibleOptions = function () {
        if (this.filterValue && this.filterValue.trim().length) {
            var items = [];
            for (var i = 0; i < this.options.length; i++) {
                var option = this.options[i];
                if (option.label.toLowerCase().includes(this.filterValue.toLowerCase())) {
                    items.push(option);
                }
            }
            return items;
        }
        else {
            return this.options;
        }
    };
    MultiSelect.prototype.bindDocumentClickListener = function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'click', function () {
                if (!_this.selfClick && !_this.panelClick && _this.overlayVisible) {
                    _this.hide();
                }
                _this.selfClick = false;
                _this.panelClick = false;
                _this.cd.markForCheck();
            });
        }
    };
    MultiSelect.prototype.unbindDocumentClickListener = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    MultiSelect.prototype.ngOnDestroy = function () {
        this.unbindDocumentClickListener();
        if (this.appendTo) {
            this.container.appendChild(this.panel);
        }
    };
    return MultiSelect;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], MultiSelect.prototype, "options", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], MultiSelect.prototype, "onChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], MultiSelect.prototype, "onBlur", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], MultiSelect.prototype, "scrollHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], MultiSelect.prototype, "defaultLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], MultiSelect.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], MultiSelect.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], MultiSelect.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], MultiSelect.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], MultiSelect.prototype, "filter", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], MultiSelect.prototype, "overlayVisible", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], MultiSelect.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], MultiSelect.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], MultiSelect.prototype, "dataKey", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], MultiSelect.prototype, "displaySelectedLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], MultiSelect.prototype, "maxSelectedLabels", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], MultiSelect.prototype, "selectedItemsLabel", void 0);
__decorate([
    core_1.ViewChild('container'),
    __metadata("design:type", core_1.ElementRef)
], MultiSelect.prototype, "containerViewChild", void 0);
__decorate([
    core_1.ViewChild('panel'),
    __metadata("design:type", core_1.ElementRef)
], MultiSelect.prototype, "panelViewChild", void 0);
MultiSelect = __decorate([
    core_1.Component({
        selector: 'p-multiSelect',
        template: "\n        <div #container [ngClass]=\"{'ui-multiselect ui-widget ui-state-default ui-corner-all':true,'ui-state-focus':focus,'ui-state-disabled': disabled}\" [ngStyle]=\"style\" [class]=\"styleClass\"\n            (click)=\"onMouseclick($event,in)\">\n            <div class=\"ui-helper-hidden-accessible\">\n                <input #in type=\"text\" readonly=\"readonly\" [attr.id]=\"inputId\" (focus)=\"onFocus($event)\" (blur)=\"onInputBlur($event)\" [disabled]=\"disabled\" [attr.tabindex]=\"tabindex\">\n            </div>\n            <div class=\"ui-multiselect-label-container\" [title]=\"valuesAsString\">\n                <label class=\"ui-multiselect-label ui-corner-all\">{{valuesAsString}}</label>\n            </div>\n            <div [ngClass]=\"{'ui-multiselect-trigger ui-state-default ui-corner-right':true}\">\n                <span class=\"fa fa-fw fa-caret-down ui-clickable\"></span>\n            </div>\n            <div #panel class=\"ui-multiselect-panel ui-widget ui-widget-content ui-corner-all ui-shadow\" [style.display]=\"overlayVisible ? 'block' : 'none'\" (click)=\"panelClick=true\">\n                <div class=\"ui-widget-header ui-corner-all ui-multiselect-header ui-helper-clearfix\">\n                    <div class=\"ui-chkbox ui-widget\">\n                        <div class=\"ui-helper-hidden-accessible\">\n                            <input #cb type=\"checkbox\" readonly=\"readonly\" [checked]=\"isAllChecked()\">\n                        </div>\n                        <div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\" [ngClass]=\"{'ui-state-active':isAllChecked()}\" (click)=\"toggleAll($event,cb)\">\n                            <span class=\"ui-chkbox-icon ui-clickable\" [ngClass]=\"{'fa fa-check':isAllChecked()}\"></span>\n                        </div>\n                    </div>\n                    <div class=\"ui-multiselect-filter-container\" *ngIf=\"filter\">\n                        <input type=\"text\" role=\"textbox\" (input)=\"onFilter($event)\"\n                                    class=\"ui-inputtext ui-widget ui-state-default ui-corner-all\">\n                        <span class=\"fa fa-fw fa-search\"></span>\n                    </div>\n                    <a class=\"ui-multiselect-close ui-corner-all\" href=\"#\" (click)=\"close($event)\">\n                        <span class=\"fa fa-close\"></span>\n                    </a>\n                </div>\n                <div class=\"ui-multiselect-items-wrapper\">\n                    <ul class=\"ui-multiselect-items ui-multiselect-list ui-widget-content ui-widget ui-corner-all ui-helper-reset\" [style.max-height]=\"scrollHeight||'auto'\">\n                        <li *ngFor=\"let option of options\" class=\"ui-multiselect-item ui-corner-all\" (click)=\"onItemClick($event,option.value)\" \n                            [style.display]=\"isItemVisible(option) ? 'block' : 'none'\" [ngClass]=\"{'ui-state-highlight':isSelected(option.value)}\">\n                            <div class=\"ui-chkbox ui-widget\">\n                                <div class=\"ui-helper-hidden-accessible\">\n                                    <input type=\"checkbox\" readonly=\"readonly\" [checked]=\"isSelected(option.value)\">\n                                </div>\n                                <div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\" [ngClass]=\"{'ui-state-active':isSelected(option.value)}\">\n                                    <span class=\"ui-chkbox-icon ui-clickable\" [ngClass]=\"{'fa fa-check':isSelected(option.value)}\"></span>\n                                </div>\n                            </div>\n                            <label>{{option.label}}</label>\n                        </li>\n                    </ul>\n                </div>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler, objectutils_1.ObjectUtils, exports.MULTISELECT_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, core_1.IterableDiffers, objectutils_1.ObjectUtils, core_1.ChangeDetectorRef])
], MultiSelect);
exports.MultiSelect = MultiSelect;
var MultiSelectModule = (function () {
    function MultiSelectModule() {
    }
    return MultiSelectModule;
}());
MultiSelectModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [MultiSelect],
        declarations: [MultiSelect]
    })
], MultiSelectModule);
exports.MultiSelectModule = MultiSelectModule;
//# sourceMappingURL=multiselect.js.map

/***/ }),

/***/ "./node_modules/primeng/components/orderlist/orderlist.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var button_1 = __webpack_require__("./node_modules/primeng/components/button/button.js");
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var objectutils_1 = __webpack_require__("./node_modules/primeng/components/utils/objectutils.js");
var OrderList = (function () {
    function OrderList(el, domHandler, objectUtils) {
        this.el = el;
        this.domHandler = domHandler;
        this.objectUtils = objectUtils;
        this.metaKeySelection = true;
        this.onReorder = new core_1.EventEmitter();
        this.onSelectionChange = new core_1.EventEmitter();
        this.onFilterEvent = new core_1.EventEmitter();
    }
    OrderList.prototype.ngAfterViewInit = function () {
        this.listContainer = this.domHandler.findSingle(this.el.nativeElement, 'ul.ui-orderlist-list');
    };
    OrderList.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    OrderList.prototype.ngAfterViewChecked = function () {
        if (this.movedUp || this.movedDown) {
            var listItems = this.domHandler.find(this.listContainer, 'li.ui-state-highlight');
            var listItem = void 0;
            if (this.movedUp)
                listItem = listItems[0];
            else
                listItem = listItems[listItems.length - 1];
            this.domHandler.scrollInView(this.listContainer, listItem);
            this.movedUp = false;
            this.movedDown = false;
        }
    };
    Object.defineProperty(OrderList.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (val) {
            this._value = val ? val.slice() : null;
            if (this.filterValue) {
                this.filter();
            }
        },
        enumerable: true,
        configurable: true
    });
    OrderList.prototype.onItemClick = function (event, item) {
        var index = this.findIndexInList(item, this.selectedItems);
        var selected = (index != -1);
        var metaSelection = this.itemTouched ? false : this.metaKeySelection;
        if (metaSelection) {
            var metaKey = (event.metaKey || event.ctrlKey);
            if (selected && metaKey) {
                this.selectedItems.splice(index, 1);
            }
            else {
                this.selectedItems = (metaKey) ? this.selectedItems || [] : [];
                this.selectedItems.push(item);
            }
        }
        else {
            if (selected) {
                this.selectedItems.splice(index, 1);
            }
            else {
                this.selectedItems = this.selectedItems || [];
                this.selectedItems.push(item);
            }
        }
        this.onSelectionChange.emit({ originalEvent: event, value: this.selectedItems });
        this.itemTouched = false;
    };
    OrderList.prototype.onFilterKeyup = function (event) {
        this.filterValue = event.target.value.trim().toLowerCase();
        this.filter();
        this.onFilterEvent.emit({
            originalEvent: event,
            value: this.visibleOptions
        });
    };
    OrderList.prototype.filter = function () {
        var searchFields = this.filterBy.split(',');
        this.visibleOptions = this.objectUtils.filter(this.value, searchFields, this.filterValue);
    };
    OrderList.prototype.isItemVisible = function (item) {
        if (this.filterValue && this.filterValue.trim().length) {
            for (var i = 0; i < this.visibleOptions.length; i++) {
                if (item == this.visibleOptions[i]) {
                    return true;
                }
            }
        }
        else {
            return true;
        }
    };
    OrderList.prototype.onItemTouchEnd = function (event) {
        this.itemTouched = true;
    };
    OrderList.prototype.isSelected = function (item) {
        return this.findIndexInList(item, this.selectedItems) != -1;
    };
    OrderList.prototype.findIndexInList = function (item, list) {
        var index = -1;
        if (list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i] == item) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    OrderList.prototype.moveUp = function (event, listElement) {
        if (this.selectedItems) {
            for (var i = 0; i < this.selectedItems.length; i++) {
                var selectedItem = this.selectedItems[i];
                var selectedItemIndex = this.findIndexInList(selectedItem, this.value);
                if (selectedItemIndex != 0) {
                    var movedItem = this.value[selectedItemIndex];
                    var temp = this.value[selectedItemIndex - 1];
                    this.value[selectedItemIndex - 1] = movedItem;
                    this.value[selectedItemIndex] = temp;
                }
                else {
                    break;
                }
            }
            this.movedUp = true;
            this.onReorder.emit(event);
        }
    };
    OrderList.prototype.moveTop = function (event, listElement) {
        if (this.selectedItems) {
            for (var i = 0; i < this.selectedItems.length; i++) {
                var selectedItem = this.selectedItems[i];
                var selectedItemIndex = this.findIndexInList(selectedItem, this.value);
                if (selectedItemIndex != 0) {
                    var movedItem = this.value.splice(selectedItemIndex, 1)[0];
                    this.value.unshift(movedItem);
                    listElement.scrollTop = 0;
                }
                else {
                    break;
                }
            }
            this.onReorder.emit(event);
            listElement.scrollTop = 0;
        }
    };
    OrderList.prototype.moveDown = function (event, listElement) {
        if (this.selectedItems) {
            for (var i = this.selectedItems.length - 1; i >= 0; i--) {
                var selectedItem = this.selectedItems[i];
                var selectedItemIndex = this.findIndexInList(selectedItem, this.value);
                if (selectedItemIndex != (this.value.length - 1)) {
                    var movedItem = this.value[selectedItemIndex];
                    var temp = this.value[selectedItemIndex + 1];
                    this.value[selectedItemIndex + 1] = movedItem;
                    this.value[selectedItemIndex] = temp;
                }
                else {
                    break;
                }
            }
            this.movedDown = true;
            this.onReorder.emit(event);
        }
    };
    OrderList.prototype.moveBottom = function (event, listElement) {
        if (this.selectedItems) {
            for (var i = this.selectedItems.length - 1; i >= 0; i--) {
                var selectedItem = this.selectedItems[i];
                var selectedItemIndex = this.findIndexInList(selectedItem, this.value);
                if (selectedItemIndex != (this.value.length - 1)) {
                    var movedItem = this.value.splice(selectedItemIndex, 1)[0];
                    this.value.push(movedItem);
                }
                else {
                    break;
                }
            }
            this.onReorder.emit(event);
            listElement.scrollTop = listElement.scrollHeight;
        }
    };
    OrderList.prototype.onDragStart = function (event, index) {
        this.dragging = true;
        this.draggedItemIndex = index;
        if (this.dragdropScope) {
            event.dataTransfer.setData("text", this.dragdropScope);
        }
    };
    OrderList.prototype.onDragOver = function (event, index) {
        if (this.draggedItemIndex !== index && this.draggedItemIndex + 1 !== index) {
            this.dragOverItemIndex = index;
            event.preventDefault();
        }
    };
    OrderList.prototype.onDragLeave = function (event, index) {
        this.dragOverItemIndex = null;
    };
    OrderList.prototype.onDrop = function (event, index) {
        var dropIndex = (this.draggedItemIndex > index) ? index : (index === 0) ? 0 : index - 1;
        this.objectUtils.reorderArray(this.value, this.draggedItemIndex, dropIndex);
        this.dragOverItemIndex = null;
    };
    OrderList.prototype.onDragEnd = function (event) {
        this.dragging = false;
    };
    OrderList.prototype.onListMouseMove = function (event) {
        if (this.dragging) {
            var offsetY = this.listViewChild.nativeElement.getBoundingClientRect().top + document.body.scrollTop;
            var bottomDiff = (offsetY + this.listViewChild.nativeElement.clientHeight) - event.pageY;
            var topDiff = (event.pageY - offsetY);
            if (bottomDiff < 25 && bottomDiff > 0)
                this.listViewChild.nativeElement.scrollTop += 15;
            else if (topDiff < 25 && topDiff > 0)
                this.listViewChild.nativeElement.scrollTop -= 15;
        }
    };
    return OrderList;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], OrderList.prototype, "header", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], OrderList.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], OrderList.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], OrderList.prototype, "listStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], OrderList.prototype, "responsive", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], OrderList.prototype, "filterBy", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], OrderList.prototype, "filterPlaceholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], OrderList.prototype, "metaKeySelection", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], OrderList.prototype, "dragdrop", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], OrderList.prototype, "dragdropScope", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OrderList.prototype, "onReorder", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OrderList.prototype, "onSelectionChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OrderList.prototype, "onFilterEvent", void 0);
__decorate([
    core_1.ViewChild('listelement'),
    __metadata("design:type", core_1.ElementRef)
], OrderList.prototype, "listViewChild", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], OrderList.prototype, "templates", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], OrderList.prototype, "value", null);
OrderList = __decorate([
    core_1.Component({
        selector: 'p-orderList',
        template: "\n        <div [ngClass]=\"{'ui-orderlist ui-widget':true,'ui-orderlist-responsive':responsive}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-orderlist-controls\">\n                <button type=\"button\" pButton icon=\"fa-angle-up\" (click)=\"moveUp($event,listelement)\"></button>\n                <button type=\"button\" pButton icon=\"fa-angle-double-up\" (click)=\"moveTop($event,listelement)\"></button>\n                <button type=\"button\" pButton icon=\"fa-angle-down\" (click)=\"moveDown($event,listelement)\"></button>\n                <button type=\"button\" pButton icon=\"fa-angle-double-down\" (click)=\"moveBottom($event,listelement)\"></button>\n            </div>\n            <div class=\"ui-orderlist-list-container\">\n                <div class=\"ui-orderlist-caption ui-widget-header ui-corner-top\" *ngIf=\"header\">{{header}}</div>\n                <div class=\"ui-orderlist-filter-container ui-widget-content\" *ngIf=\"filterBy\">\n                    <input type=\"text\" role=\"textbox\" (keyup)=\"onFilterKeyup($event)\" class=\"ui-inputtext ui-widget ui-state-default ui-corner-all\" [disabled]=\"disabled\" [attr.placeholder]=\"filterPlaceholder\">\n                    <span class=\"fa fa-search\"></span>\n                </div>\n                <ul #listelement class=\"ui-widget-content ui-orderlist-list ui-corner-bottom\" [ngStyle]=\"listStyle\" (dragover)=\"onListMouseMove($event)\">\n                    <ng-template ngFor let-item [ngForOf]=\"value\" let-i=\"index\" let-l=\"last\">\n                        <li class=\"ui-orderlist-droppoint\" *ngIf=\"dragdrop && isItemVisible(item)\" (dragover)=\"onDragOver($event, i)\" (drop)=\"onDrop($event, i)\" (dragleave)=\"onDragLeave($event)\" \n                            [ngClass]=\"{'ui-state-highlight': (i === dragOverItemIndex)}\"></li>\n                        <li class=\"ui-orderlist-item\"\n                            [ngClass]=\"{'ui-state-highlight':isSelected(item)}\" \n                            (click)=\"onItemClick($event,item)\" (touchend)=\"onItemTouchEnd($event)\"\n                            [style.display]=\"isItemVisible(item) ? 'block' : 'none'\"\n                            [draggable]=\"dragdrop\" (dragstart)=\"onDragStart($event, i)\" (dragend)=\"onDragEnd($event)\">\n                            <ng-template [pTemplateWrapper]=\"itemTemplate\" [item]=\"item\"></ng-template>\n                        </li>\n                        <li class=\"ui-orderlist-droppoint\" *ngIf=\"dragdrop && l\" (dragover)=\"onDragOver($event, i + 1)\" (drop)=\"onDrop($event, i + 1)\" (dragleave)=\"onDragLeave($event)\" \n                            [ngClass]=\"{'ui-state-highlight': (i + 1 === dragOverItemIndex)}\"></li>\n                    </ng-template>\n                </ul>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler, objectutils_1.ObjectUtils]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, objectutils_1.ObjectUtils])
], OrderList);
exports.OrderList = OrderList;
var OrderListModule = (function () {
    function OrderListModule() {
    }
    return OrderListModule;
}());
OrderListModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, button_1.ButtonModule, shared_1.SharedModule],
        exports: [OrderList, shared_1.SharedModule],
        declarations: [OrderList]
    })
], OrderListModule);
exports.OrderListModule = OrderListModule;
//# sourceMappingURL=orderlist.js.map

/***/ }),

/***/ "./node_modules/primeng/components/organizationchart/organizationchart.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var shared_2 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var OrganizationChartNodeTemplateLoader = (function () {
    function OrganizationChartNodeTemplateLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    OrganizationChartNodeTemplateLoader.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.template, {
            '\$implicit': this.node
        });
    };
    OrganizationChartNodeTemplateLoader.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return OrganizationChartNodeTemplateLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], OrganizationChartNodeTemplateLoader.prototype, "node", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", core_1.TemplateRef)
], OrganizationChartNodeTemplateLoader.prototype, "template", void 0);
OrganizationChartNodeTemplateLoader = __decorate([
    core_1.Component({
        selector: 'p-organizationChartNodeTemplateLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], OrganizationChartNodeTemplateLoader);
exports.OrganizationChartNodeTemplateLoader = OrganizationChartNodeTemplateLoader;
var OrganizationChartNode = (function () {
    function OrganizationChartNode(chart) {
        this.chart = chart;
    }
    Object.defineProperty(OrganizationChartNode.prototype, "leaf", {
        get: function () {
            return this.node.leaf == false ? false : !(this.node.children && this.node.children.length);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OrganizationChartNode.prototype, "colspan", {
        get: function () {
            return (this.node.children && this.node.children.length) ? this.node.children.length * 2 : null;
        },
        enumerable: true,
        configurable: true
    });
    OrganizationChartNode.prototype.onNodeClick = function (event, node) {
        this.chart.onNodeClick(event, node);
    };
    OrganizationChartNode.prototype.toggleNode = function (event, node) {
        node.expanded = !node.expanded;
        event.preventDefault();
    };
    OrganizationChartNode.prototype.isSelected = function () {
        return this.chart.isSelected(this.node);
    };
    return OrganizationChartNode;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], OrganizationChartNode.prototype, "node", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], OrganizationChartNode.prototype, "root", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], OrganizationChartNode.prototype, "first", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], OrganizationChartNode.prototype, "last", void 0);
OrganizationChartNode = __decorate([
    core_1.Component({
        selector: '[pOrganizationChartNode]',
        template: "\n        <tr>\n            <td [attr.colspan]=\"colspan\">\n                <div class=\"ui-organizationchart-node-content ui-widget-content ui-corner-all {{node.styleClass}}\" \n                    [ngClass]=\"{'ui-organizationchart-selectable-node': chart.selectionMode && node.selectable !== false,'ui-state-highlight':isSelected()}\"\n                    (click)=\"onNodeClick($event,node)\">\n                    <div *ngIf=\"!chart.getTemplateForNode(node)\">{{node.label}}</div>\n                    <div *ngIf=\"chart.getTemplateForNode(node)\">\n                        <p-organizationChartNodeTemplateLoader [node]=\"node\" [template]=\"chart.getTemplateForNode(node)\"></p-organizationChartNodeTemplateLoader>\n                    </div>\n                    <a *ngIf=\"!leaf\" href=\"#\" class=\"ui-node-toggler\" (click)=\"toggleNode($event, node)\">\n                        <i class=\"fa ui-node-toggler-icon\" [ngClass]=\"{'fa-chevron-down': node.expanded, 'fa-chevron-up': !node.expanded}\"></i>\n                    </a>\n                </div>\n            </td>\n        </tr>\n        <tr [style.visibility]=\"!leaf&&node.expanded ? 'inherit' : 'hidden'\" class=\"ui-organizationchart-lines\" [@childState]=\"'in'\">\n            <td [attr.colspan]=\"colspan\">\n                <div class=\"ui-organizationchart-line-down\"></div>\n            </td>\n        </tr>\n        <tr [style.visibility]=\"!leaf&&node.expanded ? 'inherit' : 'hidden'\" class=\"ui-organizationchart-lines\" [@childState]=\"'in'\">\n            <ng-template ngFor let-child [ngForOf]=\"node.children\" let-first=\"first\" let-last=\"last\">\n                <td class=\"ui-organizationchart-line-left\" [ngClass]=\"{'ui-organizationchart-line-top':!first}\">&nbsp;</td>\n                <td class=\"ui-organizationchart-line-right\" [ngClass]=\"{'ui-organizationchart-line-top':!last}\">&nbsp;</td>\n            </ng-template>\n        </tr>\n        <tr [style.visibility]=\"!leaf&&node.expanded ? 'inherit' : 'hidden'\" class=\"ui-organizationchart-nodes\" [@childState]=\"'in'\">\n            <td *ngFor=\"let child of node.children\" colspan=\"2\">\n                <table class=\"ui-organizationchart-table\" pOrganizationChartNode [node]=\"child\"></table>\n            </td>\n        </tr>\n    ",
        animations: [
            animations_1.trigger('childState', [
                animations_1.state('in', animations_1.style({ opacity: 1 })),
                animations_1.transition('void => *', [
                    animations_1.style({ opacity: 0 }),
                    animations_1.animate(150)
                ]),
                animations_1.transition('* => void', [
                    animations_1.animate(150, animations_1.style({ opacity: 0 }))
                ])
            ])
        ],
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return OrganizationChart; }))),
    __metadata("design:paramtypes", [OrganizationChart])
], OrganizationChartNode);
exports.OrganizationChartNode = OrganizationChartNode;
var OrganizationChart = (function () {
    function OrganizationChart(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.selectionChange = new core_1.EventEmitter();
        this.onNodeSelect = new core_1.EventEmitter();
        this.onNodeUnselect = new core_1.EventEmitter();
    }
    Object.defineProperty(OrganizationChart.prototype, "root", {
        get: function () {
            return this.value && this.value.length ? this.value[0] : null;
        },
        enumerable: true,
        configurable: true
    });
    OrganizationChart.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (this.templates.length) {
            this.templateMap = {};
        }
        this.templates.forEach(function (item) {
            _this.templateMap[item.getType()] = item.template;
        });
    };
    OrganizationChart.prototype.getTemplateForNode = function (node) {
        if (this.templateMap)
            return node.type ? this.templateMap[node.type] : this.templateMap['default'];
        else
            return null;
    };
    OrganizationChart.prototype.onNodeClick = function (event, node) {
        var eventTarget = event.target;
        if (eventTarget.className && (eventTarget.className.indexOf('ui-node-toggler') !== -1 || eventTarget.className.indexOf('ui-node-toggler-icon') !== -1)) {
            return;
        }
        else if (this.selectionMode) {
            if (node.selectable === false) {
                return;
            }
            var index_1 = this.findIndexInSelection(node);
            var selected = (index_1 >= 0);
            if (this.selectionMode === 'single') {
                if (selected) {
                    this.selection = null;
                    this.onNodeUnselect.emit({ originalEvent: event, node: node });
                }
                else {
                    this.selection = node;
                    this.onNodeSelect.emit({ originalEvent: event, node: node });
                }
            }
            else if (this.selectionMode === 'multiple') {
                if (selected) {
                    this.selection = this.selection.filter(function (val, i) { return i != index_1; });
                    this.onNodeUnselect.emit({ originalEvent: event, node: node });
                }
                else {
                    this.selection = (this.selection || []).concat([node]);
                    this.onNodeSelect.emit({ originalEvent: event, node: node });
                }
            }
            this.selectionChange.emit(this.selection);
        }
    };
    OrganizationChart.prototype.findIndexInSelection = function (node) {
        var index = -1;
        if (this.selectionMode && this.selection) {
            if (this.selectionMode === 'single') {
                index = (this.selection == node) ? 0 : -1;
            }
            else if (this.selectionMode === 'multiple') {
                for (var i = 0; i < this.selection.length; i++) {
                    if (this.selection[i] == node) {
                        index = i;
                        break;
                    }
                }
            }
        }
        return index;
    };
    OrganizationChart.prototype.isSelected = function (node) {
        return this.findIndexInSelection(node) != -1;
    };
    return OrganizationChart;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], OrganizationChart.prototype, "value", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], OrganizationChart.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], OrganizationChart.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], OrganizationChart.prototype, "selectionMode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], OrganizationChart.prototype, "selection", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OrganizationChart.prototype, "selectionChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OrganizationChart.prototype, "onNodeSelect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OrganizationChart.prototype, "onNodeUnselect", void 0);
__decorate([
    core_1.ContentChildren(shared_2.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], OrganizationChart.prototype, "templates", void 0);
OrganizationChart = __decorate([
    core_1.Component({
        selector: 'p-organizationChart',
        template: "\n        <div [ngStyle]=\"style\" [class]=\"styleClass\" [ngClass]=\"'ui-organizationchart ui-widget'\">\n            <table class=\"ui-organizationchart-table\" pOrganizationChartNode [node]=\"root\"></table>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], OrganizationChart);
exports.OrganizationChart = OrganizationChart;
var OrganizationChartModule = (function () {
    function OrganizationChartModule() {
    }
    return OrganizationChartModule;
}());
OrganizationChartModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [OrganizationChart, shared_1.SharedModule],
        declarations: [OrganizationChart, OrganizationChartNode, OrganizationChartNodeTemplateLoader]
    })
], OrganizationChartModule);
exports.OrganizationChartModule = OrganizationChartModule;
//# sourceMappingURL=organizationchart.js.map

/***/ }),

/***/ "./node_modules/primeng/components/overlaypanel/overlaypanel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var OverlayPanel = (function () {
    function OverlayPanel(el, domHandler, renderer, cd) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.cd = cd;
        this.dismissable = true;
        this.onBeforeShow = new core_1.EventEmitter();
        this.onAfterShow = new core_1.EventEmitter();
        this.onBeforeHide = new core_1.EventEmitter();
        this.onAfterHide = new core_1.EventEmitter();
        this.visible = false;
    }
    OverlayPanel.prototype.ngOnInit = function () {
        var _this = this;
        if (this.dismissable) {
            this.documentClickListener = this.renderer.listen('document', 'click', function () {
                if (!_this.selfClick && !_this.targetEvent) {
                    _this.hide();
                }
                _this.selfClick = false;
                _this.targetEvent = false;
                _this.cd.markForCheck();
            });
        }
    };
    OverlayPanel.prototype.ngAfterViewInit = function () {
        this.container = this.el.nativeElement.children[0];
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.container);
            else
                this.domHandler.appendChild(this.container, this.appendTo);
        }
    };
    OverlayPanel.prototype.toggle = function (event, target) {
        var currentTarget = (target || event.currentTarget || event.target);
        if (!this.target || this.target == currentTarget) {
            if (this.visible)
                this.hide();
            else
                this.show(event, target);
        }
        else {
            this.show(event, target);
        }
        if (this.dismissable) {
            this.targetEvent = true;
        }
        this.target = currentTarget;
    };
    OverlayPanel.prototype.show = function (event, target) {
        if (this.dismissable) {
            this.targetEvent = true;
        }
        this.onBeforeShow.emit(null);
        var elementTarget = target || event.currentTarget || event.target;
        this.container.style.zIndex = ++domhandler_1.DomHandler.zindex;
        if (this.visible) {
            this.domHandler.absolutePosition(this.container, elementTarget);
        }
        else {
            this.visible = true;
            this.domHandler.absolutePosition(this.container, elementTarget);
            this.domHandler.fadeIn(this.container, 250);
        }
        this.onAfterShow.emit(null);
    };
    OverlayPanel.prototype.hide = function () {
        if (this.visible) {
            this.onBeforeHide.emit(null);
            this.visible = false;
            this.onAfterHide.emit(null);
        }
    };
    OverlayPanel.prototype.onPanelClick = function () {
        if (this.dismissable) {
            this.selfClick = true;
        }
    };
    OverlayPanel.prototype.onCloseClick = function (event) {
        this.hide();
        if (this.dismissable) {
            this.selfClick = true;
        }
        event.preventDefault();
    };
    OverlayPanel.prototype.ngOnDestroy = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
        if (this.appendTo) {
            this.el.nativeElement.appendChild(this.container);
        }
        this.target = null;
    };
    return OverlayPanel;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], OverlayPanel.prototype, "dismissable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], OverlayPanel.prototype, "showCloseIcon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], OverlayPanel.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], OverlayPanel.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], OverlayPanel.prototype, "appendTo", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OverlayPanel.prototype, "onBeforeShow", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OverlayPanel.prototype, "onAfterShow", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OverlayPanel.prototype, "onBeforeHide", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], OverlayPanel.prototype, "onAfterHide", void 0);
OverlayPanel = __decorate([
    core_1.Component({
        selector: 'p-overlayPanel',
        template: "\n        <div [ngClass]=\"'ui-overlaypanel ui-widget ui-widget-content ui-corner-all ui-shadow'\" [ngStyle]=\"style\" [class]=\"styleClass\"\n            [style.display]=\"visible ? 'block' : 'none'\" (click)=\"onPanelClick()\">\n            <div class=\"ui-overlaypanel-content\">\n                <ng-content></ng-content>\n            </div>\n            <a href=\"#\" *ngIf=\"showCloseIcon\" class=\"ui-overlaypanel-close ui-state-default\" (click)=\"onCloseClick($event)\">\n                <span class=\"fa fa-fw fa-close\"></span>\n            </a>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, core_1.ChangeDetectorRef])
], OverlayPanel);
exports.OverlayPanel = OverlayPanel;
var OverlayPanelModule = (function () {
    function OverlayPanelModule() {
    }
    return OverlayPanelModule;
}());
OverlayPanelModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [OverlayPanel],
        declarations: [OverlayPanel]
    })
], OverlayPanelModule);
exports.OverlayPanelModule = OverlayPanelModule;
//# sourceMappingURL=overlaypanel.js.map

/***/ }),

/***/ "./node_modules/primeng/components/paginator/paginator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var Paginator = (function () {
    function Paginator() {
        this.pageLinkSize = 5;
        this.onPageChange = new core_1.EventEmitter();
        this.alwaysShow = true;
        this._totalRecords = 0;
        this._first = 0;
        this._rows = 0;
    }
    Object.defineProperty(Paginator.prototype, "totalRecords", {
        get: function () {
            return this._totalRecords;
        },
        set: function (val) {
            this._totalRecords = val;
            this.updatePageLinks();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Paginator.prototype, "first", {
        get: function () {
            return this._first;
        },
        set: function (val) {
            this._first = val;
            this.updatePageLinks();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Paginator.prototype, "rows", {
        get: function () {
            return this._rows;
        },
        set: function (val) {
            this._rows = val;
            this.updatePageLinks();
        },
        enumerable: true,
        configurable: true
    });
    Paginator.prototype.isFirstPage = function () {
        return this.getPage() === 0;
    };
    Paginator.prototype.isLastPage = function () {
        return this.getPage() === this.getPageCount() - 1;
    };
    Paginator.prototype.getPageCount = function () {
        return Math.ceil(this.totalRecords / this.rows) || 1;
    };
    Paginator.prototype.calculatePageLinkBoundaries = function () {
        var numberOfPages = this.getPageCount(), visiblePages = Math.min(this.pageLinkSize, numberOfPages);
        //calculate range, keep current in middle if necessary
        var start = Math.max(0, Math.ceil(this.getPage() - ((visiblePages) / 2))), end = Math.min(numberOfPages - 1, start + visiblePages - 1);
        //check when approaching to last page
        var delta = this.pageLinkSize - (end - start + 1);
        start = Math.max(0, start - delta);
        return [start, end];
    };
    Paginator.prototype.updatePageLinks = function () {
        this.pageLinks = [];
        var boundaries = this.calculatePageLinkBoundaries(), start = boundaries[0], end = boundaries[1];
        for (var i = start; i <= end; i++) {
            this.pageLinks.push(i + 1);
        }
    };
    Paginator.prototype.changePage = function (p, event) {
        var pc = this.getPageCount();
        if (p >= 0 && p < pc) {
            this.first = this.rows * p;
            var state = {
                page: p,
                first: this.first,
                rows: this.rows,
                pageCount: pc
            };
            this.updatePageLinks();
            this.onPageChange.emit(state);
        }
        if (event) {
            event.preventDefault();
        }
    };
    Paginator.prototype.getPage = function () {
        return Math.floor(this.first / this.rows);
    };
    Paginator.prototype.changePageToFirst = function (event) {
        this.changePage(0, event);
    };
    Paginator.prototype.changePageToPrev = function (event) {
        this.changePage(this.getPage() - 1, event);
    };
    Paginator.prototype.changePageToNext = function (event) {
        this.changePage(this.getPage() + 1, event);
    };
    Paginator.prototype.changePageToLast = function (event) {
        this.changePage(this.getPageCount() - 1, event);
    };
    Paginator.prototype.onRppChange = function (event) {
        this.rows = this.rowsPerPageOptions[event.target.selectedIndex];
        this.changePageToFirst(event);
    };
    return Paginator;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Paginator.prototype, "pageLinkSize", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Paginator.prototype, "onPageChange", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Paginator.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Paginator.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Paginator.prototype, "rowsPerPageOptions", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Paginator.prototype, "alwaysShow", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], Paginator.prototype, "totalRecords", null);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], Paginator.prototype, "first", null);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], Paginator.prototype, "rows", null);
Paginator = __decorate([
    core_1.Component({
        selector: 'p-paginator',
        template: "\n        <div [class]=\"styleClass\" [ngStyle]=\"style\" [ngClass]=\"'ui-paginator ui-widget ui-widget-header ui-unselectable-text'\"\n            *ngIf=\"alwaysShow ? true : (pageLinks && pageLinks.length > 1)\">\n            <a href=\"#\" class=\"ui-paginator-first ui-paginator-element ui-state-default ui-corner-all\"\n                    (click)=\"changePageToFirst($event)\" [ngClass]=\"{'ui-state-disabled':isFirstPage()}\" [tabindex]=\"isFirstPage() ? -1 : null\">\n                <span class=\"fa fa-step-backward\"></span>\n            </a>\n            <a href=\"#\" class=\"ui-paginator-prev ui-paginator-element ui-state-default ui-corner-all\"\n                    (click)=\"changePageToPrev($event)\" [ngClass]=\"{'ui-state-disabled':isFirstPage()}\" [tabindex]=\"isFirstPage() ? -1 : null\">\n                <span class=\"fa fa-backward\"></span>\n            </a>\n            <span class=\"ui-paginator-pages\">\n                <a href=\"#\" *ngFor=\"let pageLink of pageLinks\" class=\"ui-paginator-page ui-paginator-element ui-state-default ui-corner-all\"\n                    (click)=\"changePage(pageLink - 1, $event)\" [ngClass]=\"{'ui-state-active': (pageLink-1 == getPage())}\">{{pageLink}}</a>\n            </span>\n            <a href=\"#\" class=\"ui-paginator-next ui-paginator-element ui-state-default ui-corner-all\"\n                    (click)=\"changePageToNext($event)\" [ngClass]=\"{'ui-state-disabled':isLastPage()}\" [tabindex]=\"isLastPage() ? -1 : null\">\n                <span class=\"fa fa-forward\"></span>\n            </a>\n            <a href=\"#\" class=\"ui-paginator-last ui-paginator-element ui-state-default ui-corner-all\"\n                    (click)=\"changePageToLast($event)\" [ngClass]=\"{'ui-state-disabled':isLastPage()}\" [tabindex]=\"isLastPage() ? -1 : null\">\n                <span class=\"fa fa-step-forward\"></span>\n            </a>\n            <select class=\"ui-paginator-rpp-options ui-widget ui-state-default\" *ngIf=\"rowsPerPageOptions\" (change)=\"onRppChange($event)\">\n                <option *ngFor=\"let opt of rowsPerPageOptions\" [value]=\"opt\" [selected]=\"rows == opt\">{{opt}}</option>\n            </select>\n        </div>\n    "
    })
], Paginator);
exports.Paginator = Paginator;
var PaginatorModule = (function () {
    function PaginatorModule() {
    }
    return PaginatorModule;
}());
PaginatorModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Paginator],
        declarations: [Paginator]
    })
], PaginatorModule);
exports.PaginatorModule = PaginatorModule;
//# sourceMappingURL=paginator.js.map

/***/ }),

/***/ "./node_modules/primeng/components/panel/panel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var Panel = (function () {
    function Panel(el) {
        this.el = el;
        this.collapsed = false;
        this.expandIcon = 'fa-plus';
        this.collapseIcon = 'fa-minus';
        this.collapsedChange = new core_1.EventEmitter();
        this.onBeforeToggle = new core_1.EventEmitter();
        this.onAfterToggle = new core_1.EventEmitter();
    }
    Panel.prototype.toggle = function (event) {
        if (this.animating) {
            return false;
        }
        this.animating = true;
        this.onBeforeToggle.emit({ originalEvent: event, collapsed: this.collapsed });
        if (this.toggleable) {
            if (this.collapsed)
                this.expand(event);
            else
                this.collapse(event);
        }
        this.onAfterToggle.emit({ originalEvent: event, collapsed: this.collapsed });
        event.preventDefault();
    };
    Panel.prototype.expand = function (event) {
        this.collapsed = false;
        this.collapsedChange.emit(this.collapsed);
    };
    Panel.prototype.collapse = function (event) {
        this.collapsed = true;
        this.collapsedChange.emit(this.collapsed);
    };
    Panel.prototype.getBlockableElement = function () {
        return this.el.nativeElement.children[0];
    };
    Panel.prototype.onToggleDone = function (event) {
        this.animating = false;
    };
    return Panel;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Panel.prototype, "toggleable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Panel.prototype, "header", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Panel.prototype, "collapsed", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Panel.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Panel.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Panel.prototype, "expandIcon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Panel.prototype, "collapseIcon", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Panel.prototype, "collapsedChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Panel.prototype, "onBeforeToggle", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Panel.prototype, "onAfterToggle", void 0);
__decorate([
    core_1.ContentChild(shared_1.Footer),
    __metadata("design:type", Object)
], Panel.prototype, "footerFacet", void 0);
Panel = __decorate([
    core_1.Component({
        selector: 'p-panel',
        template: "\n        <div [ngClass]=\"'ui-panel ui-widget ui-widget-content ui-corner-all'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-panel-titlebar ui-widget-header ui-helper-clearfix ui-corner-all\">\n                <span class=\"ui-panel-title\" *ngIf=\"header\">{{header}}</span>\n                <ng-content select=\"p-header\"></ng-content>\n                <a *ngIf=\"toggleable\" class=\"ui-panel-titlebar-icon ui-panel-titlebar-toggler ui-corner-all ui-state-default\" href=\"#\"\n                    (click)=\"toggle($event)\">\n                    <span [class]=\"collapsed ? 'fa fa-fw ' + expandIcon : 'fa fa-fw ' + collapseIcon\"></span>\n                </a>\n            </div>\n            <div class=\"ui-panel-content-wrapper\" [@panelContent]=\"collapsed ? 'hidden' : 'visible'\" (@panelContent.done)=\"onToggleDone($event)\"\n                [ngClass]=\"{'ui-panel-content-wrapper-overflown': collapsed||animating}\">\n                <div class=\"ui-panel-content ui-widget-content\">\n                    <ng-content></ng-content>\n                </div>\n                \n                <div class=\"ui-panel-footer ui-widget-content\" *ngIf=\"footerFacet\">\n                    <ng-content select=\"p-footer\"></ng-content>\n                </div>\n            </div>\n        </div>\n    ",
        animations: [
            animations_1.trigger('panelContent', [
                animations_1.state('hidden', animations_1.style({
                    height: '0'
                })),
                animations_1.state('visible', animations_1.style({
                    height: '*'
                })),
                animations_1.transition('visible <=> hidden', animations_1.animate('400ms cubic-bezier(0.86, 0, 0.07, 1)'))
            ])
        ]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef])
], Panel);
exports.Panel = Panel;
var PanelModule = (function () {
    function PanelModule() {
    }
    return PanelModule;
}());
PanelModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Panel, shared_1.SharedModule],
        declarations: [Panel]
    })
], PanelModule);
exports.PanelModule = PanelModule;
//# sourceMappingURL=panel.js.map

/***/ }),

/***/ "./node_modules/primeng/components/panelmenu/panelmenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var router_1 = __webpack_require__(5);
var BasePanelMenuItem = (function () {
    function BasePanelMenuItem() {
    }
    BasePanelMenuItem.prototype.handleClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        item.expanded = !item.expanded;
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
    };
    return BasePanelMenuItem;
}());
exports.BasePanelMenuItem = BasePanelMenuItem;
var PanelMenuSub = (function (_super) {
    __extends(PanelMenuSub, _super);
    function PanelMenuSub() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PanelMenuSub;
}(BasePanelMenuItem));
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], PanelMenuSub.prototype, "item", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], PanelMenuSub.prototype, "expanded", void 0);
PanelMenuSub = __decorate([
    core_1.Component({
        selector: 'p-panelMenuSub',
        template: "\n        <ul class=\"ui-menu-list ui-helper-reset\" [@submenu]=\"expanded ? 'visible' : 'hidden'\">\n            <ng-template ngFor let-child [ngForOf]=\"item.items\">\n                <li *ngIf=\"child.separator\" class=\"ui-menu-separator ui-widget-content\">\n                <li *ngIf=\"!child.separator\" class=\"ui-menuitem ui-corner-all\" [ngClass]=\"{'ui-menu-parent':child.items}\" [class]=\"child.styleClass\" [ngStyle]=\"child.style\">\n                    <a *ngIf=\"!child.routerLink\" [href]=\"child.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" [attr.tabindex]=\"item.expanded ? null : '-1'\"\n                        [ngClass]=\"{'ui-menuitem-link-hasicon':child.icon&&child.items,'ui-state-disabled':child.disabled}\" \n                        (click)=\"handleClick($event,child)\" [attr.target]=\"child.target\">\n                        <span class=\"ui-panelmenu-icon fa fa-fw\" [ngClass]=\"{'fa-caret-right':!child.expanded,'fa-caret-down':child.expanded}\" *ngIf=\"child.items\"></span\n                        ><span class=\"ui-menuitem-icon fa fa-fw\" [ngClass]=\"child.icon\" *ngIf=\"child.icon\"></span\n                        ><span class=\"ui-menuitem-text\">{{child.label}}</span>\n                    </a>\n                    <a *ngIf=\"child.routerLink\" [routerLink]=\"child.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"child.routerLinkActiveOptions||{exact:false}\" class=\"ui-menuitem-link ui-corner-all\" \n                        [ngClass]=\"{'ui-menuitem-link-hasicon':child.icon&&child.items,'ui-state-disabled':child.disabled}\" [attr.tabindex]=\"item.expanded ? null : '-1'\" \n                        (click)=\"handleClick($event,child)\" [attr.target]=\"child.target\">\n                        <span class=\"ui-panelmenu-icon fa fa-fw\" [ngClass]=\"{'fa-caret-right':!child.expanded,'fa-caret-down':child.expanded}\" *ngIf=\"child.items\"></span\n                        ><span class=\"ui-menuitem-icon fa fa-fw\" [ngClass]=\"child.icon\" *ngIf=\"child.icon\"></span\n                        ><span class=\"ui-menuitem-text\">{{child.label}}</span>\n                    </a>\n                    <p-panelMenuSub [item]=\"child\" [expanded]=\"child.expanded\" *ngIf=\"child.items\"></p-panelMenuSub>\n                </li>\n            </ng-template>\n        </ul>\n    ",
        animations: [
            animations_1.trigger('submenu', [
                animations_1.state('hidden', animations_1.style({
                    height: '0px'
                })),
                animations_1.state('visible', animations_1.style({
                    height: '*'
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms cubic-bezier(0.86, 0, 0.07, 1)'))
            ])
        ]
    })
], PanelMenuSub);
exports.PanelMenuSub = PanelMenuSub;
var PanelMenu = (function (_super) {
    __extends(PanelMenu, _super);
    function PanelMenu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PanelMenu.prototype.handleClick = function (event, item) {
        this.animating = true;
        _super.prototype.handleClick.call(this, event, item);
    };
    PanelMenu.prototype.onToggleDone = function () {
        this.animating = false;
    };
    return PanelMenu;
}(BasePanelMenuItem));
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], PanelMenu.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], PanelMenu.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PanelMenu.prototype, "styleClass", void 0);
PanelMenu = __decorate([
    core_1.Component({
        selector: 'p-panelMenu',
        template: "\n        <div [class]=\"styleClass\" [ngStyle]=\"style\" [ngClass]=\"'ui-panelmenu ui-widget'\">\n            <div *ngFor=\"let item of model;let f=first;let l=last;\" class=\"ui-panelmenu-panel\">\n                <div [ngClass]=\"{'ui-widget ui-panelmenu-header ui-state-default':true,'ui-corner-top':f,'ui-corner-bottom':l&&!item.expanded,\n                    'ui-state-active':item.expanded,'ui-state-disabled':item.disabled}\" [class]=\"item.styleClass\" [ngStyle]=\"item.style\">\n                    <a *ngIf=\"!item.routerLink\" [href]=\"item.url||'#'\" [ngClass]=\"{'ui-panelmenu-headerlink-hasicon':item.icon}\" (click)=\"handleClick($event,item)\"\n                        [attr.target]=\"item.target\">\n                        <span *ngIf=\"item.items\" class=\"ui-panelmenu-icon fa\" [ngClass]=\"{'fa-caret-right':!item.expanded,'fa-caret-down':item.expanded}\"></span\n                        ><span class=\"ui-menuitem-icon fa\" [ngClass]=\"item.icon\" *ngIf=\"item.icon\"></span\n                        ><span class=\"ui-menuitem-text\">{{item.label}}</span>\n                    </a>\n                    <a *ngIf=\"item.routerLink\" [routerLink]=\"item.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"item.routerLinkActiveOptions||{exact:false}\" [ngClass]=\"{'ui-panelmenu-headerlink-hasicon':item.icon}\" (click)=\"handleClick($event,item)\"\n                        [attr.target]=\"item.target\">\n                        <span *ngIf=\"item.items\" class=\"ui-panelmenu-icon fa\" [ngClass]=\"{'fa-caret-right':!item.expanded,'fa-caret-down':item.expanded}\"></span\n                        ><span class=\"ui-menuitem-icon fa\" [ngClass]=\"item.icon\" *ngIf=\"item.icon\"></span\n                        ><span class=\"ui-menuitem-text\">{{item.label}}</span>\n                    </a>\n                </div>\n                <div *ngIf=\"item.items\" class=\"ui-panelmenu-content-wrapper\" [@rootItem]=\"item.expanded ? 'visible' : 'hidden'\"  (@rootItem.done)=\"onToggleDone($event)\"\n                    [ngClass]=\"{'ui-panelmenu-content-wrapper-overflown': !item.expanded||animating}\">\n                    <div class=\"ui-panelmenu-content ui-widget-content\">\n                        <p-panelMenuSub [item]=\"item\" [expanded]=\"true\"></p-panelMenuSub>\n                    </div>\n                </div>\n            </div>\n        </div>\n    ",
        animations: [
            animations_1.trigger('rootItem', [
                animations_1.state('hidden', animations_1.style({
                    height: '0px'
                })),
                animations_1.state('visible', animations_1.style({
                    height: '*'
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms cubic-bezier(0.86, 0, 0.07, 1)'))
            ])
        ]
    })
], PanelMenu);
exports.PanelMenu = PanelMenu;
var PanelMenuModule = (function () {
    function PanelMenuModule() {
    }
    return PanelMenuModule;
}());
PanelMenuModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [PanelMenu, router_1.RouterModule],
        declarations: [PanelMenu, PanelMenuSub]
    })
], PanelMenuModule);
exports.PanelMenuModule = PanelMenuModule;
//# sourceMappingURL=panelmenu.js.map

/***/ }),

/***/ "./node_modules/primeng/components/password/password.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var Password = (function () {
    function Password(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.promptLabel = 'Please enter a password';
        this.weakLabel = 'Weak';
        this.mediumLabel = 'Medium';
        this.strongLabel = 'Strong';
        this.feedback = true;
    }
    Password.prototype.ngAfterViewInit = function () {
        this.panel = document.createElement('div');
        this.panel.className = 'ui-password-panel ui-widget ui-state-highlight ui-corner-all ui-helper-hidden ui-password-panel-overlay';
        this.meter = document.createElement('div');
        this.meter.className = 'ui-password-meter';
        this.info = document.createElement('div');
        this.info.className = 'ui-password-info';
        this.info.textContent = this.promptLabel;
        if (this.feedback) {
            this.panel.appendChild(this.meter);
            this.panel.appendChild(this.info);
            document.body.appendChild(this.panel);
        }
    };
    Password.prototype.ngDoCheck = function () {
        this.updateFilledState();
    };
    //To trigger change detection to manage ui-state-filled for material labels when there is no value binding
    Password.prototype.onInput = function (e) {
        this.updateFilledState();
    };
    Password.prototype.updateFilledState = function () {
        this.filled = this.el.nativeElement.value && this.el.nativeElement.value.length;
    };
    Password.prototype.onFocus = function (e) {
        this.panel.style.zIndex = String(++domhandler_1.DomHandler.zindex);
        this.domHandler.removeClass(this.panel, 'ui-helper-hidden');
        this.domHandler.absolutePosition(this.panel, this.el.nativeElement);
        this.domHandler.fadeIn(this.panel, 250);
    };
    Password.prototype.onBlur = function (e) {
        this.domHandler.addClass(this.panel, 'ui-helper-hidden');
    };
    Password.prototype.onKeyup = function (e) {
        var value = e.target.value, label = null, meterPos = null;
        if (value.length === 0) {
            label = this.promptLabel;
            meterPos = '0px 0px';
        }
        else {
            var score = this.testStrength(value);
            if (score < 30) {
                label = this.weakLabel;
                meterPos = '0px -10px';
            }
            else if (score >= 30 && score < 80) {
                label = this.mediumLabel;
                meterPos = '0px -20px';
            }
            else if (score >= 80) {
                label = this.strongLabel;
                meterPos = '0px -30px';
            }
        }
        this.meter.style.backgroundPosition = meterPos;
        this.info.textContent = label;
    };
    Password.prototype.testStrength = function (str) {
        var grade = 0;
        var val;
        val = str.match('[0-9]');
        grade += this.normalize(val ? val.length : 1 / 4, 1) * 25;
        val = str.match('[a-zA-Z]');
        grade += this.normalize(val ? val.length : 1 / 2, 3) * 10;
        val = str.match('[!@#$%^&*?_~.,;=]');
        grade += this.normalize(val ? val.length : 1 / 6, 1) * 35;
        val = str.match('[A-Z]');
        grade += this.normalize(val ? val.length : 1 / 6, 1) * 30;
        grade *= str.length / 8;
        return grade > 100 ? 100 : grade;
    };
    Password.prototype.normalize = function (x, y) {
        var diff = x - y;
        if (diff <= 0)
            return x / y;
        else
            return 1 + 0.5 * (x / (x + y / 4));
    };
    Object.defineProperty(Password.prototype, "disabled", {
        get: function () {
            return this.el.nativeElement.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Password.prototype.ngOnDestroy = function () {
        if (!this.feedback)
            return;
        this.panel.removeChild(this.meter);
        this.panel.removeChild(this.info);
        document.body.removeChild(this.panel);
        this.panel = null;
        this.meter = null;
        this.info = null;
    };
    return Password;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Password.prototype, "promptLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Password.prototype, "weakLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Password.prototype, "mediumLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Password.prototype, "strongLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Password.prototype, "feedback", void 0);
__decorate([
    core_1.HostListener('input', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Password.prototype, "onInput", null);
__decorate([
    core_1.HostListener('focus', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Password.prototype, "onFocus", null);
__decorate([
    core_1.HostListener('blur', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Password.prototype, "onBlur", null);
__decorate([
    core_1.HostListener('keyup', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Password.prototype, "onKeyup", null);
Password = __decorate([
    core_1.Directive({
        selector: '[pPassword]',
        host: {
            '[class.ui-inputtext]': 'true',
            '[class.ui-corner-all]': 'true',
            '[class.ui-state-default]': 'true',
            '[class.ui-widget]': 'true',
            '[class.ui-state-filled]': 'filled'
        },
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Password);
exports.Password = Password;
var PasswordModule = (function () {
    function PasswordModule() {
    }
    return PasswordModule;
}());
PasswordModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Password],
        declarations: [Password]
    })
], PasswordModule);
exports.PasswordModule = PasswordModule;
//# sourceMappingURL=password.js.map

/***/ }),

/***/ "./node_modules/primeng/components/picklist/picklist.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var button_1 = __webpack_require__("./node_modules/primeng/components/button/button.js");
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var objectutils_1 = __webpack_require__("./node_modules/primeng/components/utils/objectutils.js");
var PickList = (function () {
    function PickList(el, domHandler, objectUtils) {
        this.el = el;
        this.domHandler = domHandler;
        this.objectUtils = objectUtils;
        this.metaKeySelection = true;
        this.showSourceControls = true;
        this.showTargetControls = true;
        this.onMoveToSource = new core_1.EventEmitter();
        this.onMoveAllToSource = new core_1.EventEmitter();
        this.onMoveAllToTarget = new core_1.EventEmitter();
        this.onMoveToTarget = new core_1.EventEmitter();
        this.onSourceReorder = new core_1.EventEmitter();
        this.onTargetReorder = new core_1.EventEmitter();
        this.selectedItemsSource = [];
        this.selectedItemsTarget = [];
    }
    PickList.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.templates.forEach(function (item) {
            switch (item.getType()) {
                case 'item':
                    _this.itemTemplate = item.template;
                    break;
                default:
                    _this.itemTemplate = item.template;
                    break;
            }
        });
    };
    PickList.prototype.ngAfterViewChecked = function () {
        if (this.movedUp || this.movedDown) {
            var listItems = this.domHandler.find(this.reorderedListElement, 'li.ui-state-highlight');
            var listItem = void 0;
            if (this.movedUp)
                listItem = listItems[0];
            else
                listItem = listItems[listItems.length - 1];
            this.domHandler.scrollInView(this.reorderedListElement, listItem);
            this.movedUp = false;
            this.movedDown = false;
            this.reorderedListElement = null;
        }
    };
    PickList.prototype.onItemClick = function (event, item, selectedItems) {
        var index = this.findIndexInSelection(item, selectedItems);
        var selected = (index != -1);
        var metaSelection = this.itemTouched ? false : this.metaKeySelection;
        if (metaSelection) {
            var metaKey = (event.metaKey || event.ctrlKey);
            if (selected && metaKey) {
                selectedItems.splice(index, 1);
            }
            else {
                if (!metaKey) {
                    selectedItems.length = 0;
                }
                selectedItems.push(item);
            }
        }
        else {
            if (selected)
                selectedItems.splice(index, 1);
            else
                selectedItems.push(item);
        }
        this.itemTouched = false;
    };
    PickList.prototype.onSourceItemDblClick = function () {
        this.moveRight();
    };
    PickList.prototype.onTargetItemDblClick = function () {
        this.moveLeft();
    };
    PickList.prototype.onFilter = function (event, data, listType) {
        var query = event.target.value.trim().toLowerCase();
        if (listType === -1)
            this.filterValueSource = query;
        else
            this.filterValueTarget = query;
        this.activateFilter(data, listType);
    };
    PickList.prototype.activateFilter = function (data, listType) {
        var searchFields = this.filterBy.split(',');
        if (listType === -1)
            this.visibleOptionsSource = this.objectUtils.filter(data, searchFields, this.filterValueSource);
        else
            this.visibleOptionsTarget = this.objectUtils.filter(data, searchFields, this.filterValueTarget);
    };
    PickList.prototype.isItemVisible = function (item, listType) {
        if (listType == -1)
            return this.isVisibleInList(this.visibleOptionsSource, item, this.filterValueSource);
        else
            return this.isVisibleInList(this.visibleOptionsTarget, item, this.filterValueTarget);
    };
    PickList.prototype.isVisibleInList = function (data, item, filterValue) {
        if (filterValue && filterValue.trim().length) {
            for (var i = 0; i < data.length; i++) {
                if (item == data[i]) {
                    return true;
                }
            }
        }
        else {
            return true;
        }
    };
    PickList.prototype.onItemTouchEnd = function (event) {
        this.itemTouched = true;
    };
    PickList.prototype.moveUp = function (listElement, list, selectedItems, callback) {
        if (selectedItems && selectedItems.length) {
            for (var i = 0; i < selectedItems.length; i++) {
                var selectedItem = selectedItems[i];
                var selectedItemIndex = this.findIndexInList(selectedItem, list);
                if (selectedItemIndex != 0) {
                    var movedItem = list[selectedItemIndex];
                    var temp = list[selectedItemIndex - 1];
                    list[selectedItemIndex - 1] = movedItem;
                    list[selectedItemIndex] = temp;
                }
                else {
                    break;
                }
            }
            this.movedUp = true;
            this.reorderedListElement = listElement;
            callback.emit({ items: selectedItems });
        }
    };
    PickList.prototype.moveTop = function (listElement, list, selectedItems, callback) {
        if (selectedItems && selectedItems.length) {
            for (var i = 0; i < selectedItems.length; i++) {
                var selectedItem = selectedItems[i];
                var selectedItemIndex = this.findIndexInList(selectedItem, list);
                if (selectedItemIndex != 0) {
                    var movedItem = list.splice(selectedItemIndex, 1)[0];
                    list.unshift(movedItem);
                }
                else {
                    break;
                }
            }
            listElement.scrollTop = 0;
            callback.emit({ items: selectedItems });
        }
    };
    PickList.prototype.moveDown = function (listElement, list, selectedItems, callback) {
        if (selectedItems && selectedItems.length) {
            for (var i = selectedItems.length - 1; i >= 0; i--) {
                var selectedItem = selectedItems[i];
                var selectedItemIndex = this.findIndexInList(selectedItem, list);
                if (selectedItemIndex != (list.length - 1)) {
                    var movedItem = list[selectedItemIndex];
                    var temp = list[selectedItemIndex + 1];
                    list[selectedItemIndex + 1] = movedItem;
                    list[selectedItemIndex] = temp;
                }
                else {
                    break;
                }
            }
            this.movedDown = true;
            this.reorderedListElement = listElement;
            callback.emit({ items: selectedItems });
        }
    };
    PickList.prototype.moveBottom = function (listElement, list, selectedItems, callback) {
        if (selectedItems && selectedItems.length) {
            for (var i = selectedItems.length - 1; i >= 0; i--) {
                var selectedItem = selectedItems[i];
                var selectedItemIndex = this.findIndexInList(selectedItem, list);
                if (selectedItemIndex != (list.length - 1)) {
                    var movedItem = list.splice(selectedItemIndex, 1)[0];
                    list.push(movedItem);
                }
                else {
                    break;
                }
            }
            listElement.scrollTop = listElement.scrollHeight;
            callback.emit({ items: selectedItems });
        }
    };
    PickList.prototype.moveRight = function () {
        if (this.selectedItemsSource && this.selectedItemsSource.length) {
            for (var i = 0; i < this.selectedItemsSource.length; i++) {
                var selectedItem = this.selectedItemsSource[i];
                if (this.findIndexInList(selectedItem, this.target) == -1) {
                    this.target.push(this.source.splice(this.findIndexInList(selectedItem, this.source), 1)[0]);
                }
            }
            this.onMoveToTarget.emit({
                items: this.selectedItemsSource
            });
            this.selectedItemsSource = [];
        }
    };
    PickList.prototype.moveAllRight = function () {
        if (this.source) {
            for (var i = 0; i < this.source.length; i++) {
                this.target.push(this.source[i]);
            }
            this.onMoveToTarget.emit({
                items: this.source
            });
            this.onMoveAllToTarget.emit({
                items: this.source
            });
            this.source.splice(0, this.source.length);
            this.selectedItemsSource = [];
        }
    };
    PickList.prototype.moveLeft = function () {
        if (this.selectedItemsTarget && this.selectedItemsTarget.length) {
            for (var i = 0; i < this.selectedItemsTarget.length; i++) {
                var selectedItem = this.selectedItemsTarget[i];
                if (this.findIndexInList(selectedItem, this.source) == -1) {
                    this.source.push(this.target.splice(this.findIndexInList(selectedItem, this.target), 1)[0]);
                }
            }
            this.onMoveToSource.emit({
                items: this.selectedItemsTarget
            });
            this.selectedItemsTarget = [];
        }
    };
    PickList.prototype.moveAllLeft = function () {
        if (this.target) {
            for (var i = 0; i < this.target.length; i++) {
                this.source.push(this.target[i]);
            }
            this.onMoveToSource.emit({
                items: this.target
            });
            this.onMoveAllToSource.emit({
                items: this.target
            });
            this.target.splice(0, this.target.length);
            this.selectedItemsTarget = [];
        }
    };
    PickList.prototype.isSelected = function (item, selectedItems) {
        return this.findIndexInSelection(item, selectedItems) != -1;
    };
    PickList.prototype.findIndexInSelection = function (item, selectedItems) {
        return this.findIndexInList(item, selectedItems);
    };
    PickList.prototype.findIndexInList = function (item, list) {
        var index = -1;
        if (list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i] == item) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    PickList.prototype.onDragStart = function (event, index, listType) {
        this.dragging = true;
        this.fromListType = listType;
        if (listType === -1)
            this.draggedItemIndexSource = index;
        else
            this.draggedItemIndexTarget = index;
        if (this.dragdropScope) {
            event.dataTransfer.setData("text", this.dragdropScope);
        }
    };
    PickList.prototype.onDragOver = function (event, index, listType) {
        if (listType == -1) {
            if (this.draggedItemIndexSource !== index && this.draggedItemIndexSource + 1 !== index || (this.fromListType === 1)) {
                this.dragOverItemIndexSource = index;
                event.preventDefault();
            }
        }
        else {
            if (this.draggedItemIndexTarget !== index && this.draggedItemIndexTarget + 1 !== index || (this.fromListType === -1)) {
                this.dragOverItemIndexTarget = index;
                event.preventDefault();
            }
        }
        this.onListItemDroppoint = true;
    };
    PickList.prototype.onDragLeave = function (event, listType) {
        this.dragOverItemIndexSource = null;
        this.dragOverItemIndexTarget = null;
        this.onListItemDroppoint = false;
    };
    PickList.prototype.onDrop = function (event, index, listType) {
        if (this.onListItemDroppoint) {
            if (listType === -1) {
                if (this.fromListType === 1)
                    this.insert(this.draggedItemIndexTarget, this.target, index, this.source);
                else
                    this.objectUtils.reorderArray(this.source, this.draggedItemIndexSource, (this.draggedItemIndexSource > index) ? index : (index === 0) ? 0 : index - 1);
                this.dragOverItemIndexSource = null;
            }
            else {
                if (this.fromListType === -1)
                    this.insert(this.draggedItemIndexSource, this.source, index, this.target);
                else
                    this.objectUtils.reorderArray(this.target, this.draggedItemIndexTarget, (this.draggedItemIndexTarget > index) ? index : (index === 0) ? 0 : index - 1);
                this.dragOverItemIndexTarget = null;
            }
            this.listHighlightTarget = false;
            this.listHighlightSource = false;
            event.preventDefault();
        }
    };
    PickList.prototype.onDragEnd = function (event) {
        this.dragging = false;
    };
    PickList.prototype.onListDrop = function (event, listType) {
        if (!this.onListItemDroppoint) {
            if (listType === -1) {
                if (this.fromListType === 1)
                    this.insert(this.draggedItemIndexTarget, this.target, null, this.source);
            }
            else {
                if (this.fromListType === -1)
                    this.insert(this.draggedItemIndexSource, this.source, null, this.target);
            }
            this.listHighlightTarget = false;
            this.listHighlightSource = false;
            event.preventDefault();
        }
    };
    PickList.prototype.insert = function (fromIndex, fromList, toIndex, toList) {
        if (toIndex === null)
            toList.push(fromList.splice(fromIndex, 1)[0]);
        else
            toList.splice(toIndex, 0, fromList.splice(fromIndex, 1)[0]);
    };
    PickList.prototype.onListMouseMove = function (event, listType) {
        if (this.dragging) {
            var moveListType = (listType == 0 ? this.listViewSourceChild : this.listViewTargetChild);
            var offsetY = moveListType.nativeElement.getBoundingClientRect().top + document.body.scrollTop;
            var bottomDiff = (offsetY + moveListType.nativeElement.clientHeight) - event.pageY;
            var topDiff = (event.pageY - offsetY);
            if (bottomDiff < 25 && bottomDiff > 0)
                moveListType.nativeElement.scrollTop += 15;
            else if (topDiff < 25 && topDiff > 0)
                moveListType.nativeElement.scrollTop -= 15;
        }
        if (listType === -1) {
            if (this.fromListType === 1)
                this.listHighlightSource = true;
        }
        else {
            if (this.fromListType === -1)
                this.listHighlightTarget = true;
        }
        event.preventDefault();
    };
    PickList.prototype.onListDragLeave = function () {
        this.listHighlightTarget = false;
        this.listHighlightSource = false;
    };
    return PickList;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], PickList.prototype, "source", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], PickList.prototype, "target", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PickList.prototype, "sourceHeader", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PickList.prototype, "targetHeader", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], PickList.prototype, "responsive", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PickList.prototype, "filterBy", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], PickList.prototype, "metaKeySelection", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], PickList.prototype, "dragdrop", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PickList.prototype, "dragdropScope", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], PickList.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PickList.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], PickList.prototype, "sourceStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], PickList.prototype, "targetStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], PickList.prototype, "showSourceControls", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], PickList.prototype, "showTargetControls", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PickList.prototype, "sourceFilterPlaceholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], PickList.prototype, "targetFilterPlaceholder", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], PickList.prototype, "onMoveToSource", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], PickList.prototype, "onMoveAllToSource", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], PickList.prototype, "onMoveAllToTarget", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], PickList.prototype, "onMoveToTarget", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], PickList.prototype, "onSourceReorder", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], PickList.prototype, "onTargetReorder", void 0);
__decorate([
    core_1.ViewChild('sourcelist'),
    __metadata("design:type", core_1.ElementRef)
], PickList.prototype, "listViewSourceChild", void 0);
__decorate([
    core_1.ViewChild('targetlist'),
    __metadata("design:type", core_1.ElementRef)
], PickList.prototype, "listViewTargetChild", void 0);
__decorate([
    core_1.ContentChildren(shared_1.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], PickList.prototype, "templates", void 0);
PickList = __decorate([
    core_1.Component({
        selector: 'p-pickList',
        template: "\n        <div [class]=\"styleClass\" [ngStyle]=\"style\" [ngClass]=\"{'ui-picklist ui-widget ui-helper-clearfix': true,'ui-picklist-responsive': responsive}\">\n            <div class=\"ui-picklist-source-controls ui-picklist-buttons\" *ngIf=\"showSourceControls\">\n                <div class=\"ui-picklist-buttons-cell\">\n                    <button type=\"button\" pButton icon=\"fa-angle-up\" (click)=\"moveUp(sourcelist,source,selectedItemsSource,onSourceReorder)\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-double-up\" (click)=\"moveTop(sourcelist,source,selectedItemsSource,onSourceReorder)\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-down\" (click)=\"moveDown(sourcelist,source,selectedItemsSource,onSourceReorder)\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-double-down\" (click)=\"moveBottom(sourcelist,source,selectedItemsSource,onSourceReorder)\"></button>\n                </div>\n            </div>\n            <div class=\"ui-picklist-listwrapper ui-picklist-source-wrapper\" [ngClass]=\"{'ui-picklist-listwrapper-nocontrols':!showSourceControls}\">\n                <div class=\"ui-picklist-caption ui-widget-header ui-corner-tl ui-corner-tr\" *ngIf=\"sourceHeader\">{{sourceHeader}}</div>\n                <div class=\"ui-picklist-filter-container ui-widget-content\" *ngIf=\"filterBy\">\n                    <input type=\"text\" role=\"textbox\" (keyup)=\"onFilter($event,source,-1)\" class=\"ui-picklist-filter ui-inputtext ui-widget ui-state-default ui-corner-all\" [disabled]=\"disabled\" [attr.placeholder]=\"sourceFilterPlaceholder\">\n                    <span class=\"fa fa-search\"></span>\n                </div>\n                <ul #sourcelist class=\"ui-widget-content ui-picklist-list ui-picklist-source ui-corner-bottom\" [ngClass]=\"{'ui-picklist-highlight': listHighlightSource}\" [ngStyle]=\"sourceStyle\" (dragover)=\"onListMouseMove($event,-1)\" (dragleave)=\"onListDragLeave()\" (drop)=\"onListDrop($event, -1)\">\n                    <ng-template ngFor let-item [ngForOf]=\"source\" let-i=\"index\" let-l=\"last\">\n                        <li class=\"ui-picklist-droppoint\" *ngIf=\"dragdrop\" (dragover)=\"onDragOver($event, i, -1)\" (drop)=\"onDrop($event, i, -1)\" (dragleave)=\"onDragLeave($event, -1)\" \n                        [ngClass]=\"{'ui-picklist-droppoint-highlight': (i === dragOverItemIndexSource)}\" [style.display]=\"isItemVisible(item, -1) ? 'block' : 'none'\"></li>\n                        <li [ngClass]=\"{'ui-picklist-item':true,'ui-state-highlight':isSelected(item,selectedItemsSource)}\"\n                            (click)=\"onItemClick($event,item,selectedItemsSource)\" (dblclick)=\"onSourceItemDblClick()\" (touchend)=\"onItemTouchEnd($event)\"\n                            [style.display]=\"isItemVisible(item, -1) ? 'block' : 'none'\"\n                            [draggable]=\"dragdrop\" (dragstart)=\"onDragStart($event, i, -1)\" (dragend)=\"onDragEnd($event)\">\n                            <ng-template [pTemplateWrapper]=\"itemTemplate\" [item]=\"item\"></ng-template>\n                        </li>\n                        <li class=\"ui-picklist-droppoint\" *ngIf=\"dragdrop&&l\" (dragover)=\"onDragOver($event, i + 1, -1)\" (drop)=\"onDrop($event, i + 1, -1)\" (dragleave)=\"onDragLeave($event, -1)\" \n                        [ngClass]=\"{'ui-picklist-droppoint-highlight': (i + 1 === dragOverItemIndexSource)}\"></li>\n                    </ng-template>\n                </ul>\n            </div>\n            <div class=\"ui-picklist-buttons\">\n                <div class=\"ui-picklist-buttons-cell\">\n                    <button type=\"button\" pButton icon=\"fa-angle-right\" (click)=\"moveRight()\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-double-right\" (click)=\"moveAllRight()\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-left\" (click)=\"moveLeft()\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-double-left\" (click)=\"moveAllLeft()\"></button>\n                </div>\n            </div>\n            <div class=\"ui-picklist-listwrapper ui-picklist-target-wrapper\" [ngClass]=\"{'ui-picklist-listwrapper-nocontrols':!showTargetControls}\">\n                <div class=\"ui-picklist-caption ui-widget-header ui-corner-tl ui-corner-tr\" *ngIf=\"targetHeader\">{{targetHeader}}</div>\n                <div class=\"ui-picklist-filter-container ui-widget-content\" *ngIf=\"filterBy\">\n                    <input type=\"text\" role=\"textbox\" (keyup)=\"onFilter($event,target,1)\" class=\"ui-picklist-filter ui-inputtext ui-widget ui-state-default ui-corner-all\" [disabled]=\"disabled\" [attr.placeholder]=\"targetFilterPlaceholder\">\n                    <span class=\"fa fa-search\"></span>\n                </div>\n                <ul #targetlist class=\"ui-widget-content ui-picklist-list ui-picklist-target ui-corner-bottom\" [ngClass]=\"{'ui-picklist-highlight': listHighlightTarget}\" [ngStyle]=\"targetStyle\" (dragover)=\"onListMouseMove($event,1)\" (dragleave)=\"onListDragLeave()\" (drop)=\"onListDrop($event,1)\">\n                    <ng-template ngFor let-item [ngForOf]=\"target\" let-i=\"index\" let-l=\"last\">\n                        <li class=\"ui-picklist-droppoint\" *ngIf=\"dragdrop\" (dragover)=\"onDragOver($event, i, 1)\" (drop)=\"onDrop($event, i, 1)\" (dragleave)=\"onDragLeave($event, 1)\" \n                        [ngClass]=\"{'ui-picklist-droppoint-highlight': (i === dragOverItemIndexTarget)}\" [style.display]=\"isItemVisible(item, 1) ? 'block' : 'none'\"></li>\n                        <li [ngClass]=\"{'ui-picklist-item':true,'ui-state-highlight':isSelected(item,selectedItemsTarget)}\"\n                            (click)=\"onItemClick($event,item,selectedItemsTarget)\" (dblclick)=\"onTargetItemDblClick()\" (touchend)=\"onItemTouchEnd($event)\"\n                            [style.display]=\"isItemVisible(item, 1) ? 'block' : 'none'\"\n                            [draggable]=\"dragdrop\" (dragstart)=\"onDragStart($event, i, 1)\" (dragend)=\"onDragEnd($event)\">\n                            <ng-template [pTemplateWrapper]=\"itemTemplate\" [item]=\"item\"></ng-template>\n                        </li>\n                        <li class=\"ui-picklist-droppoint\" *ngIf=\"dragdrop&&l\" (dragover)=\"onDragOver($event, i + 1, 1)\" (drop)=\"onDrop($event, i + 1, 1)\" (dragleave)=\"onDragLeave($event, 1)\" \n                        [ngClass]=\"{'ui-picklist-droppoint-highlight': (i + 1 === dragOverItemIndexTarget)}\"></li>\n                    </ng-template>\n                </ul>\n            </div>\n            <div class=\"ui-picklist-target-controls ui-picklist-buttons\" *ngIf=\"showTargetControls\">\n                <div class=\"ui-picklist-buttons-cell\">\n                    <button type=\"button\" pButton icon=\"fa-angle-up\" (click)=\"moveUp(targetlist,target,selectedItemsTarget,onTargetReorder)\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-double-up\" (click)=\"moveTop(targetlist,target,selectedItemsTarget,onTargetReorder)\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-down\" (click)=\"moveDown(targetlist,target,selectedItemsTarget,onTargetReorder)\"></button>\n                    <button type=\"button\" pButton icon=\"fa-angle-double-down\" (click)=\"moveBottom(targetlist,target,selectedItemsTarget,onTargetReorder)\"></button>\n                </div>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler, objectutils_1.ObjectUtils]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, objectutils_1.ObjectUtils])
], PickList);
exports.PickList = PickList;
var PickListModule = (function () {
    function PickListModule() {
    }
    return PickListModule;
}());
PickListModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, button_1.ButtonModule, shared_1.SharedModule],
        exports: [PickList, shared_1.SharedModule],
        declarations: [PickList]
    })
], PickListModule);
exports.PickListModule = PickListModule;
//# sourceMappingURL=picklist.js.map

/***/ }),

/***/ "./node_modules/primeng/components/progressbar/progressbar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var ProgressBar = (function () {
    function ProgressBar() {
        this.showValue = true;
        this.unit = '%';
    }
    return ProgressBar;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ProgressBar.prototype, "value", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ProgressBar.prototype, "showValue", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ProgressBar.prototype, "unit", void 0);
ProgressBar = __decorate([
    core_1.Component({
        selector: 'p-progressBar',
        template: "\n        <div class=\"ui-progressbar ui-widget ui-widget-content ui-corner-all\" role=\"progressbar\" aria-valuemin=\"0\" [attr.aria-valuenow]=\"value\" aria-valuemax=\"100\">\n            <div class=\"ui-progressbar-value ui-progressbar-value-animate ui-widget-header ui-corner-all\" [style.width]=\"value + '%'\" style=\"display:block\"></div>\n            <div class=\"ui-progressbar-label\" [style.display]=\"value ? 'block' : 'none'\" *ngIf=\"showValue\">{{value}}{{unit}}</div>\n        </div>\n    "
    })
], ProgressBar);
exports.ProgressBar = ProgressBar;
var ProgressBarModule = (function () {
    function ProgressBarModule() {
    }
    return ProgressBarModule;
}());
ProgressBarModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [ProgressBar],
        declarations: [ProgressBar]
    })
], ProgressBarModule);
exports.ProgressBarModule = ProgressBarModule;
//# sourceMappingURL=progressbar.js.map

/***/ }),

/***/ "./node_modules/primeng/components/radiobutton/radiobutton.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var forms_1 = __webpack_require__(4);
exports.RADIO_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return RadioButton; }),
    multi: true
};
var RadioButton = (function () {
    function RadioButton(cd) {
        this.cd = cd;
        this.onClick = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    RadioButton.prototype.handleClick = function () {
        if (!this.disabled) {
            this.onClick.emit(null);
            this.select();
        }
    };
    RadioButton.prototype.select = function () {
        if (!this.disabled) {
            this.inputViewChild.nativeElement.checked = true;
            this.checked = true;
            this.onModelChange(this.value);
        }
    };
    RadioButton.prototype.writeValue = function (value) {
        this.checked = (value == this.value);
        if (this.inputViewChild.nativeElement) {
            this.inputViewChild.nativeElement.checked = this.checked;
        }
        this.cd.markForCheck();
    };
    RadioButton.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    RadioButton.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    RadioButton.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    RadioButton.prototype.onFocus = function (event) {
        this.focused = true;
    };
    RadioButton.prototype.onBlur = function (event) {
        this.focused = false;
        this.onModelTouched();
    };
    RadioButton.prototype.onChange = function (event) {
        this.select();
    };
    return RadioButton;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], RadioButton.prototype, "value", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], RadioButton.prototype, "name", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], RadioButton.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], RadioButton.prototype, "label", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], RadioButton.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], RadioButton.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], RadioButton.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], RadioButton.prototype, "styleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], RadioButton.prototype, "onClick", void 0);
__decorate([
    core_1.ViewChild('rb'),
    __metadata("design:type", core_1.ElementRef)
], RadioButton.prototype, "inputViewChild", void 0);
RadioButton = __decorate([
    core_1.Component({
        selector: 'p-radioButton',
        template: "\n        <div [ngStyle]=\"style\" [ngClass]=\"'ui-radiobutton ui-widget'\" [class]=\"styleClass\">\n            <div class=\"ui-helper-hidden-accessible\">\n                <input #rb type=\"radio\" [attr.id]=\"inputId\" [attr.name]=\"name\" [attr.value]=\"value\" [attr.tabindex]=\"tabindex\" \n                    [checked]=\"checked\" (change)=\"onChange($event)\" (focus)=\"onFocus($event)\" (blur)=\"onBlur($event)\">\n            </div>\n            <div (click)=\"handleClick()\"\n                [ngClass]=\"{'ui-radiobutton-box ui-widget ui-state-default':true,\n                'ui-state-active':rb.checked,'ui-state-disabled':disabled,'ui-state-focus':focused}\">\n                <span class=\"ui-radiobutton-icon ui-clickable\" [ngClass]=\"{'fa fa-circle':rb.checked}\"></span>\n            </div>\n        </div>\n        <label class=\"ui-radiobutton-label\" (click)=\"select()\" *ngIf=\"label\">{{label}}</label>\n    ",
        providers: [exports.RADIO_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ChangeDetectorRef])
], RadioButton);
exports.RadioButton = RadioButton;
var RadioButtonModule = (function () {
    function RadioButtonModule() {
    }
    return RadioButtonModule;
}());
RadioButtonModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [RadioButton],
        declarations: [RadioButton]
    })
], RadioButtonModule);
exports.RadioButtonModule = RadioButtonModule;
//# sourceMappingURL=radiobutton.js.map

/***/ }),

/***/ "./node_modules/primeng/components/rating/rating.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var forms_1 = __webpack_require__(4);
exports.RATING_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Rating; }),
    multi: true
};
var Rating = (function () {
    function Rating() {
        this.stars = 5;
        this.cancel = true;
        this.onRate = new core_1.EventEmitter();
        this.onCancel = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    Rating.prototype.ngOnInit = function () {
        this.starsArray = [];
        for (var i = 0; i < this.stars; i++) {
            this.starsArray[i] = i;
        }
    };
    Rating.prototype.rate = function (event, i) {
        if (!this.readonly && !this.disabled) {
            this.value = (i + 1);
            this.onModelChange(this.value);
            this.onModelTouched();
            this.onRate.emit({
                originalEvent: event,
                value: (i + 1)
            });
        }
        event.preventDefault();
    };
    Rating.prototype.clear = function (event) {
        if (!this.readonly && !this.disabled) {
            this.value = null;
            this.onModelChange(this.value);
            this.onModelTouched();
            this.onCancel.emit(event);
        }
        event.preventDefault();
    };
    Rating.prototype.writeValue = function (value) {
        this.value = value;
    };
    Rating.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Rating.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Rating.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    return Rating;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Rating.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Rating.prototype, "readonly", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Rating.prototype, "stars", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Rating.prototype, "cancel", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Rating.prototype, "onRate", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Rating.prototype, "onCancel", void 0);
Rating = __decorate([
    core_1.Component({
        selector: 'p-rating',
        template: "\n        <div class=\"ui-rating\" [ngClass]=\"{'ui-state-disabled': disabled}\">\n            <a href=\"#\" *ngIf=\"cancel\" (click)=\"clear($event)\">\n                <span class=\"fa fa-ban\"></span>\n            </a>\n            <a href=\"#\" *ngFor=\"let star of starsArray;let i=index\" (click)=\"rate($event,i)\">\n                <span class=\"fa\" [ngClass]=\"{'fa-star-o': (!value || i >= value), 'fa-star':(i < value)}\"></span>\n            </a>\n        </div>\n    ",
        providers: [exports.RATING_VALUE_ACCESSOR]
    })
], Rating);
exports.Rating = Rating;
var RatingModule = (function () {
    function RatingModule() {
    }
    return RatingModule;
}());
RatingModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Rating],
        declarations: [Rating]
    })
], RatingModule);
exports.RatingModule = RatingModule;
//# sourceMappingURL=rating.js.map

/***/ }),

/***/ "./node_modules/primeng/components/schedule/schedule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery) {
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var Schedule = (function () {
    function Schedule(el, differs) {
        this.el = el;
        this.aspectRatio = 1.35;
        this.defaultView = 'month';
        this.allDaySlot = true;
        this.allDayText = 'all-day';
        this.slotDuration = '00:30:00';
        this.scrollTime = '06:00:00';
        this.minTime = '00:00:00';
        this.maxTime = '24:00:00';
        this.slotEventOverlap = true;
        this.dragRevertDuration = 500;
        this.dragOpacity = .75;
        this.dragScroll = true;
        this.timezone = false;
        this.timeFormat = null;
        this.onDayClick = new core_1.EventEmitter();
        this.onDrop = new core_1.EventEmitter();
        this.onEventClick = new core_1.EventEmitter();
        this.onEventMouseover = new core_1.EventEmitter();
        this.onEventMouseout = new core_1.EventEmitter();
        this.onEventDragStart = new core_1.EventEmitter();
        this.onEventDragStop = new core_1.EventEmitter();
        this.onEventDrop = new core_1.EventEmitter();
        this.onEventResizeStart = new core_1.EventEmitter();
        this.onEventResizeStop = new core_1.EventEmitter();
        this.onEventResize = new core_1.EventEmitter();
        this.onViewRender = new core_1.EventEmitter();
        this.onViewDestroy = new core_1.EventEmitter();
        this.differ = differs.find([]).create(null);
        this.initialized = false;
    }
    Schedule.prototype.ngOnInit = function () {
        var _this = this;
        this.config = {
            theme: true,
            header: this.header,
            isRTL: this.rtl,
            weekends: this.weekends,
            hiddenDays: this.hiddenDays,
            fixedWeekCount: this.fixedWeekCount,
            weekNumbers: this.weekNumbers,
            businessHours: this.businessHours,
            height: this.height,
            contentHeight: this.contentHeight,
            aspectRatio: this.aspectRatio,
            eventLimit: this.eventLimit,
            defaultDate: this.defaultDate,
            locale: this.locale,
            timezone: this.timezone,
            timeFormat: this.timeFormat,
            editable: this.editable,
            droppable: this.droppable,
            eventStartEditable: this.eventStartEditable,
            eventDurationEditable: this.eventDurationEditable,
            defaultView: this.defaultView,
            allDaySlot: this.allDaySlot,
            allDayText: this.allDayText,
            slotDuration: this.slotDuration,
            slotLabelInterval: this.slotLabelInterval,
            snapDuration: this.snapDuration,
            scrollTime: this.scrollTime,
            minTime: this.minTime,
            maxTime: this.maxTime,
            slotEventOverlap: this.slotEventOverlap,
            nowIndicator: this.nowIndicator,
            dragRevertDuration: this.dragRevertDuration,
            dragOpacity: this.dragOpacity,
            dragScroll: this.dragScroll,
            eventOverlap: this.eventOverlap,
            eventConstraint: this.eventConstraint,
            eventRender: this.eventRender,
            dayRender: this.dayRender,
            dayClick: function (date, jsEvent, view) {
                _this.onDayClick.emit({
                    'date': date,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            drop: function (date, jsEvent, ui, resourceId) {
                _this.onDrop.emit({
                    'date': date,
                    'jsEvent': jsEvent,
                    'ui': ui,
                    'resourceId': resourceId
                });
            },
            eventClick: function (calEvent, jsEvent, view) {
                _this.onEventClick.emit({
                    'calEvent': calEvent,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            eventMouseover: function (calEvent, jsEvent, view) {
                _this.onEventMouseover.emit({
                    'calEvent': calEvent,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            eventMouseout: function (calEvent, jsEvent, view) {
                _this.onEventMouseout.emit({
                    'calEvent': calEvent,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            eventDragStart: function (event, jsEvent, ui, view) {
                _this.onEventDragStart.emit({
                    'event': event,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            eventDragStop: function (event, jsEvent, ui, view) {
                _this.onEventDragStop.emit({
                    'event': event,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            eventDrop: function (event, delta, revertFunc, jsEvent, ui, view) {
                _this.updateEvent(event);
                _this.onEventDrop.emit({
                    'event': event,
                    'delta': delta,
                    'revertFunc': revertFunc,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            eventResizeStart: function (event, jsEvent, ui, view) {
                _this.onEventResizeStart.emit({
                    'event': event,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            eventResizeStop: function (event, jsEvent, ui, view) {
                _this.onEventResizeStop.emit({
                    'event': event,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            eventResize: function (event, delta, revertFunc, jsEvent, ui, view) {
                _this.updateEvent(event);
                _this.onEventResize.emit({
                    'event': event,
                    'delta': delta,
                    'revertFunc': revertFunc,
                    'jsEvent': jsEvent,
                    'view': view
                });
            },
            viewRender: function (view, element) {
                _this.onViewRender.emit({
                    'view': view,
                    'element': element
                });
            },
            viewDestroy: function (view, element) {
                _this.onViewDestroy.emit({
                    'view': view,
                    'element': element
                });
            }
        };
        if (this.options) {
            for (var prop in this.options) {
                this.config[prop] = this.options[prop];
            }
        }
    };
    Schedule.prototype.ngAfterViewChecked = function () {
        if (!this.initialized && this.el.nativeElement.offsetParent) {
            this.initialize();
        }
    };
    Schedule.prototype.ngOnChanges = function (changes) {
        if (this.schedule) {
            var options = {};
            for (var change in changes) {
                if (change !== 'events') {
                    options[change] = changes[change].currentValue;
                }
            }
            if (Object.keys(options).length) {
                this.schedule.fullCalendar('option', options);
            }
        }
    };
    Schedule.prototype.initialize = function () {
        this.schedule = jQuery(this.el.nativeElement.children[0]);
        this.schedule.fullCalendar(this.config);
        this.schedule.fullCalendar('addEventSource', this.events);
        this.initialized = true;
    };
    Schedule.prototype.ngDoCheck = function () {
        var changes = this.differ.diff(this.events);
        if (this.schedule && changes) {
            this.schedule.fullCalendar('removeEventSources');
            this.schedule.fullCalendar('addEventSource', this.events);
        }
    };
    Schedule.prototype.ngOnDestroy = function () {
        jQuery(this.el.nativeElement.children[0]).fullCalendar('destroy');
        this.initialized = false;
        this.schedule = null;
    };
    Schedule.prototype.gotoDate = function (date) {
        this.schedule.fullCalendar('gotoDate', date);
    };
    Schedule.prototype.prev = function () {
        this.schedule.fullCalendar('prev');
    };
    Schedule.prototype.next = function () {
        this.schedule.fullCalendar('next');
    };
    Schedule.prototype.prevYear = function () {
        this.schedule.fullCalendar('prevYear');
    };
    Schedule.prototype.nextYear = function () {
        this.schedule.fullCalendar('nextYear');
    };
    Schedule.prototype.today = function () {
        this.schedule.fullCalendar('today');
    };
    Schedule.prototype.incrementDate = function (duration) {
        this.schedule.fullCalendar('incrementDate', duration);
    };
    Schedule.prototype.changeView = function (viewName) {
        this.schedule.fullCalendar('changeView', viewName);
    };
    Schedule.prototype.getDate = function () {
        return this.schedule.fullCalendar('getDate');
    };
    Schedule.prototype.findEvent = function (id) {
        var event;
        if (this.events) {
            for (var _i = 0, _a = this.events; _i < _a.length; _i++) {
                var e = _a[_i];
                if (e.id === id) {
                    event = e;
                    break;
                }
            }
        }
        return event;
    };
    Schedule.prototype.updateEvent = function (event) {
        var sourceEvent = this.findEvent(event.id);
        if (sourceEvent) {
            sourceEvent.start = event.start.format();
            if (event.end) {
                sourceEvent.end = event.end.format();
            }
        }
    };
    return Schedule;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Schedule.prototype, "events", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "header", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Schedule.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "rtl", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "weekends", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Schedule.prototype, "hiddenDays", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "fixedWeekCount", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "weekNumbers", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "businessHours", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "height", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "contentHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Schedule.prototype, "aspectRatio", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "eventLimit", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "defaultDate", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "editable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "droppable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "eventStartEditable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "eventDurationEditable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Schedule.prototype, "defaultView", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "allDaySlot", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Schedule.prototype, "allDayText", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "slotDuration", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "slotLabelInterval", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "snapDuration", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "scrollTime", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "minTime", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "maxTime", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "slotEventOverlap", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "nowIndicator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Schedule.prototype, "dragRevertDuration", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Schedule.prototype, "dragOpacity", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Schedule.prototype, "dragScroll", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "eventOverlap", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "eventConstraint", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Schedule.prototype, "locale", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "timezone", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Schedule.prototype, "timeFormat", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Function)
], Schedule.prototype, "eventRender", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Function)
], Schedule.prototype, "dayRender", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Schedule.prototype, "options", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onDayClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onDrop", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventMouseover", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventMouseout", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventDragStart", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventDragStop", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventDrop", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventResizeStart", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventResizeStop", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onEventResize", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onViewRender", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Schedule.prototype, "onViewDestroy", void 0);
Schedule = __decorate([
    core_1.Component({
        selector: 'p-schedule',
        template: '<div [ngStyle]="style" [class]="styleClass"></div>'
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, core_1.IterableDiffers])
], Schedule);
exports.Schedule = Schedule;
var ScheduleModule = (function () {
    function ScheduleModule() {
    }
    return ScheduleModule;
}());
ScheduleModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Schedule],
        declarations: [Schedule]
    })
], ScheduleModule);
exports.ScheduleModule = ScheduleModule;
//# sourceMappingURL=schedule.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),

/***/ "./node_modules/primeng/components/selectbutton/selectbutton.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var forms_1 = __webpack_require__(4);
exports.SELECTBUTTON_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return SelectButton; }),
    multi: true
};
var SelectButton = (function () {
    function SelectButton() {
        this.onChange = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    SelectButton.prototype.writeValue = function (value) {
        this.value = value;
    };
    SelectButton.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    SelectButton.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    SelectButton.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    SelectButton.prototype.onItemClick = function (event, option, checkbox) {
        if (this.disabled) {
            return;
        }
        checkbox.focus();
        if (this.multiple) {
            var itemIndex_1 = this.findItemIndex(option);
            if (itemIndex_1 != -1)
                this.value = this.value.filter(function (val, i) { return i != itemIndex_1; });
            else
                this.value = (this.value || []).concat([option.value]);
        }
        else {
            this.value = option.value;
        }
        this.onModelChange(this.value);
        this.onChange.emit({
            originalEvent: event,
            value: this.value
        });
    };
    SelectButton.prototype.onFocus = function (event) {
        this.focusedItem = event.target;
    };
    SelectButton.prototype.onBlur = function (event) {
        this.focusedItem = null;
        this.onModelTouched();
    };
    SelectButton.prototype.isSelected = function (option) {
        if (this.multiple)
            return this.findItemIndex(option) != -1;
        else
            return option.value == this.value;
    };
    SelectButton.prototype.findItemIndex = function (option) {
        var index = -1;
        if (this.value) {
            for (var i = 0; i < this.value.length; i++) {
                if (this.value[i] == option.value) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    return SelectButton;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], SelectButton.prototype, "options", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], SelectButton.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], SelectButton.prototype, "multiple", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], SelectButton.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SelectButton.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], SelectButton.prototype, "disabled", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], SelectButton.prototype, "onChange", void 0);
SelectButton = __decorate([
    core_1.Component({
        selector: 'p-selectButton',
        template: "\n        <div [ngClass]=\"'ui-selectbutton ui-buttonset ui-widget ui-corner-all ui-buttonset-' + options.length\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div *ngFor=\"let option of options;\" class=\"ui-button ui-widget ui-state-default ui-button-text-only\"\n                [ngClass]=\"{'ui-state-active':isSelected(option), 'ui-state-disabled':disabled, 'ui-state-focus': cbox == focusedItem}\" (click)=\"onItemClick($event,option,cbox)\">\n                <span class=\"ui-button-text ui-clickable\">{{option.label}}</span>\n                <div class=\"ui-helper-hidden-accessible\">\n                    <input #cbox type=\"checkbox\" [checked]=\"isSelected(option)\" (focus)=\"onFocus($event)\" (blur)=\"onBlur($event)\" [attr.tabindex]=\"tabindex\" [attr.disabled]=\"disabled\">\n                </div>\n            </div>\n        </div>\n    ",
        providers: [exports.SELECTBUTTON_VALUE_ACCESSOR]
    })
], SelectButton);
exports.SelectButton = SelectButton;
var SelectButtonModule = (function () {
    function SelectButtonModule() {
    }
    return SelectButtonModule;
}());
SelectButtonModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [SelectButton],
        declarations: [SelectButton]
    })
], SelectButtonModule);
exports.SelectButtonModule = SelectButtonModule;
//# sourceMappingURL=selectbutton.js.map

/***/ }),

/***/ "./node_modules/primeng/components/slidemenu/slidemenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var router_1 = __webpack_require__(5);
var SlideMenuSub = (function () {
    function SlideMenuSub(slideMenu) {
        this.slideMenu = slideMenu;
        this.backLabel = 'Back';
        this.easing = 'ease-out';
    }
    SlideMenuSub.prototype.itemClick = function (event, item, listitem) {
        var _this = this;
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
        if (item.items && !this.slideMenu.animating) {
            this.slideMenu.left -= this.slideMenu.menuWidth;
            this.activeItem = listitem;
            this.slideMenu.animating = true;
            setTimeout(function () { return _this.slideMenu.animating = false; }, this.effectDuration);
        }
    };
    SlideMenuSub.prototype.ngOnDestroy = function () {
        this.activeItem = null;
    };
    return SlideMenuSub;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], SlideMenuSub.prototype, "item", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], SlideMenuSub.prototype, "root", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SlideMenuSub.prototype, "backLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SlideMenuSub.prototype, "menuWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], SlideMenuSub.prototype, "effectDuration", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SlideMenuSub.prototype, "easing", void 0);
SlideMenuSub = __decorate([
    core_1.Component({
        selector: 'p-slideMenuSub',
        template: "\n        <ul [ngClass]=\"{'ui-helper-reset ui-menu-rootlist':root, 'ui-widget-content ui-corner-all ui-helper-clearfix ui-menu-child':!root}\" class=\"ui-menu-list\"\n            [style.width.px]=\"menuWidth\" [style.left.px]=\"root ? slideMenu.left : slideMenu.menuWidth\" \n            [style.transitionProperty]=\"root ? 'left' : 'none'\" [style.transitionDuration]=\"effectDuration + 'ms'\" [style.transitionTimingFunction]=\"easing\">\n            <ng-template ngFor let-child [ngForOf]=\"(root ? item : item.items)\">\n                <li *ngIf=\"child.separator\" class=\"ui-menu-separator ui-widget-content\">\n                <li *ngIf=\"!child.separator\" #listitem [ngClass]=\"{'ui-menuitem ui-widget ui-corner-all':true,'ui-menu-parent':child.items,'ui-slidemenuitem-active':listitem==activeItem}\">\n                    <a *ngIf=\"!child.routerLink\" [href]=\"child.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"child.target\"\n                        [ngClass]=\"{'ui-menuitem-link-parent':child.items,'ui-state-disabled':child.disabled}\" \n                        (click)=\"itemClick($event, child, listitem)\">\n                        <span class=\"ui-submenu-icon fa fa-fw fa-caret-right\" *ngIf=\"child.items\"></span>\n                        <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"child.icon\" [ngClass]=\"child.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{child.label}}</span>\n                    </a>\n                    <a *ngIf=\"child.routerLink\" [routerLink]=\"child.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"child.routerLinkActiveOptions||{exact:false}\" [href]=\"child.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"child.target\"\n                        [ngClass]=\"{'ui-menuitem-link-parent':child.items,'ui-state-disabled':child.disabled}\" \n                        (click)=\"itemClick($event, child, listitem)\">\n                        <span class=\"ui-submenu-icon fa fa-fw fa-caret-right\" *ngIf=\"child.items\"></span>\n                        <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"child.icon\" [ngClass]=\"child.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{child.label}}</span>\n                    </a>\n                    <p-slideMenuSub class=\"ui-submenu\" [item]=\"child\" [menuWidth]=\"menuWidth\" *ngIf=\"child.items\"></p-slideMenuSub>\n                </li>\n            </ng-template>\n        </ul>\n    "
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return SlideMenu; }))),
    __metadata("design:paramtypes", [SlideMenu])
], SlideMenuSub);
exports.SlideMenuSub = SlideMenuSub;
var SlideMenu = (function () {
    function SlideMenu(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.menuWidth = 190;
        this.viewportHeight = 175;
        this.effectDuration = 250;
        this.easing = 'ease-out';
        this.backLabel = 'Back';
        this.left = 0;
        this.animating = false;
    }
    SlideMenu.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.container = this.containerViewChild.nativeElement;
        this.backwardElement = this.backwardViewChild.nativeElement;
        this.slideMenuContentElement = this.slideMenuContentViewChild.nativeElement;
        this.slideMenuContentElement.style.height = this.viewportHeight - this.domHandler.getHiddenElementOuterHeight(this.backwardElement) + 'px';
        if (this.popup) {
            this.documentClickListener = this.renderer.listen('document', 'click', function () {
                if (!_this.preventDocumentDefault) {
                    _this.hide();
                }
                _this.preventDocumentDefault = false;
            });
        }
    };
    SlideMenu.prototype.toggle = function (event) {
        if (this.container.offsetParent)
            this.hide();
        else
            this.show(event);
    };
    SlideMenu.prototype.show = function (event) {
        this.preventDocumentDefault = true;
        this.container.style.display = 'block';
        this.domHandler.absolutePosition(this.container, event.target);
        this.domHandler.fadeIn(this.container, 250);
    };
    SlideMenu.prototype.hide = function () {
        this.container.style.display = 'none';
    };
    SlideMenu.prototype.onClick = function (event) {
        this.preventDocumentDefault = true;
    };
    SlideMenu.prototype.goBack = function () {
        this.left += this.menuWidth;
    };
    SlideMenu.prototype.ngOnDestroy = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
    };
    return SlideMenu;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], SlideMenu.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], SlideMenu.prototype, "popup", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], SlideMenu.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SlideMenu.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], SlideMenu.prototype, "menuWidth", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], SlideMenu.prototype, "viewportHeight", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], SlideMenu.prototype, "effectDuration", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SlideMenu.prototype, "easing", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SlideMenu.prototype, "backLabel", void 0);
__decorate([
    core_1.ViewChild('container'),
    __metadata("design:type", core_1.ElementRef)
], SlideMenu.prototype, "containerViewChild", void 0);
__decorate([
    core_1.ViewChild('backward'),
    __metadata("design:type", core_1.ElementRef)
], SlideMenu.prototype, "backwardViewChild", void 0);
__decorate([
    core_1.ViewChild('slideMenuContent'),
    __metadata("design:type", core_1.ElementRef)
], SlideMenu.prototype, "slideMenuContentViewChild", void 0);
SlideMenu = __decorate([
    core_1.Component({
        selector: 'p-slideMenu',
        template: "\n        <div #container [ngClass]=\"{'ui-menu ui-slidemenu ui-widget ui-widget-content ui-corner-all':true,'ui-menu-dynamic ui-shadow':popup}\" \n            [class]=\"styleClass\" [ngStyle]=\"style\" (click)=\"onClick($event)\">\n            <div class=\"ui-slidemenu-wrapper\" [style.height.px]=\"viewportHeight\">\n                <div #slideMenuContent class=\"ui-slidemenu-content\">\n                    <p-slideMenuSub [item]=\"model\" root=\"root\" [menuWidth]=\"menuWidth\" [effectDuration]=\"effectDuration\" [easing]=\"easing\"></p-slideMenuSub>\n                </div>\n                <div #backward class=\"ui-slidemenu-backward ui-widget-header ui-corner-all\" [style.display]=\"left ? 'block' : 'none'\" (click)=\"goBack()\">\n                    <span class=\"fa fa-fw fa-caret-left\"></span><span>{{backLabel}}</span>\n                </div>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], SlideMenu);
exports.SlideMenu = SlideMenu;
var SlideMenuModule = (function () {
    function SlideMenuModule() {
    }
    return SlideMenuModule;
}());
SlideMenuModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [SlideMenu, router_1.RouterModule],
        declarations: [SlideMenu, SlideMenuSub]
    })
], SlideMenuModule);
exports.SlideMenuModule = SlideMenuModule;
//# sourceMappingURL=slidemenu.js.map

/***/ }),

/***/ "./node_modules/primeng/components/slider/slider.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var forms_1 = __webpack_require__(4);
exports.SLIDER_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Slider; }),
    multi: true
};
var Slider = (function () {
    function Slider(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.min = 0;
        this.max = 100;
        this.orientation = 'horizontal';
        this.onChange = new core_1.EventEmitter();
        this.onSlideEnd = new core_1.EventEmitter();
        this.handleValues = [];
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    Slider.prototype.onMouseDown = function (event, index) {
        if (this.disabled) {
            return;
        }
        this.dragging = true;
        this.updateDomData();
        this.sliderHandleClick = true;
        this.handleIndex = index;
        event.preventDefault();
    };
    Slider.prototype.onTouchStart = function (event, index) {
        var touchobj = event.changedTouches[0];
        this.startHandleValue = (this.range) ? this.handleValues[index] : this.handleValue;
        this.dragging = true;
        this.handleIndex = index;
        if (this.orientation === 'horizontal') {
            this.startx = parseInt(touchobj.clientX, 10);
            this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        }
        else {
            this.starty = parseInt(touchobj.clientY, 10);
            this.barHeight = this.el.nativeElement.children[0].offsetHeight;
        }
        event.preventDefault();
    };
    Slider.prototype.onTouchMove = function (event, index) {
        var touchobj = event.changedTouches[0], handleValue = 0;
        if (this.orientation === 'horizontal') {
            handleValue = Math.floor(((parseInt(touchobj.clientX, 10) - this.startx) * 100) / (this.barWidth)) + this.startHandleValue;
        }
        else {
            handleValue = Math.floor(((this.starty - parseInt(touchobj.clientY, 10)) * 100) / (this.barHeight)) + this.startHandleValue;
        }
        this.setValueFromHandle(event, handleValue);
        event.preventDefault();
    };
    Slider.prototype.onBarClick = function (event) {
        if (this.disabled) {
            return;
        }
        if (!this.sliderHandleClick) {
            this.updateDomData();
            this.handleChange(event);
        }
        this.sliderHandleClick = false;
    };
    Slider.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.disabled) {
            return;
        }
        this.dragListener = this.renderer.listen('document', 'mousemove', function (event) {
            if (_this.dragging) {
                _this.handleChange(event);
            }
        });
        this.mouseupListener = this.renderer.listen('document', 'mouseup', function (event) {
            if (_this.dragging) {
                _this.dragging = false;
                if (_this.range) {
                    _this.onSlideEnd.emit({ originalEvent: event, values: _this.values });
                }
                else {
                    _this.onSlideEnd.emit({ originalEvent: event, value: _this.value });
                }
            }
        });
    };
    Slider.prototype.handleChange = function (event) {
        var handleValue = this.calculateHandleValue(event);
        this.setValueFromHandle(event, handleValue);
    };
    Slider.prototype.setValueFromHandle = function (event, handleValue) {
        var newValue = this.getValueFromHandle(handleValue);
        if (this.range) {
            if (this.step) {
                this.handleStepChange(newValue, this.values[this.handleIndex]);
            }
            else {
                this.handleValues[this.handleIndex] = handleValue;
                this.updateValue(newValue, event);
            }
        }
        else {
            if (this.step) {
                this.handleStepChange(newValue, this.value);
            }
            else {
                this.handleValue = handleValue;
                this.updateValue(newValue, event);
            }
        }
    };
    Slider.prototype.handleStepChange = function (newValue, oldValue) {
        var diff = (newValue - oldValue);
        if (diff < 0 && (-1 * diff) >= this.step / 2) {
            newValue = oldValue - this.step;
            this.updateValue(newValue);
            this.updateHandleValue();
        }
        else if (diff > 0 && diff >= this.step / 2) {
            newValue = oldValue + this.step;
            this.updateValue(newValue);
            this.updateHandleValue();
        }
    };
    Slider.prototype.writeValue = function (value) {
        if (this.range)
            this.values = value || [0, 0];
        else
            this.value = value || 0;
        this.updateHandleValue();
    };
    Slider.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Slider.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Slider.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    Slider.prototype.updateDomData = function () {
        var rect = this.el.nativeElement.children[0].getBoundingClientRect();
        this.initX = rect.left + this.domHandler.getWindowScrollLeft();
        this.initY = rect.top + this.domHandler.getWindowScrollTop();
        this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        this.barHeight = this.el.nativeElement.children[0].offsetHeight;
    };
    Slider.prototype.calculateHandleValue = function (event) {
        if (this.orientation === 'horizontal')
            return Math.floor(((event.pageX - this.initX) * 100) / (this.barWidth));
        else
            return Math.floor((((this.initY + this.barHeight) - event.pageY) * 100) / (this.barHeight));
    };
    Slider.prototype.updateHandleValue = function () {
        if (this.range) {
            this.handleValues[0] = (this.values[0] < this.min ? 0 : this.values[0] - this.min) * 100 / (this.max - this.min);
            this.handleValues[1] = (this.values[1] > this.max ? 100 : this.values[1] - this.min) * 100 / (this.max - this.min);
        }
        else {
            if (this.value < this.min)
                this.handleValue = 0;
            else if (this.value > this.max)
                this.handleValue = 100;
            else
                this.handleValue = (this.value - this.min) * 100 / (this.max - this.min);
        }
    };
    Slider.prototype.updateValue = function (val, event) {
        if (this.range) {
            var value = val;
            if (this.handleIndex == 0) {
                if (value < this.min) {
                    value = this.min;
                    this.handleValues[0] = 0;
                }
                else if (value > this.values[1]) {
                    value = this.values[1];
                    this.handleValues[0] = this.handleValues[1];
                }
            }
            else {
                if (value > this.max) {
                    value = this.max;
                    this.handleValues[1] = 100;
                }
                else if (value < this.values[0]) {
                    value = this.values[0];
                    this.handleValues[1] = this.handleValues[0];
                }
            }
            this.values[this.handleIndex] = Math.floor(value);
            this.onModelChange(this.values);
            this.onChange.emit({ event: event, values: this.values });
        }
        else {
            if (val < this.min) {
                val = this.min;
                this.handleValue = 0;
            }
            else if (val > this.max) {
                val = this.max;
                this.handleValue = 100;
            }
            this.value = Math.floor(val);
            this.onModelChange(this.value);
            this.onChange.emit({ event: event, value: this.value });
        }
    };
    Slider.prototype.getValueFromHandle = function (handleValue) {
        return (this.max - this.min) * (handleValue / 100) + this.min;
    };
    Slider.prototype.ngOnDestroy = function () {
        if (this.dragListener) {
            this.dragListener();
        }
        if (this.mouseupListener) {
            this.mouseupListener();
        }
    };
    return Slider;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Slider.prototype, "animate", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Slider.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Slider.prototype, "min", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Slider.prototype, "max", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Slider.prototype, "orientation", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Slider.prototype, "step", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Slider.prototype, "range", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Slider.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Slider.prototype, "styleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Slider.prototype, "onChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Slider.prototype, "onSlideEnd", void 0);
Slider = __decorate([
    core_1.Component({
        selector: 'p-slider',
        template: "\n        <div [ngStyle]=\"style\" [class]=\"styleClass\" [ngClass]=\"{'ui-slider ui-widget ui-widget-content ui-corner-all':true,'ui-state-disabled':disabled,\n            'ui-slider-horizontal':orientation == 'horizontal','ui-slider-vertical':orientation == 'vertical','ui-slider-animate':animate}\"\n            (click)=\"onBarClick($event)\">\n            <span *ngIf=\"range\" class=\"ui-slider-range ui-widget-header ui-corner-all\" [ngStyle]=\"{'left':handleValues[0] + '%',width: (handleValues[1] - handleValues[0] + '%')}\"></span>\n            <span *ngIf=\"orientation=='vertical'\" class=\"ui-slider-range ui-slider-range-min ui-widget-header ui-corner-all\" [ngStyle]=\"{'height': handleValue + '%'}\"></span>\n            <span *ngIf=\"!range\" class=\"ui-slider-handle ui-state-default ui-corner-all ui-clickable\" (mousedown)=\"onMouseDown($event)\" (touchstart)=\"onTouchStart($event)\" (touchmove)=\"onTouchMove($event)\" (touchend)=\"dragging=false\"\n                [style.transition]=\"dragging ? 'none': null\" [ngStyle]=\"{'left': orientation == 'horizontal' ? handleValue + '%' : null,'bottom': orientation == 'vertical' ? handleValue + '%' : null}\"></span>\n            <span *ngIf=\"range\" (mousedown)=\"onMouseDown($event,0)\" (touchstart)=\"onTouchStart($event,0)\" (touchmove)=\"onTouchMove($event,0)\" (touchend)=\"dragging=false\" [style.transition]=\"dragging ? 'none': null\" class=\"ui-slider-handle ui-state-default ui-corner-all ui-clickable\" \n                [ngStyle]=\"{'left':handleValues[0] + '%'}\" [ngClass]=\"{'ui-slider-handle-active':handleIndex==0}\"></span>\n            <span *ngIf=\"range\" (mousedown)=\"onMouseDown($event,1)\" (touchstart)=\"onTouchStart($event,1)\" (touchmove)=\"onTouchMove($event,1)\" (touchend)=\"dragging=false\" [style.transition]=\"dragging ? 'none': null\" class=\"ui-slider-handle ui-state-default ui-corner-all ui-clickable\" \n                [ngStyle]=\"{'left':handleValues[1] + '%'}\" [ngClass]=\"{'ui-slider-handle-active':handleIndex==1}\"></span>\n        </div>\n    ",
        providers: [exports.SLIDER_VALUE_ACCESSOR, domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], Slider);
exports.Slider = Slider;
var SliderModule = (function () {
    function SliderModule() {
    }
    return SliderModule;
}());
SliderModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Slider],
        declarations: [Slider]
    })
], SliderModule);
exports.SliderModule = SliderModule;
//# sourceMappingURL=slider.js.map

/***/ }),

/***/ "./node_modules/primeng/components/spinner/spinner.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var inputtext_1 = __webpack_require__("./node_modules/primeng/components/inputtext/inputtext.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var forms_1 = __webpack_require__(4);
exports.SPINNER_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return Spinner; }),
    multi: true
};
var Spinner = (function () {
    function Spinner(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.onChange = new core_1.EventEmitter();
        this.onBlur = new core_1.EventEmitter();
        this.step = 1;
        this.decimalSeparator = '.';
        this.thousandSeparator = ',';
        this.formatInput = true;
        this.type = 'text';
        this.valueAsString = '';
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
        this.keyPattern = /[0-9\+\-]/;
    }
    Spinner.prototype.ngOnInit = function () {
        if (Math.floor(this.step) === 0) {
            this.precision = this.step.toString().split(/[,]|[.]/)[1].length;
        }
    };
    Spinner.prototype.repeat = function (interval, dir) {
        var _this = this;
        var i = interval || 500;
        this.clearTimer();
        this.timer = setTimeout(function () {
            _this.repeat(40, dir);
        }, i);
        this.spin(dir);
    };
    Spinner.prototype.spin = function (dir) {
        var step = this.step * dir;
        var currentValue = this.value || 0;
        var newValue = null;
        if (this.precision)
            this.value = parseFloat(this.toFixed(currentValue + step, this.precision));
        else
            this.value = currentValue + step;
        if (this.maxlength !== undefined && this.value.toString().length > this.maxlength) {
            this.value = currentValue;
        }
        if (this.min !== undefined && this.value < this.min) {
            this.value = this.min;
        }
        if (this.max !== undefined && this.value > this.max) {
            this.value = this.max;
        }
        this.formatValue();
        this.onModelChange(this.value);
        this.onChange.emit();
    };
    Spinner.prototype.toFixed = function (value, precision) {
        var power = Math.pow(10, precision || 0);
        return String(Math.round(value * power) / power);
    };
    Spinner.prototype.onUpButtonMousedown = function (event, input) {
        if (!this.disabled) {
            input.focus();
            this.repeat(null, 1);
            this.updateFilledState();
        }
    };
    Spinner.prototype.onUpButtonMouseup = function (event) {
        if (!this.disabled) {
            this.clearTimer();
        }
    };
    Spinner.prototype.onUpButtonMouseleave = function (event) {
        if (!this.disabled) {
            this.clearTimer();
        }
    };
    Spinner.prototype.onDownButtonMousedown = function (event, input) {
        if (!this.disabled) {
            input.focus();
            this.repeat(null, -1);
            this.updateFilledState();
        }
    };
    Spinner.prototype.onDownButtonMouseup = function (event) {
        if (!this.disabled) {
            this.clearTimer();
        }
    };
    Spinner.prototype.onDownButtonMouseleave = function (event) {
        if (!this.disabled) {
            this.clearTimer();
        }
    };
    Spinner.prototype.onInputKeydown = function (event) {
        if (event.which == 38) {
            this.spin(1);
            event.preventDefault();
        }
        else if (event.which == 40) {
            this.spin(-1);
            event.preventDefault();
        }
    };
    Spinner.prototype.onInputKeyPress = function (event) {
        var inputChar = String.fromCharCode(event.charCode);
        if (!this.keyPattern.test(inputChar) && inputChar != this.decimalSeparator && event.keyCode != 9 && event.keyCode != 8 && event.keyCode != 37 && event.keyCode != 39 && event.keyCode != 46) {
            event.preventDefault();
        }
    };
    Spinner.prototype.onInput = function (event, inputValue) {
        this.value = this.parseValue(inputValue);
        this.formatValue();
        this.onModelChange(this.value);
        this.updateFilledState();
    };
    Spinner.prototype.onInputBlur = function (event) {
        this.focus = false;
        this.onModelTouched();
        this.onBlur.emit(event);
    };
    Spinner.prototype.onFocus = function () {
        this.focus = true;
    };
    Spinner.prototype.parseValue = function (val) {
        var value;
        if (this.formatInput) {
            val = val.split(this.thousandSeparator).join('');
        }
        if (val.trim() === '') {
            value = null;
        }
        else {
            if (this.precision) {
                value = parseFloat(val.replace(',', '.'));
            }
            else {
                value = parseInt(val);
            }
            if (!isNaN(value)) {
                if (this.max !== undefined && value > this.max) {
                    value = this.max;
                }
                if (this.min !== undefined && value < this.min) {
                    value = this.min;
                }
            }
            else {
                value = null;
            }
        }
        return value;
    };
    Spinner.prototype.formatValue = function () {
        if (this.value !== null && this.value !== undefined) {
            var textValue = String(this.value).replace('.', this.decimalSeparator);
            if (this.formatInput) {
                textValue = textValue.replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandSeparator);
            }
            this.valueAsString = textValue;
        }
        else {
            this.valueAsString = '';
        }
    };
    Spinner.prototype.handleChange = function (event) {
        this.onChange.emit(event);
    };
    Spinner.prototype.clearTimer = function () {
        if (this.timer) {
            clearInterval(this.timer);
        }
    };
    Spinner.prototype.writeValue = function (value) {
        this.value = value;
        this.formatValue();
        this.updateFilledState();
    };
    Spinner.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    Spinner.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    Spinner.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    Spinner.prototype.updateFilledState = function () {
        this.filled = (this.value !== undefined && this.value != null);
    };
    return Spinner;
}());
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Spinner.prototype, "onChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Spinner.prototype, "onBlur", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Spinner.prototype, "step", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Spinner.prototype, "min", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Spinner.prototype, "max", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Spinner.prototype, "maxlength", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Spinner.prototype, "size", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Spinner.prototype, "placeholder", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Spinner.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Spinner.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Spinner.prototype, "readonly", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Spinner.prototype, "decimalSeparator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Spinner.prototype, "thousandSeparator", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Spinner.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Spinner.prototype, "formatInput", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Spinner.prototype, "type", void 0);
Spinner = __decorate([
    core_1.Component({
        selector: 'p-spinner',
        template: "\n        <span class=\"ui-spinner ui-widget ui-corner-all\">\n            <input #in [attr.type]=\"type\" [attr.id]=\"inputId\" class=\"ui-spinner-input\" [value]=\"valueAsString\" class=\"ui-inputtext ui-widget ui-state-default ui-corner-all\"\n            [attr.size]=\"size\" [attr.maxlength]=\"maxlength\" [attr.tabindex]=\"tabindex\" [attr.placeholder]=\"placeholder\" [disabled]=\"disabled\" [readonly]=\"readonly\"\n            (keydown)=\"onInputKeydown($event)\" (keyup)=\"onInput($event,in.value)\" (keypress)=\"onInputKeyPress($event)\" (blur)=\"onInputBlur($event)\" (change)=\"handleChange($event)\" (focus)=\"onFocus()\">\n            <button type=\"button\" [ngClass]=\"{'ui-spinner-button ui-spinner-up ui-corner-tr ui-button ui-widget ui-state-default':true,'ui-state-disabled':disabled}\" [disabled]=\"disabled\"\n                (mouseleave)=\"onUpButtonMouseleave($event)\" (mousedown)=\"onUpButtonMousedown($event,in)\" (mouseup)=\"onUpButtonMouseup($event)\">\n                <span class=\"fa fa-caret-up ui-clickable\"></span>\n            </button>\n            <button type=\"button\" [ngClass]=\"{'ui-spinner-button ui-spinner-down ui-corner-br ui-button ui-widget ui-state-default':true,'ui-state-disabled':disabled}\" [disabled]=\"disabled\"\n                (mouseleave)=\"onDownButtonMouseleave($event)\" (mousedown)=\"onDownButtonMousedown($event,in)\" (mouseup)=\"onDownButtonMouseup($event)\">\n                <span class=\"fa fa-caret-down ui-clickable\"></span>\n            </button>\n        </span>\n    ",
        host: {
            '[class.ui-inputwrapper-filled]': 'filled',
            '[class.ui-inputwrapper-focus]': 'focus'
        },
        providers: [domhandler_1.DomHandler, exports.SPINNER_VALUE_ACCESSOR],
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Spinner);
exports.Spinner = Spinner;
var SpinnerModule = (function () {
    function SpinnerModule() {
    }
    return SpinnerModule;
}());
SpinnerModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, inputtext_1.InputTextModule],
        exports: [Spinner],
        declarations: [Spinner]
    })
], SpinnerModule);
exports.SpinnerModule = SpinnerModule;
//# sourceMappingURL=spinner.js.map

/***/ }),

/***/ "./node_modules/primeng/components/splitbutton/splitbutton.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var animations_1 = __webpack_require__("./node_modules/@angular/animations/@angular/animations.es5.js");
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var button_1 = __webpack_require__("./node_modules/primeng/components/button/button.js");
var router_1 = __webpack_require__(5);
var router_2 = __webpack_require__(5);
var SplitButton = (function () {
    function SplitButton(el, domHandler, renderer, router, cd) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.router = router;
        this.cd = cd;
        this.iconPos = 'left';
        this.onClick = new core_1.EventEmitter();
        this.onDropdownClick = new core_1.EventEmitter();
        this.menuVisible = false;
    }
    SplitButton.prototype.ngAfterViewInit = function () {
        if (this.appendTo) {
            if (this.appendTo === 'body')
                document.body.appendChild(this.overlayViewChild.nativeElement);
            else
                this.domHandler.appendChild(this.overlayViewChild.nativeElement, this.appendTo);
        }
    };
    SplitButton.prototype.ngAfterViewChecked = function () {
        if (this.shown) {
            this.onShow();
            this.shown = false;
        }
    };
    SplitButton.prototype.onDefaultButtonClick = function (event) {
        this.onClick.emit(event);
    };
    SplitButton.prototype.itemClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
        this.menuVisible = false;
    };
    SplitButton.prototype.show = function () {
        this.shown = true;
        this.menuVisible = !this.menuVisible;
        this.alignPanel();
        this.overlayViewChild.nativeElement.style.zIndex = String(++domhandler_1.DomHandler.zindex);
    };
    SplitButton.prototype.onShow = function () {
        this.alignPanel();
        this.bindDocumentClickListener();
    };
    SplitButton.prototype.onDropdownButtonClick = function (event) {
        this.onDropdownClick.emit(event);
        this.dropdownClick = true;
        this.show();
    };
    SplitButton.prototype.alignPanel = function () {
        if (this.appendTo)
            this.domHandler.absolutePosition(this.overlayViewChild.nativeElement, this.buttonViewChild.nativeElement);
        else
            this.domHandler.relativePosition(this.overlayViewChild.nativeElement, this.buttonViewChild.nativeElement);
    };
    SplitButton.prototype.bindDocumentClickListener = function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'click', function () {
                if (_this.dropdownClick) {
                    _this.dropdownClick = false;
                }
                else {
                    _this.menuVisible = false;
                    _this.unbindDocumentClickListener();
                    _this.cd.markForCheck();
                }
            });
        }
    };
    SplitButton.prototype.unbindDocumentClickListener = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    SplitButton.prototype.ngOnDestroy = function () {
        this.unbindDocumentClickListener();
    };
    return SplitButton;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], SplitButton.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SplitButton.prototype, "icon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SplitButton.prototype, "iconPos", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SplitButton.prototype, "label", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], SplitButton.prototype, "onClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], SplitButton.prototype, "onDropdownClick", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], SplitButton.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SplitButton.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], SplitButton.prototype, "menuStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], SplitButton.prototype, "menuStyleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], SplitButton.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], SplitButton.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], SplitButton.prototype, "appendTo", void 0);
__decorate([
    core_1.ViewChild('defaultbtn'),
    __metadata("design:type", core_1.ElementRef)
], SplitButton.prototype, "buttonViewChild", void 0);
__decorate([
    core_1.ViewChild('overlay'),
    __metadata("design:type", core_1.ElementRef)
], SplitButton.prototype, "overlayViewChild", void 0);
SplitButton = __decorate([
    core_1.Component({
        selector: 'p-splitButton',
        template: "\n        <div #container [ngClass]=\"{'ui-splitbutton ui-buttonset ui-widget':true,'ui-state-disabled':disabled}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <button #defaultbtn type=\"button\" pButton [icon]=\"icon\" [iconPos]=\"iconPos\" [label]=\"label\" cornerStyleClass=\"ui-corner-left\" (click)=\"onDefaultButtonClick($event)\" [disabled]=\"disabled\" [attr.tabindex]=\"tabindex\">\n            </button><button type=\"button\" pButton class=\"ui-splitbutton-menubutton\" icon=\"fa-caret-down\" cornerStyleClass=\"ui-corner-right\" (click)=\"onDropdownButtonClick($event)\" [disabled]=\"disabled\"></button>\n            <div #overlay [ngClass]=\"'ui-menu ui-menu-dynamic ui-widget ui-widget-content ui-corner-all ui-helper-clearfix ui-shadow'\" [style.display]=\"menuVisible ? 'block' : 'none'\"\n                    [ngStyle]=\"menuStyle\" [class]=\"menuStyleClass\" [@overlayState]=\"menuVisible ? 'visible' : 'hidden'\">\n                <ul class=\"ui-menu-list ui-helper-reset\">\n                    <li class=\"ui-menuitem ui-widget ui-corner-all\" role=\"menuitem\" *ngFor=\"let item of model\">\n                        <a *ngIf=\"!item.routerLink\" [href]=\"item.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"item.target\"\n                            [ngClass]=\"{'ui-state-disabled':item.disabled}\" (click)=\"itemClick($event, item)\">\n                            <span [ngClass]=\"'ui-menuitem-icon fa fa-fw'\" [class]=\"item.icon\" *ngIf=\"item.icon\"></span>\n                            <span class=\"ui-menuitem-text\">{{item.label}}</span>\n                        </a>\n                        <a *ngIf=\"item.routerLink\" [routerLink]=\"item.routerLink\"\n                            class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"item.target\" [ngClass]=\"{'ui-state-disabled':item.disabled}\" (click)=\"itemClick($event, item)\">\n                            <span [ngClass]=\"'ui-menuitem-icon fa fa-fw'\" [class]=\"item.icon\" *ngIf=\"item.icon\"></span>\n                            <span class=\"ui-menuitem-text\">{{item.label}}</span>\n                        </a>\n                    </li>\n                </ul>\n            </div>\n        </div>\n    ",
        animations: [
            animations_1.trigger('overlayState', [
                animations_1.state('hidden', animations_1.style({
                    opacity: 0
                })),
                animations_1.state('visible', animations_1.style({
                    opacity: 1
                })),
                animations_1.transition('visible => hidden', animations_1.animate('400ms ease-in')),
                animations_1.transition('hidden => visible', animations_1.animate('400ms ease-out'))
            ])
        ],
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2, router_1.Router, core_1.ChangeDetectorRef])
], SplitButton);
exports.SplitButton = SplitButton;
var SplitButtonModule = (function () {
    function SplitButtonModule() {
    }
    return SplitButtonModule;
}());
SplitButtonModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, button_1.ButtonModule, router_2.RouterModule],
        exports: [SplitButton, button_1.ButtonModule, router_2.RouterModule],
        declarations: [SplitButton]
    })
], SplitButtonModule);
exports.SplitButtonModule = SplitButtonModule;
//# sourceMappingURL=splitbutton.js.map

/***/ }),

/***/ "./node_modules/primeng/components/steps/steps.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var router_1 = __webpack_require__(5);
var Steps = (function () {
    function Steps() {
        this.activeIndex = 0;
        this.readonly = true;
        this.activeIndexChange = new core_1.EventEmitter();
    }
    Steps.prototype.itemClick = function (event, item, i) {
        if (this.readonly || item.disabled) {
            event.preventDefault();
            return;
        }
        this.activeIndexChange.emit(i);
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item,
                index: i
            });
        }
    };
    return Steps;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Steps.prototype, "activeIndex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Steps.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Steps.prototype, "readonly", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Steps.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Steps.prototype, "styleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Steps.prototype, "activeIndexChange", void 0);
Steps = __decorate([
    core_1.Component({
        selector: 'p-steps',
        template: "\n        <div [ngClass]=\"{'ui-steps ui-widget ui-helper-clearfix':true,'ui-steps-readonly':readonly}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <ul role=\"tablist\">\n                <li *ngFor=\"let item of model; let i = index\" class=\"ui-steps-item\" #menuitem\n                    [ngClass]=\"{'ui-state-highlight':(i === activeIndex),'ui-state-default':(i !== activeIndex),\n                        'ui-state-disabled':item.disabled||(i !== activeIndex && readonly)}\">\n                    <a *ngIf=\"!item.routerLink\" [href]=\"item.url||'#'\" class=\"ui-menuitem-link\" (click)=\"itemClick($event, item, i)\" [attr.target]=\"item.target\">\n                        <span class=\"ui-steps-number\">{{i + 1}}</span>\n                        <span class=\"ui-steps-title\">{{item.label}}</span>\n                    </a>\n                    <a *ngIf=\"item.routerLink\" [routerLink]=\"item.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"item.routerLinkActiveOptions||{exact:false}\" class=\"ui-menuitem-link\" (click)=\"itemClick($event, item, i)\" [attr.target]=\"item.target\">\n                        <span class=\"ui-steps-number\">{{i + 1}}</span>\n                        <span class=\"ui-steps-title\">{{item.label}}</span>\n                    </a>\n                </li>\n            </ul>\n        </div>\n    "
    })
], Steps);
exports.Steps = Steps;
var StepsModule = (function () {
    function StepsModule() {
    }
    return StepsModule;
}());
StepsModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [Steps, router_1.RouterModule],
        declarations: [Steps]
    })
], StepsModule);
exports.StepsModule = StepsModule;
//# sourceMappingURL=steps.js.map

/***/ }),

/***/ "./node_modules/primeng/components/tabmenu/tabmenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var router_1 = __webpack_require__(5);
var TabMenu = (function () {
    function TabMenu() {
    }
    TabMenu.prototype.ngOnInit = function () {
        if (!this.activeItem && this.model && this.model.length) {
            this.activeItem = this.model[0];
        }
    };
    TabMenu.prototype.itemClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
        this.activeItem = item;
    };
    return TabMenu;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], TabMenu.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TabMenu.prototype, "activeItem", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TabMenu.prototype, "popup", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TabMenu.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TabMenu.prototype, "styleClass", void 0);
TabMenu = __decorate([
    core_1.Component({
        selector: 'p-tabMenu',
        template: "\n        <div [ngClass]=\"'ui-tabmenu ui-widget ui-widget-content ui-corner-all'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <ul class=\"ui-tabmenu-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\" role=\"tablist\">\n                <li *ngFor=\"let item of model\" \n                    [ngClass]=\"{'ui-tabmenuitem ui-state-default ui-corner-top':true,'ui-state-disabled':item.disabled,\n                        'ui-tabmenuitem-hasicon':item.icon,'ui-state-active':activeItem==item}\">\n                    <a *ngIf=\"!item.routerLink\" [href]=\"item.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" (click)=\"itemClick($event,item)\"\n                        [attr.target]=\"item.target\">\n                        <span class=\"ui-menuitem-icon fa\" [ngClass]=\"item.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{item.label}}</span>\n                    </a>\n                    <a *ngIf=\"item.routerLink\" [routerLink]=\"item.routerLink\" [routerLinkActive]=\"'ui-state-active'\"  [routerLinkActiveOptions]=\"item.routerLinkActiveOptions||{exact:false}\" class=\"ui-menuitem-link ui-corner-all\" (click)=\"itemClick($event,item)\"\n                        [attr.target]=\"item.target\">\n                        <span class=\"ui-menuitem-icon fa\" [ngClass]=\"item.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{item.label}}</span>\n                    </a>\n                </li>\n            </ul>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    })
], TabMenu);
exports.TabMenu = TabMenu;
var TabMenuModule = (function () {
    function TabMenuModule() {
    }
    return TabMenuModule;
}());
TabMenuModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [TabMenu, router_1.RouterModule],
        declarations: [TabMenu]
    })
], TabMenuModule);
exports.TabMenuModule = TabMenuModule;
//# sourceMappingURL=tabmenu.js.map

/***/ }),

/***/ "./node_modules/primeng/components/tabview/tabview.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var TabViewNav = (function () {
    function TabViewNav() {
        this.orientation = 'top';
        this.onTabClick = new core_1.EventEmitter();
        this.onTabCloseClick = new core_1.EventEmitter();
    }
    TabViewNav.prototype.getDefaultHeaderClass = function (tab) {
        var styleClass = 'ui-state-default ui-corner-' + this.orientation;
        if (tab.headerStyleClass) {
            styleClass = styleClass + " " + tab.headerStyleClass;
        }
        return styleClass;
    };
    TabViewNav.prototype.clickTab = function (event, tab) {
        this.onTabClick.emit({
            originalEvent: event,
            tab: tab
        });
    };
    TabViewNav.prototype.clickClose = function (event, tab) {
        this.onTabCloseClick.emit({
            originalEvent: event,
            tab: tab
        });
    };
    return TabViewNav;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], TabViewNav.prototype, "tabs", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TabViewNav.prototype, "orientation", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TabViewNav.prototype, "onTabClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TabViewNav.prototype, "onTabCloseClick", void 0);
TabViewNav = __decorate([
    core_1.Component({
        selector: '[p-tabViewNav]',
        host: {
            '[class.ui-tabview-nav]': 'true',
            '[class.ui-helper-reset]': 'true',
            '[class.ui-helper-clearfix]': 'true',
            '[class.ui-widget-header]': 'true',
            '[class.ui-corner-all]': 'true'
        },
        template: "\n        <ng-template ngFor let-tab [ngForOf]=\"tabs\">\n            <li [class]=\"getDefaultHeaderClass(tab)\" [ngStyle]=\"tab.headerStyle\" role=\"tab\"\n                [ngClass]=\"{'ui-tabview-selected ui-state-active': tab.selected, 'ui-state-disabled': tab.disabled}\"\n                (click)=\"clickTab($event,tab)\" *ngIf=\"!tab.closed\"\n                [attr.aria-expanded]=\"tab.selected\" [attr.aria-selected]=\"tab.selected\">\n                <a href=\"#\">\n                    <span class=\"ui-tabview-left-icon fa\" [ngClass]=\"tab.leftIcon\" *ngIf=\"tab.leftIcon\"></span>\n                    <span class=\"ui-tabview-title\">{{tab.header}}</span>\n                    <span class=\"ui-tabview-right-icon fa\" [ngClass]=\"tab.rightIcon\" *ngIf=\"tab.rightIcon\"></span>\n                </a>\n                <span *ngIf=\"tab.closable\" class=\"ui-tabview-close fa fa-close\" (click)=\"clickClose($event,tab)\"></span>\n            </li>\n        </ng-template>\n    ",
    })
], TabViewNav);
exports.TabViewNav = TabViewNav;
var TabPanel = (function () {
    function TabPanel() {
    }
    return TabPanel;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TabPanel.prototype, "header", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TabPanel.prototype, "selected", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TabPanel.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TabPanel.prototype, "closable", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TabPanel.prototype, "headerStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TabPanel.prototype, "headerStyleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TabPanel.prototype, "leftIcon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TabPanel.prototype, "rightIcon", void 0);
TabPanel = __decorate([
    core_1.Component({
        selector: 'p-tabPanel',
        template: "\n        <div class=\"ui-tabview-panel ui-widget-content\" [style.display]=\"selected ? 'block' : 'none'\" \n            role=\"tabpanel\" [attr.aria-hidden]=\"!selected\" *ngIf=\"closed ? false :\u00A0(lazy ? selected : true)\">\n            <ng-content></ng-content>\n        </div>\n    "
    })
], TabPanel);
exports.TabPanel = TabPanel;
var TabView = (function () {
    function TabView(el) {
        this.el = el;
        this.orientation = 'top';
        this.onChange = new core_1.EventEmitter();
        this.onClose = new core_1.EventEmitter();
    }
    TabView.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.initTabs();
        this.tabPanels.changes.subscribe(function (_) {
            _this.initTabs();
        });
    };
    TabView.prototype.initTabs = function () {
        this.tabs = this.tabPanels.toArray();
        for (var _i = 0, _a = this.tabs; _i < _a.length; _i++) {
            var tab = _a[_i];
            tab.lazy = this.lazy;
        }
        var selectedTab = this.findSelectedTab();
        if (!selectedTab && this.tabs.length) {
            if (this.activeIndex != null && this.tabs.length > this.activeIndex)
                this.tabs[this.activeIndex].selected = true;
            else
                this.tabs[0].selected = true;
        }
    };
    TabView.prototype.open = function (event, tab) {
        if (tab.disabled) {
            if (event) {
                event.preventDefault();
            }
            return;
        }
        if (!tab.selected) {
            var selectedTab = this.findSelectedTab();
            if (selectedTab) {
                selectedTab.selected = false;
            }
            tab.selected = true;
            this.onChange.emit({ originalEvent: event, index: this.findTabIndex(tab) });
        }
        if (event) {
            event.preventDefault();
        }
    };
    TabView.prototype.close = function (event, tab) {
        var _this = this;
        if (this.controlClose) {
            this.onClose.emit({
                originalEvent: event,
                index: this.findTabIndex(tab),
                close: function () {
                    _this.closeTab(tab);
                }
            });
        }
        else {
            this.closeTab(tab);
            this.onClose.emit({
                originalEvent: event,
                index: this.findTabIndex(tab)
            });
        }
        event.stopPropagation();
    };
    TabView.prototype.closeTab = function (tab) {
        if (tab.selected) {
            tab.selected = false;
            for (var i = 0; i < this.tabs.length; i++) {
                var tabPanel = this.tabs[i];
                if (!tabPanel.closed && !tab.disabled) {
                    tabPanel.selected = true;
                    break;
                }
            }
        }
        tab.closed = true;
    };
    TabView.prototype.findSelectedTab = function () {
        for (var i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].selected) {
                return this.tabs[i];
            }
        }
        return null;
    };
    TabView.prototype.findTabIndex = function (tab) {
        var index = -1;
        for (var i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i] == tab) {
                index = i;
                break;
            }
        }
        return index;
    };
    TabView.prototype.getBlockableElement = function () {
        return this.el.nativeElement.children[0];
    };
    Object.defineProperty(TabView.prototype, "activeIndex", {
        get: function () {
            return this._activeIndex;
        },
        set: function (val) {
            this._activeIndex = val;
            if (this.tabs && this.tabs.length && this._activeIndex != null && this.tabs.length > this._activeIndex) {
                this.findSelectedTab().selected = false;
                this.tabs[this._activeIndex].selected = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    return TabView;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TabView.prototype, "orientation", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TabView.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TabView.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TabView.prototype, "controlClose", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TabView.prototype, "lazy", void 0);
__decorate([
    core_1.ContentChildren(TabPanel),
    __metadata("design:type", core_1.QueryList)
], TabView.prototype, "tabPanels", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TabView.prototype, "onChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TabView.prototype, "onClose", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], TabView.prototype, "activeIndex", null);
TabView = __decorate([
    core_1.Component({
        selector: 'p-tabView',
        template: "\n        <div [ngClass]=\"'ui-tabview ui-widget ui-widget-content ui-corner-all ui-tabview-' + orientation\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <ul p-tabViewNav role=\"tablist\" *ngIf=\"orientation!='bottom'\" [tabs]=\"tabs\" [orientation]=\"orientation\" \n                (onTabClick)=\"open($event.originalEvent, $event.tab)\" (onTabCloseClick)=\"close($event.originalEvent, $event.tab)\"></ul>\n            <div class=\"ui-tabview-panels\">\n                <ng-content></ng-content>\n            </div>\n            <ul p-tabViewNav role=\"tablist\" *ngIf=\"orientation=='bottom'\" [tabs]=\"tabs\" [orientation]=\"orientation\"\n                (onTabClick)=\"open($event.originalEvent, $event.tab)\" (onTabCloseClick)=\"close($event.originalEvent, $event.tab)\"></ul>\n        </div>\n    ",
    }),
    __metadata("design:paramtypes", [core_1.ElementRef])
], TabView);
exports.TabView = TabView;
var TabViewModule = (function () {
    function TabViewModule() {
    }
    return TabViewModule;
}());
TabViewModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [TabView, TabPanel, TabViewNav],
        declarations: [TabView, TabPanel, TabViewNav]
    })
], TabViewModule);
exports.TabViewModule = TabViewModule;
//# sourceMappingURL=tabview.js.map

/***/ }),

/***/ "./node_modules/primeng/components/terminal/terminal.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var forms_1 = __webpack_require__(4);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var Terminal = (function () {
    function Terminal(el, domHandler) {
        this.el = el;
        this.domHandler = domHandler;
        this.responseChange = new core_1.EventEmitter();
        this.handler = new core_1.EventEmitter();
        this.commands = [];
    }
    Terminal.prototype.ngAfterViewInit = function () {
        this.container = this.domHandler.find(this.el.nativeElement, '.ui-terminal')[0];
    };
    Terminal.prototype.ngAfterViewChecked = function () {
        if (this.commandProcessed) {
            this.container.scrollTop = this.container.scrollHeight;
            this.commandProcessed = false;
        }
    };
    Object.defineProperty(Terminal.prototype, "response", {
        set: function (value) {
            if (value) {
                this.commands[this.commands.length - 1].response = value;
                this.commandProcessed = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.handleCommand = function (event) {
        if (event.keyCode == 13) {
            this.commands.push({ text: this.command });
            this.handler.emit({ originalEvent: event, command: this.command });
            this.command = '';
        }
    };
    Terminal.prototype.focus = function (element) {
        element.focus();
    };
    return Terminal;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Terminal.prototype, "welcomeMessage", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Terminal.prototype, "prompt", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Terminal.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Terminal.prototype, "styleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Terminal.prototype, "responseChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Terminal.prototype, "handler", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], Terminal.prototype, "response", null);
Terminal = __decorate([
    core_1.Component({
        selector: 'p-terminal',
        template: "\n        <div [ngClass]=\"'ui-terminal ui-widget ui-widget-content ui-corner-all'\" [ngStyle]=\"style\" [class]=\"styleClass\" (click)=\"focus(in)\">\n            <div *ngIf=\"welcomeMessage\">{{welcomeMessage}}</div>\n            <div class=\"ui-terminal-content\">\n                <div *ngFor=\"let command of commands\">\n                    <span>{{prompt}}</span>\n                    <span class=\"ui-terminal-command\">{{command.text}}</span>\n                    <div>{{command.response}}</div>\n                </div>\n            </div>\n            <div>\n                <span class=\"ui-terminal-content-prompt\">{{prompt}}</span>\n                <input #in type=\"text\" [(ngModel)]=\"command\" class=\"ui-terminal-input\" autocomplete=\"off\" (keydown)=\"handleCommand($event)\" autofocus>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler])
], Terminal);
exports.Terminal = Terminal;
var TerminalModule = (function () {
    function TerminalModule() {
    }
    return TerminalModule;
}());
TerminalModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, forms_1.FormsModule],
        exports: [Terminal],
        declarations: [Terminal]
    })
], TerminalModule);
exports.TerminalModule = TerminalModule;
//# sourceMappingURL=terminal.js.map

/***/ }),

/***/ "./node_modules/primeng/components/tieredmenu/tieredmenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var router_1 = __webpack_require__(5);
var TieredMenuSub = (function () {
    function TieredMenuSub(domHandler) {
        this.domHandler = domHandler;
    }
    TieredMenuSub.prototype.onItemMouseEnter = function (event, item, menuitem) {
        if (menuitem.disabled) {
            return;
        }
        this.activeItem = item;
        var nextElement = item.children[0].nextElementSibling;
        if (nextElement) {
            var sublist = nextElement.children[0];
            sublist.style.zIndex = String(++domhandler_1.DomHandler.zindex);
            sublist.style.top = '0px';
            sublist.style.left = this.domHandler.getOuterWidth(item.children[0]) + 'px';
        }
    };
    TieredMenuSub.prototype.onItemMouseLeave = function (event) {
        this.activeItem = null;
    };
    TieredMenuSub.prototype.itemClick = function (event, item) {
        if (item.disabled) {
            event.preventDefault();
            return true;
        }
        if (!item.url) {
            event.preventDefault();
        }
        if (item.command) {
            item.command({
                originalEvent: event,
                item: item
            });
        }
    };
    TieredMenuSub.prototype.listClick = function (event) {
        this.activeItem = null;
    };
    return TieredMenuSub;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TieredMenuSub.prototype, "item", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TieredMenuSub.prototype, "root", void 0);
TieredMenuSub = __decorate([
    core_1.Component({
        selector: 'p-tieredMenuSub',
        template: "\n        <ul [ngClass]=\"{'ui-helper-reset':root, 'ui-widget-content ui-corner-all ui-helper-clearfix ui-menu-child ui-shadow':!root}\" class=\"ui-menu-list\"\n            (click)=\"listClick($event)\">\n            <ng-template ngFor let-child [ngForOf]=\"(root ? item : item.items)\">\n                <li *ngIf=\"child.separator\" class=\"ui-menu-separator ui-widget-content\">\n                <li *ngIf=\"!child.separator\" #listItem [ngClass]=\"{'ui-menuitem ui-widget ui-corner-all':true,'ui-menu-parent':child.items,'ui-menuitem-active':listItem==activeItem}\"\n                    (mouseenter)=\"onItemMouseEnter($event, listItem, child)\" (mouseleave)=\"onItemMouseLeave($event)\">\n                    <a *ngIf=\"!child.routerLink\" [href]=\"child.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"child.target\"\n                        [ngClass]=\"{'ui-state-disabled':child.disabled}\" (click)=\"itemClick($event, child)\">\n                        <span class=\"ui-submenu-icon fa fa-fw fa-caret-right\" *ngIf=\"child.items\"></span>\n                        <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"child.icon\" [ngClass]=\"child.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{child.label}}</span>\n                    </a>\n                    <a *ngIf=\"child.routerLink\" [routerLink]=\"child.routerLink\" [routerLinkActive]=\"'ui-state-active'\" [routerLinkActiveOptions]=\"child.routerLinkActiveOptions||{exact:false}\" [href]=\"child.url||'#'\" class=\"ui-menuitem-link ui-corner-all\" [attr.target]=\"child.target\"\n                        [ngClass]=\"{'ui-state-disabled':child.disabled}\" (click)=\"itemClick($event, child)\">\n                        <span class=\"ui-submenu-icon fa fa-fw fa-caret-right\" *ngIf=\"child.items\"></span>\n                        <span class=\"ui-menuitem-icon fa fa-fw\" *ngIf=\"child.icon\" [ngClass]=\"child.icon\"></span>\n                        <span class=\"ui-menuitem-text\">{{child.label}}</span>\n                    </a>\n                    <p-tieredMenuSub class=\"ui-submenu\" [item]=\"child\" *ngIf=\"child.items\"></p-tieredMenuSub>\n                </li>\n            </ng-template>\n        </ul>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [domhandler_1.DomHandler])
], TieredMenuSub);
exports.TieredMenuSub = TieredMenuSub;
var TieredMenu = (function () {
    function TieredMenu(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
    }
    TieredMenu.prototype.ngAfterViewInit = function () {
        this.container = this.el.nativeElement.children[0];
        if (this.popup) {
            if (this.appendTo) {
                if (this.appendTo === 'body')
                    document.body.appendChild(this.container);
                else
                    this.domHandler.appendChild(this.container, this.appendTo);
            }
        }
    };
    TieredMenu.prototype.toggle = function (event) {
        if (this.container.offsetParent)
            this.hide();
        else
            this.show(event);
    };
    TieredMenu.prototype.show = function (event) {
        this.preventDocumentDefault = true;
        this.container.style.display = 'block';
        this.domHandler.absolutePosition(this.container, event.currentTarget);
        this.domHandler.fadeIn(this.container, 250);
        this.bindDocumentClickListener();
    };
    TieredMenu.prototype.hide = function () {
        this.container.style.display = 'none';
        this.unbindDocumentClickListener();
    };
    TieredMenu.prototype.unbindDocumentClickListener = function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    TieredMenu.prototype.bindDocumentClickListener = function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'click', function () {
                if (!_this.preventDocumentDefault) {
                    _this.hide();
                }
                _this.preventDocumentDefault = false;
            });
        }
    };
    TieredMenu.prototype.ngOnDestroy = function () {
        if (this.popup && this.documentClickListener) {
            this.unbindDocumentClickListener();
            if (this.appendTo) {
                this.el.nativeElement.appendChild(this.container);
            }
        }
    };
    return TieredMenu;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], TieredMenu.prototype, "model", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TieredMenu.prototype, "popup", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TieredMenu.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TieredMenu.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TieredMenu.prototype, "appendTo", void 0);
TieredMenu = __decorate([
    core_1.Component({
        selector: 'p-tieredMenu',
        template: "\n        <div [ngClass]=\"{'ui-tieredmenu ui-menu ui-widget ui-widget-content ui-corner-all ui-helper-clearfix':true,'ui-menu-dynamic ui-shadow':popup}\" \n            [class]=\"styleClass\" [ngStyle]=\"style\">\n            <p-tieredMenuSub [item]=\"model\" root=\"root\"></p-tieredMenuSub>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], TieredMenu);
exports.TieredMenu = TieredMenu;
var TieredMenuModule = (function () {
    function TieredMenuModule() {
    }
    return TieredMenuModule;
}());
TieredMenuModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, router_1.RouterModule],
        exports: [TieredMenu, router_1.RouterModule],
        declarations: [TieredMenu, TieredMenuSub]
    })
], TieredMenuModule);
exports.TieredMenuModule = TieredMenuModule;
//# sourceMappingURL=tieredmenu.js.map

/***/ }),

/***/ "./node_modules/primeng/components/togglebutton/togglebutton.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var forms_1 = __webpack_require__(4);
exports.TOGGLEBUTTON_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return ToggleButton; }),
    multi: true
};
var ToggleButton = (function () {
    function ToggleButton() {
        this.onLabel = 'Yes';
        this.offLabel = 'No';
        this.onChange = new core_1.EventEmitter();
        this.checked = false;
        this.focus = false;
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    ToggleButton.prototype.ngAfterViewInit = function () {
        this.checkbox = this.checkboxViewChild.nativeElement;
    };
    ToggleButton.prototype.getIconClass = function () {
        var baseClass = 'ui-button-icon-left fa fa-fw';
        return baseClass + ' ' + (this.checked ? this.onIcon : this.offIcon);
    };
    ToggleButton.prototype.toggle = function (event) {
        if (!this.disabled) {
            this.checked = !this.checked;
            this.onModelChange(this.checked);
            this.onModelTouched();
            this.onChange.emit({
                originalEvent: event,
                checked: this.checked
            });
            this.checkbox.focus();
        }
    };
    ToggleButton.prototype.onFocus = function () {
        this.focus = true;
    };
    ToggleButton.prototype.onBlur = function () {
        this.focus = false;
        this.onModelTouched();
    };
    ToggleButton.prototype.writeValue = function (value) {
        this.checked = value;
    };
    ToggleButton.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    ToggleButton.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    ToggleButton.prototype.setDisabledState = function (val) {
        this.disabled = val;
    };
    Object.defineProperty(ToggleButton.prototype, "hasOnLabel", {
        get: function () {
            return this.onLabel && this.onLabel.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ToggleButton.prototype, "hasOffLabel", {
        get: function () {
            return this.onLabel && this.onLabel.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    return ToggleButton;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ToggleButton.prototype, "onLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ToggleButton.prototype, "offLabel", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ToggleButton.prototype, "onIcon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ToggleButton.prototype, "offIcon", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], ToggleButton.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], ToggleButton.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ToggleButton.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], ToggleButton.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], ToggleButton.prototype, "tabindex", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], ToggleButton.prototype, "onChange", void 0);
__decorate([
    core_1.ViewChild('checkbox'),
    __metadata("design:type", core_1.ElementRef)
], ToggleButton.prototype, "checkboxViewChild", void 0);
ToggleButton = __decorate([
    core_1.Component({
        selector: 'p-toggleButton',
        template: "\n        <div [ngClass]=\"{'ui-button ui-togglebutton ui-widget ui-state-default ui-corner-all': true, 'ui-button-text-only': (!onIcon&&!offIcon), \n                'ui-button-text-icon-left': (onIcon&&offIcon&&hasOnLabel&&hasOffLabel), 'ui-button-icon-only': (onIcon&&offIcon&&!hasOnLabel&&!hasOffLabel),\n                'ui-state-active': checked,'ui-state-focus':focus,'ui-state-disabled':disabled}\" [ngStyle]=\"style\" [class]=\"styleClass\" \n                (click)=\"toggle($event)\">\n            <div class=\"ui-helper-hidden-accessible\">\n                <input #checkbox type=\"checkbox\" [attr.id]=\"inputId\" [checked]=\"checked\" (focus)=\"onFocus()\" (blur)=\"onBlur()\" [attr.tabindex]=\"tabindex\">\n            </div>\n            <span *ngIf=\"onIcon||offIcon\" [class]=\"getIconClass()\"></span>\n            <span class=\"ui-button-text ui-unselectable-text\">{{checked ? hasOnLabel ? onLabel : 'ui-btn' : hasOffLabel ? offLabel : 'ui-btn'}}</span>\n        </div>\n    ",
        providers: [exports.TOGGLEBUTTON_VALUE_ACCESSOR]
    })
], ToggleButton);
exports.ToggleButton = ToggleButton;
var ToggleButtonModule = (function () {
    function ToggleButtonModule() {
    }
    return ToggleButtonModule;
}());
ToggleButtonModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [ToggleButton],
        declarations: [ToggleButton]
    })
], ToggleButtonModule);
exports.ToggleButtonModule = ToggleButtonModule;
//# sourceMappingURL=togglebutton.js.map

/***/ }),

/***/ "./node_modules/primeng/components/toolbar/toolbar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var Toolbar = (function () {
    function Toolbar() {
    }
    return Toolbar;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Toolbar.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Toolbar.prototype, "styleClass", void 0);
Toolbar = __decorate([
    core_1.Component({
        selector: 'p-toolbar',
        template: "\n        <div [ngClass]=\"'ui-toolbar ui-widget ui-widget-header ui-corner-all ui-helper-clearfix'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <ng-content></ng-content>\n        </div>\n    "
    })
], Toolbar);
exports.Toolbar = Toolbar;
var ToolbarModule = (function () {
    function ToolbarModule() {
    }
    return ToolbarModule;
}());
ToolbarModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Toolbar],
        declarations: [Toolbar]
    })
], ToolbarModule);
exports.ToolbarModule = ToolbarModule;
//# sourceMappingURL=toolbar.js.map

/***/ }),

/***/ "./node_modules/primeng/components/tooltip/tooltip.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var Tooltip = (function () {
    function Tooltip(el, domHandler, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.tooltipPosition = 'right';
        this.tooltipEvent = 'hover';
        this.appendTo = 'body';
        this.escape = true;
    }
    Tooltip.prototype.onMouseEnter = function (e) {
        if (this.tooltipEvent === 'hover') {
            this.activate();
        }
    };
    Tooltip.prototype.onMouseLeave = function (e) {
        if (this.tooltipEvent === 'hover') {
            this.deactivate();
        }
    };
    Tooltip.prototype.onFocus = function (e) {
        if (this.tooltipEvent === 'focus') {
            this.activate();
        }
    };
    Tooltip.prototype.onBlur = function (e) {
        if (this.tooltipEvent === 'focus') {
            this.deactivate();
        }
    };
    Tooltip.prototype.activate = function () {
        var _this = this;
        this.active = true;
        if (this.hideTimeout) {
            clearTimeout(this.hideTimeout);
        }
        if (this.showDelay)
            this.showTimeout = setTimeout(function () { _this.show(); }, this.showDelay);
        else
            this.show();
    };
    Tooltip.prototype.deactivate = function () {
        var _this = this;
        this.active = false;
        if (this.showTimeout) {
            clearTimeout(this.showTimeout);
        }
        if (this.hideDelay)
            this.hideTimeout = setTimeout(function () { _this.hide(); }, this.hideDelay);
        else
            this.hide();
    };
    Object.defineProperty(Tooltip.prototype, "text", {
        get: function () {
            return this._text;
        },
        set: function (text) {
            this._text = text;
            if (this.active) {
                if (this._text) {
                    if (this.container && this.container.offsetParent)
                        this.updateText();
                    else
                        this.show();
                }
                else {
                    this.hide();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Tooltip.prototype.create = function () {
        this.container = document.createElement('div');
        var tooltipArrow = document.createElement('div');
        tooltipArrow.className = 'ui-tooltip-arrow';
        this.container.appendChild(tooltipArrow);
        this.tooltipText = document.createElement('div');
        this.tooltipText.className = 'ui-tooltip-text ui-shadow ui-corner-all';
        this.updateText();
        if (this.positionStyle) {
            this.container.style.position = this.positionStyle;
        }
        this.container.appendChild(this.tooltipText);
        if (this.appendTo === 'body')
            document.body.appendChild(this.container);
        else if (this.appendTo === 'target')
            this.domHandler.appendChild(this.container, this.el.nativeElement);
        else
            this.domHandler.appendChild(this.container, this.appendTo);
        this.container.style.display = 'inline-block';
    };
    Tooltip.prototype.show = function () {
        if (!this.text || this.disabled) {
            return;
        }
        this.create();
        this.align();
        if (this.tooltipStyleClass) {
            this.container.className = this.container.className + ' ' + this.tooltipStyleClass;
        }
        this.domHandler.fadeIn(this.container, 250);
        this.container.style.zIndex = ++domhandler_1.DomHandler.zindex;
        this.bindDocumentResizeListener();
    };
    Tooltip.prototype.hide = function () {
        this.destroy();
    };
    Tooltip.prototype.updateText = function () {
        if (this.escape) {
            this.tooltipText.innerHTML = '';
            this.tooltipText.appendChild(document.createTextNode(this._text));
        }
        else {
            this.tooltipText.innerHTML = this._text;
        }
    };
    Tooltip.prototype.align = function () {
        var position = this.tooltipPosition;
        switch (position) {
            case 'top':
                this.alignTop();
                if (this.isOutOfBounds()) {
                    this.alignBottom();
                }
                break;
            case 'bottom':
                this.alignBottom();
                if (this.isOutOfBounds()) {
                    this.alignTop();
                }
                break;
            case 'left':
                this.alignLeft();
                if (this.isOutOfBounds()) {
                    this.alignRight();
                    if (this.isOutOfBounds()) {
                        this.alignTop();
                        if (this.isOutOfBounds()) {
                            this.alignBottom();
                        }
                    }
                }
                break;
            case 'right':
                this.alignRight();
                if (this.isOutOfBounds()) {
                    this.alignLeft();
                    if (this.isOutOfBounds()) {
                        this.alignTop();
                        if (this.isOutOfBounds()) {
                            this.alignBottom();
                        }
                    }
                }
                break;
        }
    };
    Tooltip.prototype.getHostOffset = function () {
        var offset = this.el.nativeElement.getBoundingClientRect();
        var targetLeft = offset.left + this.domHandler.getWindowScrollLeft();
        var targetTop = offset.top + this.domHandler.getWindowScrollTop();
        return { left: targetLeft, top: targetTop };
    };
    Tooltip.prototype.alignRight = function () {
        this.preAlign();
        this.container.className = 'ui-tooltip ui-widget ui-tooltip-right';
        var hostOffset = this.getHostOffset();
        var left = hostOffset.left + this.domHandler.getOuterWidth(this.el.nativeElement);
        var top = hostOffset.top + (this.domHandler.getOuterHeight(this.el.nativeElement) - this.domHandler.getOuterHeight(this.container)) / 2;
        this.container.style.left = left + 'px';
        this.container.style.top = top + 'px';
    };
    Tooltip.prototype.alignLeft = function () {
        this.preAlign();
        this.container.className = 'ui-tooltip ui-widget ui-tooltip-left';
        var hostOffset = this.getHostOffset();
        var left = hostOffset.left - this.domHandler.getOuterWidth(this.container);
        var top = hostOffset.top + (this.domHandler.getOuterHeight(this.el.nativeElement) - this.domHandler.getOuterHeight(this.container)) / 2;
        this.container.style.left = left + 'px';
        this.container.style.top = top + 'px';
    };
    Tooltip.prototype.alignTop = function () {
        this.preAlign();
        this.container.className = 'ui-tooltip ui-widget ui-tooltip-top';
        var hostOffset = this.getHostOffset();
        var left = hostOffset.left + (this.domHandler.getOuterWidth(this.el.nativeElement) - this.domHandler.getOuterWidth(this.container)) / 2;
        var top = hostOffset.top - this.domHandler.getOuterHeight(this.container);
        this.container.style.left = left + 'px';
        this.container.style.top = top + 'px';
    };
    Tooltip.prototype.alignBottom = function () {
        this.preAlign();
        this.container.className = 'ui-tooltip ui-widget ui-tooltip-bottom';
        var hostOffset = this.getHostOffset();
        var left = hostOffset.left + (this.domHandler.getOuterWidth(this.el.nativeElement) - this.domHandler.getOuterWidth(this.container)) / 2;
        var top = hostOffset.top + this.domHandler.getOuterHeight(this.el.nativeElement);
        this.container.style.left = left + 'px';
        this.container.style.top = top + 'px';
    };
    Tooltip.prototype.preAlign = function () {
        this.container.style.left = -999 + 'px';
        this.container.style.top = -999 + 'px';
    };
    Tooltip.prototype.isOutOfBounds = function () {
        var offset = this.container.getBoundingClientRect();
        var targetTop = offset.top;
        var targetLeft = offset.left;
        var width = this.domHandler.getOuterWidth(this.container);
        var height = this.domHandler.getOuterHeight(this.container);
        var viewport = this.domHandler.getViewport();
        return (targetLeft + width > viewport.width) || (targetLeft < 0) || (targetTop < 0) || (targetTop + height > viewport.height);
    };
    Tooltip.prototype.bindDocumentResizeListener = function () {
        var _this = this;
        this.documentResizeListener = this.renderer.listen('window', 'resize', function (event) {
            _this.hide();
        });
    };
    Tooltip.prototype.unbindDocumentResizeListener = function () {
        if (this.documentResizeListener) {
            this.documentResizeListener();
            this.documentResizeListener = null;
        }
    };
    Tooltip.prototype.destroy = function () {
        this.unbindDocumentResizeListener();
        if (this.container && this.container.parentElement) {
            if (this.appendTo === 'body')
                document.body.removeChild(this.container);
            else if (this.appendTo === 'target')
                this.el.nativeElement.removeChild(this.container);
            else
                this.domHandler.removeChild(this.container, this.appendTo);
        }
        this.container = null;
    };
    Tooltip.prototype.ngOnDestroy = function () {
        this.destroy();
    };
    return Tooltip;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Tooltip.prototype, "tooltipPosition", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Tooltip.prototype, "tooltipEvent", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Tooltip.prototype, "appendTo", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Tooltip.prototype, "positionStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Tooltip.prototype, "tooltipStyleClass", void 0);
__decorate([
    core_1.Input("tooltipDisabled"),
    __metadata("design:type", Boolean)
], Tooltip.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Tooltip.prototype, "escape", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Tooltip.prototype, "showDelay", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], Tooltip.prototype, "hideDelay", void 0);
__decorate([
    core_1.HostListener('mouseenter', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], Tooltip.prototype, "onMouseEnter", null);
__decorate([
    core_1.HostListener('mouseleave', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], Tooltip.prototype, "onMouseLeave", null);
__decorate([
    core_1.HostListener('focus', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], Tooltip.prototype, "onFocus", null);
__decorate([
    core_1.HostListener('blur', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], Tooltip.prototype, "onBlur", null);
__decorate([
    core_1.Input('pTooltip'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], Tooltip.prototype, "text", null);
Tooltip = __decorate([
    core_1.Directive({
        selector: '[pTooltip]',
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.Renderer2])
], Tooltip);
exports.Tooltip = Tooltip;
var TooltipModule = (function () {
    function TooltipModule() {
    }
    return TooltipModule;
}());
TooltipModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Tooltip],
        declarations: [Tooltip]
    })
], TooltipModule);
exports.TooltipModule = TooltipModule;
//# sourceMappingURL=tooltip.js.map

/***/ }),

/***/ "./node_modules/primeng/components/tree/tree.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var core_2 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var shared_2 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var treedragdropservice_1 = __webpack_require__("./node_modules/primeng/components/common/treedragdropservice.js");
var TreeNodeTemplateLoader = (function () {
    function TreeNodeTemplateLoader(viewContainer) {
        this.viewContainer = viewContainer;
    }
    TreeNodeTemplateLoader.prototype.ngOnInit = function () {
        this.view = this.viewContainer.createEmbeddedView(this.template, {
            '\$implicit': this.node
        });
    };
    TreeNodeTemplateLoader.prototype.ngOnDestroy = function () {
        this.view.destroy();
    };
    return TreeNodeTemplateLoader;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TreeNodeTemplateLoader.prototype, "node", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", core_1.TemplateRef)
], TreeNodeTemplateLoader.prototype, "template", void 0);
TreeNodeTemplateLoader = __decorate([
    core_1.Component({
        selector: 'p-treeNodeTemplateLoader',
        template: ""
    }),
    __metadata("design:paramtypes", [core_1.ViewContainerRef])
], TreeNodeTemplateLoader);
exports.TreeNodeTemplateLoader = TreeNodeTemplateLoader;
var UITreeNode = UITreeNode_1 = (function () {
    function UITreeNode(tree) {
        this.tree = tree;
    }
    UITreeNode.prototype.ngOnInit = function () {
        this.node.parent = this.parentNode;
    };
    UITreeNode.prototype.getIcon = function () {
        var icon;
        if (this.node.icon)
            icon = this.node.icon;
        else
            icon = this.node.expanded && this.node.children && this.node.children.length ? this.node.expandedIcon : this.node.collapsedIcon;
        return UITreeNode_1.ICON_CLASS + ' ' + icon;
    };
    UITreeNode.prototype.isLeaf = function () {
        return this.node.leaf == false ? false : !(this.node.children && this.node.children.length);
    };
    UITreeNode.prototype.toggle = function (event) {
        if (this.node.expanded)
            this.tree.onNodeCollapse.emit({ originalEvent: event, node: this.node });
        else
            this.tree.onNodeExpand.emit({ originalEvent: event, node: this.node });
        this.node.expanded = !this.node.expanded;
    };
    UITreeNode.prototype.onNodeClick = function (event) {
        this.tree.onNodeClick(event, this.node);
    };
    UITreeNode.prototype.onNodeTouchEnd = function () {
        this.tree.onNodeTouchEnd();
    };
    UITreeNode.prototype.onNodeRightClick = function (event) {
        this.tree.onNodeRightClick(event, this.node);
    };
    UITreeNode.prototype.isSelected = function () {
        return this.tree.isSelected(this.node);
    };
    UITreeNode.prototype.onDropPoint = function (event, position) {
        event.preventDefault();
        var dragNode = this.tree.dragNode;
        var dragNodeIndex = this.tree.dragNodeIndex;
        var dragNodeScope = this.tree.dragNodeScope;
        var isValidDropPointIndex = this.tree.dragNodeTree === this.tree ? (position === 1 || dragNodeIndex !== this.index - 1) : true;
        if (this.tree.allowDrop(dragNode, this.node, dragNodeScope) && isValidDropPointIndex) {
            var newNodeList = this.node.parent ? this.node.parent.children : this.tree.value;
            this.tree.dragNodeSubNodes.splice(dragNodeIndex, 1);
            if (position < 0) {
                var dropIndex = (this.tree.dragNodeSubNodes === newNodeList) ? ((this.tree.dragNodeIndex > this.index) ? this.index : this.index - 1) : this.index;
                newNodeList.splice(dropIndex, 0, dragNode);
            }
            else {
                newNodeList.push(dragNode);
            }
            this.tree.dragDropService.stopDrag({
                node: dragNode,
                subNodes: this.node.parent ? this.node.parent.children : this.tree.value,
                index: dragNodeIndex
            });
            this.tree.onNodeDrop.emit({
                originalEvent: event,
                dragNode: dragNode
            });
        }
        this.draghoverPrev = false;
        this.draghoverNext = false;
    };
    UITreeNode.prototype.onDropPointDragOver = function (event) {
        event.dataTransfer.dropEffect = 'move';
        event.preventDefault();
    };
    UITreeNode.prototype.onDropPointDragEnter = function (event, position) {
        if (this.tree.allowDrop(this.tree.dragNode, this.node, this.tree.dragNodeScope)) {
            if (position < 0)
                this.draghoverPrev = true;
            else
                this.draghoverNext = true;
        }
    };
    UITreeNode.prototype.onDropPointDragLeave = function (event) {
        this.draghoverPrev = false;
        this.draghoverNext = false;
    };
    UITreeNode.prototype.onDragStart = function (event) {
        if (this.tree.draggableNodes && this.node.draggable !== false) {
            event.dataTransfer.setData("text", "data");
            this.tree.dragDropService.startDrag({
                tree: this,
                node: this.node,
                subNodes: this.node.parent ? this.node.parent.children : this.tree.value,
                index: this.index,
                scope: this.tree.draggableScope
            });
        }
        else {
            event.preventDefault();
        }
    };
    UITreeNode.prototype.onDragStop = function (event) {
        this.tree.dragDropService.stopDrag({
            node: this.node,
            subNodes: this.node.parent ? this.node.parent.children : this.tree.value,
            index: this.index
        });
    };
    UITreeNode.prototype.onDropNodeDragOver = function (event) {
        event.dataTransfer.dropEffect = 'move';
        if (this.tree.droppableNodes) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    UITreeNode.prototype.onDropNode = function (event) {
        if (this.tree.droppableNodes && this.node.droppable !== false) {
            event.preventDefault();
            event.stopPropagation();
            var dragNode = this.tree.dragNode;
            if (this.tree.allowDrop(dragNode, this.node, this.tree.dragNodeScope)) {
                var dragNodeIndex = this.tree.dragNodeIndex;
                this.tree.dragNodeSubNodes.splice(dragNodeIndex, 1);
                if (this.node.children)
                    this.node.children.push(dragNode);
                else
                    this.node.children = [dragNode];
                this.tree.dragDropService.stopDrag({
                    node: dragNode,
                    subNodes: this.node.parent ? this.node.parent.children : this.tree.value,
                    index: this.tree.dragNodeIndex
                });
                this.tree.onNodeDrop.emit({
                    originalEvent: event,
                    dragNode: dragNode,
                    dropNode: this.node
                });
            }
        }
        this.draghoverNode = false;
    };
    UITreeNode.prototype.onDropNodeDragEnter = function (event) {
        if (this.tree.droppableNodes && this.node.droppable !== false && this.tree.allowDrop(this.tree.dragNode, this.node, this.tree.dragNodeScope)) {
            this.draghoverNode = true;
        }
    };
    UITreeNode.prototype.onDropNodeDragLeave = function (event) {
        if (this.tree.droppableNodes) {
            var rect = event.currentTarget.getBoundingClientRect();
            if (event.x > rect.left + rect.width || event.x < rect.left || event.y >= Math.floor(rect.top + rect.height) || event.y < rect.top) {
                this.draghoverNode = false;
            }
        }
    };
    return UITreeNode;
}());
UITreeNode.ICON_CLASS = 'ui-treenode-icon fa fa-fw';
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], UITreeNode.prototype, "node", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], UITreeNode.prototype, "parentNode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], UITreeNode.prototype, "root", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], UITreeNode.prototype, "index", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], UITreeNode.prototype, "firstChild", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], UITreeNode.prototype, "lastChild", void 0);
UITreeNode = UITreeNode_1 = __decorate([
    core_1.Component({
        selector: 'p-treeNode',
        template: "\n        <ng-template [ngIf]=\"node\">\n            <li *ngIf=\"tree.droppableNodes\" class=\"ui-treenode-droppoint\" [ngClass]=\"{'ui-treenode-droppoint-active ui-state-highlight':draghoverPrev}\"\n            (drop)=\"onDropPoint($event,-1)\" (dragover)=\"onDropPointDragOver($event)\" (dragenter)=\"onDropPointDragEnter($event,-1)\" (dragleave)=\"onDropPointDragLeave($event)\"></li>\n            <li class=\"ui-treenode {{node.styleClass}}\" *ngIf=\"!tree.horizontal\" [ngClass]=\"{'ui-treenode-leaf': isLeaf()}\">\n                <div class=\"ui-treenode-content\" (click)=\"onNodeClick($event)\" (contextmenu)=\"onNodeRightClick($event)\" (touchend)=\"onNodeTouchEnd()\"\n                    (drop)=\"onDropNode($event)\" (dragover)=\"onDropNodeDragOver($event)\" (dragenter)=\"onDropNodeDragEnter($event)\" (dragleave)=\"onDropNodeDragLeave($event)\"\n                    [ngClass]=\"{'ui-treenode-selectable':tree.selectionMode && node.selectable !== false,'ui-treenode-dragover':draghoverNode}\" [draggable]=\"tree.draggableNodes\" (dragstart)=\"onDragStart($event)\" (dragend)=\"onDragStop($event)\">\n                    <span class=\"ui-tree-toggler  fa fa-fw\" [ngClass]=\"{'fa-caret-right':!node.expanded,'fa-caret-down':node.expanded}\"\n                            (click)=\"toggle($event)\"></span\n                    ><div class=\"ui-chkbox\" *ngIf=\"tree.selectionMode == 'checkbox'\"><div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\">\n                        <span class=\"ui-chkbox-icon ui-clickable fa\" \n                            [ngClass]=\"{'fa-check':isSelected(),'fa-minus':node.partialSelected}\"></span></div></div\n                    ><span [class]=\"getIcon()\" *ngIf=\"node.icon||node.expandedIcon||node.collapsedIcon\"></span\n                    ><span class=\"ui-treenode-label ui-corner-all\" \n                        [ngClass]=\"{'ui-state-highlight':isSelected()}\">\n                            <span *ngIf=\"!tree.getTemplateForNode(node)\">{{node.label}}</span>\n                            <span *ngIf=\"tree.getTemplateForNode(node)\">\n                                <p-treeNodeTemplateLoader [node]=\"node\" [template]=\"tree.getTemplateForNode(node)\"></p-treeNodeTemplateLoader>\n                            </span>\n                    </span>\n                </div>\n                <ul class=\"ui-treenode-children\" style=\"display: none;\" *ngIf=\"node.children && node.expanded\" [style.display]=\"node.expanded ? 'block' : 'none'\">\n                    <p-treeNode *ngFor=\"let childNode of node.children;let firstChild=first;let lastChild=last; let index=index\" [node]=\"childNode\" [parentNode]=\"node\"\n                        [firstChild]=\"firstChild\" [lastChild]=\"lastChild\" [index]=\"index\"></p-treeNode>\n                </ul>\n            </li>\n            <li *ngIf=\"tree.droppableNodes&&lastChild\" class=\"ui-treenode-droppoint\" [ngClass]=\"{'ui-treenode-droppoint-active ui-state-highlight':draghoverNext}\"\n            (drop)=\"onDropPoint($event,1)\" (dragover)=\"onDropPointDragOver($event)\" (dragenter)=\"onDropPointDragEnter($event,1)\" (dragleave)=\"onDropPointDragLeave($event)\"></li>\n            <table *ngIf=\"tree.horizontal\" [class]=\"node.styleClass\">\n                <tbody>\n                    <tr>\n                        <td class=\"ui-treenode-connector\" *ngIf=\"!root\">\n                            <table class=\"ui-treenode-connector-table\">\n                                <tbody>\n                                    <tr>\n                                        <td [ngClass]=\"{'ui-treenode-connector-line':!firstChild}\"></td>\n                                    </tr>\n                                    <tr>\n                                        <td [ngClass]=\"{'ui-treenode-connector-line':!lastChild}\"></td>\n                                    </tr>\n                                </tbody>\n                            </table>\n                        </td>\n                        <td class=\"ui-treenode\" [ngClass]=\"{'ui-treenode-collapsed':!node.expanded}\">\n                            <div class=\"ui-treenode-content ui-state-default ui-corner-all\" \n                                [ngClass]=\"{'ui-treenode-selectable':tree.selectionMode,'ui-state-highlight':isSelected()}\" (click)=\"onNodeClick($event)\" (contextmenu)=\"onNodeRightClick($event)\"\n                                (touchend)=\"onNodeTouchEnd()\">\n                                <span class=\"ui-tree-toggler fa fa-fw\" [ngClass]=\"{'fa-plus':!node.expanded,'fa-minus':node.expanded}\" *ngIf=\"!isLeaf()\"\n                                        (click)=\"toggle($event)\"></span\n                                ><span [class]=\"getIcon()\" *ngIf=\"node.icon||node.expandedIcon||node.collapsedIcon\"></span\n                                ><span class=\"ui-treenode-label ui-corner-all\">\n                                        <span *ngIf=\"!tree.getTemplateForNode(node)\">{{node.label}}</span>\n                                        <span *ngIf=\"tree.getTemplateForNode(node)\">\n                                            <p-treeNodeTemplateLoader [node]=\"node\" [template]=\"tree.getTemplateForNode(node)\"></p-treeNodeTemplateLoader>\n                                        </span>\n                                </span>\n                            </div>\n                        </td>\n                        <td class=\"ui-treenode-children-container\" *ngIf=\"node.children && node.expanded\" [style.display]=\"node.expanded ? 'table-cell' : 'none'\">\n                            <div class=\"ui-treenode-children\">\n                                <p-treeNode *ngFor=\"let childNode of node.children;let firstChild=first;let lastChild=last;\" [node]=\"childNode\" \n                                        [firstChild]=\"firstChild\" [lastChild]=\"lastChild\"></p-treeNode>\n                            </div>\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n        </ng-template>\n    "
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return Tree; }))),
    __metadata("design:paramtypes", [Tree])
], UITreeNode);
exports.UITreeNode = UITreeNode;
var Tree = (function () {
    function Tree(dragDropService) {
        this.dragDropService = dragDropService;
        this.selectionChange = new core_1.EventEmitter();
        this.onNodeSelect = new core_1.EventEmitter();
        this.onNodeUnselect = new core_1.EventEmitter();
        this.onNodeExpand = new core_1.EventEmitter();
        this.onNodeCollapse = new core_1.EventEmitter();
        this.onNodeContextMenuSelect = new core_1.EventEmitter();
        this.onNodeDrop = new core_1.EventEmitter();
        this.layout = 'vertical';
        this.metaKeySelection = true;
        this.propagateSelectionUp = true;
        this.propagateSelectionDown = true;
    }
    Tree.prototype.ngOnInit = function () {
        var _this = this;
        if (this.droppableNodes) {
            this.dragStartSubscription = this.dragDropService.dragStart$.subscribe(function (event) {
                _this.dragNodeTree = event.tree;
                _this.dragNode = event.node;
                _this.dragNodeSubNodes = event.subNodes;
                _this.dragNodeIndex = event.index;
                _this.dragNodeScope = event.scope;
            });
            this.dragStopSubscription = this.dragDropService.dragStop$.subscribe(function (event) {
                _this.dragNodeTree = null;
                _this.dragNode = null;
                _this.dragNodeSubNodes = null;
                _this.dragNodeIndex = null;
                _this.dragNodeScope = null;
                _this.dragHover = false;
            });
        }
    };
    Object.defineProperty(Tree.prototype, "horizontal", {
        get: function () {
            return this.layout == 'horizontal';
        },
        enumerable: true,
        configurable: true
    });
    Tree.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (this.templates.length) {
            this.templateMap = {};
        }
        this.templates.forEach(function (item) {
            _this.templateMap[item.name] = item.template;
        });
    };
    Tree.prototype.onNodeClick = function (event, node) {
        var eventTarget = event.target;
        if (eventTarget.className && eventTarget.className.indexOf('ui-tree-toggler') === 0) {
            return;
        }
        else if (this.selectionMode) {
            if (node.selectable === false) {
                return;
            }
            var index_1 = this.findIndexInSelection(node);
            var selected = (index_1 >= 0);
            if (this.isCheckboxSelectionMode()) {
                if (selected) {
                    if (this.propagateSelectionDown)
                        this.propagateDown(node, false);
                    else
                        this.selection = this.selection.filter(function (val, i) { return i != index_1; });
                    if (this.propagateSelectionUp && node.parent) {
                        this.propagateUp(node.parent, false);
                    }
                    this.selectionChange.emit(this.selection);
                    this.onNodeUnselect.emit({ originalEvent: event, node: node });
                }
                else {
                    if (this.propagateSelectionDown)
                        this.propagateDown(node, true);
                    else
                        this.selection = (this.selection || []).concat([node]);
                    if (this.propagateSelectionUp && node.parent) {
                        this.propagateUp(node.parent, true);
                    }
                    this.selectionChange.emit(this.selection);
                    this.onNodeSelect.emit({ originalEvent: event, node: node });
                }
            }
            else {
                var metaSelection = this.nodeTouched ? false : this.metaKeySelection;
                if (metaSelection) {
                    var metaKey = (event.metaKey || event.ctrlKey);
                    if (selected && metaKey) {
                        if (this.isSingleSelectionMode()) {
                            this.selectionChange.emit(null);
                        }
                        else {
                            this.selection = this.selection.filter(function (val, i) { return i != index_1; });
                            this.selectionChange.emit(this.selection);
                        }
                        this.onNodeUnselect.emit({ originalEvent: event, node: node });
                    }
                    else {
                        if (this.isSingleSelectionMode()) {
                            this.selectionChange.emit(node);
                        }
                        else if (this.isMultipleSelectionMode()) {
                            this.selection = (!metaKey) ? [] : this.selection || [];
                            this.selection = this.selection.concat([node]);
                            this.selectionChange.emit(this.selection);
                        }
                        this.onNodeSelect.emit({ originalEvent: event, node: node });
                    }
                }
                else {
                    if (this.isSingleSelectionMode()) {
                        if (selected) {
                            this.selection = null;
                            this.onNodeUnselect.emit({ originalEvent: event, node: node });
                        }
                        else {
                            this.selection = node;
                            this.onNodeSelect.emit({ originalEvent: event, node: node });
                        }
                    }
                    else {
                        if (selected) {
                            this.selection = this.selection.filter(function (val, i) { return i != index_1; });
                            this.onNodeUnselect.emit({ originalEvent: event, node: node });
                        }
                        else {
                            this.selection = (this.selection || []).concat([node]);
                            this.onNodeSelect.emit({ originalEvent: event, node: node });
                        }
                    }
                    this.selectionChange.emit(this.selection);
                }
            }
        }
        this.nodeTouched = false;
    };
    Tree.prototype.onNodeTouchEnd = function () {
        this.nodeTouched = true;
    };
    Tree.prototype.onNodeRightClick = function (event, node) {
        if (this.contextMenu) {
            var eventTarget = event.target;
            if (eventTarget.className && eventTarget.className.indexOf('ui-tree-toggler') === 0) {
                return;
            }
            else {
                var index = this.findIndexInSelection(node);
                var selected = (index >= 0);
                if (!selected) {
                    if (this.isSingleSelectionMode())
                        this.selectionChange.emit(node);
                    else
                        this.selectionChange.emit([node]);
                }
                this.contextMenu.show(event);
                this.onNodeContextMenuSelect.emit({ originalEvent: event, node: node });
            }
        }
    };
    Tree.prototype.findIndexInSelection = function (node) {
        var index = -1;
        if (this.selectionMode && this.selection) {
            if (this.isSingleSelectionMode()) {
                index = (this.selection == node) ? 0 : -1;
            }
            else {
                for (var i = 0; i < this.selection.length; i++) {
                    if (this.selection[i] == node) {
                        index = i;
                        break;
                    }
                }
            }
        }
        return index;
    };
    Tree.prototype.propagateUp = function (node, select) {
        if (node.children && node.children.length) {
            var selectedCount = 0;
            var childPartialSelected = false;
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (this.isSelected(child)) {
                    selectedCount++;
                }
                else if (child.partialSelected) {
                    childPartialSelected = true;
                }
            }
            if (select && selectedCount == node.children.length) {
                this.selection = (this.selection || []).concat([node]);
                node.partialSelected = false;
            }
            else {
                if (!select) {
                    var index_2 = this.findIndexInSelection(node);
                    if (index_2 >= 0) {
                        this.selection = this.selection.filter(function (val, i) { return i != index_2; });
                    }
                }
                if (childPartialSelected || selectedCount > 0 && selectedCount != node.children.length)
                    node.partialSelected = true;
                else
                    node.partialSelected = false;
            }
        }
        var parent = node.parent;
        if (parent) {
            this.propagateUp(parent, select);
        }
    };
    Tree.prototype.propagateDown = function (node, select) {
        var index = this.findIndexInSelection(node);
        if (select && index == -1) {
            this.selection = (this.selection || []).concat([node]);
        }
        else if (!select && index > -1) {
            this.selection = this.selection.filter(function (val, i) { return i != index; });
        }
        node.partialSelected = false;
        if (node.children && node.children.length) {
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this.propagateDown(child, select);
            }
        }
    };
    Tree.prototype.isSelected = function (node) {
        return this.findIndexInSelection(node) != -1;
    };
    Tree.prototype.isSingleSelectionMode = function () {
        return this.selectionMode && this.selectionMode == 'single';
    };
    Tree.prototype.isMultipleSelectionMode = function () {
        return this.selectionMode && this.selectionMode == 'multiple';
    };
    Tree.prototype.isCheckboxSelectionMode = function () {
        return this.selectionMode && this.selectionMode == 'checkbox';
    };
    Tree.prototype.getTemplateForNode = function (node) {
        if (this.templateMap)
            return node.type ? this.templateMap[node.type] : this.templateMap['default'];
        else
            return null;
    };
    Tree.prototype.onDragOver = function (event) {
        if (this.droppableNodes && (!this.value || this.value.length === 0)) {
            event.dataTransfer.dropEffect = 'move';
            event.preventDefault();
        }
    };
    Tree.prototype.onDrop = function (event) {
        if (this.droppableNodes && (!this.value || this.value.length === 0)) {
            event.preventDefault();
            var dragNode = this.dragNode;
            if (this.allowDrop(dragNode, null, this.dragNodeScope)) {
                var dragNodeIndex = this.dragNodeIndex;
                this.dragNodeSubNodes.splice(dragNodeIndex, 1);
                this.value = this.value || [];
                this.value.push(dragNode);
                this.dragDropService.stopDrag({
                    node: dragNode
                });
            }
        }
    };
    Tree.prototype.onDragEnter = function (event) {
        if (this.droppableNodes && this.allowDrop(this.dragNode, null, this.dragNodeScope)) {
            this.dragHover = true;
        }
    };
    Tree.prototype.onDragLeave = function (event) {
        if (this.droppableNodes) {
            var rect = event.currentTarget.getBoundingClientRect();
            if (event.x > rect.left + rect.width || event.x < rect.left || event.y > rect.top + rect.height || event.y < rect.top) {
                this.dragHover = false;
            }
        }
    };
    Tree.prototype.allowDrop = function (dragNode, dropNode, dragNodeScope) {
        if (this.isValidDragScope(dragNodeScope)) {
            var allow = true;
            if (dropNode) {
                if (dragNode === dropNode) {
                    allow = false;
                }
                else {
                    var parent_1 = dropNode.parent;
                    while (parent_1 != null) {
                        if (parent_1 === dragNode) {
                            allow = false;
                            break;
                        }
                        parent_1 = parent_1.parent;
                    }
                }
            }
            return allow;
        }
        else {
            return false;
        }
    };
    Tree.prototype.isValidDragScope = function (dragScope) {
        var dropScope = this.droppableScope;
        if (dropScope) {
            if (typeof dropScope === 'string') {
                if (typeof dragScope === 'string')
                    return dropScope === dragScope;
                else if (dragScope instanceof Array)
                    return dragScope.indexOf(dropScope) != -1;
            }
            else if (dropScope instanceof Array) {
                if (typeof dragScope === 'string') {
                    return dropScope.indexOf(dragScope) != -1;
                }
                else if (dragScope instanceof Array) {
                    for (var _i = 0, dropScope_1 = dropScope; _i < dropScope_1.length; _i++) {
                        var s = dropScope_1[_i];
                        for (var _a = 0, dragScope_1 = dragScope; _a < dragScope_1.length; _a++) {
                            var ds = dragScope_1[_a];
                            if (s === ds) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        else {
            return true;
        }
    };
    Tree.prototype.ngOnDestroy = function () {
        if (this.dragStartSubscription) {
            this.dragStartSubscription.unsubscribe();
        }
        if (this.dragStopSubscription) {
            this.dragStopSubscription.unsubscribe();
        }
    };
    return Tree;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], Tree.prototype, "value", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Tree.prototype, "selectionMode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Tree.prototype, "selection", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Tree.prototype, "selectionChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Tree.prototype, "onNodeSelect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Tree.prototype, "onNodeUnselect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Tree.prototype, "onNodeExpand", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Tree.prototype, "onNodeCollapse", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Tree.prototype, "onNodeContextMenuSelect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], Tree.prototype, "onNodeDrop", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Tree.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Tree.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Tree.prototype, "contextMenu", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], Tree.prototype, "layout", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Tree.prototype, "draggableScope", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], Tree.prototype, "droppableScope", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Tree.prototype, "draggableNodes", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Tree.prototype, "droppableNodes", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Tree.prototype, "metaKeySelection", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Tree.prototype, "propagateSelectionUp", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], Tree.prototype, "propagateSelectionDown", void 0);
__decorate([
    core_1.ContentChildren(shared_2.PrimeTemplate),
    __metadata("design:type", core_1.QueryList)
], Tree.prototype, "templates", void 0);
Tree = __decorate([
    core_1.Component({
        selector: 'p-tree',
        template: "\n        <div [ngClass]=\"{'ui-tree ui-widget ui-widget-content ui-corner-all':true,'ui-tree-selectable':selectionMode,'ui-treenode-dragover':dragHover}\" [ngStyle]=\"style\" [class]=\"styleClass\" *ngIf=\"!horizontal\"\n            (drop)=\"onDrop($event)\" (dragover)=\"onDragOver($event)\" (dragenter)=\"onDragEnter($event)\" (dragleave)=\"onDragLeave($event)\">\n            <ul class=\"ui-tree-container\">\n                <p-treeNode *ngFor=\"let node of value;let firstChild=first;let lastChild=last; let index=index\" [node]=\"node\" \n                [firstChild]=\"firstChild\" [lastChild]=\"lastChild\" [index]=\"index\"></p-treeNode>\n            </ul>\n        </div>\n        <div [ngClass]=\"{'ui-tree ui-tree-horizontal ui-widget ui-widget-content ui-corner-all':true,'ui-tree-selectable':selectionMode}\"  [ngStyle]=\"style\" [class]=\"styleClass\" *ngIf=\"horizontal\">\n            <table *ngIf=\"value&&value[0]\">\n                <p-treeNode [node]=\"value[0]\" [root]=\"true\"></p-treeNode>\n            </table>\n        </div>\n    "
    }),
    __param(0, core_2.Optional()),
    __metadata("design:paramtypes", [treedragdropservice_1.TreeDragDropService])
], Tree);
exports.Tree = Tree;
var TreeModule = (function () {
    function TreeModule() {
    }
    return TreeModule;
}());
TreeModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [Tree, shared_1.SharedModule],
        declarations: [Tree, UITreeNode, TreeNodeTemplateLoader]
    })
], TreeModule);
exports.TreeModule = TreeModule;
var UITreeNode_1;
//# sourceMappingURL=tree.js.map

/***/ }),

/***/ "./node_modules/primeng/components/treetable/treetable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var shared_1 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var shared_2 = __webpack_require__("./node_modules/primeng/components/common/shared.js");
var domhandler_1 = __webpack_require__("./node_modules/primeng/components/dom/domhandler.js");
var UITreeRow = (function () {
    function UITreeRow(treeTable) {
        this.treeTable = treeTable;
        this.level = 0;
        this.labelExpand = "Expand";
        this.labelCollapse = "Collapse";
    }
    UITreeRow.prototype.ngOnInit = function () {
        this.node.parent = this.parentNode;
    };
    UITreeRow.prototype.toggle = function (event) {
        if (this.node.expanded)
            this.treeTable.onNodeCollapse.emit({ originalEvent: event, node: this.node });
        else
            this.treeTable.onNodeExpand.emit({ originalEvent: event, node: this.node });
        this.node.expanded = !this.node.expanded;
        event.preventDefault();
    };
    UITreeRow.prototype.isLeaf = function () {
        return this.node.leaf == false ? false : !(this.node.children && this.node.children.length);
    };
    UITreeRow.prototype.isSelected = function () {
        return this.treeTable.isSelected(this.node);
    };
    UITreeRow.prototype.onRowClick = function (event) {
        this.treeTable.onRowClick(event, this.node);
    };
    UITreeRow.prototype.onRowRightClick = function (event) {
        this.treeTable.onRowRightClick(event, this.node);
    };
    UITreeRow.prototype.rowDblClick = function (event) {
        this.treeTable.onRowDblclick.emit({ originalEvent: event, node: this.node });
    };
    UITreeRow.prototype.onRowTouchEnd = function () {
        this.treeTable.onRowTouchEnd();
    };
    UITreeRow.prototype.resolveFieldData = function (data, field) {
        if (data && field) {
            if (field.indexOf('.') == -1) {
                return data[field];
            }
            else {
                var fields = field.split('.');
                var value = data;
                for (var i = 0, len = fields.length; i < len; ++i) {
                    value = value[fields[i]];
                }
                return value;
            }
        }
        else {
            return null;
        }
    };
    return UITreeRow;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], UITreeRow.prototype, "node", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], UITreeRow.prototype, "parentNode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], UITreeRow.prototype, "level", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], UITreeRow.prototype, "labelExpand", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], UITreeRow.prototype, "labelCollapse", void 0);
UITreeRow = __decorate([
    core_1.Component({
        selector: '[pTreeRow]',
        template: "\n        <div class=\"ui-treetable-row\" [ngClass]=\"{'ui-state-highlight':isSelected(),'ui-treetable-row-selectable':treeTable.selectionMode && node.selectable !== false}\">\n            <td *ngFor=\"let col of treeTable.columns; let i=index\" [ngStyle]=\"col.style\" [class]=\"col.styleClass\" (click)=\"onRowClick($event)\" (dblclick)=\"rowDblClick($event)\" (touchend)=\"onRowTouchEnd()\" (contextmenu)=\"onRowRightClick($event)\">\n                <a href=\"#\" *ngIf=\"i == treeTable.toggleColumnIndex\" class=\"ui-treetable-toggler fa fa-fw ui-clickable\" [ngClass]=\"{'fa-caret-down':node.expanded,'fa-caret-right':!node.expanded}\"\n                    [ngStyle]=\"{'margin-left':level*16 + 'px','visibility': isLeaf() ? 'hidden' : 'visible'}\"\n                    (click)=\"toggle($event)\"\n                    [title]=\"node.expanded ? labelCollapse : labelExpand\">\n                </a>\n                <div class=\"ui-chkbox ui-treetable-checkbox\" *ngIf=\"treeTable.selectionMode == 'checkbox' && i==0\"><div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\">\n                    <span class=\"ui-chkbox-icon ui-clickable fa\" \n                        [ngClass]=\"{'fa-check':isSelected(),'fa-minus':node.partialSelected}\"></span></div></div\n                ><span *ngIf=\"!col.template\">{{resolveFieldData(node.data,col.field)}}</span>\n                <p-columnBodyTemplateLoader [column]=\"col\" [rowData]=\"node\" *ngIf=\"col.template\"></p-columnBodyTemplateLoader>\n            </td>\n        </div>\n        <div *ngIf=\"node.children && node.expanded\" class=\"ui-treetable-row\" style=\"display:table-row\">\n            <td [attr.colspan]=\"treeTable.columns.length\" class=\"ui-treetable-child-table-container\">\n                <table [class]=\"treeTable.tableStyleClass\" [ngStyle]=\"treeTable.tableStyle\">\n                    <tbody pTreeRow *ngFor=\"let childNode of node.children\" [node]=\"childNode\" [level]=\"level+1\" [labelExpand]=\"labelExpand\" [labelCollapse]=\"labelCollapse\" [parentNode]=\"node\"></tbody>\n                </table>\n            </td>\n        </div>\n    "
    }),
    __param(0, core_1.Inject(core_1.forwardRef(function () { return TreeTable; }))),
    __metadata("design:paramtypes", [TreeTable])
], UITreeRow);
exports.UITreeRow = UITreeRow;
var TreeTable = (function () {
    function TreeTable(el, domHandler, changeDetector, renderer) {
        this.el = el;
        this.domHandler = domHandler;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.labelExpand = "Expand";
        this.labelCollapse = "Collapse";
        this.metaKeySelection = true;
        this.toggleColumnIndex = 0;
        this.onRowDblclick = new core_1.EventEmitter();
        this.selectionChange = new core_1.EventEmitter();
        this.onNodeSelect = new core_1.EventEmitter();
        this.onNodeUnselect = new core_1.EventEmitter();
        this.onNodeExpand = new core_1.EventEmitter();
        this.onNodeCollapse = new core_1.EventEmitter();
        this.onContextMenuSelect = new core_1.EventEmitter();
    }
    TreeTable.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.initColumns();
        this.columnsSubscription = this.cols.changes.subscribe(function (_) {
            _this.initColumns();
            _this.changeDetector.markForCheck();
        });
    };
    TreeTable.prototype.initColumns = function () {
        this.columns = this.cols.toArray();
    };
    TreeTable.prototype.onRowClick = function (event, node) {
        var eventTarget = event.target;
        if (eventTarget.className && eventTarget.className.indexOf('ui-treetable-toggler') === 0) {
            return;
        }
        else if (this.selectionMode) {
            if (node.selectable === false) {
                return;
            }
            var metaSelection = this.rowTouched ? false : this.metaKeySelection;
            var index_1 = this.findIndexInSelection(node);
            var selected = (index_1 >= 0);
            if (this.isCheckboxSelectionMode()) {
                if (selected) {
                    this.propagateSelectionDown(node, false);
                    if (node.parent) {
                        this.propagateSelectionUp(node.parent, false);
                    }
                    this.selectionChange.emit(this.selection);
                    this.onNodeUnselect.emit({ originalEvent: event, node: node });
                }
                else {
                    this.propagateSelectionDown(node, true);
                    if (node.parent) {
                        this.propagateSelectionUp(node.parent, true);
                    }
                    this.selectionChange.emit(this.selection);
                    this.onNodeSelect.emit({ originalEvent: event, node: node });
                }
            }
            else {
                if (metaSelection) {
                    var metaKey = (event.metaKey || event.ctrlKey);
                    if (selected && metaKey) {
                        if (this.isSingleSelectionMode()) {
                            this.selectionChange.emit(null);
                        }
                        else {
                            this.selection = this.selection.filter(function (val, i) { return i != index_1; });
                            this.selectionChange.emit(this.selection);
                        }
                        this.onNodeUnselect.emit({ originalEvent: event, node: node });
                    }
                    else {
                        if (this.isSingleSelectionMode()) {
                            this.selectionChange.emit(node);
                        }
                        else if (this.isMultipleSelectionMode()) {
                            this.selection = (!metaKey) ? [] : this.selection || [];
                            this.selection = this.selection.concat([node]);
                            this.selectionChange.emit(this.selection);
                        }
                        this.onNodeSelect.emit({ originalEvent: event, node: node });
                    }
                }
                else {
                    if (this.isSingleSelectionMode()) {
                        if (selected) {
                            this.selection = null;
                            this.onNodeUnselect.emit({ originalEvent: event, node: node });
                        }
                        else {
                            this.selection = node;
                            this.onNodeSelect.emit({ originalEvent: event, node: node });
                        }
                    }
                    else {
                        if (selected) {
                            this.selection = this.selection.filter(function (val, i) { return i != index_1; });
                            this.onNodeUnselect.emit({ originalEvent: event, node: node });
                        }
                        else {
                            this.selection = (this.selection || []).concat([node]);
                            this.onNodeSelect.emit({ originalEvent: event, node: node });
                        }
                    }
                    this.selectionChange.emit(this.selection);
                }
            }
        }
        this.rowTouched = false;
    };
    TreeTable.prototype.onRowTouchEnd = function () {
        this.rowTouched = true;
    };
    TreeTable.prototype.onRowRightClick = function (event, node) {
        if (this.contextMenu) {
            var index = this.findIndexInSelection(node);
            var selected = (index >= 0);
            if (!selected) {
                if (this.isSingleSelectionMode()) {
                    this.selection = node;
                }
                else if (this.isMultipleSelectionMode()) {
                    this.selection = [node];
                    this.selectionChange.emit(this.selection);
                }
                this.selectionChange.emit(this.selection);
            }
            this.contextMenu.show(event);
            this.onContextMenuSelect.emit({ originalEvent: event, node: node });
        }
    };
    TreeTable.prototype.findIndexInSelection = function (node) {
        var index = -1;
        if (this.selectionMode && this.selection) {
            if (this.isSingleSelectionMode()) {
                index = (this.selection == node) ? 0 : -1;
            }
            else {
                for (var i = 0; i < this.selection.length; i++) {
                    if (this.selection[i] == node) {
                        index = i;
                        break;
                    }
                }
            }
        }
        return index;
    };
    TreeTable.prototype.propagateSelectionUp = function (node, select) {
        if (node.children && node.children.length) {
            var selectedCount = 0;
            var childPartialSelected = false;
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (this.isSelected(child)) {
                    selectedCount++;
                }
                else if (child.partialSelected) {
                    childPartialSelected = true;
                }
            }
            if (select && selectedCount == node.children.length) {
                this.selection = (this.selection || []).concat([node]);
                node.partialSelected = false;
            }
            else {
                if (!select) {
                    var index_2 = this.findIndexInSelection(node);
                    if (index_2 >= 0) {
                        this.selection = this.selection.filter(function (val, i) { return i != index_2; });
                    }
                }
                if (childPartialSelected || selectedCount > 0 && selectedCount != node.children.length)
                    node.partialSelected = true;
                else
                    node.partialSelected = false;
            }
        }
        var parent = node.parent;
        if (parent) {
            this.propagateSelectionUp(parent, select);
        }
    };
    TreeTable.prototype.propagateSelectionDown = function (node, select) {
        var index = this.findIndexInSelection(node);
        if (select && index == -1) {
            this.selection = (this.selection || []).concat([node]);
        }
        else if (!select && index > -1) {
            this.selection = this.selection.filter(function (val, i) { return i != index; });
        }
        node.partialSelected = false;
        if (node.children && node.children.length) {
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this.propagateSelectionDown(child, select);
            }
        }
    };
    TreeTable.prototype.isSelected = function (node) {
        return this.findIndexInSelection(node) != -1;
    };
    TreeTable.prototype.isSingleSelectionMode = function () {
        return this.selectionMode && this.selectionMode == 'single';
    };
    TreeTable.prototype.isMultipleSelectionMode = function () {
        return this.selectionMode && this.selectionMode == 'multiple';
    };
    TreeTable.prototype.isCheckboxSelectionMode = function () {
        return this.selectionMode && this.selectionMode == 'checkbox';
    };
    TreeTable.prototype.hasFooter = function () {
        if (this.columns) {
            var columnsArr = this.cols.toArray();
            for (var i = 0; i < columnsArr.length; i++) {
                if (columnsArr[i].footer) {
                    return true;
                }
            }
        }
        return false;
    };
    return TreeTable;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Array)
], TreeTable.prototype, "value", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TreeTable.prototype, "selectionMode", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TreeTable.prototype, "selection", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TreeTable.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TreeTable.prototype, "styleClass", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TreeTable.prototype, "labelExpand", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TreeTable.prototype, "labelCollapse", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TreeTable.prototype, "metaKeySelection", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TreeTable.prototype, "contextMenu", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], TreeTable.prototype, "toggleColumnIndex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TreeTable.prototype, "tableStyle", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TreeTable.prototype, "tableStyleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TreeTable.prototype, "onRowDblclick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TreeTable.prototype, "selectionChange", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TreeTable.prototype, "onNodeSelect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TreeTable.prototype, "onNodeUnselect", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TreeTable.prototype, "onNodeExpand", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TreeTable.prototype, "onNodeCollapse", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TreeTable.prototype, "onContextMenuSelect", void 0);
__decorate([
    core_1.ContentChild(shared_1.Header),
    __metadata("design:type", shared_1.Header)
], TreeTable.prototype, "header", void 0);
__decorate([
    core_1.ContentChild(shared_1.Footer),
    __metadata("design:type", shared_1.Footer)
], TreeTable.prototype, "footer", void 0);
__decorate([
    core_1.ContentChildren(shared_1.Column),
    __metadata("design:type", core_1.QueryList)
], TreeTable.prototype, "cols", void 0);
__decorate([
    core_1.ViewChild('tbl'),
    __metadata("design:type", core_1.ElementRef)
], TreeTable.prototype, "tableViewChild", void 0);
TreeTable = __decorate([
    core_1.Component({
        selector: 'p-treeTable',
        template: "\n        <div [ngClass]=\"'ui-treetable ui-widget'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"ui-treetable-header ui-widget-header\" *ngIf=\"header\">\n                <ng-content select=\"p-header\"></ng-content>\n            </div>\n            <div class=\"ui-treetable-tablewrapper\">\n                <table #tbl class=\"ui-widget-content\" [class]=\"tableStyleClass\" [ngStyle]=\"tableStyle\">\n                    <thead>\n                        <tr class=\"ui-state-default\">\n                            <th #headerCell *ngFor=\"let col of columns; let lastCol=last \"  [ngStyle]=\"col.style\" [class]=\"col.styleClass\" \n                                [ngClass]=\"'ui-state-default ui-unselectable-text'\">\n                                <span class=\"ui-column-title\" *ngIf=\"!col.headerTemplate\">{{col.header}}</span>\n                                <span class=\"ui-column-title\" *ngIf=\"col.headerTemplate\">\n                                    <p-columnHeaderTemplateLoader [column]=\"col\"></p-columnHeaderTemplateLoader>\n                                </span>\n                            </th>\n                        </tr>\n                    </thead>\n                    <tfoot *ngIf=\"hasFooter()\">\n                        <tr>\n                            <td *ngFor=\"let col of columns\" [ngStyle]=\"col.style\" [class]=\"col.styleClass\" [ngClass]=\"{'ui-state-default':true}\">\n                                <span class=\"ui-column-footer\" *ngIf=\"!col.footerTemplate\">{{col.footer}}</span>\n                                <span class=\"ui-column-footer\" *ngIf=\"col.footerTemplate\">\n                                    <p-columnFooterTemplateLoader [column]=\"col\"></p-columnFooterTemplateLoader>\n                                </span>\n                            </td>\n                        </tr>\n                    </tfoot>\n                    <tbody pTreeRow *ngFor=\"let node of value\" class=\"ui-treetable-data ui-widget-content\" [node]=\"node\" [level]=\"0\" [labelExpand]=\"labelExpand\" [labelCollapse]=\"labelCollapse\"></tbody>\n                </table>\n            </div>\n            \n            <div class=\"ui-treetable-footer ui-widget-header\" *ngIf=\"footer\">\n                <ng-content select=\"p-footer\"></ng-content>\n            </div>\n        </div>\n    ",
        providers: [domhandler_1.DomHandler]
    }),
    __metadata("design:paramtypes", [core_1.ElementRef, domhandler_1.DomHandler, core_1.ChangeDetectorRef, core_1.Renderer2])
], TreeTable);
exports.TreeTable = TreeTable;
var TreeTableModule = (function () {
    function TreeTableModule() {
    }
    return TreeTableModule;
}());
TreeTableModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule, shared_2.SharedModule],
        exports: [TreeTable, shared_2.SharedModule],
        declarations: [TreeTable, UITreeRow]
    })
], TreeTableModule);
exports.TreeTableModule = TreeTableModule;
//# sourceMappingURL=treetable.js.map

/***/ }),

/***/ "./node_modules/primeng/components/tristatecheckbox/tristatecheckbox.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(1);
var forms_1 = __webpack_require__(4);
exports.TRISTATECHECKBOX_VALUE_ACCESSOR = {
    provide: forms_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return TriStateCheckbox; }),
    multi: true
};
var TriStateCheckbox = (function () {
    function TriStateCheckbox(cd) {
        this.cd = cd;
        this.onChange = new core_1.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    TriStateCheckbox.prototype.onClick = function (event, input) {
        if (!this.disabled) {
            this.toggle(event);
            this.focus = true;
            input.focus();
        }
    };
    TriStateCheckbox.prototype.onKeydown = function (event) {
        if (event.keyCode == 32) {
            event.preventDefault();
        }
    };
    TriStateCheckbox.prototype.onKeyup = function (event) {
        if (event.keyCode == 32) {
            this.toggle(event);
            event.preventDefault();
        }
    };
    TriStateCheckbox.prototype.toggle = function (event) {
        if (this.value == null || this.value == undefined)
            this.value = true;
        else if (this.value == true)
            this.value = false;
        else if (this.value == false)
            this.value = null;
        this.onModelChange(this.value);
        this.onChange.emit({
            originalEvent: event,
            value: this.value
        });
    };
    TriStateCheckbox.prototype.onFocus = function () {
        this.focus = true;
    };
    TriStateCheckbox.prototype.onBlur = function () {
        this.focus = false;
        this.onModelTouched();
    };
    TriStateCheckbox.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    TriStateCheckbox.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    TriStateCheckbox.prototype.writeValue = function (value) {
        this.value = value;
        this.cd.markForCheck();
    };
    TriStateCheckbox.prototype.setDisabledState = function (disabled) {
        this.disabled = disabled;
    };
    return TriStateCheckbox;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], TriStateCheckbox.prototype, "disabled", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TriStateCheckbox.prototype, "name", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], TriStateCheckbox.prototype, "tabindex", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TriStateCheckbox.prototype, "inputId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], TriStateCheckbox.prototype, "style", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], TriStateCheckbox.prototype, "styleClass", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], TriStateCheckbox.prototype, "onChange", void 0);
TriStateCheckbox = __decorate([
    core_1.Component({
        selector: 'p-triStateCheckbox',
        template: "\n        <div [ngStyle]=\"style\" [ngClass]=\"'ui-chkbox ui-tristatechkbox ui-widget'\" [class]=\"styleClass\">\n            <div class=\"ui-helper-hidden-accessible\">\n                <input #input type=\"text\" [attr.id]=\"inputId\" [name]=\"name\" [attr.tabindex]=\"tabindex\" readonly [disabled]=\"disabled\" (keyup)=\"onKeyup($event)\" (keydown)=\"onKeydown($event)\" (focus)=\"onFocus()\" (blur)=\"onBlur()\">\n            </div>\n            <div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\" (click)=\"onClick($event,input)\"\n                [ngClass]=\"{'ui-state-active':value!=null,'ui-state-disabled':disabled,'ui-state-focus':focus}\">\n                <span class=\"ui-chkbox-icon fa ui-clickable\" [ngClass]=\"{'fa-check':value==true,'fa-close':value==false}\"></span>\n            </div>\n        </div>\n    ",
        providers: [exports.TRISTATECHECKBOX_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [core_1.ChangeDetectorRef])
], TriStateCheckbox);
exports.TriStateCheckbox = TriStateCheckbox;
var TriStateCheckboxModule = (function () {
    function TriStateCheckboxModule() {
    }
    return TriStateCheckboxModule;
}());
TriStateCheckboxModule = __decorate([
    core_1.NgModule({
        imports: [common_1.CommonModule],
        exports: [TriStateCheckbox],
        declarations: [TriStateCheckbox]
    })
], TriStateCheckboxModule);
exports.TriStateCheckboxModule = TriStateCheckboxModule;
//# sourceMappingURL=tristatecheckbox.js.map

/***/ }),

/***/ "./node_modules/primeng/components/utils/objectutils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var ObjectUtils = (function () {
    function ObjectUtils() {
    }
    ObjectUtils.prototype.equals = function (obj1, obj2, field) {
        if (field)
            return (this.resolveFieldData(obj1, field) === this.resolveFieldData(obj2, field));
        else
            return this.equalsByValue(obj1, obj2);
    };
    ObjectUtils.prototype.equalsByValue = function (obj1, obj2) {
        if (obj1 == null && obj2 == null) {
            return true;
        }
        if (obj1 == null || obj2 == null) {
            return false;
        }
        if (obj1 == obj2) {
            delete obj1._$visited;
            return true;
        }
        if (typeof obj1 == 'object' && typeof obj2 == 'object') {
            obj1._$visited = true;
            for (var p in obj1) {
                if (p === "_$visited")
                    continue;
                if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p)) {
                    return false;
                }
                switch (typeof (obj1[p])) {
                    case 'object':
                        if (obj1[p] && obj1[p]._$visited || !this.equals(obj1[p], obj2[p]))
                            return false;
                        break;
                    case 'function':
                        if (typeof (obj2[p]) == 'undefined' || (p != 'compare' && obj1[p].toString() != obj2[p].toString()))
                            return false;
                        break;
                    default:
                        if (obj1[p] != obj2[p])
                            return false;
                        break;
                }
            }
            for (var p in obj2) {
                if (typeof (obj1[p]) == 'undefined')
                    return false;
            }
            delete obj1._$visited;
            return true;
        }
        return false;
    };
    ObjectUtils.prototype.resolveFieldData = function (data, field) {
        if (data && field) {
            if (field.indexOf('.') == -1) {
                return data[field];
            }
            else {
                var fields = field.split('.');
                var value = data;
                for (var i = 0, len = fields.length; i < len; ++i) {
                    if (value == null) {
                        return null;
                    }
                    value = value[fields[i]];
                }
                return value;
            }
        }
        else {
            return null;
        }
    };
    ObjectUtils.prototype.filter = function (value, fields, filterValue) {
        var filteredItems = [];
        if (value) {
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var item = value_1[_i];
                for (var _a = 0, fields_1 = fields; _a < fields_1.length; _a++) {
                    var field = fields_1[_a];
                    if (String(this.resolveFieldData(item, field)).toLowerCase().indexOf(filterValue.toLowerCase()) > -1) {
                        filteredItems.push(item);
                        break;
                    }
                }
            }
        }
        return filteredItems;
    };
    ObjectUtils.prototype.reorderArray = function (value, from, to) {
        var target;
        if (value && (from !== to)) {
            if (to >= value.length) {
                target = to - value.length;
                while ((target--) + 1) {
                    value.push(undefined);
                }
            }
            value.splice(to, 0, value.splice(from, 1)[0]);
        }
    };
    return ObjectUtils;
}());
ObjectUtils = __decorate([
    core_1.Injectable()
], ObjectUtils);
exports.ObjectUtils = ObjectUtils;
//# sourceMappingURL=objectutils.js.map

/***/ }),

/***/ "./node_modules/primeng/primeng.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Shorthand */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("./node_modules/primeng/components/common/api.js"));
__export(__webpack_require__("./node_modules/primeng/components/common/shared.js"));
__export(__webpack_require__("./node_modules/primeng/components/accordion/accordion.js"));
__export(__webpack_require__("./node_modules/primeng/components/autocomplete/autocomplete.js"));
__export(__webpack_require__("./node_modules/primeng/components/blockui/blockui.js"));
__export(__webpack_require__("./node_modules/primeng/components/breadcrumb/breadcrumb.js"));
__export(__webpack_require__("./node_modules/primeng/components/button/button.js"));
__export(__webpack_require__("./node_modules/primeng/components/captcha/captcha.js"));
__export(__webpack_require__("./node_modules/primeng/components/calendar/calendar.js"));
__export(__webpack_require__("./node_modules/primeng/components/carousel/carousel.js"));
__export(__webpack_require__("./node_modules/primeng/components/chart/chart.js"));
__export(__webpack_require__("./node_modules/primeng/components/checkbox/checkbox.js"));
__export(__webpack_require__("./node_modules/primeng/components/chips/chips.js"));
__export(__webpack_require__("./node_modules/primeng/components/codehighlighter/codehighlighter.js"));
__export(__webpack_require__("./node_modules/primeng/components/colorpicker/colorpicker.js"));
__export(__webpack_require__("./node_modules/primeng/components/contextmenu/contextmenu.js"));
__export(__webpack_require__("./node_modules/primeng/components/datagrid/datagrid.js"));
__export(__webpack_require__("./node_modules/primeng/components/datalist/datalist.js"));
__export(__webpack_require__("./node_modules/primeng/components/datascroller/datascroller.js"));
__export(__webpack_require__("./node_modules/primeng/components/datatable/datatable.js"));
__export(__webpack_require__("./node_modules/primeng/components/defer/defer.js"));
__export(__webpack_require__("./node_modules/primeng/components/confirmdialog/confirmdialog.js"));
__export(__webpack_require__("./node_modules/primeng/components/dialog/dialog.js"));
__export(__webpack_require__("./node_modules/primeng/components/dragdrop/dragdrop.js"));
__export(__webpack_require__("./node_modules/primeng/components/dropdown/dropdown.js"));
__export(__webpack_require__("./node_modules/primeng/components/editor/editor.js"));
__export(__webpack_require__("./node_modules/primeng/components/fieldset/fieldset.js"));
__export(__webpack_require__("./node_modules/primeng/components/fileupload/fileupload.js"));
__export(__webpack_require__("./node_modules/primeng/components/galleria/galleria.js"));
__export(__webpack_require__("./node_modules/primeng/components/gmap/gmap.js"));
__export(__webpack_require__("./node_modules/primeng/components/growl/growl.js"));
__export(__webpack_require__("./node_modules/primeng/components/inplace/inplace.js"));
__export(__webpack_require__("./node_modules/primeng/components/inputmask/inputmask.js"));
__export(__webpack_require__("./node_modules/primeng/components/inputswitch/inputswitch.js"));
__export(__webpack_require__("./node_modules/primeng/components/inputtext/inputtext.js"));
__export(__webpack_require__("./node_modules/primeng/components/inputtextarea/inputtextarea.js"));
__export(__webpack_require__("./node_modules/primeng/components/lightbox/lightbox.js"));
__export(__webpack_require__("./node_modules/primeng/components/listbox/listbox.js"));
__export(__webpack_require__("./node_modules/primeng/components/megamenu/megamenu.js"));
__export(__webpack_require__("./node_modules/primeng/components/menu/menu.js"));
__export(__webpack_require__("./node_modules/primeng/components/menubar/menubar.js"));
__export(__webpack_require__("./node_modules/primeng/components/messages/messages.js"));
__export(__webpack_require__("./node_modules/primeng/components/multiselect/multiselect.js"));
__export(__webpack_require__("./node_modules/primeng/components/orderlist/orderlist.js"));
__export(__webpack_require__("./node_modules/primeng/components/organizationchart/organizationchart.js"));
__export(__webpack_require__("./node_modules/primeng/components/overlaypanel/overlaypanel.js"));
__export(__webpack_require__("./node_modules/primeng/components/paginator/paginator.js"));
__export(__webpack_require__("./node_modules/primeng/components/panel/panel.js"));
__export(__webpack_require__("./node_modules/primeng/components/panelmenu/panelmenu.js"));
__export(__webpack_require__("./node_modules/primeng/components/password/password.js"));
__export(__webpack_require__("./node_modules/primeng/components/picklist/picklist.js"));
__export(__webpack_require__("./node_modules/primeng/components/progressbar/progressbar.js"));
__export(__webpack_require__("./node_modules/primeng/components/radiobutton/radiobutton.js"));
__export(__webpack_require__("./node_modules/primeng/components/rating/rating.js"));
__export(__webpack_require__("./node_modules/primeng/components/schedule/schedule.js"));
__export(__webpack_require__("./node_modules/primeng/components/selectbutton/selectbutton.js"));
__export(__webpack_require__("./node_modules/primeng/components/slidemenu/slidemenu.js"));
__export(__webpack_require__("./node_modules/primeng/components/slider/slider.js"));
__export(__webpack_require__("./node_modules/primeng/components/spinner/spinner.js"));
__export(__webpack_require__("./node_modules/primeng/components/splitbutton/splitbutton.js"));
__export(__webpack_require__("./node_modules/primeng/components/steps/steps.js"));
__export(__webpack_require__("./node_modules/primeng/components/tabview/tabview.js"));
__export(__webpack_require__("./node_modules/primeng/components/tabmenu/tabmenu.js"));
__export(__webpack_require__("./node_modules/primeng/components/terminal/terminal.js"));
__export(__webpack_require__("./node_modules/primeng/components/tieredmenu/tieredmenu.js"));
__export(__webpack_require__("./node_modules/primeng/components/togglebutton/togglebutton.js"));
__export(__webpack_require__("./node_modules/primeng/components/toolbar/toolbar.js"));
__export(__webpack_require__("./node_modules/primeng/components/tooltip/tooltip.js"));
__export(__webpack_require__("./node_modules/primeng/components/tree/tree.js"));
__export(__webpack_require__("./node_modules/primeng/components/treetable/treetable.js"));
__export(__webpack_require__("./node_modules/primeng/components/tristatecheckbox/tristatecheckbox.js"));

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = __extends;
/* unused harmony export __assign */
/* unused harmony export __rest */
/* unused harmony export __decorate */
/* unused harmony export __param */
/* unused harmony export __metadata */
/* unused harmony export __awaiter */
/* unused harmony export __generator */
/* unused harmony export __exportStar */
/* unused harmony export __values */
/* unused harmony export __read */
/* unused harmony export __spread */
/* unused harmony export __await */
/* unused harmony export __asyncGenerator */
/* unused harmony export __asyncDelegator */
/* unused harmony export __asyncValues */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator];
    return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
}

/***/ }),

/***/ "./src/app/app.component.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var AppComponent = (function () {
    function AppComponent() {
        this.name = 'Angular';
    }
    return AppComponent;
}());
AppComponent = __decorate([
    core_1.Component({
        selector: 'my-app',
        template: "\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n        <h1>Hello {{name}}</h1>\n        <p-calendar [(ngModel)]=\"value\"></p-calendar>\n      </div>\n    </div>  \n  </div>\n  "
    })
], AppComponent);
exports.AppComponent = AppComponent;


/***/ }),

/***/ "./src/app/app.module.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(0);
var forms_1 = __webpack_require__(4);
var animations_1 = __webpack_require__("./node_modules/@angular/platform-browser/@angular/platform-browser/animations.es5.js");
var primeng_1 = __webpack_require__("./node_modules/primeng/primeng.js");
var app_component_1 = __webpack_require__("./src/app/app.component.ts");
var AppModule = (function () {
    function AppModule() {
    }
    return AppModule;
}());
AppModule = __decorate([
    core_1.NgModule({
        imports: [animations_1.BrowserAnimationsModule, forms_1.FormsModule, primeng_1.CalendarModule],
        declarations: [app_component_1.AppComponent],
        bootstrap: [app_component_1.AppComponent]
    })
], AppModule);
exports.AppModule = AppModule;


/***/ }),

/***/ "./src/main.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var platform_browser_dynamic_1 = __webpack_require__(9);
var app_module_1 = __webpack_require__("./src/app/app.module.ts");
platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);


/***/ }),

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(6))(12);

/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(6))(24);

/***/ }),

/***/ 10:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(6))(88);

/***/ }),

/***/ 13:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/webpack-dev-server/client/index.js?http:/localhost:8080");
__webpack_require__("./node_modules/webpack/hot/dev-server.js");
module.exports = __webpack_require__("./src/main.ts");


/***/ }),

/***/ 4:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(6))(84);

/***/ }),

/***/ 5:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(6))(87);

/***/ }),

/***/ 7:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(6))(16);

/***/ }),

/***/ 8:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(6))(4);

/***/ }),

/***/ 9:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(6))(86);

/***/ })

},[13]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL2FuaW1hdGlvbnMvQGFuZ3VsYXIvYW5pbWF0aW9ucy5lczUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9hbmltYXRpb25zL0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3Nlci5lczUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucy5lczUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9hdXRvY29tcGxldGUvYXV0b2NvbXBsZXRlLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2Jsb2NrdWkvYmxvY2t1aS5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9icmVhZGNydW1iL2JyZWFkY3J1bWIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jYWxlbmRhci9jYWxlbmRhci5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jYXB0Y2hhL2NhcHRjaGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvY2Fyb3VzZWwvY2Fyb3VzZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvY2hhcnQvY2hhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvY2hlY2tib3gvY2hlY2tib3guanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvY2hpcHMvY2hpcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvY29kZWhpZ2hsaWdodGVyL2NvZGVoaWdobGlnaHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jb2xvcnBpY2tlci9jb2xvcnBpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jb21tb24vYXBpLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2NvbW1vbi9jb25maXJtYXRpb25zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2NvbW1vbi9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvY29tbW9uL3RyZWVkcmFnZHJvcHNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvY29uZmlybWRpYWxvZy9jb25maXJtZGlhbG9nLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2NvbnRleHRtZW51L2NvbnRleHRtZW51LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2RhdGFncmlkL2RhdGFncmlkLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2RhdGFsaXN0L2RhdGFsaXN0LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2RhdGFzY3JvbGxlci9kYXRhc2Nyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvZGF0YXRhYmxlL2RhdGF0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9kZWZlci9kZWZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9kaWFsb2cvZGlhbG9nLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2RvbS9kb21oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2RyYWdkcm9wL2RyYWdkcm9wLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2Ryb3Bkb3duL2Ryb3Bkb3duLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2VkaXRvci9lZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvZmllbGRzZXQvZmllbGRzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvZmlsZXVwbG9hZC9maWxldXBsb2FkLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2dhbGxlcmlhL2dhbGxlcmlhLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2dtYXAvZ21hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9ncm93bC9ncm93bC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9pbnBsYWNlL2lucGxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvaW5wdXRtYXNrL2lucHV0bWFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9pbnB1dHN3aXRjaC9pbnB1dHN3aXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9pbnB1dHRleHQvaW5wdXR0ZXh0LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL2lucHV0dGV4dGFyZWEvaW5wdXR0ZXh0YXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9saWdodGJveC9saWdodGJveC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9saXN0Ym94L2xpc3Rib3guanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvbWVnYW1lbnUvbWVnYW1lbnUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvbWVudS9tZW51LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL21lbnViYXIvbWVudWJhci5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9tZXNzYWdlcy9tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9tdWx0aXNlbGVjdC9tdWx0aXNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9vcmRlcmxpc3Qvb3JkZXJsaXN0LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL29yZ2FuaXphdGlvbmNoYXJ0L29yZ2FuaXphdGlvbmNoYXJ0LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL292ZXJsYXlwYW5lbC9vdmVybGF5cGFuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvcGFnaW5hdG9yL3BhZ2luYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9wYW5lbC9wYW5lbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9wYW5lbG1lbnUvcGFuZWxtZW51LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3Bhc3N3b3JkL3Bhc3N3b3JkLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3BpY2tsaXN0L3BpY2tsaXN0LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3JhZGlvYnV0dG9uL3JhZGlvYnV0dG9uLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3JhdGluZy9yYXRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvc2NoZWR1bGUvc2NoZWR1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvc2VsZWN0YnV0dG9uL3NlbGVjdGJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy9zbGlkZW1lbnUvc2xpZGVtZW51LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3NwbGl0YnV0dG9uL3NwbGl0YnV0dG9uLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3N0ZXBzL3N0ZXBzLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3RhYm1lbnUvdGFibWVudS5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy90YWJ2aWV3L3RhYnZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvdGVybWluYWwvdGVybWluYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvdGllcmVkbWVudS90aWVyZWRtZW51LmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3RvZ2dsZWJ1dHRvbi90b2dnbGVidXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvdG9vbGJhci90b29sYmFyLmpzIiwid2VicGFjazovLy8uL34vcHJpbWVuZy9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy90cmVlL3RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvdHJlZXRhYmxlL3RyZWV0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaW1lbmcvY29tcG9uZW50cy90cmlzdGF0ZWNoZWNrYm94L3RyaXN0YXRlY2hlY2tib3guanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL2NvbXBvbmVudHMvdXRpbHMvb2JqZWN0dXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmltZW5nL3ByaW1lbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi90c2xpYi90c2xpYi5lczYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9hcHAuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi50cyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvQGFuZ3VsYXIvY29yZS5lczUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9AYW5ndWxhci9jb21tb24uZXM1LmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Zvcm1zL0Bhbmd1bGFyL2Zvcm1zLmVzNS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcm91dGVyL0Bhbmd1bGFyL3JvdXRlci5lczUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci5lczUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy5lczUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvciJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RSxtREFBbUQsS0FBSztBQUN4RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQiw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlDQUF5QztBQUN2Riw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLENBQUM7QUFDRDtBQUNBLHVEQUF1RDtBQUN2RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCLEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsdUJBQXVCLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0M7Ozs7Ozs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0Esa0VBQWtFLDBCQUEwQjtBQUM1RjtBQUNBLCtCQUErQjtBQUMvQix1SUFBdUk7QUFDdkk7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQsK0JBQStCO0FBQy9CLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4SUFBOEksNkJBQTZCO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw2REFBNkQsMExBQTBMLFlBQVksNEtBQTRLLDJEQUEyRCw0TUFBNE0sOENBQThDLDBSQUEwUiwyQkFBMkIsMkJBQTJCLHFXQUFxVyxVQUFVLGljQUFpYyxVQUFVO0FBQ3g2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQzs7Ozs7Ozs7QUN4VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhEQUE4RDtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUM7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNEJBQTRCLEVBQUU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsb0JBQW9CLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEIsdURBQXVEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHNIQUFzSCwrS0FBK0ssOEJBQThCLDJSQUEyUiw0SEFBNEg7QUFDcHpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Qzs7Ozs7Ozs7QUNyZUE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0M7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDOzs7Ozs7OztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDOzs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMEdBQTBHLDZXQUE2VyxRQUFRLDREQUE0RCxzRUFBc0U7QUFDaHBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDOzs7Ozs7OztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkdBQTJHLDJUQUEyVCw4R0FBOEcsb1hBQW9YLHlFQUF5RSwrVkFBK1YsYUFBYSw0TkFBNE4sWUFBWSw2R0FBNkcseUVBQXlFLCtWQUErVixhQUFhO0FBQ3JuRTtBQUNBLEtBQUs7QUFDTCw0REFBNEQsb0JBQW9CLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDOzs7Ozs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esby9CQUFvL0IsY0FBYztBQUNsZ0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DOzs7Ozs7OztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvRUFBb0UsZ3JCQUFnckIsMkJBQTJCLG1GQUFtRixjQUFjLG1IQUFtSCxjQUFjO0FBQ2hpQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0M7Ozs7Ozs7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9FQUFvRSxrVEFBa1QsMkJBQTJCO0FBQzViO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdD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QUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLG1FQUFtRSxFQUFFO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQ0FBK0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpREFBaUQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpREFBaUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSw2S0FBNkssdzdEQUF3N0Qsc0dBQXNHLGtQQUFrUCwwQkFBMEIsaUpBQWlKLHlCQUF5Qix5SkFBeUoscURBQXFELHlMQUF5TCw0Q0FBNEMsdzFCQUF3MUIsZUFBZSxzSEFBc0gsZUFBZTtBQUN4cUk7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDOzs7Ozs7OztBQ2xyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5SEFBeUgsdWlCQUF1aUIsUUFBUSxnT0FBZ08sc0VBQXNFLHNxQkFBc3FCO0FBQzlxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0M7Ozs7Ozs7O0FDcmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDJEQUEyRDtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDJEQUEyRDtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7O0FDOVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQzs7Ozs7Ozs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlCQUFpQixFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0M7Ozs7Ozs7O0FDcFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQStDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2REFBNkQseVBBQXlQLHVEQUF1RCxrQ0FBa0Msb1VBQW9VLHFDQUFxQywwTUFBME0sMkJBQTJCLDBDQUEwQyxtaUNBQW1pQyw0QkFBNEIsVUFBVSwwQkFBMEI7QUFDenBFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DOzs7Ozs7OztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDBCQUEwQixFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDOzs7Ozs7OztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQSxxRUFBcUUsbUJBQW1CLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsNEJBQTRCLDhCQUE4QixFQUFFLEVBQUU7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseU1BQXlNLGdKQUFnSiwwTkFBME4sNlJBQTZSLGlNQUFpTSw0SEFBNEgsYUFBYSxnSkFBZ0o7QUFDMXlDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDOzs7Ozs7OztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNk5BQTZOLDZCQUE2QjtBQUMxUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DOzs7Ozs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQixFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUEwQyxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7QUNsakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0IsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdLQUF3SyxzTUFBc00sVUFBVSxxSUFBcUksU0FBUywyREFBMkQsd0VBQXdFO0FBQ3hyQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Qzs7Ozs7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDOzs7Ozs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLGVBQWUsNGtCQUE0a0IsK0JBQStCLDBaQUEwWixnQ0FBZ0MseXFCQUF5cUIsaUNBQWlDLHdQQUF3UCxhQUFhO0FBQzFwRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQzs7Ozs7Ozs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0IsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsb0VBQW9FLEVBQUU7QUFDN0g7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Qzs7Ozs7Ozs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNB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QzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DOzs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDhCQUE4QiwyTUFBMk0sMkZBQTJGLDJEQUEyRDtBQUNsYztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0M7Ozs7Ozs7OzhDQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7QUNsZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QscUJBQXFCLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2Q0FBNkM7QUFDeEY7QUFDQTtBQUNBLDJDQUEyQywyQ0FBMkM7QUFDdEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixvT0FBb08seUpBQXlKLDhFQUE4RSwwSkFBMEosNEJBQTRCLCtVQUErVSw4SEFBOEgscVZBQXFWLDZCQUE2QixnQkFBZ0IseUNBQXlDLHFWQUFxViw2QkFBNkIsZ0JBQWdCLHlDQUF5QztBQUM5L0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0M7Ozs7Ozs7O0FDL1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQixFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa3NCQUFrc0Isc0hBQXNILGdVQUFnVSx3SEFBd0g7QUFDaHZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDBFQUEwRSx1ckNBQXVyQyxrQ0FBa0MsdU9BQXVPLFlBQVksOE9BQThPLGtDQUFrQyx1T0FBdU8sWUFBWTtBQUNubEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDOzs7Ozs7OztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMEVBQTBFLGtJQUFrSSxxRkFBcUYsNktBQTZLLDRPQUE0TyxPQUFPLGtFQUFrRSxZQUFZLHlOQUF5TixZQUFZLCtKQUErSixPQUFPLGtFQUFrRSxZQUFZO0FBQ3Z4QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDOzs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNXQUFzVyx1TEFBdUwsNldBQTZXLFlBQVksME5BQTBOLFlBQVksZ1NBQWdTLFlBQVk7QUFDeDZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZNQUE2TSx1RkFBdUYsd1hBQXdYLFlBQVk7QUFDeHFCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNEhBQTRIO0FBQzNLO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDOzs7Ozs7OztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHVYQUF1WCxvZUFBb2UsK0VBQStFO0FBQ3o5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0M7Ozs7Ozs7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DOzs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYyxFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUM7Ozs7Ozs7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5QkFBeUI7QUFDdEY7QUFDQSxpRUFBaUUseUJBQXlCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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NkM7QUFFN0MsaURBQXNCLEVBQUUsQ0FBQyxlQUFlLENBQUMsc0JBQVMsQ0FBQyxDQUFDOzs7Ozs7OztBQ0pwRCw4Qzs7Ozs7OztBQ0FBLDhDOzs7Ozs7O0FDQUEsOEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUEsOEM7Ozs7Ozs7QUNBQSw4Qzs7Ozs7OztBQ0FBLDhDOzs7Ozs7O0FDQUEsNkM7Ozs7Ozs7QUNBQSw4QyIsImZpbGUiOiJtYWluLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NC4zLjNcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuaW1hdGlvbkJ1aWxkZXIgaXMgYW4gaW5qZWN0YWJsZSBzZXJ2aWNlIHRoYXQgaXMgYXZhaWxhYmxlIHdoZW4gdGhlIHtcXEBsaW5rXG4gKiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSBCcm93c2VyQW5pbWF0aW9uc01vZHVsZX0gb3Ige1xcQGxpbmsgTm9vcEFuaW1hdGlvbnNNb2R1bGVcbiAqIE5vb3BBbmltYXRpb25zTW9kdWxlfSBtb2R1bGVzIGFyZSB1c2VkIHdpdGhpbiBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBUaGUgcHVycG9zZSBpZiB0aGlzIHNlcnZpY2UgaXMgdG8gcHJvZHVjZSBhbiBhbmltYXRpb24gc2VxdWVuY2UgcHJvZ3JhbW1hdGljYWxseSB3aXRoaW4gYW5cbiAqIGFuZ3VsYXIgY29tcG9uZW50IG9yIGRpcmVjdGl2ZS5cbiAqXG4gKiBQcm9ncmFtbWF0aWMgYW5pbWF0aW9ucyBhcmUgZmlyc3QgYnVpbHQgYW5kIHRoZW4gYSBwbGF5ZXIgaXMgY3JlYXRlZCB3aGVuIHRoZSBidWlsZCBhbmltYXRpb24gaXNcbiAqIGF0dGFjaGVkIHRvIGFuIGVsZW1lbnQuXG4gKlxuICogYGBgdHNcbiAqIC8vIHJlbWVtYmVyIHRvIGluY2x1ZGUgdGhlIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlIG1vZHVsZSBmb3IgdGhpcyB0byB3b3JrLi4uXG4gKiBpbXBvcnQge0FuaW1hdGlvbkJ1aWxkZXJ9IGZyb20gJ1xcQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG4gKlxuICogY2xhc3MgTXlDbXAge1xuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9idWlsZGVyOiBBbmltYXRpb25CdWlsZGVyKSB7fVxuICpcbiAqICAgbWFrZUFuaW1hdGlvbihlbGVtZW50OiBhbnkpIHtcbiAqICAgICAvLyBmaXJzdCBidWlsZCB0aGUgYW5pbWF0aW9uXG4gKiAgICAgY29uc3QgbXlBbmltYXRpb24gPSB0aGlzLl9idWlsZGVyLmJ1aWxkKFtcbiAqICAgICAgIHN0eWxlKHsgd2lkdGg6IDAgfSksXG4gKiAgICAgICBhbmltYXRlKDEwMDAsIHN0eWxlKHsgd2lkdGg6ICcxMDBweCcgfSkpXG4gKiAgICAgXSk7XG4gKlxuICogICAgIC8vIHRoZW4gY3JlYXRlIGEgcGxheWVyIGZyb20gaXRcbiAqICAgICBjb25zdCBwbGF5ZXIgPSBteUFuaW1hdGlvbi5jcmVhdGUoZWxlbWVudCk7XG4gKlxuICogICAgIHBsYXllci5wbGF5KCk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdoZW4gYW4gYW5pbWF0aW9uIGlzIGJ1aWx0IGFuIGluc3RhbmNlIG9mIHtcXEBsaW5rIEFuaW1hdGlvbkZhY3RvcnkgQW5pbWF0aW9uRmFjdG9yeX0gd2lsbCBiZVxuICogcmV0dXJuZWQuIFVzaW5nIHRoYXQgYW4ge1xcQGxpbmsgQW5pbWF0aW9uUGxheWVyIEFuaW1hdGlvblBsYXllcn0gY2FuIGJlIGNyZWF0ZWQgd2hpY2ggY2FuIHRoZW4gYmVcbiAqIHVzZWQgdG8gc3RhcnQgdGhlIGFuaW1hdGlvbi5cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBBbmltYXRpb25CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25CdWlsZGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7IH07XG4gICAgcmV0dXJuIEFuaW1hdGlvbkJ1aWxkZXI7XG59KCkpO1xuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBgQW5pbWF0aW9uRmFjdG9yeWAgaXMgcmV0dXJuZWQgZnJvbSB7XFxAbGluayBBbmltYXRpb25CdWlsZGVyI2J1aWxkXG4gKiBBbmltYXRpb25CdWlsZGVyLmJ1aWxkfS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBBbmltYXRpb25GYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25GYWN0b3J5KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25GYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykgeyB9O1xuICAgIHJldHVybiBBbmltYXRpb25GYWN0b3J5O1xufSgpKTtcbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xudmFyIEFVVE9fU1RZTEUgPSAnKic7XG4vKipcbiAqIGB0cmlnZ2VyYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gKiB7XFxAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucyBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YSBwYWdlfSB0byBnYWluIGEgYmV0dGVyXG4gKiB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIgYXJlIHVzZWQuXG4gKlxuICogYHRyaWdnZXJgIENyZWF0ZXMgYW4gYW5pbWF0aW9uIHRyaWdnZXIgd2hpY2ggd2lsbCBhIGxpc3Qgb2Yge1xcQGxpbmsgc3RhdGUgc3RhdGV9IGFuZFxuICoge1xcQGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9ufSBlbnRyaWVzIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgd2hlbiB0aGUgZXhwcmVzc2lvblxuICogYm91bmQgdG8gdGhlIHRyaWdnZXIgY2hhbmdlcy5cbiAqXG4gKiBUcmlnZ2VycyBhcmUgcmVnaXN0ZXJlZCB3aXRoaW4gdGhlIGNvbXBvbmVudCBhbm5vdGF0aW9uIGRhdGEgdW5kZXIgdGhlXG4gKiB7XFxAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucyBhbmltYXRpb25zIHNlY3Rpb259LiBBbiBhbmltYXRpb24gdHJpZ2dlciBjYW4gYmUgcGxhY2VkIG9uIGFuIGVsZW1lbnRcbiAqIHdpdGhpbiBhIHRlbXBsYXRlIGJ5IHJlZmVyZW5jaW5nIHRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyIGZvbGxvd2VkIGJ5IHRoZSBleHByZXNzaW9uIHZhbHVlIHRoYXRcbiAqIHRoZVxuICogdHJpZ2dlciBpcyBib3VuZCB0byAoaW4gdGhlIGZvcm0gb2YgYFtcXEB0cmlnZ2VyTmFtZV09XCJleHByZXNzaW9uXCJgLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIGB0cmlnZ2VyYCB3aWxsIGNyZWF0ZSBhbiBhbmltYXRpb24gdHJpZ2dlciByZWZlcmVuY2UgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGBuYW1lYCB2YWx1ZS4gVGhlXG4gKiBwcm92aWRlZCBgYW5pbWF0aW9uYCB2YWx1ZSBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheSBjb25zaXN0aW5nIG9mIHtcXEBsaW5rIHN0YXRlIHN0YXRlfSBhbmRcbiAqIHtcXEBsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn0gZGVjbGFyYXRpb25zLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIFxcQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcbiAqICAgdGVtcGxhdGVVcmw6ICdteS1jb21wb25lbnQtdHBsLmh0bWwnLFxuICogICBhbmltYXRpb25zOiBbXG4gKiAgICAgdHJpZ2dlcihcIm15QW5pbWF0aW9uVHJpZ2dlclwiLCBbXG4gKiAgICAgICBzdGF0ZSguLi4pLFxuICogICAgICAgc3RhdGUoLi4uKSxcbiAqICAgICAgIHRyYW5zaXRpb24oLi4uKSxcbiAqICAgICAgIHRyYW5zaXRpb24oLi4uKVxuICogICAgIF0pXG4gKiAgIF1cbiAqIH0pXG4gKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKiAgIG15U3RhdHVzRXhwID0gXCJzb21ldGhpbmdcIjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb21wb25lbnQgd2lsbCBtYWtlIHVzZSBvZiB0aGUgYG15QW5pbWF0aW9uVHJpZ2dlcmAgYW5pbWF0aW9uXG4gKiB0cmlnZ2VyIGJ5IGJpbmRpbmcgdG8gYW4gZWxlbWVudCB3aXRoaW4gaXRzIHRlbXBsYXRlIGNvZGUuXG4gKlxuICogYGBgaHRtbFxuICogPCEtLSBzb21ld2hlcmUgaW5zaWRlIG9mIG15LWNvbXBvbmVudC10cGwuaHRtbCAtLT5cbiAqIDxkaXYgW1xcQG15QW5pbWF0aW9uVHJpZ2dlcl09XCJteVN0YXR1c0V4cFwiPi4uLjwvZGl2PlxuICogYGBgXG4gKlxuICogIyMgRGlzYWJsZSBDaGlsZCBBbmltYXRpb25zXG4gKiBBIHNwZWNpYWwgYW5pbWF0aW9uIGNvbnRyb2wgYmluZGluZyBjYWxsZWQgYFxcQC5kaXNhYmxlZGAgY2FuIGJlIHBsYWNlZCBvbiBhbiBlbGVtZW50IHdoaWNoIHdpbGxcbiAqIHRoZW4gZGlzYWJsZSBhbmltYXRpb25zIGZvciBhbnkgaW5uZXIgYW5pbWF0aW9uIHRyaWdnZXJzIHNpdHVhdGVkIHdpdGhpbiB0aGUgZWxlbWVudC5cbiAqXG4gKiBXaGVuIHRydWUsIHRoZSBgXFxALmRpc2FibGVkYCBiaW5kaW5nIHdpbGwgcHJldmVudCBpbm5lciBhbmltYXRpb25zIGZyb20gcmVuZGVyaW5nLiBUaGUgZXhhbXBsZVxuICogYmVsb3cgc2hvd3MgaG93IHRvIHVzZSB0aGlzIGZlYXR1cmU6XG4gKlxuICogYGBgdHNcbiAqIFxcQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8ZGl2IFtcXEAuZGlzYWJsZWRdPVwiaXNEaXNhYmxlZFwiPlxuICogICAgICAgPGRpdiBbXFxAY2hpbGRBbmltYXRpb25dPVwiZXhwXCI+PC9kaXY+XG4gKiAgICAgPC9kaXY+XG4gKiAgIGAsXG4gKiAgIGFuaW1hdGlvbnM6IFtcbiAqICAgICB0cmlnZ2VyKFwiY2hpbGRBbmltYXRpb25cIiwgW1xuICogICAgICAgLy8gLi4uXG4gKiAgICAgXSlcbiAqICAgXVxuICogfSlcbiAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgaXNEaXNhYmxlZCA9IHRydWU7XG4gKiAgIGV4cCA9ICcuLi4nO1xuICogfVxuICogYGBgXG4gKlxuICogVGhlIGBcXEBjaGlsZEFuaW1hdGlvbmAgdHJpZ2dlciB3aWxsIG5vdCBhbmltYXRlIGJlY2F1c2UgYFxcQC5kaXNhYmxlZGAgcHJldmVudHMgaXQgZnJvbSBoYXBwZW5pbmdcbiAqICh3aGVuIHRydWUpLlxuICpcbiAqIE5vdGUgdGhhdCBgXFxALmRpc2JsZWRgIHdpbGwgb25seSBkaXNhYmxlIGlubmVyIGFuaW1hdGlvbnMgKGFueSBhbmltYXRpb25zIHJ1bm5pbmcgb24gdGhlIHNhbWVcbiAqIGVsZW1lbnQgd2lsbCBub3QgYmUgZGlzYWJsZWQpLlxuICpcbiAqICMjIyBEaXNhYmxpbmcgQW5pbWF0aW9ucyBBcHBsaWNhdGlvbi13aWRlXG4gKiBXaGVuIGFuIGFyZWEgb2YgdGhlIHRlbXBsYXRlIGlzIHNldCB0byBoYXZlIGFuaW1hdGlvbnMgZGlzYWJsZWQsICoqYWxsKiogaW5uZXIgY29tcG9uZW50cyB3aWxsXG4gKiBhbHNvIGhhdmUgdGhlaXIgYW5pbWF0aW9ucyBkaXNhYmxlZCBhcyB3ZWxsLiBUaGlzIG1lYW5zIHRoYXQgYWxsIGFuaW1hdGlvbnMgZm9yIGFuIGFuZ3VsYXJcbiAqIGFwcGxpY2F0aW9uIGNhbiBiZSBkaXNhYmxlZCBieSBwbGFjaW5nIGEgaG9zdCBiaW5kaW5nIHNldCBvbiBgXFxALmRpc2FibGVkYCBvbiB0aGUgdG9wbW9zdCBBbmd1bGFyXG4gKiBjb21wb25lbnQuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7Q29tcG9uZW50LCBIb3N0QmluZGluZ30gZnJvbSAnXFxAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBcXEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcC1jb21wb25lbnQnLFxuICogICB0ZW1wbGF0ZVVybDogJ2FwcC5jb21wb25lbnQuaHRtbCcsXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgXFxASG9zdEJpbmRpbmcoJ1xcQC5kaXNhYmxlZCcpXG4gKiAgIHB1YmxpYyBhbmltYXRpb25zRGlzYWJsZWQgPSB0cnVlO1xuICogfVxuICogYGBgXG4gKlxuICogIyMjIFdoYXQgYWJvdXQgYW5pbWF0aW9ucyB0aGF0IHVzIGBxdWVyeSgpYCBhbmQgYGFuaW1hdGVDaGlsZCgpYD9cbiAqIERlc3BpdGUgaW5uZXIgYW5pbWF0aW9ucyBiZWluZyBkaXNhYmxlZCwgYSBwYXJlbnQgYW5pbWF0aW9uIGNhbiB7XFxAbGluayBxdWVyeSBxdWVyeX0gZm9yIGlubmVyXG4gKiBlbGVtZW50cyBsb2NhdGVkIGluIGRpc2FibGVkIGFyZWFzIG9mIHRoZSB0ZW1wbGF0ZSBhbmQgc3RpbGwgYW5pbWF0ZSB0aGVtIGFzIGl0IHNlZXMgZml0LiBUaGlzIGlzXG4gKiBhbHNvIHRoZSBjYXNlIGZvciB3aGVuIGEgc3ViIGFuaW1hdGlvbiBpcyBxdWVyaWVkIGJ5IGEgcGFyZW50IGFuZCB0aGVuIGxhdGVyIGFuaW1hdGVkIHVzaW5nIHtcXEBsaW5rXG4gKiBhbmltYXRlQ2hpbGQgYW5pbWF0ZUNoaWxkfS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/fSBuYW1lXG4gKiBAcGFyYW0gez99IGRlZmluaXRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyKG5hbWUsIGRlZmluaXRpb25zKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogNyAvKiBUcmlnZ2VyICovLCBuYW1lOiBuYW1lLCBkZWZpbml0aW9uczogZGVmaW5pdGlvbnMsIG9wdGlvbnM6IHt9IH07XG59XG4vKipcbiAqIGBhbmltYXRlYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlIHtcXEBsaW5rXG4gKiBDb21wb25lbnQjYW5pbWF0aW9ucyBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YSBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2ZcbiAqIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIgYXJlIHVzZWQuXG4gKlxuICogYGFuaW1hdGVgIHNwZWNpZmllcyBhbiBhbmltYXRpb24gc3RlcCB0aGF0IHdpbGwgYXBwbHkgdGhlIHByb3ZpZGVkIGBzdHlsZXNgIGRhdGEgZm9yIGEgZ2l2ZW5cbiAqIGFtb3VudCBvZiB0aW1lIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBgdGltaW5nYCBleHByZXNzaW9uIHZhbHVlLiBDYWxscyB0byBgYW5pbWF0ZWAgYXJlIGV4cGVjdGVkXG4gKiB0byBiZSB1c2VkIHdpdGhpbiB7XFxAbGluayBzZXF1ZW5jZSBhbiBhbmltYXRpb24gc2VxdWVuY2V9LCB7XFxAbGluayBncm91cCBncm91cH0sIG9yIHtcXEBsaW5rXG4gKiB0cmFuc2l0aW9uIHRyYW5zaXRpb259LlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIFRoZSBgYW5pbWF0ZWAgZnVuY3Rpb24gYWNjZXB0cyB0d28gaW5wdXQgcGFyYW1ldGVyczogYHRpbWluZ2AgYW5kIGBzdHlsZXNgOlxuICpcbiAqIC0gYHRpbWluZ2AgaXMgYSBzdHJpbmcgYmFzZWQgdmFsdWUgdGhhdCBjYW4gYmUgYSBjb21iaW5hdGlvbiBvZiBhIGR1cmF0aW9uIHdpdGggb3B0aW9uYWwgZGVsYXlcbiAqIGFuZCBlYXNpbmcgdmFsdWVzLiBUaGUgZm9ybWF0IGZvciB0aGUgZXhwcmVzc2lvbiBicmVha3MgZG93biB0byBgZHVyYXRpb24gZGVsYXkgZWFzaW5nYFxuICogKHRoZXJlZm9yZSBhIHZhbHVlIHN1Y2ggYXMgYDFzIDEwMG1zIGVhc2Utb3V0YCB3aWxsIGJlIHBhcnNlIGl0c2VsZiBpbnRvIGBkdXJhdGlvbj0xMDAwLFxuICogZGVsYXk9MTAwLCBlYXNpbmc9ZWFzZS1vdXRgLiBJZiBhIG51bWVyaWMgdmFsdWUgaXMgcHJvdmlkZWQgdGhlbiB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGVcbiAqIGBkdXJhdGlvbmAgdmFsdWUgaW4gbWlsbGlzZWNvbmQgZm9ybS5cbiAqIC0gYHN0eWxlc2AgaXMgdGhlIHN0eWxlIGlucHV0IGRhdGEgd2hpY2ggY2FuIGVpdGhlciBiZSBhIGNhbGwgdG8ge1xcQGxpbmsgc3R5bGUgc3R5bGV9IG9yIHtcXEBsaW5rXG4gKiBrZXlmcmFtZXMga2V5ZnJhbWVzfS4gSWYgbGVmdCBlbXB0eSB0aGVuIHRoZSBzdHlsZXMgZnJvbSB0aGUgZGVzdGluYXRpb24gc3RhdGUgd2lsbCBiZSBjb2xsZWN0ZWRcbiAqIGFuZCB1c2VkICh0aGlzIGlzIHVzZWZ1bCB3aGVuIGRlc2NyaWJpbmcgYW4gYW5pbWF0aW9uIHN0ZXAgdGhhdCB3aWxsIGNvbXBsZXRlIGFuIGFuaW1hdGlvbiBieVxuICoge1xcQGxpbmsgdHJhbnNpdGlvbiN0aGUtZmluYWwtYW5pbWF0ZS1jYWxsIGFuaW1hdGluZyB0byB0aGUgZmluYWwgc3RhdGV9KS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyB2YXJpb3VzIGZ1bmN0aW9ucyBmb3Igc3BlY2lmeWluZyB0aW1pbmcgZGF0YVxuICogYW5pbWF0ZSg1MDAsIHN0eWxlKC4uLikpXG4gKiBhbmltYXRlKFwiMXNcIiwgc3R5bGUoLi4uKSlcbiAqIGFuaW1hdGUoXCIxMDBtcyAwLjVzXCIsIHN0eWxlKC4uLikpXG4gKiBhbmltYXRlKFwiNXMgZWFzZVwiLCBzdHlsZSguLi4pKVxuICogYW5pbWF0ZShcIjVzIDEwbXMgY3ViaWMtYmV6aWVyKC4xNywuNjcsLjg4LC4xKVwiLCBzdHlsZSguLi4pKVxuICpcbiAqIC8vIGVpdGhlciBzdHlsZSgpIG9mIGtleWZyYW1lcygpIGNhbiBiZSB1c2VkXG4gKiBhbmltYXRlKDUwMCwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiIH0pKVxuICogYW5pbWF0ZSg1MDAsIGtleWZyYW1lcyhbXG4gKiAgIHN0eWxlKHsgYmFja2dyb3VuZDogXCJibHVlXCIgfSkpLFxuICogICBzdHlsZSh7IGJhY2tncm91bmQ6IFwicmVkXCIgfSkpXG4gKiBdKVxuICogYGBgXG4gKlxuICoge1xcQGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/fSB0aW1pbmdzXG4gKiBAcGFyYW0gez89fSBzdHlsZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUodGltaW5ncywgc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7IHN0eWxlcyA9IG51bGw7IH1cbiAgICByZXR1cm4geyB0eXBlOiA0IC8qIEFuaW1hdGUgKi8sIHN0eWxlczogc3R5bGVzLCB0aW1pbmdzOiB0aW1pbmdzIH07XG59XG4vKipcbiAqIGBncm91cGAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZSB7XFxAbGlua1xuICogQ29tcG9uZW50I2FuaW1hdGlvbnMgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGEgcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mXG4gKiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyIGFyZSB1c2VkLlxuICpcbiAqIGBncm91cGAgc3BlY2lmaWVzIGEgbGlzdCBvZiBhbmltYXRpb24gc3RlcHMgdGhhdCBhcmUgYWxsIHJ1biBpbiBwYXJhbGxlbC4gR3JvdXBlZCBhbmltYXRpb25zIGFyZVxuICogdXNlZnVsIHdoZW4gYSBzZXJpZXMgb2Ygc3R5bGVzIG11c3QgYmUgYW5pbWF0ZWQvY2xvc2VkIG9mZiBhdCBkaWZmZXJlbnQgc3RhcnRpbmcvZW5kaW5nIHRpbWVzLlxuICpcbiAqIFRoZSBgZ3JvdXBgIGZ1bmN0aW9uIGNhbiBlaXRoZXIgYmUgdXNlZCB3aXRoaW4gYSB7XFxAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZX0gb3IgYSB7XFxAbGluayB0cmFuc2l0aW9uXG4gKiB0cmFuc2l0aW9ufSBhbmQgaXQgd2lsbCBvbmx5IGNvbnRpbnVlIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIG9uY2UgYWxsIG9mIHRoZSBpbm5lciBhbmltYXRpb25cbiAqIHN0ZXBzIGhhdmUgY29tcGxldGVkLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIFRoZSBgc3RlcHNgIGRhdGEgdGhhdCBpcyBwYXNzZWQgaW50byB0aGUgYGdyb3VwYCBhbmltYXRpb24gZnVuY3Rpb24gY2FuIGVpdGhlciBjb25zaXN0IG9mIHtcXEBsaW5rXG4gKiBzdHlsZSBzdHlsZX0gb3Ige1xcQGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBmdW5jdGlvbiBjYWxscy4gRWFjaCBjYWxsIHRvIGBzdHlsZSgpYCBvciBgYW5pbWF0ZSgpYFxuICogd2l0aGluIGEgZ3JvdXAgd2lsbCBiZSBleGVjdXRlZCBpbnN0YW50bHkgKHVzZSB7XFxAbGluayBrZXlmcmFtZXMga2V5ZnJhbWVzfSBvciBhIHtcXEBsaW5rXG4gKiBhbmltYXRlI3VzYWdlIGFuaW1hdGUoKSB3aXRoIGEgZGVsYXkgdmFsdWV9IHRvIG9mZnNldCBzdHlsZXMgdG8gYmUgYXBwbGllZCBhdCBhIGxhdGVyIHRpbWUpLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGdyb3VwKFtcbiAqICAgYW5pbWF0ZShcIjFzXCIsIHsgYmFja2dyb3VuZDogXCJibGFja1wiIH0pKVxuICogICBhbmltYXRlKFwiMnNcIiwgeyBjb2xvcjogXCJ3aGl0ZVwiIH0pKVxuICogXSlcbiAqIGBgYFxuICpcbiAqIHtcXEBleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gc3RlcHNcbiAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdyb3VwKHN0ZXBzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgIHJldHVybiB7IHR5cGU6IDMgLyogR3JvdXAgKi8sIHN0ZXBzOiBzdGVwcywgb3B0aW9uczogb3B0aW9ucyB9O1xufVxuLyoqXG4gKiBgc2VxdWVuY2VgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXInc1xuICogYW5pbWF0aW9uIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGUge1xcQGxpbmtcbiAqIENvbXBvbmVudCNhbmltYXRpb25zIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZlxuICogaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhciBhcmUgdXNlZC5cbiAqXG4gKiBgc2VxdWVuY2VgIFNwZWNpZmllcyBhIGxpc3Qgb2YgYW5pbWF0aW9uIHN0ZXBzIHRoYXQgYXJlIHJ1biBvbmUgYnkgb25lLiAoYHNlcXVlbmNlYCBpcyB1c2VkIGJ5XG4gKiBkZWZhdWx0IHdoZW4gYW4gYXJyYXkgaXMgcGFzc2VkIGFzIGFuaW1hdGlvbiBkYXRhIGludG8ge1xcQGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9ufS4pXG4gKlxuICogVGhlIGBzZXF1ZW5jZWAgZnVuY3Rpb24gY2FuIGVpdGhlciBiZSB1c2VkIHdpdGhpbiBhIHtcXEBsaW5rIGdyb3VwIGdyb3VwfSBvciBhIHtcXEBsaW5rIHRyYW5zaXRpb25cbiAqIHRyYW5zaXRpb259IGFuZCBpdCB3aWxsIG9ubHkgY29udGludWUgdG8gdGhlIG5leHQgaW5zdHJ1Y3Rpb24gb25jZSBlYWNoIG9mIHRoZSBpbm5lciBhbmltYXRpb25cbiAqIHN0ZXBzIGhhdmUgY29tcGxldGVkLlxuICpcbiAqIFRvIHBlcmZvcm0gYW5pbWF0aW9uIHN0eWxpbmcgaW4gcGFyYWxsZWwgd2l0aCBvdGhlciBhbmltYXRpb24gc3RlcHMgdGhlbiBoYXZlIGEgbG9vayBhdCB0aGVcbiAqIHtcXEBsaW5rIGdyb3VwIGdyb3VwfSBhbmltYXRpb24gZnVuY3Rpb24uXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogVGhlIGBzdGVwc2AgZGF0YSB0aGF0IGlzIHBhc3NlZCBpbnRvIHRoZSBgc2VxdWVuY2VgIGFuaW1hdGlvbiBmdW5jdGlvbiBjYW4gZWl0aGVyIGNvbnNpc3Qgb2ZcbiAqIHtcXEBsaW5rIHN0eWxlIHN0eWxlfSBvciB7XFxAbGluayBhbmltYXRlIGFuaW1hdGV9IGZ1bmN0aW9uIGNhbGxzLiBBIGNhbGwgdG8gYHN0eWxlKClgIHdpbGwgYXBwbHkgdGhlXG4gKiBwcm92aWRlZCBzdHlsaW5nIGRhdGEgaW1tZWRpYXRlbHkgd2hpbGUgYSBjYWxsIHRvIGBhbmltYXRlKClgIHdpbGwgYXBwbHkgaXRzIHN0eWxpbmcgZGF0YSBvdmVyIGFcbiAqIGdpdmVuIHRpbWUgZGVwZW5kaW5nIG9uIGl0cyB0aW1pbmcgZGF0YS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBzZXF1ZW5jZShbXG4gKiAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSksXG4gKiAgIGFuaW1hdGUoXCIxc1wiLCB7IG9wYWNpdHk6IDEgfSkpXG4gKiBdKVxuICogYGBgXG4gKlxuICoge1xcQGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/fSBzdGVwc1xuICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2VxdWVuY2Uoc3RlcHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIHsgdHlwZTogMiAvKiBTZXF1ZW5jZSAqLywgc3RlcHM6IHN0ZXBzLCBvcHRpb25zOiBvcHRpb25zIH07XG59XG4vKipcbiAqIGBzdHlsZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZSB7XFxAbGlua1xuICogQ29tcG9uZW50I2FuaW1hdGlvbnMgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGEgcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mXG4gKiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyIGFyZSB1c2VkLlxuICpcbiAqIGBzdHlsZWAgZGVjbGFyZXMgYSBrZXkvdmFsdWUgb2JqZWN0IGNvbnRhaW5pbmcgQ1NTIHByb3BlcnRpZXMvc3R5bGVzIHRoYXQgY2FuIHRoZW4gYmUgdXNlZCBmb3JcbiAqIHtcXEBsaW5rIHN0YXRlIGFuaW1hdGlvbiBzdGF0ZXN9LCB3aXRoaW4gYW4ge1xcQGxpbmsgc2VxdWVuY2UgYW5pbWF0aW9uIHNlcXVlbmNlfSwgb3IgYXMgc3R5bGluZyBkYXRhXG4gKiBmb3IgYm90aCB7XFxAbGluayBhbmltYXRlIGFuaW1hdGV9IGFuZCB7XFxAbGluayBrZXlmcmFtZXMga2V5ZnJhbWVzfS5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBgc3R5bGVgIHRha2VzIGluIGEga2V5L3ZhbHVlIHN0cmluZyBtYXAgYXMgZGF0YSBhbmQgZXhwZWN0cyBvbmUgb3IgbW9yZSBDU1MgcHJvcGVydHkvdmFsdWUgcGFpcnNcbiAqIHRvIGJlIGRlZmluZWQuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gc3RyaW5nIHZhbHVlcyBhcmUgdXNlZCBmb3IgY3NzIHByb3BlcnRpZXNcbiAqIHN0eWxlKHsgYmFja2dyb3VuZDogXCJyZWRcIiwgY29sb3I6IFwiYmx1ZVwiIH0pXG4gKlxuICogLy8gbnVtZXJpY2FsIChwaXhlbCkgdmFsdWVzIGFyZSBhbHNvIHN1cHBvcnRlZFxuICogc3R5bGUoeyB3aWR0aDogMTAwLCBoZWlnaHQ6IDAgfSlcbiAqIGBgYFxuICpcbiAqICMjIyMgQXV0by1zdHlsZXMgKHVzaW5nIGAqYClcbiAqXG4gKiBXaGVuIGFuIGFzdGVyaXggKGAqYCkgY2hhcmFjdGVyIGlzIHVzZWQgYXMgYSB2YWx1ZSB0aGVuIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgZnJvbSB0aGUgZWxlbWVudFxuICogYmVpbmcgYW5pbWF0ZWQgYW5kIGFwcGxpZWQgYXMgYW5pbWF0aW9uIGRhdGEgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAqXG4gKiBUaGlzIGZlYXR1cmUgcHJvdmVzIHVzZWZ1bCBmb3IgYSBzdGF0ZSBkZXBlbmRpbmcgb24gbGF5b3V0IGFuZC9vciBlbnZpcm9ubWVudCBmYWN0b3JzOyBpbiBzdWNoXG4gKiBjYXNlcyB0aGUgc3R5bGVzIGFyZSBjYWxjdWxhdGVkIGp1c3QgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIHRoZSBzdGVwcyBiZWxvdyB3aWxsIGFuaW1hdGUgZnJvbSAwIHRvIHRoZVxuICogLy8gYWN0dWFsIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICogc3R5bGUoeyBoZWlnaHQ6IDAgfSksXG4gKiBhbmltYXRlKFwiMXNcIiwgc3R5bGUoeyBoZWlnaHQ6IFwiKlwiIH0pKVxuICogYGBgXG4gKlxuICoge1xcQGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/fSB0b2tlbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0eWxlKHRva2Vucykge1xuICAgIHJldHVybiB7IHR5cGU6IDYgLyogU3R5bGUgKi8sIHN0eWxlczogdG9rZW5zLCBvZmZzZXQ6IG51bGwgfTtcbn1cbi8qKlxuICogYHN0YXRlYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlIHtcXEBsaW5rXG4gKiBDb21wb25lbnQjYW5pbWF0aW9ucyBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YSBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2ZcbiAqIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIgYXJlIHVzZWQuXG4gKlxuICogYHN0YXRlYCBkZWNsYXJlcyBhbiBhbmltYXRpb24gc3RhdGUgd2l0aGluIHRoZSBnaXZlbiB0cmlnZ2VyLiBXaGVuIGEgc3RhdGUgaXMgYWN0aXZlIHdpdGhpbiBhXG4gKiBjb21wb25lbnQgdGhlbiBpdHMgYXNzb2NpYXRlZCBzdHlsZXMgd2lsbCBwZXJzaXN0IG9uIHRoZSBlbGVtZW50IHRoYXQgdGhlIHRyaWdnZXIgaXMgYXR0YWNoZWQgdG9cbiAqIChldmVuIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzKS5cbiAqXG4gKiBUbyBhbmltYXRlIGJldHdlZW4gc3RhdGVzLCBoYXZlIGEgbG9vayBhdCB0aGUgYW5pbWF0aW9uIHtcXEBsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn0gRFNMXG4gKiBmdW5jdGlvbi4gVG8gcmVnaXN0ZXIgc3RhdGVzIHRvIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHBsZWFzZSBoYXZlIGEgbG9vayBhdCB0aGUge1xcQGxpbmsgdHJpZ2dlclxuICogdHJpZ2dlcn0gZnVuY3Rpb24uXG4gKlxuICogIyMjIyBUaGUgYHZvaWRgIHN0YXRlXG4gKlxuICogVGhlIGB2b2lkYCBzdGF0ZSB2YWx1ZSBpcyBhIHJlc2VydmVkIHdvcmQgdGhhdCBhbmd1bGFyIHVzZXMgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90XG4gKiBhcGFydCBvZiB0aGUgYXBwbGljYXRpb24gYW55bW9yZSAoZS5nLiB3aGVuIGFuIGBuZ0lmYCBldmFsdWF0ZXMgdG8gZmFsc2UgdGhlbiB0aGUgc3RhdGUgb2YgdGhlXG4gKiBhc3NvY2lhdGVkIGVsZW1lbnQgaXMgdm9pZCkuXG4gKlxuICogIyMjIyBUaGUgYCpgIChkZWZhdWx0KSBzdGF0ZVxuICpcbiAqIFRoZSBgKmAgc3RhdGUgKHdoZW4gc3R5bGVkKSBpcyBhIGZhbGxiYWNrIHN0YXRlIHRoYXQgd2lsbCBiZSB1c2VkIGlmIHRoZSBzdGF0ZSB0aGF0IGlzIGJlaW5nXG4gKiBhbmltYXRlZCBpcyBub3QgZGVjbGFyZWQgd2l0aGluIHRoZSB0cmlnZ2VyLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIGBzdGF0ZWAgd2lsbCBkZWNsYXJlIGFuIGFuaW1hdGlvbiBzdGF0ZSB3aXRoIGl0cyBhc3NvY2lhdGVkIHN0eWxlc1xuICogd2l0aGluIHRoZSBnaXZlbiB0cmlnZ2VyLlxuICpcbiAqIC0gYHN0YXRlTmFtZUV4cHJgIGNhbiBiZSBvbmUgb3IgbW9yZSBzdGF0ZSBuYW1lcyBzZXBhcmF0ZWQgYnkgY29tbWFzLlxuICogLSBgc3R5bGVzYCByZWZlcnMgdG8gdGhlIHtcXEBsaW5rIHN0eWxlIHN0eWxpbmcgZGF0YX0gdGhhdCB3aWxsIGJlIHBlcnNpc3RlZCBvbiB0aGUgZWxlbWVudCBvbmNlXG4gKiB0aGUgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZC5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBcInZvaWRcIiBpcyBhIHJlc2VydmVkIG5hbWUgZm9yIGEgc3RhdGUgYW5kIGlzIHVzZWQgdG8gcmVwcmVzZW50XG4gKiAvLyB0aGUgc3RhdGUgaW4gd2hpY2ggYW4gZWxlbWVudCBpcyBkZXRhY2hlZCBmcm9tIGZyb20gdGhlIGFwcGxpY2F0aW9uLlxuICogc3RhdGUoXCJ2b2lkXCIsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKVxuICpcbiAqIC8vIHVzZXItZGVmaW5lZCBzdGF0ZXNcbiAqIHN0YXRlKFwiY2xvc2VkXCIsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKVxuICogc3RhdGUoXCJvcGVuLCB2aXNpYmxlXCIsIHN0eWxlKHsgaGVpZ2h0OiBcIipcIiB9KSlcbiAqIGBgYFxuICpcbiAqIHtcXEBleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHBhcmFtIHs/fSBzdHlsZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0YXRlKG5hbWUsIHN0eWxlcykge1xuICAgIHJldHVybiB7IHR5cGU6IDAgLyogU3RhdGUgKi8sIG5hbWU6IG5hbWUsIHN0eWxlczogc3R5bGVzIH07XG59XG4vKipcbiAqIGBrZXlmcmFtZXNgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXInc1xuICogYW5pbWF0aW9uIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGUge1xcQGxpbmtcbiAqIENvbXBvbmVudCNhbmltYXRpb25zIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZlxuICogaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhciBhcmUgdXNlZC5cbiAqXG4gKiBga2V5ZnJhbWVzYCBzcGVjaWZpZXMgYSBjb2xsZWN0aW9uIG9mIHtcXEBsaW5rIHN0eWxlIHN0eWxlfSBlbnRyaWVzIGVhY2ggb3B0aW9uYWxseSBjaGFyYWN0ZXJpemVkXG4gKiBieSBhbiBgb2Zmc2V0YCB2YWx1ZS5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBUaGUgYGtleWZyYW1lc2AgYW5pbWF0aW9uIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgYWxvbmdzaWRlIHRoZSB7XFxAbGluayBhbmltYXRlIGFuaW1hdGV9XG4gKiBhbmltYXRpb24gZnVuY3Rpb24uIEluc3RlYWQgb2YgYXBwbHlpbmcgYW5pbWF0aW9ucyBmcm9tIHdoZXJlIHRoZXkgYXJlIGN1cnJlbnRseSB0byB0aGVpclxuICogZGVzdGluYXRpb24sIGtleWZyYW1lcyBjYW4gZGVzY3JpYmUgaG93IGVhY2ggc3R5bGUgZW50cnkgaXMgYXBwbGllZCBhbmQgYXQgd2hhdCBwb2ludCB3aXRoaW4gdGhlXG4gKiBhbmltYXRpb24gYXJjIChtdWNoIGxpa2UgQ1NTIEtleWZyYW1lIEFuaW1hdGlvbnMgZG8pLlxuICpcbiAqIEZvciBlYWNoIGBzdHlsZSgpYCBlbnRyeSBhbiBgb2Zmc2V0YCB2YWx1ZSBjYW4gYmUgc2V0LiBEb2luZyBzbyBhbGxvd3MgdG8gc3BlY2lmaXkgYXQgd2hhdFxuICogcGVyY2VudGFnZSBvZiB0aGUgYW5pbWF0ZSB0aW1lIHRoZSBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIHRoZSBwcm92aWRlZCBvZmZzZXQgdmFsdWVzIGRlc2NyaWJlIHdoZW4gZWFjaCBiYWNrZ3JvdW5kQ29sb3IgdmFsdWUgaXMgYXBwbGllZC5cbiAqIGFuaW1hdGUoXCI1c1wiLCBrZXlmcmFtZXMoW1xuICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJyZWRcIiwgb2Zmc2V0OiAwIH0pLFxuICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibHVlXCIsIG9mZnNldDogMC4yIH0pLFxuICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJvcmFuZ2VcIiwgb2Zmc2V0OiAwLjMgfSksXG4gKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsYWNrXCIsIG9mZnNldDogMSB9KVxuICogXSkpXG4gKiBgYGBcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCBpZiB0aGVyZSBhcmUgbm8gYG9mZnNldGAgdmFsdWVzIHVzZWQgd2l0aGluIHRoZSBzdHlsZSBlbnRyaWVzIHRoZW4gdGhlIG9mZnNldHNcbiAqIHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGFuaW1hdGUoXCI1c1wiLCBrZXlmcmFtZXMoW1xuICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJyZWRcIiB9KSAvLyBvZmZzZXQgPSAwXG4gKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsdWVcIiB9KSAvLyBvZmZzZXQgPSAwLjMzXG4gKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcIm9yYW5nZVwiIH0pIC8vIG9mZnNldCA9IDAuNjZcbiAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmxhY2tcIiB9KSAvLyBvZmZzZXQgPSAxXG4gKiBdKSlcbiAqIGBgYFxuICpcbiAqIHtcXEBleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gc3RlcHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGtleWZyYW1lcyhzdGVwcykge1xuICAgIHJldHVybiB7IHR5cGU6IDUgLyogS2V5ZnJhbWVzICovLCBzdGVwczogc3RlcHMgfTtcbn1cbi8qKlxuICogYHRyYW5zaXRpb25gIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXInc1xuICogYW5pbWF0aW9uIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGUge1xcQGxpbmtcbiAqIENvbXBvbmVudCNhbmltYXRpb25zIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZlxuICogaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhciBhcmUgdXNlZC5cbiAqXG4gKiBgdHJhbnNpdGlvbmAgZGVjbGFyZXMgdGhlIHtcXEBsaW5rIHNlcXVlbmNlIHNlcXVlbmNlIG9mIGFuaW1hdGlvbiBzdGVwc30gdGhhdCB3aWxsIGJlIHJ1biB3aGVuIHRoZVxuICogcHJvdmlkZWQgYHN0YXRlQ2hhbmdlRXhwcmAgdmFsdWUgaXMgc2F0aXNmaWVkLiBUaGUgYHN0YXRlQ2hhbmdlRXhwcmAgY29uc2lzdHMgb2YgYSBgc3RhdGUxID0+XG4gKiBzdGF0ZTJgIHdoaWNoIGNvbnNpc3RzIG9mIHR3byBrbm93biBzdGF0ZXMgKHVzZSBhbiBhc3Rlcml4IChgKmApIHRvIHJlZmVyIHRvIGEgZHluYW1pYyBzdGFydGluZ1xuICogYW5kL29yIGVuZGluZyBzdGF0ZSkuXG4gKlxuICogQSBmdW5jdGlvbiBjYW4gYWxzbyBiZSBwcm92aWRlZCBhcyB0aGUgYHN0YXRlQ2hhbmdlRXhwcmAgYXJndW1lbnQgZm9yIGEgdHJhbnNpdGlvbiBhbmQgdGhpc1xuICogZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCBlYWNoIHRpbWUgYSBzdGF0ZSBjaGFuZ2Ugb2NjdXJzLiBJZiB0aGUgdmFsdWUgcmV0dXJuZWQgd2l0aGluIHRoZVxuICogZnVuY3Rpb24gaXMgdHJ1ZSB0aGVuIHRoZSBhc3NvY2lhdGVkIGFuaW1hdGlvbiB3aWxsIGJlIHJ1bi5cbiAqXG4gKiBBbmltYXRpb24gdHJhbnNpdGlvbnMgYXJlIHBsYWNlZCB3aXRoaW4gYW4ge1xcQGxpbmsgdHJpZ2dlciBhbmltYXRpb24gdHJpZ2dlcn0uIEZvciBhbiB0cmFuc2l0aW9uXG4gKiB0byBhbmltYXRlIHRvIGEgc3RhdGUgdmFsdWUgYW5kIHBlcnNpc3QgaXRzIHN0eWxlcyB0aGVuIG9uZSBvciBtb3JlIHtcXEBsaW5rIHN0YXRlIGFuaW1hdGlvblxuICogc3RhdGVzfSBpcyBleHBlY3RlZCB0byBiZSBkZWZpbmVkLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIEFuIGFuaW1hdGlvbiB0cmFuc2l0aW9uIGlzIGtpY2tlZCBvZmYgdGhlIGBzdGF0ZUNoYW5nZUV4cHJgIHByZWRpY2F0ZSBldmFsdWF0ZXMgdG8gdHJ1ZSBiYXNlZCBvblxuICogd2hhdCB0aGUgcHJldmlvdXMgc3RhdGUgaXMgYW5kIHdoYXQgdGhlIGN1cnJlbnQgc3RhdGUgaGFzIGJlY29tZS4gSW4gb3RoZXIgd29yZHMsIGlmIGEgdHJhbnNpdGlvblxuICogaXMgZGVmaW5lZCB0aGF0IG1hdGNoZXMgdGhlIG9sZC9jdXJyZW50IHN0YXRlIGNyaXRlcmlhIHRoZW4gdGhlIGFzc29jaWF0ZWQgYW5pbWF0aW9uIHdpbGwgYmVcbiAqIHRyaWdnZXJlZC5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBhbGwgdHJhbnNpdGlvbi9zdGF0ZSBjaGFuZ2VzIGFyZSBkZWZpbmVkIHdpdGhpbiBhbiBhbmltYXRpb24gdHJpZ2dlclxuICogdHJpZ2dlcihcIm15QW5pbWF0aW9uVHJpZ2dlclwiLCBbXG4gKiAgIC8vIGlmIGEgc3RhdGUgaXMgZGVmaW5lZCB0aGVuIGl0cyBzdHlsZXMgd2lsbCBiZSBwZXJzaXN0ZWQgd2hlbiB0aGVcbiAqICAgLy8gYW5pbWF0aW9uIGhhcyBmdWxseSBjb21wbGV0ZWQgaXRzZWxmXG4gKiAgIHN0YXRlKFwib25cIiwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcImdyZWVuXCIgfSkpLFxuICogICBzdGF0ZShcIm9mZlwiLCBzdHlsZSh7IGJhY2tncm91bmQ6IFwiZ3JleVwiIH0pKSxcbiAqXG4gKiAgIC8vIGEgdHJhbnNpdGlvbiBhbmltYXRpb24gdGhhdCB3aWxsIGJlIGtpY2tlZCBvZmYgd2hlbiB0aGUgc3RhdGUgdmFsdWVcbiAqICAgLy8gYm91bmQgdG8gXCJteUFuaW1hdGlvblRyaWdnZXJcIiBjaGFuZ2VzIGZyb20gXCJvblwiIHRvIFwib2ZmXCJcbiAqICAgdHJhbnNpdGlvbihcIm9uID0+IG9mZlwiLCBhbmltYXRlKDUwMCkpLFxuICpcbiAqICAgLy8gaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBkbyBydW4gdGhlIHNhbWUgYW5pbWF0aW9uIGZvciBib3RoIGRpcmVjdGlvbnNcbiAqICAgdHJhbnNpdGlvbihcIm9uIDw9PiBvZmZcIiwgYW5pbWF0ZSg1MDApKSxcbiAqXG4gKiAgIC8vIG9yIHRvIGRlZmluZSBtdWx0aXBsZSBzdGF0ZXMgcGFpcnMgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICogICB0cmFuc2l0aW9uKFwib24gPT4gb2ZmLCBvZmYgPT4gdm9pZFwiLCBhbmltYXRlKDUwMCkpLFxuICpcbiAqICAgLy8gdGhpcyBpcyBhIGNhdGNoLWFsbCBzdGF0ZSBjaGFuZ2UgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyBpbnNlcnRlZCBpbnRvXG4gKiAgIC8vIHRoZSBwYWdlIGFuZCB0aGUgZGVzdGluYXRpb24gc3RhdGUgaXMgdW5rbm93blxuICogICB0cmFuc2l0aW9uKFwidm9pZCA9PiAqXCIsIFtcbiAqICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gKiAgICAgYW5pbWF0ZSg1MDApXG4gKiAgIF0pLFxuICpcbiAqICAgLy8gdGhpcyB3aWxsIGNhcHR1cmUgYSBzdGF0ZSBjaGFuZ2UgYmV0d2VlbiBhbnkgc3RhdGVzXG4gKiAgIHRyYW5zaXRpb24oXCIqID0+ICpcIiwgYW5pbWF0ZShcIjFzIDBzXCIpKSxcbiAqXG4gKiAgIC8vIHlvdSBjYW4gYWxzbyBnbyBmdWxsIG91dCBhbmQgaW5jbHVkZSBhIGZ1bmN0aW9uXG4gKiAgIHRyYW5zaXRpb24oKGZyb21TdGF0ZSwgdG9TdGF0ZSkgPT4ge1xuICogICAgIC8vIHdoZW4gYHRydWVgIHRoZW4gaXQgd2lsbCBhbGxvdyB0aGUgYW5pbWF0aW9uIGJlbG93IHRvIGJlIGludm9rZWRcbiAqICAgICByZXR1cm4gZnJvbVN0YXRlID09IFwib2ZmXCIgJiYgdG9TdGF0ZSA9PSBcIm9uXCI7XG4gKiAgIH0sIGFuaW1hdGUoXCIxcyAwc1wiKSlcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBUaGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50IHdpbGwgbWFrZSB1c2Ugb2YgdGhlIGBteUFuaW1hdGlvblRyaWdnZXJgIGFuaW1hdGlvblxuICogdHJpZ2dlciBieSBiaW5kaW5nIHRvIGFuIGVsZW1lbnQgd2l0aGluIGl0cyB0ZW1wbGF0ZSBjb2RlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gc29tZXdoZXJlIGluc2lkZSBvZiBteS1jb21wb25lbnQtdHBsLmh0bWwgLS0+XG4gKiA8ZGl2IFtcXEBteUFuaW1hdGlvblRyaWdnZXJdPVwibXlTdGF0dXNFeHBcIj4uLi48L2Rpdj5cbiAqIGBgYFxuICpcbiAqICMjIyMgVGhlIGZpbmFsIGBhbmltYXRlYCBjYWxsXG4gKlxuICogSWYgdGhlIGZpbmFsIHN0ZXAgd2l0aGluIHRoZSB0cmFuc2l0aW9uIHN0ZXBzIGlzIGEgY2FsbCB0byBgYW5pbWF0ZSgpYCB0aGF0ICoqb25seSoqIHVzZXMgYVxuICogdGltaW5nIHZhbHVlIHdpdGggKipubyBzdHlsZSBkYXRhKiogdGhlbiBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdXNlZCBhcyB0aGUgZmluYWwgYW5pbWF0aW9uIGFyY1xuICogZm9yIHRoZSBlbGVtZW50IHRvIGFuaW1hdGUgaXRzZWxmIHRvIHRoZSBmaW5hbCBzdGF0ZS4gVGhpcyBpbnZvbHZlcyBhbiBhdXRvbWF0aWMgbWl4IG9mXG4gKiBhZGRpbmcvcmVtb3ZpbmcgQ1NTIHN0eWxlcyBzbyB0aGF0IHRoZSBlbGVtZW50IHdpbGwgYmUgaW4gdGhlIGV4YWN0IHN0YXRlIGl0IHNob3VsZCBiZSBmb3IgdGhlXG4gKiBhcHBsaWVkIHN0YXRlIHRvIGJlIHByZXNlbnRlZCBjb3JyZWN0bHkuXG4gKlxuICogYGBgXG4gKiAvLyBzdGFydCBvZmYgYnkgaGlkaW5nIHRoZSBlbGVtZW50LCBidXQgbWFrZSBzdXJlIHRoYXQgaXQgYW5pbWF0ZXMgcHJvcGVybHkgdG8gd2hhdGV2ZXIgc3RhdGVcbiAqIC8vIGlzIGN1cnJlbnRseSBhY3RpdmUgZm9yIFwibXlBbmltYXRpb25UcmlnZ2VyXCJcbiAqIHRyYW5zaXRpb24oXCJ2b2lkID0+ICpcIiwgW1xuICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gKiAgIGFuaW1hdGUoNTAwKVxuICogXSlcbiAqIGBgYFxuICpcbiAqICMjIyBUcmFuc2l0aW9uIEFsaWFzZXMgKGA6ZW50ZXJgIGFuZCBgOmxlYXZlYClcbiAqXG4gKiBHaXZlbiB0aGF0IGVudGVyIChpbnNlcnRpb24pIGFuZCBsZWF2ZSAocmVtb3ZhbCkgYW5pbWF0aW9ucyBhcmUgc28gY29tbW9uLCB0aGUgYHRyYW5zaXRpb25gXG4gKiBmdW5jdGlvbiBhY2NlcHRzIGJvdGggYDplbnRlcmAgYW5kIGA6bGVhdmVgIHZhbHVlcyB3aGljaCBhcmUgYWxpYXNlcyBmb3IgdGhlIGB2b2lkID0+ICpgIGFuZCBgKlxuICogPT4gdm9pZGAgc3RhdGUgY2hhbmdlcy5cbiAqXG4gKiBgYGBcbiAqIHRyYW5zaXRpb24oXCI6ZW50ZXJcIiwgW1xuICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gKiAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXG4gKiBdKVxuICogdHJhbnNpdGlvbihcIjpsZWF2ZVwiLCBbXG4gKiAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXG4gKiBdKVxuICogYGBgXG4gKlxuICoge1xcQGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/fSBzdGF0ZUNoYW5nZUV4cHJcbiAqIEBwYXJhbSB7P30gc3RlcHNcbiAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRyYW5zaXRpb24oc3RhdGVDaGFuZ2VFeHByLCBzdGVwcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICByZXR1cm4geyB0eXBlOiAxIC8qIFRyYW5zaXRpb24gKi8sIGV4cHI6IHN0YXRlQ2hhbmdlRXhwciwgYW5pbWF0aW9uOiBzdGVwcywgb3B0aW9uczogb3B0aW9ucyB9O1xufVxuLyoqXG4gKiBgYW5pbWF0aW9uYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuXG4gKlxuICogYHZhciBteUFuaW1hdGlvbiA9IGFuaW1hdGlvbiguLi4pYCBpcyBkZXNpZ25lZCB0byBwcm9kdWNlIGEgcmV1c2FibGUgYW5pbWF0aW9uIHRoYXQgY2FuIGJlIGxhdGVyXG4gKiBpbnZva2VkIGluIGFub3RoZXIgYW5pbWF0aW9uIG9yIHNlcXVlbmNlLiBSZXVzYWJsZSBhbmltYXRpb25zIGFyZSBkZXNpZ25lZCB0byBtYWtlIHVzZSBvZlxuICogYW5pbWF0aW9uIHBhcmFtZXRlcnMgYW5kIHRoZSBwcm9kdWNlZCBhbmltYXRpb24gY2FuIGJlIHVzZWQgdmlhIHRoZSBgdXNlQW5pbWF0aW9uYCBtZXRob2QuXG4gKlxuICogYGBgXG4gKiB2YXIgZmFkZUFuaW1hdGlvbiA9IGFuaW1hdGlvbihbXG4gKiAgIHN0eWxlKHsgb3BhY2l0eTogJ3t7IHN0YXJ0IH19JyB9KSxcbiAqICAgYW5pbWF0ZSgne3sgdGltZSB9fScsXG4gKiAgICAgc3R5bGUoeyBvcGFjaXR5OiAne3sgZW5kIH19JykpXG4gKiBdLCB7IHBhcmFtczogeyB0aW1lOiAnMTAwMG1zJywgc3RhcnQ6IDAsIGVuZDogMSB9fSk7XG4gKiBgYGBcbiAqXG4gKiBJZiBwYXJhbWV0ZXJzIGFyZSBhdHRhY2hlZCB0byBhbiBhbmltYXRpb24gdGhlbiB0aGV5IGFjdCBhcyAqKmRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlcyoqLiBXaGVuIGFuXG4gKiBhbmltYXRpb24gaXMgaW52b2tlZCB2aWEgYHVzZUFuaW1hdGlvbmAgdGhlbiBwYXJhbWV0ZXIgdmFsdWVzIGFyZSBhbGxvd2VkIHRvIGJlIHBhc3NlZCBpblxuICogZGlyZWN0bHkuIElmIGFueSBvZiB0aGUgcGFzc2VkIGluIHBhcmFtZXRlciB2YWx1ZXMgYXJlIG1pc3NpbmcgdGhlbiB0aGUgZGVmYXVsdCB2YWx1ZXMgd2lsbCBiZVxuICogdXNlZC5cbiAqXG4gKiBgYGBcbiAqIHVzZUFuaW1hdGlvbihmYWRlQW5pbWF0aW9uLCB7XG4gKiAgIHBhcmFtczoge1xuICogICAgIHRpbWU6ICcycycsXG4gKiAgICAgc3RhcnQ6IDEsXG4gKiAgICAgZW5kOiAwXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBJZiBvbmUgb3IgbW9yZSBwYXJhbWV0ZXIgdmFsdWVzIGFyZSBtaXNzaW5nIGJlZm9yZSBhbmltYXRlZCB0aGVuIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcGFyYW0gez99IHN0ZXBzXG4gKiBAcGFyYW0gez89fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhbmltYXRpb24oc3RlcHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIHsgdHlwZTogOCAvKiBSZWZlcmVuY2UgKi8sIGFuaW1hdGlvbjogc3RlcHMsIG9wdGlvbnM6IG9wdGlvbnMgfTtcbn1cbi8qKlxuICogYGFuaW1hdGVDaGlsZGAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLiBJdCB3b3JrcyBieSBhbGxvd2luZyBhIHF1ZXJpZWQgZWxlbWVudCB0byBleGVjdXRlIGl0cyBvd25cbiAqIGFuaW1hdGlvbiB3aXRoaW4gdGhlIGFuaW1hdGlvbiBzZXF1ZW5jZS5cbiAqXG4gKiBFYWNoIHRpbWUgYW4gYW5pbWF0aW9uIGlzIHRyaWdnZXJlZCBpbiBhbmd1bGFyLCB0aGUgcGFyZW50IGFuaW1hdGlvblxuICogd2lsbCBhbHdheXMgZ2V0IHByaW9yaXR5IGFuZCBhbnkgY2hpbGQgYW5pbWF0aW9ucyB3aWxsIGJlIGJsb2NrZWQuIEluIG9yZGVyXG4gKiBmb3IgYSBjaGlsZCBhbmltYXRpb24gdG8gcnVuLCB0aGUgcGFyZW50IGFuaW1hdGlvbiBtdXN0IHF1ZXJ5IGVhY2ggb2YgdGhlIGVsZW1lbnRzXG4gKiBjb250YWluaW5nIGNoaWxkIGFuaW1hdGlvbnMgYW5kIHRoZW4gYWxsb3cgdGhlIGFuaW1hdGlvbnMgdG8gcnVuIHVzaW5nIGBhbmltYXRlQ2hpbGRgLlxuICpcbiAqIFRoZSBleGFtcGxlIEhUTUwgY29kZSBiZWxvdyBzaG93cyBib3RoIHBhcmVudCBhbmQgY2hpbGQgZWxlbWVudHMgdGhhdCBoYXZlIGFuaW1hdGlvblxuICogdHJpZ2dlcnMgdGhhdCB3aWxsIGV4ZWN1dGUgYXQgdGhlIHNhbWUgdGltZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8IS0tIHBhcmVudC1jaGlsZC5jb21wb25lbnQuaHRtbCAtLT5cbiAqIDxidXR0b24gKGNsaWNrKT1cImV4cCA9ISBleHBcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqIDxocj5cbiAqXG4gKiA8ZGl2IFtcXEBwYXJlbnRBbmltYXRpb25dPVwiZXhwXCI+XG4gKiAgIDxoZWFkZXI+SGVsbG88L2hlYWRlcj5cbiAqICAgPGRpdiBbXFxAY2hpbGRBbmltYXRpb25dPVwiZXhwXCI+XG4gKiAgICAgICBvbmVcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgW1xcQGNoaWxkQW5pbWF0aW9uXT1cImV4cFwiPlxuICogICAgICAgdHdvXG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IFtcXEBjaGlsZEFuaW1hdGlvbl09XCJleHBcIj5cbiAqICAgICAgIHRocmVlXG4gKiAgIDwvZGl2PlxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBOb3cgd2hlbiB0aGUgYGV4cGAgdmFsdWUgY2hhbmdlcyB0byB0cnVlLCBvbmx5IHRoZSBgcGFyZW50QW5pbWF0aW9uYCBhbmltYXRpb24gd2lsbCBhbmltYXRlXG4gKiBiZWNhdXNlIGl0IGhhcyBwcmlvcml0eS4gSG93ZXZlciwgdXNpbmcgYHF1ZXJ5YCBhbmQgYGFuaW1hdGVDaGlsZGAgZWFjaCBvZiB0aGUgaW5uZXIgYW5pbWF0aW9uc1xuICogY2FuIGFsc28gZmlyZTpcbiAqXG4gKiBgYGB0c1xuICogLy8gcGFyZW50LWNoaWxkLmNvbXBvbmVudC50c1xuICogaW1wb3J0IHt0cmlnZ2VyLCB0cmFuc2l0aW9uLCBhbmltYXRlLCBzdHlsZSwgcXVlcnksIGFuaW1hdGVDaGlsZH0gZnJvbSAnXFxAYW5ndWxhci9hbmltYXRpb25zJztcbiAqIFxcQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAncGFyZW50LWNoaWxkLWNvbXBvbmVudCcsXG4gKiAgIGFuaW1hdGlvbnM6IFtcbiAqICAgICB0cmlnZ2VyKCdwYXJlbnRBbmltYXRpb24nLCBbXG4gKiAgICAgICB0cmFuc2l0aW9uKCdmYWxzZSA9PiB0cnVlJywgW1xuICogICAgICAgICBxdWVyeSgnaGVhZGVyJywgW1xuICogICAgICAgICAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSxcbiAqICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKVxuICogICAgICAgICBdKSxcbiAqICAgICAgICAgcXVlcnkoJ1xcQGNoaWxkQW5pbWF0aW9uJywgW1xuICogICAgICAgICAgIGFuaW1hdGVDaGlsZCgpXG4gKiAgICAgICAgIF0pXG4gKiAgICAgICBdKVxuICogICAgIF0pLFxuICogICAgIHRyaWdnZXIoJ2NoaWxkQW5pbWF0aW9uJywgW1xuICogICAgICAgdHJhbnNpdGlvbignZmFsc2UgPT4gdHJ1ZScsIFtcbiAqICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICogICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKVxuICogICAgICAgXSlcbiAqICAgICBdKVxuICogICBdXG4gKiB9KVxuICogY2xhc3MgUGFyZW50Q2hpbGRDbXAge1xuICogICBleHA6IGJvb2xlYW4gPSBmYWxzZTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEluIHRoZSBhbmltYXRpb24gY29kZSBhYm92ZSwgd2hlbiB0aGUgYHBhcmVudEFuaW1hdGlvbmAgdHJhbnNpdGlvbiBraWNrcyBvZmYgaXQgZmlyc3QgcXVlcmllcyB0b1xuICogZmluZCB0aGUgaGVhZGVyIGVsZW1lbnQgYW5kIGZhZGVzIGl0IGluLiBJdCB0aGVuIGZpbmRzIGVhY2ggb2YgdGhlIHN1YiBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlXG4gKiBgXFxAY2hpbGRBbmltYXRpb25gIHRyaWdnZXIgYW5kIHRoZW4gYWxsb3dzIGZvciB0aGVpciBhbmltYXRpb25zIHRvIGZpcmUuXG4gKlxuICogVGhpcyBleGFtcGxlIGNhbiBiZSBmdXJ0aGVyIGV4dGVuZGVkIGJ5IHVzaW5nIHN0YWdnZXI6XG4gKlxuICogYGBgdHNcbiAqIHF1ZXJ5KCdcXEBjaGlsZEFuaW1hdGlvbicsIHN0YWdnZXIoMTAwLCBbXG4gKiAgIGFuaW1hdGVDaGlsZCgpXG4gKiBdKSlcbiAqIGBgYFxuICpcbiAqIE5vdyBlYWNoIG9mIHRoZSBzdWIgYW5pbWF0aW9ucyBzdGFydCBvZmYgd2l0aCByZXNwZWN0IHRvIHRoZSBgMTAwbXNgIHN0YWdnZXJpbmcgc3RlcC5cbiAqXG4gKiAjIyBUaGUgZmlyc3QgZnJhbWUgb2YgY2hpbGQgYW5pbWF0aW9uc1xuICogV2hlbiBzdWIgYW5pbWF0aW9ucyBhcmUgZXhlY3V0ZWQgdXNpbmcgYGFuaW1hdGVDaGlsZGAgdGhlIGFuaW1hdGlvbiBlbmdpbmUgd2lsbCBhbHdheXMgYXBwbHkgdGhlXG4gKiBmaXJzdCBmcmFtZSBvZiBldmVyeSBzdWIgYW5pbWF0aW9uIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uIHNlcXVlbmNlLiBUaGlzIHdheVxuICogdGhlIHBhcmVudCBhbmltYXRpb24gZG9lcyBub3QgbmVlZCB0byBzZXQgYW55IGluaXRpYWwgc3R5bGluZyBkYXRhIG9uIHRoZSBzdWIgZWxlbWVudHMgYmVmb3JlIHRoZVxuICogc3ViIGFuaW1hdGlvbnMga2ljayBvZmYuXG4gKlxuICogSW4gdGhlIGV4YW1wbGUgYWJvdmUgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBgY2hpbGRBbmltYXRpb25gJ3MgYGZhbHNlID0+IHRydWVgIHRyYW5zaXRpb25cbiAqIGNvbnNpc3RzIG9mIGEgc3R5bGUgb2YgYG9wYWNpdHk6IDBgLiBUaGlzIGlzIGFwcGxpZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgYHBhcmVudEFuaW1hdGlvbmBcbiAqIGFuaW1hdGlvbiB0cmFuc2l0aW9uIHNlcXVlbmNlIHN0YXJ0cy4gT25seSB0aGVuIHdoZW4gdGhlIGBcXEBjaGlsZEFuaW1hdGlvbmAgaXMgcXVlcmllZCBhbmQgY2FsbGVkXG4gKiB3aXRoIGBhbmltYXRlQ2hpbGRgIHdpbGwgaXQgdGhlbiBhbmltYXRlIHRvIGl0cyBkZXN0aW5hdGlvbiBvZiBgb3BhY2l0eTogMWAuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZmVhdHVyZSBkZXNpZ25lZCB0byBiZSB1c2VkIGFsb25nc2lkZSB7XFxAbGluayBxdWVyeSBxdWVyeSgpfSBhbmQgaXQgd2lsbCBvbmx5IHdvcmtcbiAqIHdpdGggYW5pbWF0aW9ucyB0aGF0IGFyZSBhc3NpZ25lZCB1c2luZyB0aGUgQW5ndWxhciBhbmltYXRpb24gRFNMICh0aGlzIG1lYW5zIHRoYXQgQ1NTIGtleWZyYW1lc1xuICogYW5kIHRyYW5zaXRpb25zIGFyZSBub3QgaGFuZGxlZCBieSB0aGlzIEFQSSkuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVDaGlsZChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgIHJldHVybiB7IHR5cGU6IDkgLyogQW5pbWF0ZUNoaWxkICovLCBvcHRpb25zOiBvcHRpb25zIH07XG59XG4vKipcbiAqIGB1c2VBbmltYXRpb25gIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXInc1xuICogYW5pbWF0aW9uIERTTCBsYW5ndWFnZS4gSXQgaXMgdXNlZCB0byBraWNrIG9mZiBhIHJldXNhYmxlIGFuaW1hdGlvbiB0aGF0IGlzIGNyZWF0ZWQgdXNpbmcge1xcQGxpbmtcbiAqIGFuaW1hdGlvbiBhbmltYXRpb24oKX0uXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gKiBAcGFyYW0gez89fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB1c2VBbmltYXRpb24oYW5pbWF0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgIHJldHVybiB7IHR5cGU6IDEwIC8qIEFuaW1hdGVSZWYgKi8sIGFuaW1hdGlvbjogYW5pbWF0aW9uLCBvcHRpb25zOiBvcHRpb25zIH07XG59XG4vKipcbiAqIGBxdWVyeWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLlxuICpcbiAqIHF1ZXJ5KCkgaXMgdXNlZCB0byBmaW5kIG9uZSBvciBtb3JlIGlubmVyIGVsZW1lbnRzIHdpdGhpbiB0aGUgY3VycmVudCBlbGVtZW50IHRoYXQgaXNcbiAqIGJlaW5nIGFuaW1hdGVkIHdpdGhpbiB0aGUgc2VxdWVuY2UuIFRoZSBwcm92aWRlZCBhbmltYXRpb24gc3RlcHMgYXJlIGFwcGxpZWRcbiAqIHRvIHRoZSBxdWVyaWVkIGVsZW1lbnQgKGJ5IGRlZmF1bHQsIGFuIGFycmF5IGlzIHByb3ZpZGVkLCB0aGVuIHRoaXMgd2lsbCBiZVxuICogdHJlYXRlZCBhcyBhbiBhbmltYXRpb24gc2VxdWVuY2UpLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIHF1ZXJ5KCkgaXMgZGVzaWduZWQgdG8gY29sbGVjdCBtdXRpcGxlIGVsZW1lbnRzIGFuZCB3b3JrcyBpbnRlcm5hbGx5IGJ5IHVzaW5nXG4gKiBgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsYC4gQW4gYWRkaXRpb25hbCBvcHRpb25zIG9iamVjdCBjYW4gYmUgcHJvdmlkZWQgd2hpY2hcbiAqIGNhbiBiZSB1c2VkIHRvIGxpbWl0IHRoZSB0b3RhbCBhbW91bnQgb2YgaXRlbXMgdG8gYmUgY29sbGVjdGVkLlxuICpcbiAqIGBgYGpzXG4gKiBxdWVyeSgnZGl2JywgW1xuICogICBhbmltYXRlKC4uLiksXG4gKiAgIGFuaW1hdGUoLi4uKVxuICogXSwgeyBsaW1pdDogMSB9KVxuICogYGBgXG4gKlxuICogcXVlcnkoKSwgYnkgZGVmYXVsdCwgd2lsbCB0aHJvdyBhbiBlcnJvciB3aGVuIHplcm8gaXRlbXMgYXJlIGZvdW5kLiBJZiBhIHF1ZXJ5XG4gKiBoYXMgdGhlIGBvcHRpb25hbGAgZmxhZyBzZXQgdG8gdHJ1ZSB0aGVuIHRoaXMgZXJyb3Igd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIGBgYGpzXG4gKiBxdWVyeSgnLnNvbWUtZWxlbWVudC10aGF0LW1heS1ub3QtYmUtdGhlcmUnLCBbXG4gKiAgIGFuaW1hdGUoLi4uKSxcbiAqICAgYW5pbWF0ZSguLi4pXG4gKiBdLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG4gKiBgYGBcbiAqXG4gKiAjIyMgU3BlY2lhbCBTZWxlY3RvciBWYWx1ZXNcbiAqXG4gKiBUaGUgc2VsZWN0b3IgdmFsdWUgd2l0aGluIGEgcXVlcnkgY2FuIGNvbGxlY3QgZWxlbWVudHMgdGhhdCBjb250YWluIGFuZ3VsYXItc3BlY2lmaWNcbiAqIGNoYXJhY3RlcmlzdGljc1xuICogdXNpbmcgc3BlY2lhbCBwc2V1ZG8tc2VsZWN0b3JzIHRva2Vucy5cbiAqXG4gKiBUaGVzZSBpbmNsdWRlOlxuICpcbiAqICAtIFF1ZXJ5aW5nIGZvciBuZXdseSBpbnNlcnRlZC9yZW1vdmVkIGVsZW1lbnRzIHVzaW5nIGBxdWVyeShcIjplbnRlclwiKWAvYHF1ZXJ5KFwiOmxlYXZlXCIpYFxuICogIC0gUXVlcnlpbmcgYWxsIGN1cnJlbnRseSBhbmltYXRpbmcgZWxlbWVudHMgdXNpbmcgYHF1ZXJ5KFwiOmFuaW1hdGluZ1wiKWBcbiAqICAtIFF1ZXJ5aW5nIGVsZW1lbnRzIHRoYXQgY29udGFpbiBhbiBhbmltYXRpb24gdHJpZ2dlciB1c2luZyBgcXVlcnkoXCJcXEB0cmlnZ2VyTmFtZVwiKWBcbiAqICAtIFF1ZXJ5aW5nIGFsbCBlbGVtZW50cyB0aGF0IGNvbnRhaW4gYW4gYW5pbWF0aW9uIHRyaWdnZXJzIHVzaW5nIGBxdWVyeShcIlxcQCpcIilgXG4gKiAgLSBJbmNsdWRpbmcgdGhlIGN1cnJlbnQgZWxlbWVudCBpbnRvIHRoZSBhbmltYXRpb24gc2VxdWVuY2UgdXNpbmcgYHF1ZXJ5KFwiOnNlbGZcIilgXG4gKlxuICpcbiAqICBFYWNoIG9mIHRoZXNlIHBzZXVkby1zZWxlY3RvciB0b2tlbnMgY2FuIGJlIG1lcmdlZCB0b2dldGhlciBpbnRvIGEgY29tYmluZWQgcXVlcnkgc2VsZWN0b3JcbiAqIHN0cmluZzpcbiAqXG4gKiAgYGBgXG4gKiAgcXVlcnkoJzpzZWxmLCAucmVjb3JkOmVudGVyLCAucmVjb3JkOmxlYXZlLCBcXEBzdWJUcmlnZ2VyJywgWy4uLl0pXG4gKiAgYGBgXG4gKlxuICogIyMjIERlbW9cbiAqXG4gKiBgYGBcbiAqIFxcQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnaW5uZXInLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxkaXYgW1xcQHF1ZXJ5QW5pbWF0aW9uXT1cImV4cFwiPlxuICogICAgICAgPGgxPlRpdGxlPC9oMT5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gKiAgICAgICAgIEJsYWggYmxhaCBibGFoXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqICAgYCxcbiAqICAgYW5pbWF0aW9uczogW1xuICogICAgdHJpZ2dlcigncXVlcnlBbmltYXRpb24nLCBbXG4gKiAgICAgIHRyYW5zaXRpb24oJyogPT4gZ29BbmltYXRlJywgW1xuICogICAgICAgIC8vIGhpZGUgdGhlIGlubmVyIGVsZW1lbnRzXG4gKiAgICAgICAgcXVlcnkoJ2gxJywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKSxcbiAqICAgICAgICBxdWVyeSgnLmNvbnRlbnQnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpLFxuICpcbiAqICAgICAgICAvLyBhbmltYXRlIHRoZSBpbm5lciBlbGVtZW50cyBpbiwgb25lIGJ5IG9uZVxuICogICAgICAgIHF1ZXJ5KCdoMScsIGFuaW1hdGUoMTAwMCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKSxcbiAqICAgICAgICBxdWVyeSgnLmNvbnRlbnQnLCBhbmltYXRlKDEwMDAsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSksXG4gKiAgICAgIF0pXG4gKiAgICBdKVxuICogIF1cbiAqIH0pXG4gKiBjbGFzcyBDbXAge1xuICogICBleHAgPSAnJztcbiAqXG4gKiAgIGdvQW5pbWF0ZSgpIHtcbiAqICAgICB0aGlzLmV4cCA9ICdnb0FuaW1hdGUnO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yLCBhbmltYXRpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIHsgdHlwZTogMTEgLyogUXVlcnkgKi8sIHNlbGVjdG9yOiBzZWxlY3RvciwgYW5pbWF0aW9uOiBhbmltYXRpb24sIG9wdGlvbnM6IG9wdGlvbnMgfTtcbn1cbi8qKlxuICogYHN0YWdnZXJgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXInc1xuICogYW5pbWF0aW9uIERTTCBsYW5ndWFnZS4gSXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgYW4gYW5pbWF0aW9uIHtcXEBsaW5rIHF1ZXJ5IHF1ZXJ5KCl9XG4gKiBhbmQgd29ya3MgYnkgaXNzdWluZyBhIHRpbWluZyBnYXAgYmV0d2VlbiBhZnRlciBlYWNoIHF1ZXJpZWQgaXRlbSBpcyBhbmltYXRlZC5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBJbiB0aGUgZXhhbXBsZSBiZWxvdyB0aGVyZSBpcyBhIGNvbnRhaW5lciBlbGVtZW50IHRoYXQgd3JhcHMgYSBsaXN0IG9mIGl0ZW1zIHN0YW1wZWQgb3V0XG4gKiBieSBhbiBuZ0Zvci4gVGhlIGNvbnRhaW5lciBlbGVtZW50IGNvbnRhaW5zIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHRoYXQgd2lsbCBsYXRlciBiZSBzZXRcbiAqIHRvIHF1ZXJ5IGZvciBlYWNoIG9mIHRoZSBpbm5lciBpdGVtcy5cbiAqXG4gKiBgYGBodG1sXG4gKiA8IS0tIGxpc3QuY29tcG9uZW50Lmh0bWwgLS0+XG4gKiA8YnV0dG9uIChjbGljayk9XCJ0b2dnbGUoKVwiPlNob3cgLyBIaWRlIEl0ZW1zPC9idXR0b24+XG4gKiA8aHIgLz5cbiAqIDxkaXYgW1xcQGxpc3RBbmltYXRpb25dPVwiaXRlbXMubGVuZ3RoXCI+XG4gKiAgIDxkaXYgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj5cbiAqICAgICB7eyBpdGVtIH19XG4gKiAgIDwvZGl2PlxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBUaGUgY29tcG9uZW50IGNvZGUgZm9yIHRoaXMgbG9va3MgYXMgc3VjaDpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHt0cmlnZ2VyLCB0cmFuc2l0aW9uLCBzdHlsZSwgYW5pbWF0ZSwgcXVlcnksIHN0YWdnZXJ9IGZyb20gJ1xcQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG4gKiBcXEBDb21wb25lbnQoe1xuICogICB0ZW1wbGF0ZVVybDogJ2xpc3QuY29tcG9uZW50Lmh0bWwnLFxuICogICBhbmltYXRpb25zOiBbXG4gKiAgICAgdHJpZ2dlcignbGlzdEFuaW1hdGlvbicsIFtcbiAqICAgICAgICAvLy4uLlxuICogICAgIF0pXG4gKiAgIF1cbiAqIH0pXG4gKiBjbGFzcyBMaXN0Q29tcG9uZW50IHtcbiAqICAgaXRlbXMgPSBbXTtcbiAqXG4gKiAgIHNob3dJdGVtcygpIHtcbiAqICAgICB0aGlzLml0ZW1zID0gWzAsMSwyLDMsNF07XG4gKiAgIH1cbiAqXG4gKiAgIGhpZGVJdGVtcygpIHtcbiAqICAgICB0aGlzLml0ZW1zID0gW107XG4gKiAgIH1cbiAqXG4gKiAgIHRvZ2dsZSgpIHtcbiAqICAgICB0aGlzLml0ZW1zLmxlbmd0aCA/IHRoaXMuaGlkZUl0ZW1zKCkgOiB0aGlzLnNob3dJdGVtcygpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBBbmQgbm93IGZvciB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgY29kZTpcbiAqXG4gKiBgYGB0c1xuICogdHJpZ2dlcignbGlzdEFuaW1hdGlvbicsIFtcbiAqICAgdHJhbnNpdGlvbignKiA9PiAqJywgWyAvLyBlYWNoIHRpbWUgdGhlIGJpbmRpbmcgdmFsdWUgY2hhbmdlc1xuICogICAgIHF1ZXJ5KCc6bGVhdmUnLCBbXG4gKiAgICAgICBzdGFnZ2VyKDEwMCwgW1xuICogICAgICAgICBhbmltYXRlKCcwLjVzJywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxuICogICAgICAgXSlcbiAqICAgICBdKSxcbiAqICAgICBxdWVyeSgnOmVudGVyJywgW1xuICogICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICogICAgICAgc3RhZ2dlcigxMDAsIFtcbiAqICAgICAgICAgYW5pbWF0ZSgnMC41cycsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSlcbiAqICAgICAgIF0pXG4gKiAgICAgXSlcbiAqICAgXSlcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBOb3cgZWFjaCB0aW1lIHRoZSBpdGVtcyBhcmUgYWRkZWQvcmVtb3ZlZCB0aGVuIGVpdGhlciB0aGUgb3BhY2l0eVxuICogZmFkZS1pbiBhbmltYXRpb24gd2lsbCBydW4gb3IgZWFjaCByZW1vdmVkIGl0ZW0gd2lsbCBiZSBmYWRlZCBvdXQuXG4gKiBXaGVuIGVpdGhlciBvZiB0aGVzZSBhbmltYXRpb25zIG9jY3VyIHRoZW4gYSBzdGFnZ2VyIGVmZmVjdCB3aWxsIGJlXG4gKiBhcHBsaWVkIGFmdGVyIGVhY2ggaXRlbSdzIGFuaW1hdGlvbiBpcyBzdGFydGVkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcGFyYW0gez99IHRpbWluZ3NcbiAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdGFnZ2VyKHRpbWluZ3MsIGFuaW1hdGlvbikge1xuICAgIHJldHVybiB7IHR5cGU6IDEyIC8qIFN0YWdnZXIgKi8sIHRpbWluZ3M6IHRpbWluZ3MsIGFuaW1hdGlvbjogYW5pbWF0aW9uIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICogQHBhcmFtIHs/fSBjYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2NoZWR1bGVNaWNyb1Rhc2soY2IpIHtcbiAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihjYik7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKi9cbnZhciBOb29wQW5pbWF0aW9uUGxheWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uUGxheWVyKCkge1xuICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRlc3Ryb3lGbnMucHVzaChmbik7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJNaWNyb3Rhc2soKTtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUudHJpZ2dlck1pY3JvdGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmluaXNoKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fb25TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vbkZpbmlzaCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGVzdHJveUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHApIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcbiAgICByZXR1cm4gTm9vcEFuaW1hdGlvblBsYXllcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQW5pbWF0aW9uR3JvdXBQbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3BsYXllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25Hcm91cFBsYXllcihfcGxheWVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9wbGF5ZXJzID0gX3BsYXllcnM7XG4gICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveUZucyA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcbiAgICAgICAgdmFyIGRvbmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBkZXN0cm95Q291bnQgPSAwO1xuICAgICAgICB2YXIgc3RhcnRDb3VudCA9IDA7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuX3BsYXllcnMubGVuZ3RoO1xuICAgICAgICBpZiAodG90YWwgPT0gMCkge1xuICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmluaXNoKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyID0gX3RoaXM7XG4gICAgICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2RvbmVDb3VudCA+PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIub25EZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrZGVzdHJveUNvdW50ID49IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25EZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIub25TdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK3N0YXJ0Q291bnQgPj0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vblN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxUaW1lID0gdGhpcy5fcGxheWVycy5yZWR1Y2UoZnVuY3Rpb24gKHRpbWUsIHBsYXllcikgeyByZXR1cm4gTWF0aC5tYXgodGltZSwgcGxheWVyLnRvdGFsVGltZSk7IH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5pbml0KCk7IH0pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uU3RhcnRGbnMucHVzaChmbik7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuX29uU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25EZXN0cm95Rm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRQbGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uU3RhcnQoKTtcbiAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5wbGF5KCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucGF1c2UoKTsgfSk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5yZXN0YXJ0KCk7IH0pOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5maW5pc2goKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vbkRlc3Ryb3koKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5fb25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25EZXN0cm95Rm5zID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLnJlc2V0KCk7IH0pO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lQXRQb3NpdGlvbiA9IHAgKiB0aGlzLnRvdGFsVGltZTtcbiAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc2l0aW9uID0gcGxheWVyLnRvdGFsVGltZSA/IE1hdGgubWluKDEsIHRpbWVBdFBvc2l0aW9uIC8gcGxheWVyLnRvdGFsVGltZSkgOiAxO1xuICAgICAgICAgICAgcGxheWVyLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWluID0gMDtcbiAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHAgPSBwbGF5ZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHAsIG1pbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZSwgXCJwbGF5ZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYXllcnM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmJlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChwbGF5ZXIuYmVmb3JlRGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHBsYXllci5iZWZvcmVEZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvbkdyb3VwUGxheWVyO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciDJtVBSRV9TVFlMRSA9ICchJztcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIGFuaW1hdGlvbiBBUElzIG9mIHRoZSBhbmltYXRpb24gcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIGFuaW1hdGlvbiBwYWNrYWdlLlxuICovXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5leHBvcnQgeyBBbmltYXRpb25CdWlsZGVyLCBBbmltYXRpb25GYWN0b3J5LCBBVVRPX1NUWUxFLCBhbmltYXRlLCBhbmltYXRlQ2hpbGQsIGFuaW1hdGlvbiwgZ3JvdXAsIGtleWZyYW1lcywgcXVlcnksIHNlcXVlbmNlLCBzdGFnZ2VyLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIsIHVzZUFuaW1hdGlvbiwgTm9vcEFuaW1hdGlvblBsYXllciwgQW5pbWF0aW9uR3JvdXBQbGF5ZXIgYXMgybVBbmltYXRpb25Hcm91cFBsYXllciwgybVQUkVfU1RZTEUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGlvbnMuZXM1LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL2FuaW1hdGlvbnMvQGFuZ3VsYXIvYW5pbWF0aW9ucy5lczUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2FuaW1hdGlvbnMvQGFuZ3VsYXIvYW5pbWF0aW9ucy5lczUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NC4zLjNcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5pbXBvcnQgeyBBVVRPX1NUWUxFLCBOb29wQW5pbWF0aW9uUGxheWVyLCBzZXF1ZW5jZSwgc3R5bGUsIMm1QW5pbWF0aW9uR3JvdXBQbGF5ZXIsIMm1UFJFX1NUWUxFIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpIHtcbiAgICBzd2l0Y2ggKHBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyc1swXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgybVBbmltYXRpb25Hcm91cFBsYXllcihwbGF5ZXJzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVLZXlmcmFtZXMoZHJpdmVyLCBub3JtYWxpemVyLCBlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlcywgcG9zdFN0eWxlcykge1xuICAgIGlmIChwcmVTdHlsZXMgPT09IHZvaWQgMCkgeyBwcmVTdHlsZXMgPSB7fTsgfVxuICAgIGlmIChwb3N0U3R5bGVzID09PSB2b2lkIDApIHsgcG9zdFN0eWxlcyA9IHt9OyB9XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBub3JtYWxpemVkS2V5ZnJhbWVzID0gW107XG4gICAgdmFyIHByZXZpb3VzT2Zmc2V0ID0gLTE7XG4gICAgdmFyIHByZXZpb3VzS2V5ZnJhbWUgPSBudWxsO1xuICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZikge1xuICAgICAgICB2YXIgb2Zmc2V0ID0ga2ZbJ29mZnNldCddO1xuICAgICAgICB2YXIgaXNTYW1lT2Zmc2V0ID0gb2Zmc2V0ID09IHByZXZpb3VzT2Zmc2V0O1xuICAgICAgICB2YXIgbm9ybWFsaXplZEtleWZyYW1lID0gKGlzU2FtZU9mZnNldCAmJiBwcmV2aW91c0tleWZyYW1lKSB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoa2YpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkUHJvcCA9IHByb3A7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0ga2ZbcHJvcF07XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZXIubm9ybWFsaXplUHJvcGVydHlOYW1lKG5vcm1hbGl6ZWRQcm9wLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9ybWFsaXplZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgybVQUkVfU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBwcmVTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBVVRPX1NUWUxFOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gcG9zdFN0eWxlc1twcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVyLm5vcm1hbGl6ZVN0eWxlVmFsdWUocHJvcCwgbm9ybWFsaXplZFByb3AsIG5vcm1hbGl6ZWRWYWx1ZSwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlmcmFtZVtub3JtYWxpemVkUHJvcF0gPSBub3JtYWxpemVkVmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzU2FtZU9mZnNldCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZEtleWZyYW1lcy5wdXNoKG5vcm1hbGl6ZWRLZXlmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNLZXlmcmFtZSA9IG5vcm1hbGl6ZWRLZXlmcmFtZTtcbiAgICAgICAgcHJldmlvdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfSk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIExJTkVfU1RBUlQgPSAnXFxuIC0gJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGFuaW1hdGUgZHVlIHRvIHRoZSBmb2xsb3dpbmcgZXJyb3JzOlwiICsgTElORV9TVEFSVCArIGVycm9ycy5qb2luKExJTkVfU1RBUlQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRLZXlmcmFtZXM7XG59XG5mdW5jdGlvbiBsaXN0ZW5PblBsYXllcihwbGF5ZXIsIGV2ZW50TmFtZSwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soZXZlbnQgJiYgY29weUFuaW1hdGlvbkV2ZW50KGV2ZW50LCAnc3RhcnQnLCBwbGF5ZXIudG90YWxUaW1lKSk7IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCAmJiBjb3B5QW5pbWF0aW9uRXZlbnQoZXZlbnQsICdkb25lJywgcGxheWVyLnRvdGFsVGltZSkpOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soZXZlbnQgJiYgY29weUFuaW1hdGlvbkV2ZW50KGV2ZW50LCAnZGVzdHJveScsIHBsYXllci50b3RhbFRpbWUpKTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBjb3B5QW5pbWF0aW9uRXZlbnQoZSwgcGhhc2VOYW1lLCB0b3RhbFRpbWUpIHtcbiAgICB2YXIgZXZlbnQgPSBtYWtlQW5pbWF0aW9uRXZlbnQoZS5lbGVtZW50LCBlLnRyaWdnZXJOYW1lLCBlLmZyb21TdGF0ZSwgZS50b1N0YXRlLCBwaGFzZU5hbWUgfHwgZS5waGFzZU5hbWUsIHRvdGFsVGltZSA9PSB1bmRlZmluZWQgPyBlLnRvdGFsVGltZSA6IHRvdGFsVGltZSk7XG4gICAgdmFyIGRhdGEgPSBlWydfZGF0YSddO1xuICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgZXZlbnRbJ19kYXRhJ10gPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBtYWtlQW5pbWF0aW9uRXZlbnQoZWxlbWVudCwgdHJpZ2dlck5hbWUsIGZyb21TdGF0ZSwgdG9TdGF0ZSwgcGhhc2VOYW1lLCB0b3RhbFRpbWUpIHtcbiAgICBpZiAocGhhc2VOYW1lID09PSB2b2lkIDApIHsgcGhhc2VOYW1lID0gJyc7IH1cbiAgICBpZiAodG90YWxUaW1lID09PSB2b2lkIDApIHsgdG90YWxUaW1lID0gMDsgfVxuICAgIHJldHVybiB7IGVsZW1lbnQ6IGVsZW1lbnQsIHRyaWdnZXJOYW1lOiB0cmlnZ2VyTmFtZSwgZnJvbVN0YXRlOiBmcm9tU3RhdGUsIHRvU3RhdGU6IHRvU3RhdGUsIHBoYXNlTmFtZTogcGhhc2VOYW1lLCB0b3RhbFRpbWU6IHRvdGFsVGltZSB9O1xufVxuZnVuY3Rpb24gZ2V0T3JTZXRBc0luTWFwKG1hcCwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlID0gZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBtYXBba2V5XTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXBba2V5XSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZVRpbWVsaW5lQ29tbWFuZChjb21tYW5kKSB7XG4gICAgdmFyIHNlcGFyYXRvclBvcyA9IGNvbW1hbmQuaW5kZXhPZignOicpO1xuICAgIHZhciBpZCA9IGNvbW1hbmQuc3Vic3RyaW5nKDEsIHNlcGFyYXRvclBvcyk7XG4gICAgdmFyIGFjdGlvbiA9IGNvbW1hbmQuc3Vic3RyKHNlcGFyYXRvclBvcyArIDEpO1xuICAgIHJldHVybiBbaWQsIGFjdGlvbl07XG59XG52YXIgX2NvbnRhaW5zID0gZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIF9tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7IHJldHVybiBmYWxzZTsgfTtcbnZhciBfcXVlcnkgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKSB7XG4gICAgcmV0dXJuIFtdO1xufTtcbmlmICh0eXBlb2YgRWxlbWVudCAhPSAndW5kZWZpbmVkJykge1xuICAgIC8vIHRoaXMgaXMgd2VsbCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzXG4gICAgX2NvbnRhaW5zID0gZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGVsbTEuY29udGFpbnMoZWxtMik7IH07XG4gICAgaWYgKEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgICAgICAgX21hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHsgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgICAgdmFyIGZuXzEgPSBwcm90by5tYXRjaGVzU2VsZWN0b3IgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICBwcm90by5vTWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbiAgICAgICAgaWYgKGZuXzEpIHtcbiAgICAgICAgICAgIF9tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7IHJldHVybiBmbl8xLmFwcGx5KGVsZW1lbnQsIFtzZWxlY3Rvcl0pOyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9xdWVyeSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZWxtID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xufVxudmFyIG1hdGNoZXNFbGVtZW50ID0gX21hdGNoZXM7XG52YXIgY29udGFpbnNFbGVtZW50ID0gX2NvbnRhaW5zO1xudmFyIGludm9rZVF1ZXJ5ID0gX3F1ZXJ5O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBOb29wQW5pbWF0aW9uRHJpdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uRHJpdmVyKCkge1xuICAgIH1cbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5tYXRjaGVzRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH07XG4gICAgTm9vcEFuaW1hdGlvbkRyaXZlci5wcm90b3R5cGUuY29udGFpbnNFbGVtZW50ID0gZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGNvbnRhaW5zRWxlbWVudChlbG0xLCBlbG0yKTsgfTtcbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVF1ZXJ5KGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSk7XG4gICAgfTtcbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5jb21wdXRlU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgJyc7XG4gICAgfTtcbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIHByZXZpb3VzUGxheWVycykge1xuICAgICAgICBpZiAocHJldmlvdXNQbGF5ZXJzID09PSB2b2lkIDApIHsgcHJldmlvdXNQbGF5ZXJzID0gW107IH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb29wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9vcEFuaW1hdGlvbkRyaXZlcjtcbn0oKSk7XG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xudmFyIEFuaW1hdGlvbkRyaXZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRHJpdmVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gQW5pbWF0aW9uRHJpdmVyO1xufSgpKTtcbkFuaW1hdGlvbkRyaXZlci5OT09QID0gbmV3IE5vb3BBbmltYXRpb25Ecml2ZXIoKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBPTkVfU0VDT05EID0gMTAwMDtcbnZhciBFTlRFUl9DTEFTU05BTUUgPSAnbmctZW50ZXInO1xudmFyIExFQVZFX0NMQVNTTkFNRSA9ICduZy1sZWF2ZSc7XG52YXIgRU5URVJfU0VMRUNUT1IgPSAnLm5nLWVudGVyJztcbnZhciBMRUFWRV9TRUxFQ1RPUiA9ICcubmctbGVhdmUnO1xudmFyIE5HX1RSSUdHRVJfQ0xBU1NOQU1FID0gJ25nLXRyaWdnZXInO1xudmFyIE5HX1RSSUdHRVJfU0VMRUNUT1IgPSAnLm5nLXRyaWdnZXInO1xudmFyIE5HX0FOSU1BVElOR19DTEFTU05BTUUgPSAnbmctYW5pbWF0aW5nJztcbnZhciBOR19BTklNQVRJTkdfU0VMRUNUT1IgPSAnLm5nLWFuaW1hdGluZyc7XG5mdW5jdGlvbiByZXNvbHZlVGltaW5nVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgdmFyIG1hdGNoZXMgPSB2YWx1ZS5tYXRjaCgvXigtP1tcXC5cXGRdKykobT9zKS8pO1xuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBfY29udmVydFRpbWVWYWx1ZVRvTVMocGFyc2VGbG9hdChtYXRjaGVzWzFdKSwgbWF0Y2hlc1syXSk7XG59XG5mdW5jdGlvbiBfY29udmVydFRpbWVWYWx1ZVRvTVModmFsdWUsIHVuaXQpIHtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKiBPTkVfU0VDT05EO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVUaW1pbmcodGltaW5ncywgZXJyb3JzLCBhbGxvd05lZ2F0aXZlVmFsdWVzKSB7XG4gICAgcmV0dXJuIHRpbWluZ3MuaGFzT3duUHJvcGVydHkoJ2R1cmF0aW9uJykgP1xuICAgICAgICB0aW1pbmdzIDpcbiAgICAgICAgcGFyc2VUaW1lRXhwcmVzc2lvbih0aW1pbmdzLCBlcnJvcnMsIGFsbG93TmVnYXRpdmVWYWx1ZXMpO1xufVxuZnVuY3Rpb24gcGFyc2VUaW1lRXhwcmVzc2lvbihleHAsIGVycm9ycywgYWxsb3dOZWdhdGl2ZVZhbHVlcykge1xuICAgIHZhciByZWdleCA9IC9eKC0/W1xcLlxcZF0rKShtP3MpKD86XFxzKygtP1tcXC5cXGRdKykobT9zKSk/KD86XFxzKyhbLWEtel0rKD86XFwoLis/XFwpKT8pKT8kL2k7XG4gICAgdmFyIGR1cmF0aW9uO1xuICAgIHZhciBkZWxheSA9IDA7XG4gICAgdmFyIGVhc2luZyA9ICcnO1xuICAgIGlmICh0eXBlb2YgZXhwID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGV4cC5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIlRoZSBwcm92aWRlZCB0aW1pbmcgdmFsdWUgXFxcIlwiICsgZXhwICsgXCJcXFwiIGlzIGludmFsaWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZHVyYXRpb246IDAsIGRlbGF5OiAwLCBlYXNpbmc6ICcnIH07XG4gICAgICAgIH1cbiAgICAgICAgZHVyYXRpb24gPSBfY29udmVydFRpbWVWYWx1ZVRvTVMocGFyc2VGbG9hdChtYXRjaGVzWzFdKSwgbWF0Y2hlc1syXSk7XG4gICAgICAgIHZhciBkZWxheU1hdGNoID0gbWF0Y2hlc1szXTtcbiAgICAgICAgaWYgKGRlbGF5TWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsYXkgPSBfY29udmVydFRpbWVWYWx1ZVRvTVMoTWF0aC5mbG9vcihwYXJzZUZsb2F0KGRlbGF5TWF0Y2gpKSwgbWF0Y2hlc1s0XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVhc2luZ1ZhbCA9IG1hdGNoZXNbNV07XG4gICAgICAgIGlmIChlYXNpbmdWYWwpIHtcbiAgICAgICAgICAgIGVhc2luZyA9IGVhc2luZ1ZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZHVyYXRpb24gPSBleHA7XG4gICAgfVxuICAgIGlmICghYWxsb3dOZWdhdGl2ZVZhbHVlcykge1xuICAgICAgICB2YXIgY29udGFpbnNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBlcnJvcnMubGVuZ3RoO1xuICAgICAgICBpZiAoZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIkR1cmF0aW9uIHZhbHVlcyBiZWxvdyAwIGFyZSBub3QgYWxsb3dlZCBmb3IgdGhpcyBhbmltYXRpb24gc3RlcC5cIik7XG4gICAgICAgICAgICBjb250YWluc0Vycm9ycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJEZWxheSB2YWx1ZXMgYmVsb3cgMCBhcmUgbm90IGFsbG93ZWQgZm9yIHRoaXMgYW5pbWF0aW9uIHN0ZXAuXCIpO1xuICAgICAgICAgICAgY29udGFpbnNFcnJvcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluc0Vycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnNwbGljZShzdGFydEluZGV4LCAwLCBcIlRoZSBwcm92aWRlZCB0aW1pbmcgdmFsdWUgXFxcIlwiICsgZXhwICsgXCJcXFwiIGlzIGludmFsaWQuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgZGVsYXk6IGRlbGF5LCBlYXNpbmc6IGVhc2luZyB9O1xufVxuZnVuY3Rpb24gY29weU9iaihvYmosIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKGRlc3RpbmF0aW9uID09PSB2b2lkIDApIHsgZGVzdGluYXRpb24gPSB7fTsgfVxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBkZXN0aW5hdGlvbltwcm9wXSA9IG9ialtwcm9wXTsgfSk7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVzKHN0eWxlcykge1xuICAgIHZhciBub3JtYWxpemVkU3R5bGVzID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gY29weVN0eWxlcyhkYXRhLCBmYWxzZSwgbm9ybWFsaXplZFN0eWxlcyk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29weVN0eWxlcyhzdHlsZXMsIGZhbHNlLCBub3JtYWxpemVkU3R5bGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTdHlsZXM7XG59XG5mdW5jdGlvbiBjb3B5U3R5bGVzKHN0eWxlcywgcmVhZFByb3RvdHlwZSwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoZGVzdGluYXRpb24gPT09IHZvaWQgMCkgeyBkZXN0aW5hdGlvbiA9IHt9OyB9XG4gICAgaWYgKHJlYWRQcm90b3R5cGUpIHtcbiAgICAgICAgLy8gd2UgbWFrZSB1c2Ugb2YgYSBmb3ItaW4gbG9vcCBzbyB0aGF0IHRoZVxuICAgICAgICAvLyBwcm90b3R5cGljYWxseSBpbmhlcml0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgICAgLy8gcmV2ZWFsZWQgZnJvbSB0aGUgYmFja0ZpbGwgbWFwXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29weU9iaihzdHlsZXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIGlmIChlbGVtZW50WydzdHlsZSddKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIGNhbWVsUHJvcCA9IGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcCk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW2NhbWVsUHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVyYXNlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIGlmIChlbGVtZW50WydzdHlsZSddKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIGNhbWVsUHJvcCA9IGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcCk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW2NhbWVsUHJvcF0gPSAnJztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQW5pbWF0aW9uRW50cnkoc3RlcHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGVwcykpIHtcbiAgICAgICAgaWYgKHN0ZXBzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHN0ZXBzWzBdO1xuICAgICAgICByZXR1cm4gc2VxdWVuY2Uoc3RlcHMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RlcHM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlUGFyYW1zKHZhbHVlLCBvcHRpb25zLCBlcnJvcnMpIHtcbiAgICB2YXIgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwge307XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgbWF0Y2hlcyA9IHZhbHVlLnRvU3RyaW5nKCkubWF0Y2goUEFSQU1fUkVHRVgpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuaGFzT3duUHJvcGVydHkodmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChcIlVuYWJsZSB0byByZXNvbHZlIHRoZSBsb2NhbCBhbmltYXRpb24gcGFyYW0gXCIgKyB2YXJOYW1lICsgXCIgaW4gdGhlIGdpdmVuIGxpc3Qgb2YgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG52YXIgUEFSQU1fUkVHRVggPSAvXFx7XFx7XFxzKiguKz8pXFxzKlxcfVxcfS9nO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVQYXJhbXModmFsdWUsIHBhcmFtcywgZXJyb3JzKSB7XG4gICAgdmFyIG9yaWdpbmFsID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB2YXIgc3RyID0gb3JpZ2luYWwucmVwbGFjZShQQVJBTV9SRUdFWCwgZnVuY3Rpb24gKF8sIHZhck5hbWUpIHtcbiAgICAgICAgdmFyIGxvY2FsVmFsID0gcGFyYW1zW3Zhck5hbWVdO1xuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIHZhbHVlIHdhcyBuZXZlciBvdmVyaWRkZW4gYnkgdGhlIGRhdGEgcGFzc2VkIGluIGJ5IHRoZSB1c2VyXG4gICAgICAgIGlmICghcGFyYW1zLmhhc093blByb3BlcnR5KHZhck5hbWUpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBwcm92aWRlIGEgdmFsdWUgZm9yIHRoZSBhbmltYXRpb24gcGFyYW0gXCIgKyB2YXJOYW1lKTtcbiAgICAgICAgICAgIGxvY2FsVmFsID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsVmFsLnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gICAgLy8gd2UgZG8gdGhpcyB0byBhc3NlcnQgdGhhdCBudW1lcmljIHZhbHVlcyBzdGF5IGFzIHRoZXkgYXJlXG4gICAgcmV0dXJuIHN0ciA9PSBvcmlnaW5hbCA/IHZhbHVlIDogc3RyO1xufVxuZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIHdoaWxlICghaXRlbS5kb25lKSB7XG4gICAgICAgIGFyci5wdXNoKGl0ZW0udmFsdWUpO1xuICAgICAgICBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gbWVyZ2VBbmltYXRpb25PcHRpb25zKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoc291cmNlLnBhcmFtcykge1xuICAgICAgICB2YXIgcDBfMSA9IHNvdXJjZS5wYXJhbXM7XG4gICAgICAgIGlmICghZGVzdGluYXRpb24ucGFyYW1zKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcDFfMSA9IGRlc3RpbmF0aW9uLnBhcmFtcztcbiAgICAgICAgT2JqZWN0LmtleXMocDBfMSkuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghcDFfMS5oYXNPd25Qcm9wZXJ0eShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICBwMV8xW3BhcmFtXSA9IHAwXzFbcGFyYW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxudmFyIERBU0hfQ0FTRV9SRUdFWFAgPSAvLSsoW2EtejAtOV0pL2c7XG5mdW5jdGlvbiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhbGxvd1ByZXZpb3VzUGxheWVyU3R5bGVzTWVyZ2UoZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uID09PSAwIHx8IGRlbGF5ID09PSAwO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVNUFRZX0FOSU1BVElPTl9PUFRJT05TID0ge307XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3QoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IEVNUFRZX0FOSU1BVElPTl9PUFRJT05TO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN0LnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vcHRpb25zWydwYXJhbXMnXSB8fCBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQXN0O1xufSgpKTtcbnZhciBUcmlnZ2VyQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUcmlnZ2VyQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVzXG4gICAgICogQHBhcmFtIHs/fSB0cmFuc2l0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyaWdnZXJBc3QobmFtZSwgc3RhdGVzLCB0cmFuc2l0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgICAgICBfdGhpcy50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICAgICAgICBfdGhpcy5xdWVyeUNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuZGVwQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJpZ2dlckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRyaWdnZXIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRyaWdnZXJBc3Q7XG59KEFzdCkpO1xudmFyIFN0YXRlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGF0ZUFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGVBc3QobmFtZSwgc3R5bGUkJDEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnN0eWxlID0gc3R5bGUkJDE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFN0YXRlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBTdGF0ZUFzdDtcbn0oQXN0KSk7XG52YXIgVHJhbnNpdGlvbkFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVHJhbnNpdGlvbkFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hdGNoZXJzXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uQXN0KG1hdGNoZXJzLCBhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWF0Y2hlcnMgPSBtYXRjaGVycztcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICBfdGhpcy5xdWVyeUNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuZGVwQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRyYW5zaXRpb24odGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRyYW5zaXRpb25Bc3Q7XG59KEFzdCkpO1xudmFyIFNlcXVlbmNlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTZXF1ZW5jZUFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VxdWVuY2VBc3Qoc3RlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcXVlbmNlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0U2VxdWVuY2UodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFNlcXVlbmNlQXN0O1xufShBc3QpKTtcbnZhciBHcm91cEFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoR3JvdXBBc3QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyb3VwQXN0KHN0ZXBzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBHcm91cEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEdyb3VwKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBHcm91cEFzdDtcbn0oQXN0KSk7XG52YXIgQW5pbWF0ZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQW5pbWF0ZUFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbWluZ3NcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0ZUFzdCh0aW1pbmdzLCBzdHlsZSQkMSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgX3RoaXMuc3R5bGUgPSBzdHlsZSQkMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBBbmltYXRlQXN0O1xufShBc3QpKTtcbnZhciBTdHlsZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3R5bGVBc3QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGVhc2luZ1xuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3R5bGVBc3Qoc3R5bGVzLCBlYXNpbmcsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIF90aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICAgICAgX3RoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBfdGhpcy5pc0VtcHR5U3RlcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3R5bGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHlsZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gU3R5bGVBc3Q7XG59KEFzdCkpO1xudmFyIEtleWZyYW1lc0FzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoS2V5ZnJhbWVzQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gS2V5ZnJhbWVzQXN0KHN0eWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBLZXlmcmFtZXNBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXlmcmFtZXModGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEtleWZyYW1lc0FzdDtcbn0oQXN0KSk7XG52YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWZlcmVuY2VBc3QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWZlcmVuY2VBc3QoYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlZmVyZW5jZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFJlZmVyZW5jZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlQXN0O1xufShBc3QpKTtcbnZhciBBbmltYXRlQ2hpbGRBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEFuaW1hdGVDaGlsZEFzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbmltYXRlQ2hpbGRBc3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGVDaGlsZEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGVDaGlsZCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gQW5pbWF0ZUNoaWxkQXN0O1xufShBc3QpKTtcbnZhciBBbmltYXRlUmVmQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBbmltYXRlUmVmQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0ZVJlZkFzdChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0ZVJlZkFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGVSZWYodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEFuaW1hdGVSZWZBc3Q7XG59KEFzdCkpO1xudmFyIFF1ZXJ5QXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhRdWVyeUFzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBsaW1pdFxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uYWxcbiAgICAgKiBAcGFyYW0gez99IGluY2x1ZGVTZWxmXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWVyeUFzdChzZWxlY3RvciwgbGltaXQsIG9wdGlvbmFsLCBpbmNsdWRlU2VsZiwgYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIF90aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIF90aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgIF90aGlzLmluY2x1ZGVTZWxmID0gaW5jbHVkZVNlbGY7XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFF1ZXJ5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0UXVlcnkodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFF1ZXJ5QXN0O1xufShBc3QpKTtcbnZhciBTdGFnZ2VyQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGFnZ2VyQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltaW5nc1xuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhZ2dlckFzdCh0aW1pbmdzLCBhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGltaW5ncyA9IHRpbWluZ3M7XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YWdnZXJBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGFnZ2VyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBTdGFnZ2VyQXN0O1xufShBc3QpKTtcbnZhciBUaW1pbmdBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWluZ0FzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gZGVsYXlcbiAgICAgKiBAcGFyYW0gez89fSBlYXNpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaW1pbmdBc3QoZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIGlmIChlYXNpbmcgPT09IHZvaWQgMCkgeyBlYXNpbmcgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIF90aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIF90aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWluZ0FzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRpbWluZyh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGltaW5nQXN0O1xufShBc3QpKTtcbnZhciBEeW5hbWljVGltaW5nQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEeW5hbWljVGltaW5nQXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEeW5hbWljVGltaW5nQXN0KHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDAsIDAsICcnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRHluYW1pY1RpbWluZ0FzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRpbWluZyh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gRHluYW1pY1RpbWluZ0FzdDtcbn0oVGltaW5nQXN0KSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gdmlzaXRvclxuICogQHBhcmFtIHs/fSBub2RlXG4gKiBAcGFyYW0gez99IGNvbnRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHZpc2l0QW5pbWF0aW9uTm9kZSh2aXNpdG9yLCBub2RlLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSA3IC8qIFRyaWdnZXIgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyaWdnZXIoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDAgLyogU3RhdGUgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0YXRlKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAxIC8qIFRyYW5zaXRpb24gKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyYW5zaXRpb24oLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDIgLyogU2VxdWVuY2UgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNlcXVlbmNlKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAzIC8qIEdyb3VwICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRHcm91cCgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgNCAvKiBBbmltYXRlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSA1IC8qIEtleWZyYW1lcyAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZnJhbWVzKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSA2IC8qIFN0eWxlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHlsZSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgOCAvKiBSZWZlcmVuY2UgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlZmVyZW5jZSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgOSAvKiBBbmltYXRlQ2hpbGQgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGVDaGlsZCgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMTAgLyogQW5pbWF0ZVJlZiAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZVJlZigvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMTEgLyogUXVlcnkgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFF1ZXJ5KC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAxMiAvKiBTdGFnZ2VyICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGFnZ2VyKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIGFuaW1hdGlvbiBtZXRhZGF0YSBub2RlICNcIiArIG5vZGUudHlwZSk7XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFOWV9TVEFURSA9ICcqJztcbi8qKlxuICogQHBhcmFtIHs/fSB0cmFuc2l0aW9uVmFsdWVcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwYXJzZVRyYW5zaXRpb25FeHByKHRyYW5zaXRpb25WYWx1ZSwgZXJyb3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvbnMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHRyYW5zaXRpb25WYWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAoKHRyYW5zaXRpb25WYWx1ZSkpXG4gICAgICAgICAgICAuc3BsaXQoL1xccyosXFxzKi8pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBwYXJzZUlubmVyVHJhbnNpdGlvblN0cihzdHIsIGV4cHJlc3Npb25zLCBlcnJvcnMpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAodHJhbnNpdGlvblZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9ucztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBldmVudFN0clxuICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW5uZXJUcmFuc2l0aW9uU3RyKGV2ZW50U3RyLCBleHByZXNzaW9ucywgZXJyb3JzKSB7XG4gICAgaWYgKGV2ZW50U3RyWzBdID09ICc6Jykge1xuICAgICAgICBldmVudFN0ciA9IHBhcnNlQW5pbWF0aW9uQWxpYXMoZXZlbnRTdHIsIGVycm9ycyk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoID0gZXZlbnRTdHIubWF0Y2goL14oXFwqfFstXFx3XSspXFxzKig8P1s9LV0+KVxccyooXFwqfFstXFx3XSspJC8pO1xuICAgIGlmIChtYXRjaCA9PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgdHJhbnNpdGlvbiBleHByZXNzaW9uIFxcXCJcIiArIGV2ZW50U3RyICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucztcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnJvbVN0YXRlID0gbWF0Y2hbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VwYXJhdG9yID0gbWF0Y2hbMl07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9TdGF0ZSA9IG1hdGNoWzNdO1xuICAgIGV4cHJlc3Npb25zLnB1c2gobWFrZUxhbWJkYUZyb21TdGF0ZXMoZnJvbVN0YXRlLCB0b1N0YXRlKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNGdWxsQW55U3RhdGVFeHByID0gZnJvbVN0YXRlID09IEFOWV9TVEFURSAmJiB0b1N0YXRlID09IEFOWV9TVEFURTtcbiAgICBpZiAoc2VwYXJhdG9yWzBdID09ICc8JyAmJiAhaXNGdWxsQW55U3RhdGVFeHByKSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2gobWFrZUxhbWJkYUZyb21TdGF0ZXModG9TdGF0ZSwgZnJvbVN0YXRlKSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGFsaWFzXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VBbmltYXRpb25BbGlhcyhhbGlhcywgZXJyb3JzKSB7XG4gICAgc3dpdGNoIChhbGlhcykge1xuICAgICAgICBjYXNlICc6ZW50ZXInOlxuICAgICAgICAgICAgcmV0dXJuICd2b2lkID0+IConO1xuICAgICAgICBjYXNlICc6bGVhdmUnOlxuICAgICAgICAgICAgcmV0dXJuICcqID0+IHZvaWQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJUaGUgdHJhbnNpdGlvbiBhbGlhcyB2YWx1ZSBcXFwiXCIgKyBhbGlhcyArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuICcqID0+IConO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBsaHNcbiAqIEBwYXJhbSB7P30gcmhzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtYWtlTGFtYmRhRnJvbVN0YXRlcyhsaHMsIHJocykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxoc01hdGNoID0gbGhzID09IEFOWV9TVEFURSB8fCBsaHMgPT0gZnJvbVN0YXRlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaHNNYXRjaCA9IHJocyA9PSBBTllfU1RBVEUgfHwgcmhzID09IHRvU3RhdGU7XG4gICAgICAgIGlmICghbGhzTWF0Y2ggJiYgdHlwZW9mIGZyb21TdGF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBsaHNNYXRjaCA9IGZyb21TdGF0ZSA/IGxocyA9PT0gJ3RydWUnIDogbGhzID09PSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmhzTWF0Y2ggJiYgdHlwZW9mIHRvU3RhdGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmhzTWF0Y2ggPSB0b1N0YXRlID8gcmhzID09PSAndHJ1ZScgOiByaHMgPT09ICdmYWxzZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxoc01hdGNoICYmIHJoc01hdGNoO1xuICAgIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU0VMRl9UT0tFTiA9ICc6c2VsZic7XG52YXIgU0VMRl9UT0tFTl9SRUdFWCA9IG5ldyBSZWdFeHAoXCJzKlwiICsgU0VMRl9UT0tFTiArIFwicyosP1wiLCAnZycpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYnVpbGRBbmltYXRpb25Bc3QobWV0YWRhdGEsIGVycm9ycykge1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IoKS5idWlsZChtZXRhZGF0YSwgZXJyb3JzKTtcbn1cbnZhciBMRUFWRV9UT0tFTiA9ICc6bGVhdmUnO1xudmFyIExFQVZFX1RPS0VOX1JFR0VYID0gbmV3IFJlZ0V4cChMRUFWRV9UT0tFTiwgJ2cnKTtcbnZhciBFTlRFUl9UT0tFTiA9ICc6ZW50ZXInO1xudmFyIEVOVEVSX1RPS0VOX1JFR0VYID0gbmV3IFJlZ0V4cChFTlRFUl9UT0tFTiwgJ2cnKTtcbnZhciBST09UX1NFTEVDVE9SID0gJyc7XG52YXIgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgZXJyb3JzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHQgPSBuZXcgQW5pbWF0aW9uQXN0QnVpbGRlckNvbnRleHQoZXJyb3JzKTtcbiAgICAgICAgdGhpcy5fcmVzZXRDb250ZXh0U3R5bGVUaW1pbmdTdGF0ZShjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuICh2aXNpdEFuaW1hdGlvbk5vZGUodGhpcywgbm9ybWFsaXplQW5pbWF0aW9uRW50cnkobWV0YWRhdGEpLCBjb250ZXh0KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fcmVzZXRDb250ZXh0U3R5bGVUaW1pbmdTdGF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPSBST09UX1NFTEVDVE9SO1xuICAgICAgICBjb250ZXh0LmNvbGxlY3RlZFN0eWxlcyA9IHt9O1xuICAgICAgICBjb250ZXh0LmNvbGxlY3RlZFN0eWxlc1tST09UX1NFTEVDVE9SXSA9IHt9O1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyaWdnZXIgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlDb3VudCA9IGNvbnRleHQucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcENvdW50ID0gY29udGV4dC5kZXBDb3VudCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICBtZXRhZGF0YS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNldENvbnRleHRTdHlsZVRpbWluZ1N0YXRlKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGRlZi50eXBlID09IDAgLyogU3RhdGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0ZURlZl8xID0gKGRlZik7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHN0YXRlRGVmXzEubmFtZTtcbiAgICAgICAgICAgICAgICBuYW1lLnNwbGl0KC9cXHMqLFxccyovKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRGVmXzEubmFtZSA9IG47XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKF90aGlzLnZpc2l0U3RhdGUoc3RhdGVEZWZfMSwgY29udGV4dCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXRlRGVmXzEubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYudHlwZSA9PSAxIC8qIFRyYW5zaXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9uID0gX3RoaXMudmlzaXRUcmFuc2l0aW9uKC8qKiBAdHlwZSB7P30gKi8gKGRlZiksIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5Q291bnQgKz0gdHJhbnNpdGlvbi5xdWVyeUNvdW50O1xuICAgICAgICAgICAgICAgIGRlcENvdW50ICs9IHRyYW5zaXRpb24uZGVwQ291bnQ7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goJ29ubHkgc3RhdGUoKSBhbmQgdHJhbnNpdGlvbigpIGRlZmluaXRpb25zIGNhbiBzaXQgaW5zaWRlIG9mIGEgdHJpZ2dlcigpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgVHJpZ2dlckFzdChtZXRhZGF0YS5uYW1lLCBzdGF0ZXMsIHRyYW5zaXRpb25zKTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICBhc3QucXVlcnlDb3VudCA9IHF1ZXJ5Q291bnQ7XG4gICAgICAgIGFzdC5kZXBDb3VudCA9IGRlcENvdW50O1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RhdGUgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZUFzdChtZXRhZGF0YS5uYW1lLCB0aGlzLnZpc2l0U3R5bGUobWV0YWRhdGEuc3R5bGVzLCBjb250ZXh0KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIGNvbnRleHQuZGVwQ291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IHZpc2l0QW5pbWF0aW9uTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcnMgPSBwYXJzZVRyYW5zaXRpb25FeHByKG1ldGFkYXRhLmV4cHIsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IFRyYW5zaXRpb25Bc3QobWF0Y2hlcnMsIGVudHJ5KTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICBhc3QucXVlcnlDb3VudCA9IGNvbnRleHQucXVlcnlDb3VudDtcbiAgICAgICAgYXN0LmRlcENvdW50ID0gY29udGV4dC5kZXBDb3VudDtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNlcXVlbmNlID0gZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBTZXF1ZW5jZUFzdChtZXRhZGF0YS5zdGVwcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHZpc2l0QW5pbWF0aW9uTm9kZShfdGhpcywgcywgY29udGV4dCk7IH0pKTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0R3JvdXAgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdXJ0aGVzdFRpbWUgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGVwcyA9IG1ldGFkYXRhLnN0ZXBzLm1hcChmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJBc3QgPSB2aXNpdEFuaW1hdGlvbk5vZGUoX3RoaXMsIHN0ZXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBjb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiBpbm5lckFzdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSBmdXJ0aGVzdFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBHcm91cEFzdChzdGVwcyk7XG4gICAgICAgIGFzdC5vcHRpb25zID0gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGUgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5nQXN0ID0gY29uc3RydWN0VGltaW5nQXN0KG1ldGFkYXRhLnRpbWluZ3MsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSB0aW1pbmdBc3Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNZXRhZGF0YSA9IG1ldGFkYXRhLnN0eWxlcyA/IG1ldGFkYXRhLnN0eWxlcyA6IHN0eWxlKHt9KTtcbiAgICAgICAgaWYgKHN0eWxlTWV0YWRhdGEudHlwZSA9PSA1IC8qIEtleWZyYW1lcyAqLykge1xuICAgICAgICAgICAgc3R5bGVzID0gdGhpcy52aXNpdEtleWZyYW1lcygvKiogQHR5cGUgez99ICovIChzdHlsZU1ldGFkYXRhKSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1ldGFkYXRhXzEgPSAobWV0YWRhdGEuc3R5bGVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc3R5bGVNZXRhZGF0YV8xKSB7XG4gICAgICAgICAgICAgICAgaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3U3R5bGVEYXRhID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRpbWluZ0FzdC5lYXNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGVEYXRhWydlYXNpbmcnXSA9IHRpbWluZ0FzdC5lYXNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlTWV0YWRhdGFfMSA9IHN0eWxlKG5ld1N0eWxlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lICs9IHRpbWluZ0FzdC5kdXJhdGlvbiArIHRpbWluZ0FzdC5kZWxheTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlQXN0ID0gdGhpcy52aXNpdFN0eWxlKHN0eWxlTWV0YWRhdGFfMSwgY29udGV4dCk7XG4gICAgICAgICAgICBzdHlsZUFzdC5pc0VtcHR5U3RlcCA9IGlzRW1wdHk7XG4gICAgICAgICAgICBzdHlsZXMgPSBzdHlsZUFzdDtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0ZUFzdCh0aW1pbmdBc3QsIHN0eWxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdHlsZSA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9tYWtlU3R5bGVBc3QobWV0YWRhdGEsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZVN0eWxlQXN0KGFzdCwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX21ha2VTdHlsZUFzdCA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWRhdGEuc3R5bGVzKSkge1xuICAgICAgICAgICAgKChtZXRhZGF0YS5zdHlsZXMpKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVR1cGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZVR1cGxlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZVR1cGxlID09IEFVVE9fU1RZTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlVHVwbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgc3R5bGUgc3RyaW5nIHZhbHVlIFwiICsgc3R5bGVUdXBsZSArIFwiIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVUdXBsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzLnB1c2gobWV0YWRhdGEuc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xsZWN0ZWRFYXNpbmcgPSBudWxsO1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVEYXRhKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3R5bGVEYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTWFwID0gKHN0eWxlRGF0YSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWFzaW5nID0gc3R5bGVNYXBbJ2Vhc2luZyddO1xuICAgICAgICAgICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkRWFzaW5nID0gKGVhc2luZyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU1hcFsnZWFzaW5nJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHlsZUFzdChzdHlsZXMsIGNvbGxlY3RlZEVhc2luZywgbWV0YWRhdGEub2Zmc2V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlU3R5bGVBc3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kVGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIGlmICh0aW1pbmdzICYmIHN0YXJ0VGltZSA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0VGltZSAtPSB0aW1pbmdzLmR1cmF0aW9uICsgdGltaW5ncy5kZWxheTtcbiAgICAgICAgfVxuICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHR1cGxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR1cGxlID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHR1cGxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sbGVjdGVkU3R5bGVzID0gY29udGV4dC5jb2xsZWN0ZWRTdHlsZXNbKChjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yKSldO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbGxlY3RlZEVudHJ5ID0gY29sbGVjdGVkU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZUNvbGxlY3RlZFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGVkRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSAhPSBlbmRUaW1lICYmIHN0YXJ0VGltZSA+PSBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPD0gY29sbGVjdGVkRW50cnkuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlRoZSBDU1MgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIiB0aGF0IGV4aXN0cyBiZXR3ZWVuIHRoZSB0aW1lcyBvZiBcXFwiXCIgKyBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWUgKyBcIm1zXFxcIiBhbmQgXFxcIlwiICsgY29sbGVjdGVkRW50cnkuZW5kVGltZSArIFwibXNcXFwiIGlzIGFsc28gYmVpbmcgYW5pbWF0ZWQgaW4gYSBwYXJhbGxlbCBhbmltYXRpb24gYmV0d2VlbiB0aGUgdGltZXMgb2YgXFxcIlwiICsgc3RhcnRUaW1lICsgXCJtc1xcXCIgYW5kIFxcXCJcIiArIGVuZFRpbWUgKyBcIm1zXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbGxlY3RlZFN0eWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIGNob29zZSB0aGUgc21hbGxlciBzdGFydCB0aW1lIHZhbHVlIHNpbmNlIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gaGF2ZSBhIHJlY29yZCBvZiB0aGUgZW50aXJlIGFuaW1hdGlvbiB3aW5kb3cgd2hlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0eWxlIHByb3BlcnR5IGlzIGJlaW5nIGFuaW1hdGVkIGluIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gY29sbGVjdGVkRW50cnkuc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQ29sbGVjdGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3R5bGVzW3Byb3BdID0geyBzdGFydFRpbWU6IHN0YXJ0VGltZSwgZW5kVGltZTogZW5kVGltZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlU3R5bGVQYXJhbXModHVwbGVbcHJvcF0sIGNvbnRleHQub3B0aW9ucywgY29udGV4dC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWZyYW1lcyA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwia2V5ZnJhbWVzKCkgbXVzdCBiZSBwbGFjZWQgaW5zaWRlIG9mIGEgY2FsbCB0byBhbmltYXRlKClcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleWZyYW1lc0FzdChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTUFYX0tFWUZSQU1FX09GRlNFVCA9IDE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldHNPdXRPZk9yZGVyID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lc091dE9mUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBtZXRhZGF0YS5zdGVwcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGUkJDEgPSBfdGhpcy5fbWFrZVN0eWxlQXN0KHN0eWxlcywgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRWYWwgPSBzdHlsZSQkMS5vZmZzZXQgIT0gbnVsbCA/IHN0eWxlJCQxLm9mZnNldCA6IGNvbnN1bWVPZmZzZXQoc3R5bGUkJDEuc3R5bGVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0VmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzKys7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gc3R5bGUkJDEub2Zmc2V0ID0gb2Zmc2V0VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ZnJhbWVzT3V0T2ZSYW5nZSA9IGtleWZyYW1lc091dE9mUmFuZ2UgfHwgb2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiAxO1xuICAgICAgICAgICAgb2Zmc2V0c091dE9mT3JkZXIgPSBvZmZzZXRzT3V0T2ZPcmRlciB8fCBvZmZzZXQgPCBwcmV2aW91c09mZnNldDtcbiAgICAgICAgICAgIHByZXZpb3VzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGUkJDE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ZnJhbWVzT3V0T2ZSYW5nZSkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlBsZWFzZSBlbnN1cmUgdGhhdCBhbGwga2V5ZnJhbWUgb2Zmc2V0cyBhcmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRzT3V0T2ZPcmRlcikge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlBsZWFzZSBlbnN1cmUgdGhhdCBhbGwga2V5ZnJhbWUgb2Zmc2V0cyBhcmUgaW4gb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuZ3RoID0gbWV0YWRhdGEuc3RlcHMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZW5lcmF0ZWRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA+IDAgJiYgdG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIk5vdCBhbGwgc3R5bGUoKSBzdGVwcyB3aXRoaW4gdGhlIGRlY2xhcmVkIGtleWZyYW1lcygpIGNvbnRhaW4gb2Zmc2V0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzID09IDApIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZE9mZnNldCA9IE1BWF9LRVlGUkFNRV9PRkZTRVQgLyAobGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGltaXQgPSBsZW5ndGggLSAxO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRBbmltYXRlVGltaW5ncyA9ICgoY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0ZUR1cmF0aW9uID0gY3VycmVudEFuaW1hdGVUaW1pbmdzLmR1cmF0aW9uO1xuICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2YsIGkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IGdlbmVyYXRlZE9mZnNldCA+IDAgPyAoaSA9PSBsaW1pdCA/IDEgOiAoZ2VuZXJhdGVkT2Zmc2V0ICogaSkpIDogb2Zmc2V0c1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uVXBUb1RoaXNGcmFtZSA9IG9mZnNldCAqIGFuaW1hdGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSArIGN1cnJlbnRBbmltYXRlVGltaW5ncy5kZWxheSArIGR1cmF0aW9uVXBUb1RoaXNGcmFtZTtcbiAgICAgICAgICAgIGN1cnJlbnRBbmltYXRlVGltaW5ncy5kdXJhdGlvbiA9IGR1cmF0aW9uVXBUb1RoaXNGcmFtZTtcbiAgICAgICAgICAgIF90aGlzLl92YWxpZGF0ZVN0eWxlQXN0KGtmLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGtmLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZnJhbWVzQXN0KGtleWZyYW1lcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnkgPSB2aXNpdEFuaW1hdGlvbk5vZGUodGhpcywgbm9ybWFsaXplQW5pbWF0aW9uRW50cnkobWV0YWRhdGEuYW5pbWF0aW9uKSwgY29udGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBSZWZlcmVuY2VBc3QoZW50cnkpO1xuICAgICAgICBhc3Qub3B0aW9ucyA9IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlQ2hpbGQgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5kZXBDb3VudCsrO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgQW5pbWF0ZUNoaWxkQXN0KCk7XG4gICAgICAgIGFzdC5vcHRpb25zID0gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGVSZWYgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uID0gdGhpcy52aXNpdFJlZmVyZW5jZShtZXRhZGF0YS5hbmltYXRpb24sIGNvbnRleHQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgQW5pbWF0ZVJlZkFzdChhbmltYXRpb24pO1xuICAgICAgICBhc3Qub3B0aW9ucyA9IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdWVyeSA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRTZWxlY3RvciA9ICgoY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3RvcikpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gKChtZXRhZGF0YS5vcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIGNvbnRleHQucXVlcnlDb3VudCsrO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeSA9IG1ldGFkYXRhO1xuICAgICAgICB2YXIgX2EgPSBub3JtYWxpemVTZWxlY3RvcihtZXRhZGF0YS5zZWxlY3RvciksIHNlbGVjdG9yID0gX2FbMF0sIGluY2x1ZGVTZWxmID0gX2FbMV07XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPVxuICAgICAgICAgICAgcGFyZW50U2VsZWN0b3IubGVuZ3RoID8gKHBhcmVudFNlbGVjdG9yICsgJyAnICsgc2VsZWN0b3IpIDogc2VsZWN0b3I7XG4gICAgICAgIGdldE9yU2V0QXNJbk1hcChjb250ZXh0LmNvbGxlY3RlZFN0eWxlcywgY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3Rvciwge30pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IHZpc2l0QW5pbWF0aW9uTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnkgPSBudWxsO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gcGFyZW50U2VsZWN0b3I7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBRdWVyeUFzdChzZWxlY3Rvciwgb3B0aW9ucy5saW1pdCB8fCAwLCAhIW9wdGlvbnMub3B0aW9uYWwsIGluY2x1ZGVTZWxmLCBlbnRyeSk7XG4gICAgICAgIGFzdC5vcmlnaW5hbFNlbGVjdG9yID0gbWV0YWRhdGEuc2VsZWN0b3I7XG4gICAgICAgIGFzdC5vcHRpb25zID0gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0YWdnZXIgPSBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnRRdWVyeSkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcInN0YWdnZXIoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBvZiBxdWVyeSgpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBtZXRhZGF0YS50aW1pbmdzID09PSAnZnVsbCcgP1xuICAgICAgICAgICAgeyBkdXJhdGlvbjogMCwgZGVsYXk6IDAsIGVhc2luZzogJ2Z1bGwnIH0gOlxuICAgICAgICAgICAgcmVzb2x2ZVRpbWluZyhtZXRhZGF0YS50aW1pbmdzLCBjb250ZXh0LmVycm9ycywgdHJ1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbiA9IHZpc2l0QW5pbWF0aW9uTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFnZ2VyQXN0KHRpbWluZ3MsIGFuaW1hdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0FtcGVyc2FuZCA9IHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKS5maW5kKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gPT0gU0VMRl9UT0tFTjsgfSkgPyB0cnVlIDogZmFsc2U7XG4gICAgaWYgKGhhc0FtcGVyc2FuZCkge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoU0VMRl9UT0tFTl9SRUdFWCwgJycpO1xuICAgIH1cbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoRU5URVJfVE9LRU5fUkVHRVgsIEVOVEVSX1NFTEVDVE9SKVxuICAgICAgICAucmVwbGFjZShMRUFWRV9UT0tFTl9SRUdFWCwgTEVBVkVfU0VMRUNUT1IpXG4gICAgICAgIC5yZXBsYWNlKC9AXFwqL2csIE5HX1RSSUdHRVJfU0VMRUNUT1IpXG4gICAgICAgIC5yZXBsYWNlKC9AXFx3Ky9nLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIE5HX1RSSUdHRVJfU0VMRUNUT1IgKyAnLScgKyBtYXRjaC5zdWJzdHIoMSk7IH0pXG4gICAgICAgIC5yZXBsYWNlKC86YW5pbWF0aW5nL2csIE5HX0FOSU1BVElOR19TRUxFQ1RPUik7XG4gICAgcmV0dXJuIFtzZWxlY3RvciwgaGFzQW1wZXJzYW5kXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBvYmpcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtcyhvYmopIHtcbiAgICByZXR1cm4gb2JqID8gY29weU9iaihvYmopIDogbnVsbDtcbn1cbnZhciBBbmltYXRpb25Bc3RCdWlsZGVyQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25Bc3RCdWlsZGVyQ29udGV4dChlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZGVwQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnkgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRTdHlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzdHlsZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVPZmZzZXQoc3R5bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVUdXBsZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlVHVwbGUpICYmIHN0eWxlVHVwbGUuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JqID0gKHN0eWxlVHVwbGUpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAob2JqWydvZmZzZXQnXSkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbJ29mZnNldCddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc3R5bGVzKSAmJiBzdHlsZXMuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9iaiA9IChzdHlsZXMpO1xuICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KC8qKiBAdHlwZSB7P30gKi8gKG9ialsnb2Zmc2V0J10pKTtcbiAgICAgICAgZGVsZXRlIG9ialsnb2Zmc2V0J107XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RUaW1pbmdBc3QodmFsdWUsIGVycm9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBudWxsO1xuICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZHVyYXRpb24nKSkge1xuICAgICAgICB0aW1pbmdzID0gKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gcmVzb2x2ZVRpbWluZygvKiogQHR5cGUgez99ICovICh2YWx1ZSksIGVycm9ycykuZHVyYXRpb247XG4gICAgICAgIHJldHVybiBuZXcgVGltaW5nQXN0KC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSwgMCwgJycpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWx1ZSA9ICh2YWx1ZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNEeW5hbWljID0gc3RyVmFsdWUuc3BsaXQoL1xccysvKS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmNoYXJBdCgwKSA9PSAneycgJiYgdi5jaGFyQXQoMSkgPT0gJ3snOyB9KTtcbiAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgIHJldHVybiBuZXcgRHluYW1pY1RpbWluZ0FzdChzdHJWYWx1ZSk7XG4gICAgfVxuICAgIHRpbWluZ3MgPSB0aW1pbmdzIHx8IHJlc29sdmVUaW1pbmcoc3RyVmFsdWUsIGVycm9ycyk7XG4gICAgcmV0dXJuIG5ldyBUaW1pbmdBc3QodGltaW5ncy5kdXJhdGlvbiwgdGltaW5ncy5kZWxheSwgdGltaW5ncy5lYXNpbmcpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBjb3B5T2JqKG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9uc1sncGFyYW1zJ10pIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ3BhcmFtcyddID0gKChub3JtYWxpemVQYXJhbXMob3B0aW9uc1sncGFyYW1zJ10pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAqIEBwYXJhbSB7P30gcHJlU3R5bGVQcm9wc1xuICogQHBhcmFtIHs/fSBwb3N0U3R5bGVQcm9wc1xuICogQHBhcmFtIHs/fSBkdXJhdGlvblxuICogQHBhcmFtIHs/fSBkZWxheVxuICogQHBhcmFtIHs/PX0gZWFzaW5nXG4gKiBAcGFyYW0gez89fSBzdWJUaW1lbGluZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbihlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlUHJvcHMsIHBvc3RTdHlsZVByb3BzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgc3ViVGltZWxpbmUpIHtcbiAgICBpZiAoZWFzaW5nID09PSB2b2lkIDApIHsgZWFzaW5nID0gbnVsbDsgfVxuICAgIGlmIChzdWJUaW1lbGluZSA9PT0gdm9pZCAwKSB7IHN1YlRpbWVsaW5lID0gZmFsc2U7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxIC8qIFRpbWVsaW5lQW5pbWF0aW9uICovLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBrZXlmcmFtZXM6IGtleWZyYW1lcyxcbiAgICAgICAgcHJlU3R5bGVQcm9wczogcHJlU3R5bGVQcm9wcyxcbiAgICAgICAgcG9zdFN0eWxlUHJvcHM6IHBvc3RTdHlsZVByb3BzLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgdG90YWxUaW1lOiBkdXJhdGlvbiArIGRlbGF5LCBlYXNpbmc6IGVhc2luZywgc3ViVGltZWxpbmU6IHN1YlRpbWVsaW5lXG4gICAgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9ucyA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGluc3RydWN0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZ0luc3RydWN0aW9ucyA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghZXhpc3RpbmdJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoZWxlbWVudCwgZXhpc3RpbmdJbnN0cnVjdGlvbnMgPSBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdJbnN0cnVjdGlvbnMucHVzaC5hcHBseShleGlzdGluZ0luc3RydWN0aW9ucywgaW5zdHJ1Y3Rpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudEluc3RydWN0aW9uTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gdGhpcy5fbWFwLmhhcyhlbGVtZW50KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21hcC5jbGVhcigpOyB9O1xuICAgIHJldHVybiBFbGVtZW50SW5zdHJ1Y3Rpb25NYXA7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE9ORV9GUkFNRV9JTl9NSUxMSVNFQ09ORFMgPSAxO1xuLyoqXG4gKiBAcGFyYW0gez99IGRyaXZlclxuICogQHBhcmFtIHs/fSByb290RWxlbWVudFxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEBwYXJhbSB7Pz19IHN0YXJ0aW5nU3R5bGVzXG4gKiBAcGFyYW0gez89fSBmaW5hbFN0eWxlc1xuICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gKiBAcGFyYW0gez89fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKGRyaXZlciwgcm9vdEVsZW1lbnQsIGFzdCwgc3RhcnRpbmdTdHlsZXMsIGZpbmFsU3R5bGVzLCBvcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycykge1xuICAgIGlmIChzdGFydGluZ1N0eWxlcyA9PT0gdm9pZCAwKSB7IHN0YXJ0aW5nU3R5bGVzID0ge307IH1cbiAgICBpZiAoZmluYWxTdHlsZXMgPT09IHZvaWQgMCkgeyBmaW5hbFN0eWxlcyA9IHt9OyB9XG4gICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yKCkuYnVpbGRLZXlmcmFtZXMoZHJpdmVyLCByb290RWxlbWVudCwgYXN0LCBzdGFydGluZ1N0eWxlcywgZmluYWxTdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKTtcbn1cbnZhciBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRyaXZlclxuICAgICAqIEBwYXJhbSB7P30gcm9vdEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGZpbmFsU3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gICAgICogQHBhcmFtIHs/PX0gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5idWlsZEtleWZyYW1lcyA9IGZ1bmN0aW9uIChkcml2ZXIsIHJvb3RFbGVtZW50LCBhc3QsIHN0YXJ0aW5nU3R5bGVzLCBmaW5hbFN0eWxlcywgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgICAgIHN1Ykluc3RydWN0aW9ucyA9IHN1Ykluc3RydWN0aW9ucyB8fCBuZXcgRWxlbWVudEluc3RydWN0aW9uTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHQgPSBuZXcgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0KGRyaXZlciwgcm9vdEVsZW1lbnQsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzLCBbXSk7XG4gICAgICAgIGNvbnRleHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLnNldFN0eWxlcyhbc3RhcnRpbmdTdHlsZXNdLCBudWxsLCBjb250ZXh0LmVycm9ycywgb3B0aW9ucyk7XG4gICAgICAgIGFzdC52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgLy8gdGhpcyBjaGVja3MgdG8gc2VlIGlmIGFuIGFjdHVhbCBhbmltYXRpb24gaGFwcGVuZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZWxpbmVzID0gY29udGV4dC50aW1lbGluZXMuZmlsdGVyKGZ1bmN0aW9uICh0aW1lbGluZSkgeyByZXR1cm4gdGltZWxpbmUuY29udGFpbnNBbmltYXRpb24oKTsgfSk7XG4gICAgICAgIGlmICh0aW1lbGluZXMubGVuZ3RoICYmIE9iamVjdC5rZXlzKGZpbmFsU3R5bGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRsID0gdGltZWxpbmVzW3RpbWVsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICghdGwuYWxsb3dPbmx5VGltZWxpbmVTdHlsZXMoKSkge1xuICAgICAgICAgICAgICAgIHRsLnNldFN0eWxlcyhbZmluYWxTdHlsZXNdLCBudWxsLCBjb250ZXh0LmVycm9ycywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVsaW5lcy5sZW5ndGggPyB0aW1lbGluZXMubWFwKGZ1bmN0aW9uICh0aW1lbGluZSkgeyByZXR1cm4gdGltZWxpbmUuYnVpbGRLZXlmcmFtZXMoKTsgfSkgOlxuICAgICAgICAgICAgW2NyZWF0ZVRpbWVsaW5lSW5zdHJ1Y3Rpb24ocm9vdEVsZW1lbnQsIFtdLCBbXSwgW10sIDAsIDAsICcnLCBmYWxzZSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJpZ2dlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIGFyZSBub3QgdmlzaXRlZCBpbiB0aGlzIEFTVFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBhcmUgbm90IHZpc2l0ZWQgaW4gdGhpcyBBU1RcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBhcmUgbm90IHZpc2l0ZWQgaW4gdGhpcyBBU1RcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGVDaGlsZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudEluc3RydWN0aW9ucyA9IGNvbnRleHQuc3ViSW5zdHJ1Y3Rpb25zLmNvbnN1bWUoY29udGV4dC5lbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnRJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZFRpbWUgPSB0aGlzLl92aXNpdFN1Ykluc3RydWN0aW9ucyhlbGVtZW50SW5zdHJ1Y3Rpb25zLCBpbm5lckNvbnRleHQsIC8qKiBAdHlwZSB7P30gKi8gKGlubmVyQ29udGV4dC5vcHRpb25zKSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyB0aGlzIG9uIHRoZSB1cHBlciBjb250ZXh0IGJlY2F1c2Ugd2UgY3JlYXRlZCBhIHN1YiBjb250ZXh0IGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWIgY2hpbGQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGVuZFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QW5pbWF0ZVJlZiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KGFzdC5vcHRpb25zKTtcbiAgICAgICAgaW5uZXJDb250ZXh0LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZSgpO1xuICAgICAgICB0aGlzLnZpc2l0UmVmZXJlbmNlKGFzdC5hbmltYXRpb24sIGlubmVyQ29udGV4dCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWUpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25zXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRTdWJJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb25zLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdXJ0aGVzdFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLWNhc2UgZm9yIHdoZW4gYSB1c2VyIHdhbnRzIHRvIHNraXAgYSBzdWJcbiAgICAgICAgLy8gYW5pbWF0aW9uIGZyb20gYmVpbmcgZmlyZWQgZW50aXJlbHkuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiAhPSBudWxsID8gcmVzb2x2ZVRpbWluZ1ZhbHVlKG9wdGlvbnMuZHVyYXRpb24pIDogbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9IG51bGwgPyByZXNvbHZlVGltaW5nVmFsdWUob3B0aW9ucy5kZWxheSkgOiBudWxsO1xuICAgICAgICBpZiAoZHVyYXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9uVGltaW5ncyA9IGNvbnRleHQuYXBwZW5kSW5zdHJ1Y3Rpb25Ub1RpbWVsaW5lKGluc3RydWN0aW9uLCBkdXJhdGlvbiwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGZ1cnRoZXN0VGltZSA9XG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZ1cnRoZXN0VGltZSwgaW5zdHJ1Y3Rpb25UaW1pbmdzLmR1cmF0aW9uICsgaW5zdHJ1Y3Rpb25UaW1pbmdzLmRlbGF5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdXJ0aGVzdFRpbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQudXBkYXRlT3B0aW9ucyhhc3Qub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGFzdC5hbmltYXRpb24udmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2VxdWVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YkNvbnRleHRDb3VudCA9IGNvbnRleHQuc3ViQ29udGV4dENvdW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSBjb250ZXh0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gYXN0Lm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLnBhcmFtcyB8fCBvcHRpb25zLmRlbGF5KSkge1xuICAgICAgICAgICAgY3R4ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KG9wdGlvbnMpO1xuICAgICAgICAgICAgY3R4LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZSgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdHgucHJldmlvdXNOb2RlIGluc3RhbmNlb2YgU3R5bGVBc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmN1cnJlbnRUaW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KTtcbiAgICAgICAgICAgICAgICBjdHguZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdC5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFzdC5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnZpc2l0KF90aGlzLCBjdHgpOyB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgaGVyZSBqdXN0IGluY2FzZSB0aGUgaW5uZXIgc3RlcHMgb25seSBjb250YWluIG9yIGVuZCB3aXRoIGEgc3R5bGUoKSBjYWxsXG4gICAgICAgICAgICBjdHguY3VycmVudFRpbWVsaW5lLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHNvbWUgYW5pbWF0aW9uIGZ1bmN0aW9uIHdpdGhpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIGVuZGVkIHVwIGNyZWF0aW5nIGEgc3ViIHRpbWVsaW5lICh3aGljaCBtZWFucyB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gdGltZWxpbmUgY2Fubm90IG92ZXJsYXAgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIHNlcXVlbmNlKVxuICAgICAgICAgICAgaWYgKGN0eC5zdWJDb250ZXh0Q291bnQgPiBzdWJDb250ZXh0Q291bnQpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRHcm91cCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUaW1lbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVydGhlc3RUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gYXN0Lm9wdGlvbnMgJiYgYXN0Lm9wdGlvbnMuZGVsYXkgPyByZXNvbHZlVGltaW5nVmFsdWUoYXN0Lm9wdGlvbnMuZGVsYXkpIDogMDtcbiAgICAgICAgYXN0LnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRleHQuZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzLnZpc2l0KF90aGlzLCBpbm5lckNvbnRleHQpO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGlubmVyVGltZWxpbmVzLnB1c2goaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBydW4gYWZ0ZXIgdGhlIEFTVCBsb29wIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBjb2xsZWN0ZWQgc3R5bGVzIHdlcmUgdXBkYXRlZCB0aGVuXG4gICAgICAgIC8vIGl0IHdvdWxkIHBhc3MgaW4gaW52YWxpZCBkYXRhIGludG8gdGhlIG5ldy10by1iZSBmb3JrZWQgaXRlbXNcbiAgICAgICAgaW5uZXJUaW1lbGluZXMuZm9yRWFjaChmdW5jdGlvbiAodGltZWxpbmUpIHsgcmV0dXJuIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLm1lcmdlVGltZWxpbmVDb2xsZWN0ZWRTdHlsZXModGltZWxpbmUpOyB9KTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoZnVydGhlc3RUaW1lKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUaW1pbmcgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBEeW5hbWljVGltaW5nQXN0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWx1ZSA9IGNvbnRleHQucGFyYW1zID9cbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZVBhcmFtcyhhc3QudmFsdWUsIGNvbnRleHQucGFyYW1zLCBjb250ZXh0LmVycm9ycykgOlxuICAgICAgICAgICAgICAgIGFzdC52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUaW1pbmcoc3RyVmFsdWUsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBhc3QuZHVyYXRpb24sIGRlbGF5OiBhc3QuZGVsYXksIGVhc2luZzogYXN0LmVhc2luZyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1pbmdzID0gY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSB0aGlzLnZpc2l0VGltaW5nKGFzdC50aW1pbmdzLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZWxpbmUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaWYgKHRpbWluZ3MuZGVsYXkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jcmVtZW50VGltZSh0aW1pbmdzLmRlbGF5KTtcbiAgICAgICAgICAgIHRpbWVsaW5lLnNuYXBzaG90Q3VycmVudFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlJCQxID0gYXN0LnN0eWxlO1xuICAgICAgICBpZiAoc3R5bGUkJDEgaW5zdGFuY2VvZiBLZXlmcmFtZXNBc3QpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRLZXlmcmFtZXMoc3R5bGUkJDEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5pbmNyZW1lbnRUaW1lKHRpbWluZ3MuZHVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy52aXNpdFN0eWxlKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlJCQxKSwgY29udGV4dCk7XG4gICAgICAgICAgICB0aW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IG51bGw7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3R5bGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVsaW5lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSAoKGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzKSk7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYSBzdHlsZSgpIGNhbGxcbiAgICAgICAgLy8gZGlyZWN0bHkgZm9sbG93cyAgYW4gYW5pbWF0ZSgpIGNhbGwgKGJ1dCBub3QgaW5zaWRlIG9mIGFuIGFuaW1hdGUoKSBjYWxsKVxuICAgICAgICBpZiAoIXRpbWluZ3MgJiYgdGltZWxpbmUuZ2V0Q3VycmVudFN0eWxlUHJvcGVydGllcygpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGltZWxpbmUuZm9yd2FyZEZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWFzaW5nID0gKHRpbWluZ3MgJiYgdGltaW5ncy5lYXNpbmcpIHx8IGFzdC5lYXNpbmc7XG4gICAgICAgIGlmIChhc3QuaXNFbXB0eVN0ZXApIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLmFwcGx5RW1wdHlTdGVwKGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZS5zZXRTdHlsZXMoYXN0LnN0eWxlcywgZWFzaW5nLCBjb250ZXh0LmVycm9ycywgY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWZyYW1lcyA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudEFuaW1hdGVUaW1pbmdzID0gKChjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncykpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSAoKChjb250ZXh0LmN1cnJlbnRUaW1lbGluZSkpKS5kdXJhdGlvbjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZHVyYXRpb247XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRpbWVsaW5lID0gaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaW5uZXJUaW1lbGluZS5lYXNpbmcgPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZWFzaW5nO1xuICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IHN0ZXAub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmZvcndhcmRUaW1lKG9mZnNldCAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGlubmVyVGltZWxpbmUuc2V0U3R5bGVzKHN0ZXAuc3R5bGVzLCBzdGVwLmVhc2luZywgY29udGV4dC5lcnJvcnMsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBwYXJlbnQgdGltZWxpbmUgZ2V0cyBhbGwgdGhlIHN0eWxlcyBmcm9tXG4gICAgICAgIC8vIHRoZSBjaGlsZCBldmVuIGlmIHRoZSBuZXcgdGltZWxpbmUgYmVsb3cgaXMgbm90IHVzZWRcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyhpbm5lclRpbWVsaW5lKTtcbiAgICAgICAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIHRoZSB3aW5kb3cgYmV0d2VlbiB0aGlzIHRpbWVsaW5lIGFuZCB0aGUgc3ViIHRpbWVsaW5lXG4gICAgICAgIC8vIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgc3R5bGVzIHdpdGhpbiBhcmUgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGV5IHdlcmUgYmVmb3JlXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKHN0YXJ0VGltZSArIGR1cmF0aW9uKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdWVyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGZpcnN0IHN0ZXAgYmVmb3JlIHRoaXMgaXMgYSBzdHlsZSBzdGVwIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gZW5zdXJlIHRoZSBzdHlsZXMgYXJlIGFwcGxpZWQgYmVmb3JlIHRoZSBjaGlsZHJlbiBhcmUgYW5pbWF0ZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSAoKGFzdC5vcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gb3B0aW9ucy5kZWxheSA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSA6IDA7XG4gICAgICAgIGlmIChkZWxheSAmJiAoY29udGV4dC5wcmV2aW91c05vZGUgaW5zdGFuY2VvZiBTdHlsZUFzdCB8fFxuICAgICAgICAgICAgKHN0YXJ0VGltZSA9PSAwICYmIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1cnRoZXN0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxtcyA9IGNvbnRleHQuaW52b2tlUXVlcnkoYXN0LnNlbGVjdG9yLCBhc3Qub3JpZ2luYWxTZWxlY3RvciwgYXN0LmxpbWl0LCBhc3QuaW5jbHVkZVNlbGYsIG9wdGlvbnMub3B0aW9uYWwgPyB0cnVlIDogZmFsc2UsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IGVsbXMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYW1lRWxlbWVudFRpbWVsaW5lID0gbnVsbDtcbiAgICAgICAgZWxtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gaTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucywgZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRleHQuZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gY29udGV4dC5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtZUVsZW1lbnRUaW1lbGluZSA9IGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3QuYW5pbWF0aW9uLnZpc2l0KF90aGlzLCBpbm5lckNvbnRleHQpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBoZXJlIGp1c3QgaW5jYXNlIHRoZSBpbm5lciBzdGVwcyBvbmx5IGNvbnRhaW4gb3IgZW5kXG4gICAgICAgICAgICAvLyB3aXRoIGEgc3R5bGUoKSBjYWxsICh3aGljaCBpcyBoZXJlIHRvIHNpZ25hbCB0aGF0IHRoaXMgaXMgYSBwcmVwYXJhdG9yeVxuICAgICAgICAgICAgLy8gY2FsbCB0byBzdHlsZSBhbiBlbGVtZW50IGJlZm9yZSBpdCBpcyBhbmltYXRlZCBhZ2FpbilcbiAgICAgICAgICAgIGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmRUaW1lID0gaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIGZ1cnRoZXN0VGltZSA9IE1hdGgubWF4KGZ1cnRoZXN0VGltZSwgZW5kVGltZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gMDtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IDA7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGZ1cnRoZXN0VGltZSk7XG4gICAgICAgIGlmIChzYW1lRWxlbWVudFRpbWVsaW5lKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5tZXJnZVRpbWVsaW5lQ29sbGVjdGVkU3R5bGVzKHNhbWVFbGVtZW50VGltZWxpbmUpO1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGFnZ2VyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRDb250ZXh0ID0gKChjb250ZXh0LnBhcmVudENvbnRleHQpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGwgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IGFzdC50aW1pbmdzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvbiA9IE1hdGguYWJzKHRpbWluZ3MuZHVyYXRpb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXhUaW1lID0gZHVyYXRpb24gKiAoY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCAtIDEpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IGR1cmF0aW9uICogY29udGV4dC5jdXJyZW50UXVlcnlJbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhZ2dlclRyYW5zZm9ybWVyID0gdGltaW5ncy5kdXJhdGlvbiA8IDAgPyAncmV2ZXJzZScgOiB0aW1pbmdzLmVhc2luZztcbiAgICAgICAgc3dpdGNoIChzdGFnZ2VyVHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JldmVyc2UnOlxuICAgICAgICAgICAgICAgIGRlbGF5ID0gbWF4VGltZSAtIGRlbGF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVsbCc6XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJlbnRDb250ZXh0LmN1cnJlbnRTdGFnZ2VyVGltZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0aW5nVGltZSA9IHRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICBhc3QuYW5pbWF0aW9uLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICAgICAgLy8gdGltZSA9IGR1cmF0aW9uICsgZGVsYXlcbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgdGhpcyBjb21wdXRhdGlvbiBpcyBzbyBjb21wbGV4IGlzIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIGlubmVyIHRpbWVsaW5lIG1heSBlaXRoZXIgaGF2ZSBhIGRlbGF5IHZhbHVlIG9yIGEgc3RyZXRjaGVkXG4gICAgICAgIC8vIGtleWZyYW1lIGRlcGVuZGluZyBvbiBpZiBhIHN1YnRpbWVsaW5lIGlzIG5vdCB1c2VkIG9yIGlzIHVzZWQuXG4gICAgICAgIHBhcmVudENvbnRleHQuY3VycmVudFN0YWdnZXJUaW1lID1cbiAgICAgICAgICAgICh0bC5jdXJyZW50VGltZSAtIHN0YXJ0aW5nVGltZSkgKyAodGwuc3RhcnRUaW1lIC0gcGFyZW50Q29udGV4dC5jdXJyZW50VGltZWxpbmUuc3RhcnRUaW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yO1xufSgpKTtcbnZhciBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERSA9ICh7fSk7XG52YXIgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN1Ykluc3RydWN0aW9uc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSB0aW1lbGluZXNcbiAgICAgKiBAcGFyYW0gez89fSBpbml0aWFsVGltZWxpbmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25UaW1lbGluZUNvbnRleHQoX2RyaXZlciwgZWxlbWVudCwgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMsIHRpbWVsaW5lcywgaW5pdGlhbFRpbWVsaW5lKSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy50aW1lbGluZXMgPSB0aW1lbGluZXM7XG4gICAgICAgIHRoaXMucGFyZW50Q29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91c05vZGUgPSBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERTtcbiAgICAgICAgdGhpcy5zdWJDb250ZXh0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnlJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXJ5VG90YWwgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGFnZ2VyVGltZSA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lID0gaW5pdGlhbFRpbWVsaW5lIHx8IG5ldyBUaW1lbGluZUJ1aWxkZXIoZWxlbWVudCwgMCk7XG4gICAgICAgIHRpbWVsaW5lcy5wdXNoKHRoaXMuY3VycmVudFRpbWVsaW5lKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUsIFwicGFyYW1zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub3B0aW9ucy5wYXJhbXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHNraXBJZkV4aXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS51cGRhdGVPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNraXBJZkV4aXN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld09wdGlvbnMgPSAob3B0aW9ucyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnNUb1VwZGF0ZSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gTk9URTogdGhpcyB3aWxsIGdldCBwYXRjaGVkIHVwIHdoZW4gb3RoZXIgYW5pbWF0aW9uIG1ldGhvZHMgc3VwcG9ydCBkdXJhdGlvbiBvdmVycmlkZXNcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgKChvcHRpb25zVG9VcGRhdGUpKS5kdXJhdGlvbiA9IHJlc29sdmVUaW1pbmdWYWx1ZShuZXdPcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3T3B0aW9ucy5kZWxheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zVG9VcGRhdGUuZGVsYXkgPSByZXNvbHZlVGltaW5nVmFsdWUobmV3T3B0aW9ucy5kZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3UGFyYW1zID0gbmV3T3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIGlmIChuZXdQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc1RvVXBkYXRlXzEgPSAoKG9wdGlvbnNUb1VwZGF0ZS5wYXJhbXMpKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1zVG9VcGRhdGVfMSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1RvVXBkYXRlXzEgPSB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXdQYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBJZkV4aXN0cyB8fCAhcGFyYW1zVG9VcGRhdGVfMS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNUb1VwZGF0ZV8xW25hbWVdID0gaW50ZXJwb2xhdGVQYXJhbXMobmV3UGFyYW1zW25hbWVdLCBwYXJhbXNUb1VwZGF0ZV8xLCBfdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuX2NvcHlPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFBhcmFtc18xID0gdGhpcy5vcHRpb25zLnBhcmFtcztcbiAgICAgICAgICAgIGlmIChvbGRQYXJhbXNfMSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc18xID0gb3B0aW9uc1sncGFyYW1zJ10gPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMucGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHBhcmFtc18xW25hbWVdID0gb2xkUGFyYW1zXzFbbmFtZV07IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVN1YkNvbnRleHQgPSBmdW5jdGlvbiAob3B0aW9ucywgZWxlbWVudCwgbmV3VGltZSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldCA9IGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gbmV3IEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dCh0aGlzLl9kcml2ZXIsIHRhcmdldCwgdGhpcy5zdWJJbnN0cnVjdGlvbnMsIHRoaXMuZXJyb3JzLCB0aGlzLnRpbWVsaW5lcywgdGhpcy5jdXJyZW50VGltZWxpbmUuZm9yayh0YXJnZXQsIG5ld1RpbWUgfHwgMCkpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IHRoaXMucHJldmlvdXNOb2RlO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IHRoaXMuY3VycmVudEFuaW1hdGVUaW1pbmdzO1xuICAgICAgICBjb250ZXh0Lm9wdGlvbnMgPSB0aGlzLl9jb3B5T3B0aW9ucygpO1xuICAgICAgICBjb250ZXh0LnVwZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5SW5kZXggPSB0aGlzLmN1cnJlbnRRdWVyeUluZGV4O1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVRvdGFsID0gdGhpcy5jdXJyZW50UXVlcnlUb3RhbDtcbiAgICAgICAgY29udGV4dC5wYXJlbnRDb250ZXh0ID0gdGhpcztcbiAgICAgICAgdGhpcy5zdWJDb250ZXh0Q291bnQrKztcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLnRyYW5zZm9ybUludG9OZXdUaW1lbGluZSA9IGZ1bmN0aW9uIChuZXdUaW1lKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNOb2RlID0gREVGQVVMVF9OT09QX1BSRVZJT1VTX05PREU7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lID0gdGhpcy5jdXJyZW50VGltZWxpbmUuZm9yayh0aGlzLmVsZW1lbnQsIG5ld1RpbWUpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lcy5wdXNoKHRoaXMuY3VycmVudFRpbWVsaW5lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWVsaW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmFwcGVuZEluc3RydWN0aW9uVG9UaW1lbGluZSA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZWRUaW1pbmdzID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uICE9IG51bGwgPyBkdXJhdGlvbiA6IGluc3RydWN0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgZGVsYXk6IHRoaXMuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lICsgKGRlbGF5ICE9IG51bGwgPyBkZWxheSA6IDApICsgaW5zdHJ1Y3Rpb24uZGVsYXksXG4gICAgICAgICAgICBlYXNpbmc6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1aWxkZXIgPSBuZXcgU3ViVGltZWxpbmVCdWlsZGVyKGluc3RydWN0aW9uLmVsZW1lbnQsIGluc3RydWN0aW9uLmtleWZyYW1lcywgaW5zdHJ1Y3Rpb24ucHJlU3R5bGVQcm9wcywgaW5zdHJ1Y3Rpb24ucG9zdFN0eWxlUHJvcHMsIHVwZGF0ZWRUaW1pbmdzLCBpbnN0cnVjdGlvbi5zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSk7XG4gICAgICAgIHRoaXMudGltZWxpbmVzLnB1c2goYnVpbGRlcik7XG4gICAgICAgIHJldHVybiB1cGRhdGVkVGltaW5ncztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS5pbmNyZW1lbnRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUuZm9yd2FyZFRpbWUodGhpcy5jdXJyZW50VGltZWxpbmUuZHVyYXRpb24gKyB0aW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuZGVsYXlOZXh0U3RlcCA9IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICAvLyBuZWdhdGl2ZSBkZWxheXMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lLmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW5hbFNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBsaW1pdFxuICAgICAqIEBwYXJhbSB7P30gaW5jbHVkZVNlbGZcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbmFsXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuaW52b2tlUXVlcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG9yaWdpbmFsU2VsZWN0b3IsIGxpbWl0LCBpbmNsdWRlU2VsZiwgb3B0aW9uYWwsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG11bHRpID0gbGltaXQgIT0gMTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCB0aGlzLl9kcml2ZXIucXVlcnkodGhpcy5lbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbmFsICYmIHJlc3VsdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiYHF1ZXJ5KFxcXCJcIiArIG9yaWdpbmFsU2VsZWN0b3IgKyBcIlxcXCIpYCByZXR1cm5lZCB6ZXJvIGVsZW1lbnRzLiAoVXNlIGBxdWVyeShcXFwiXCIgKyBvcmlnaW5hbFNlbGVjdG9yICsgXCJcXFwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pYCBpZiB5b3Ugd2lzaCB0byBhbGxvdyB0aGlzLilcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0O1xufSgpKTtcbnZhciBUaW1lbGluZUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRUaW1lXG4gICAgICogQHBhcmFtIHs/PX0gX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRpbWVsaW5lQnVpbGRlcihlbGVtZW50LCBzdGFydFRpbWUsIF9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXApIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCA9IF9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXA7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lID0ge307XG4gICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IHt9O1xuICAgICAgICB0aGlzLl9rZXlmcmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N0eWxlU3VtbWFyeSA9IHt9O1xuICAgICAgICB0aGlzLl9wZW5kaW5nU3R5bGVzID0ge307XG4gICAgICAgIHRoaXMuX2JhY2tGaWxsID0ge307XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcyA9IE9iamVjdC5jcmVhdGUodGhpcy5fYmFja0ZpbGwsIHt9KTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMgPSB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcyA9IHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXM7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAuc2V0KGVsZW1lbnQsIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvYWRLZXlmcmFtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuY29udGFpbnNBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fa2V5ZnJhbWVzLnNpemUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFN0eWxlUHJvcGVydGllcygpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuZ2V0Q3VycmVudFN0eWxlUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2N1cnJlbnRLZXlmcmFtZSk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUsIFwiY3VycmVudFRpbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zdGFydFRpbWUgKyB0aGlzLmR1cmF0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmRlbGF5TmV4dFN0ZXAgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgYSBzdHlsZSgpIHN0ZXAgaXMgcGxhY2VkIHJpZ2h0IGJlZm9yZSBhIHN0YWdnZXIoKVxuICAgICAgICAvLyBhbmQgdGhhdCBzdHlsZSgpIHN0ZXAgaXMgdGhlIHZlcnkgZmlyc3Qgc3R5bGUoKSB2YWx1ZSBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBtYWtlIGEgY29weSBvZiB0aGUga2V5ZnJhbWUgWzAsIGNvcHksIDFdIHNvIHRoYXQgdGhlIGRlbGF5XG4gICAgICAgIC8vIHByb3Blcmx5IGFwcGxpZXMgdGhlIHN0eWxlKCkgdmFsdWVzIHRvIHdvcmsgd2l0aCB0aGUgc3RhZ2dlci4uLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNQcmVTdHlsZVN0ZXAgPSB0aGlzLl9rZXlmcmFtZXMuc2l6ZSA9PSAxICYmIE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdTdHlsZXMpLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gfHwgaGFzUHJlU3R5bGVTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRUaW1lKHRoaXMuY3VycmVudFRpbWUgKyBkZWxheSk7XG4gICAgICAgICAgICBpZiAoaGFzUHJlU3R5bGVTdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lICs9IGRlbGF5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBjdXJyZW50VGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gKGVsZW1lbnQsIGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHJldHVybiBuZXcgVGltZWxpbmVCdWlsZGVyKGVsZW1lbnQsIGN1cnJlbnRUaW1lIHx8IHRoaXMuY3VycmVudFRpbWUsIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuX2xvYWRLZXlmcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRLZXlmcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZSA9IHRoaXMuX2N1cnJlbnRLZXlmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50S2V5ZnJhbWUgPSAoKHRoaXMuX2tleWZyYW1lcy5nZXQodGhpcy5kdXJhdGlvbikpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50S2V5ZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IE9iamVjdC5jcmVhdGUodGhpcy5fYmFja0ZpbGwsIHt9KTtcbiAgICAgICAgICAgIHRoaXMuX2tleWZyYW1lcy5zZXQodGhpcy5kdXJhdGlvbiwgdGhpcy5fY3VycmVudEtleWZyYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmZvcndhcmRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiArPSBPTkVfRlJBTUVfSU5fTUlMTElTRUNPTkRTO1xuICAgICAgICB0aGlzLl9sb2FkS2V5ZnJhbWUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5mb3J3YXJkVGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSB0aW1lO1xuICAgICAgICB0aGlzLl9sb2FkS2V5ZnJhbWUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc3R5bGVTdW1tYXJ5W3Byb3BdID0geyB0aW1lOiB0aGlzLmN1cnJlbnRUaW1lLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5hbGxvd09ubHlUaW1lbGluZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSAhPT0gdGhpcy5fY3VycmVudEtleWZyYW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmFwcGx5RW1wdHlTdGVwID0gZnVuY3Rpb24gKGVhc2luZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lWydlYXNpbmcnXSA9IGVhc2luZztcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGFuaW1hdGUoZHVyYXRpb24pOlxuICAgICAgICAvLyBhbGwgbWlzc2luZyBzdHlsZXMgYXJlIGZpbGxlZCB3aXRoIGEgYCpgIHZhbHVlIHRoZW5cbiAgICAgICAgLy8gaWYgYW55IGRlc3RpbmF0aW9uIHN0eWxlcyBhcmUgZmlsbGVkIGluIGxhdGVyIG9uIHRoZSBzYW1lXG4gICAgICAgIC8vIGtleWZyYW1lIHRoZW4gdGhleSB3aWxsIG92ZXJyaWRlIHRoZSBvdmVycmlkZGVuIHN0eWxlc1xuICAgICAgICAvLyBXZSB1c2UgYF9nbG9iYWxUaW1lbGluZVN0eWxlc2AgaGVyZSBiZWNhdXNlIHRoZXJlIG1heSBiZVxuICAgICAgICAvLyBzdHlsZXMgaW4gcHJldmlvdXMga2V5ZnJhbWVzIHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoaXMgdGltZWxpbmVcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIF90aGlzLl9iYWNrRmlsbFtwcm9wXSA9IF90aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlc1twcm9wXSB8fCBBVVRPX1NUWUxFO1xuICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRLZXlmcmFtZVtwcm9wXSA9IEFVVE9fU1RZTEU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50RW1wdHlTdGVwS2V5ZnJhbWUgPSB0aGlzLl9jdXJyZW50S2V5ZnJhbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuc2V0U3R5bGVzID0gZnVuY3Rpb24gKGlucHV0LCBlYXNpbmcsIGVycm9ycywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lWydlYXNpbmcnXSA9IGVhc2luZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmFtcykgfHwge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IGZsYXR0ZW5TdHlsZXMoaW5wdXQsIHRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzKTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBpbnRlcnBvbGF0ZVBhcmFtcyhzdHlsZXNbcHJvcF0sIHBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nU3R5bGVzW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9iYWNrRmlsbFtwcm9wXSA9IF90aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlc1twcm9wXSA6XG4gICAgICAgICAgICAgICAgICAgIEFVVE9fU1RZTEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlU3R5bGUocHJvcCwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYXBwbHlTdHlsZXNUb0tleWZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB0aGlzLl9wZW5kaW5nU3R5bGVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wcyA9IE9iamVjdC5rZXlzKHN0eWxlcyk7XG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0eWxlcyA9IHt9O1xuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICBfdGhpcy5fY3VycmVudEtleWZyYW1lW3Byb3BdID0gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fY3VycmVudEtleWZyYW1lLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRLZXlmcmFtZVtwcm9wXSA9IF90aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IF90aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdTdHlsZXNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlU3R5bGUocHJvcCwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuZ2V0RmluYWxLZXlmcmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleWZyYW1lcy5nZXQodGhpcy5kdXJhdGlvbik7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUsIFwicHJvcGVydGllc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gdGhpcy5fY3VycmVudEtleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZWxpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyA9IGZ1bmN0aW9uICh0aW1lbGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aW1lbGluZS5fc3R5bGVTdW1tYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzMCA9IF90aGlzLl9zdHlsZVN1bW1hcnlbcHJvcF07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzMSA9IHRpbWVsaW5lLl9zdHlsZVN1bW1hcnlbcHJvcF07XG4gICAgICAgICAgICBpZiAoIWRldGFpbHMwIHx8IGRldGFpbHMxLnRpbWUgPiBkZXRhaWxzMC50aW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVN0eWxlKHByb3AsIGRldGFpbHMxLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYnVpbGRLZXlmcmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RTdHlsZVByb3BzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0VtcHR5ID0gdGhpcy5fa2V5ZnJhbWVzLnNpemUgPT09IDEgJiYgdGhpcy5kdXJhdGlvbiA9PT0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxLZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fa2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleWZyYW1lLCB0aW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbEtleWZyYW1lID0gY29weVN0eWxlcyhrZXlmcmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmaW5hbEtleWZyYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBmaW5hbEtleWZyYW1lW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSDJtVBSRV9TVFlMRSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVTdHlsZVByb3BzLmFkZChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gQVVUT19TVFlMRSkge1xuICAgICAgICAgICAgICAgICAgICBwb3N0U3R5bGVQcm9wcy5hZGQocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleWZyYW1lWydvZmZzZXQnXSA9IHRpbWUgLyBfdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWVzLnB1c2goZmluYWxLZXlmcmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVQcm9wcyA9IHByZVN0eWxlUHJvcHMuc2l6ZSA/IGl0ZXJhdG9yVG9BcnJheShwcmVTdHlsZVByb3BzLnZhbHVlcygpKSA6IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0UHJvcHMgPSBwb3N0U3R5bGVQcm9wcy5zaXplID8gaXRlcmF0b3JUb0FycmF5KHBvc3RTdHlsZVByb3BzLnZhbHVlcygpKSA6IFtdO1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGEgMC1zZWNvbmQgYW5pbWF0aW9uICh3aGljaCBpcyBkZXNpZ25lZCBqdXN0IHRvIHBsYWNlIHN0eWxlcyBvbnNjcmVlbilcbiAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtmMCA9IGZpbmFsS2V5ZnJhbWVzWzBdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2YxID0gY29weU9iaihrZjApO1xuICAgICAgICAgICAga2YwWydvZmZzZXQnXSA9IDA7XG4gICAgICAgICAgICBrZjFbJ29mZnNldCddID0gMTtcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWVzID0gW2tmMCwga2YxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbih0aGlzLmVsZW1lbnQsIGZpbmFsS2V5ZnJhbWVzLCBwcmVQcm9wcywgcG9zdFByb3BzLCB0aGlzLmR1cmF0aW9uLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lYXNpbmcsIGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lbGluZUJ1aWxkZXI7XG59KCkpO1xudmFyIFN1YlRpbWVsaW5lQnVpbGRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3ViVGltZWxpbmVCdWlsZGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICogQHBhcmFtIHs/fSBwcmVTdHlsZVByb3BzXG4gICAgICogQHBhcmFtIHs/fSBwb3N0U3R5bGVQcm9wc1xuICAgICAqIEBwYXJhbSB7P30gdGltaW5nc1xuICAgICAqIEBwYXJhbSB7Pz19IF9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN1YlRpbWVsaW5lQnVpbGRlcihlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlUHJvcHMsIHBvc3RTdHlsZVByb3BzLCB0aW1pbmdzLCBfc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUpIHtcbiAgICAgICAgaWYgKF9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSA9PT0gdm9pZCAwKSB7IF9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnQsIHRpbWluZ3MuZGVsYXkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBfdGhpcy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XG4gICAgICAgIF90aGlzLnByZVN0eWxlUHJvcHMgPSBwcmVTdHlsZVByb3BzO1xuICAgICAgICBfdGhpcy5wb3N0U3R5bGVQcm9wcyA9IHBvc3RTdHlsZVByb3BzO1xuICAgICAgICBfdGhpcy5fc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUgPSBfc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWU7XG4gICAgICAgIF90aGlzLnRpbWluZ3MgPSB7IGR1cmF0aW9uOiB0aW1pbmdzLmR1cmF0aW9uLCBkZWxheTogdGltaW5ncy5kZWxheSwgZWFzaW5nOiB0aW1pbmdzLmVhc2luZyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3ViVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb250YWluc0FuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5ZnJhbWVzLmxlbmd0aCA+IDE7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdWJUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkS2V5ZnJhbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy50aW1pbmdzLCBkZWxheSA9IF9hLmRlbGF5LCBkdXJhdGlvbiA9IF9hLmR1cmF0aW9uLCBlYXNpbmcgPSBfYS5lYXNpbmc7XG4gICAgICAgIGlmICh0aGlzLl9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSAmJiBkZWxheSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3S2V5ZnJhbWVzID0gW107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b3RhbFRpbWUgPSBkdXJhdGlvbiArIGRlbGF5O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRpbmdHYXAgPSBkZWxheSAvIHRvdGFsVGltZTtcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBzdGFydGluZyBrZXlmcmFtZSBub3cgc3RhcnRzIG9uY2UgdGhlIGRlbGF5IGlzIGRvbmVcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld0ZpcnN0S2V5ZnJhbWUgPSBjb3B5U3R5bGVzKGtleWZyYW1lc1swXSwgZmFsc2UpO1xuICAgICAgICAgICAgbmV3Rmlyc3RLZXlmcmFtZVsnb2Zmc2V0J10gPSAwO1xuICAgICAgICAgICAgbmV3S2V5ZnJhbWVzLnB1c2gobmV3Rmlyc3RLZXlmcmFtZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRGaXJzdEtleWZyYW1lID0gY29weVN0eWxlcyhrZXlmcmFtZXNbMF0sIGZhbHNlKTtcbiAgICAgICAgICAgIG9sZEZpcnN0S2V5ZnJhbWVbJ29mZnNldCddID0gcm91bmRPZmZzZXQoc3RhcnRpbmdHYXApO1xuICAgICAgICAgICAgbmV3S2V5ZnJhbWVzLnB1c2gob2xkRmlyc3RLZXlmcmFtZSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBXaGVuIHRoZSBrZXlmcmFtZSBpcyBzdHJldGNoZWQgdGhlbiBpdCBtZWFucyB0aGF0IHRoZSBkZWxheSBiZWZvcmUgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICBzdGFydHMgaXMgZ29uZS4gSW5zdGVhZCB0aGUgZmlyc3Qga2V5ZnJhbWUgaXMgcGxhY2VkIGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIGFuZCBpdCBpcyB0aGVuIGNvcGllZCB0byB3aGVyZSBpdCBzdGFydHMgd2hlbiB0aGUgb3JpZ2luYWwgZGVsYXkgaXMgb3Zlci4gVGhpcyBiYXNpY2FsbHlcbiAgICAgICAgICAgICAgbWVhbnMgbm90aGluZyBhbmltYXRlcyBkdXJpbmcgdGhhdCBkZWxheSwgYnV0IHRoZSBzdHlsZXMgYXJlIHN0aWxsIHJlbmRlcmVyZWQuIEZvciB0aGlzXG4gICAgICAgICAgICAgIHRvIHdvcmsgdGhlIG9yaWdpbmFsIG9mZnNldCB2YWx1ZXMgdGhhdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwga2V5ZnJhbWVzIG11c3QgYmUgXCJ3YXJwZWRcIlxuICAgICAgICAgICAgICBzbyB0aGF0IHRoZXkgY2FuIHRha2UgdGhlIG5ldyBrZXlmcmFtZSArIGRlbGF5IGludG8gYWNjb3VudC5cbiAgICAgIFxuICAgICAgICAgICAgICBkZWxheT0xMDAwLCBkdXJhdGlvbj0xMDAwLCBrZXlmcmFtZXMgPSAwIC41IDFcbiAgICAgIFxuICAgICAgICAgICAgICB0dXJucyBpbnRvXG4gICAgICBcbiAgICAgICAgICAgICAgZGVsYXk9MCwgZHVyYXRpb249MjAwMCwga2V5ZnJhbWVzID0gMCAuMzMgLjY2IDFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gb2Zmc2V0cyBiZXR3ZWVuIDEgLi4uIG4gLTEgYXJlIGFsbCB3YXJwZWQgYnkgdGhlIGtleWZyYW1lIHN0cmV0Y2hcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbWl0ID0ga2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAxOyBpIDw9IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZiA9IGNvcHlTdHlsZXMoa2V5ZnJhbWVzW2ldLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkT2Zmc2V0ID0gKGtmWydvZmZzZXQnXSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZUF0S2V5ZnJhbWUgPSBkZWxheSArIG9sZE9mZnNldCAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGtmWydvZmZzZXQnXSA9IHJvdW5kT2Zmc2V0KHRpbWVBdEtleWZyYW1lIC8gdG90YWxUaW1lKTtcbiAgICAgICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChrZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgbmV3IHN0YXJ0aW5nIGtleWZyYW1lIHNob3VsZCBiZSBhZGRlZCBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdG90YWxUaW1lO1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgZWFzaW5nID0gJyc7XG4gICAgICAgICAgICBrZXlmcmFtZXMgPSBuZXdLZXlmcmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVsaW5lSW5zdHJ1Y3Rpb24odGhpcy5lbGVtZW50LCBrZXlmcmFtZXMsIHRoaXMucHJlU3R5bGVQcm9wcywgdGhpcy5wb3N0U3R5bGVQcm9wcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIHRydWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YlRpbWVsaW5lQnVpbGRlcjtcbn0oVGltZWxpbmVCdWlsZGVyKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gKiBAcGFyYW0gez89fSBkZWNpbWFsUG9pbnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByb3VuZE9mZnNldChvZmZzZXQsIGRlY2ltYWxQb2ludHMpIHtcbiAgICBpZiAoZGVjaW1hbFBvaW50cyA9PT0gdm9pZCAwKSB7IGRlY2ltYWxQb2ludHMgPSAzOyB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXVsdCA9IE1hdGgucG93KDEwLCBkZWNpbWFsUG9pbnRzIC0gMSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQob2Zmc2V0ICogbXVsdCkgLyBtdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGFsbFN0eWxlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblN0eWxlcyhpbnB1dCwgYWxsU3R5bGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0ge307XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUHJvcGVydGllcztcbiAgICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT09ICcqJykge1xuICAgICAgICAgICAgYWxsUHJvcGVydGllcyA9IGFsbFByb3BlcnRpZXMgfHwgT2JqZWN0LmtleXMoYWxsU3R5bGVzKTtcbiAgICAgICAgICAgIGFsbFByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBzdHlsZXNbcHJvcF0gPSBBVVRPX1NUWUxFOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcHlTdHlsZXMoLyoqIEB0eXBlIHs/fSAqLyAodG9rZW4pLCBmYWxzZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZXM7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQW5pbWF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKF9kcml2ZXIsIGlucHV0KSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIGFzdCA9IGJ1aWxkQW5pbWF0aW9uQXN0KGlucHV0LCBlcnJvcnMpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiYW5pbWF0aW9uIHZhbGlkYXRpb24gZmFpbGVkOlxcblwiICsgZXJyb3JzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmltYXRpb25Bc3QgPSBhc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGRlc3RpbmF0aW9uU3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmJ1aWxkVGltZWxpbmVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBkZXN0aW5hdGlvblN0eWxlcywgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gQXJyYXkuaXNBcnJheShzdGFydGluZ1N0eWxlcykgPyBub3JtYWxpemVTdHlsZXMoc3RhcnRpbmdTdHlsZXMpIDogKHN0YXJ0aW5nU3R5bGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVzdCA9IEFycmF5LmlzQXJyYXkoZGVzdGluYXRpb25TdHlsZXMpID8gbm9ybWFsaXplU3R5bGVzKGRlc3RpbmF0aW9uU3R5bGVzKSA6IChkZXN0aW5hdGlvblN0eWxlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICBzdWJJbnN0cnVjdGlvbnMgPSBzdWJJbnN0cnVjdGlvbnMgfHwgbmV3IEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBidWlsZEFuaW1hdGlvblRpbWVsaW5lcyh0aGlzLl9kcml2ZXIsIGVsZW1lbnQsIHRoaXMuX2FuaW1hdGlvbkFzdCwgc3RhcnQsIGRlc3QsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yTWVzc2FnZSA9IFwiYW5pbWF0aW9uIGJ1aWxkaW5nIGZhaWxlZDpcXG5cIiArIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb247XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqLyB2YXIgQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XG59KCkpO1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xudmFyIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIoKSB7XG4gICAgfVxuICAgIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGVycm9ycykgeyByZXR1cm4gcHJvcGVydHlOYW1lOyB9O1xuICAgIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVN0eWxlVmFsdWUgPSBmdW5jdGlvbiAodXNlclByb3ZpZGVkUHJvcGVydHksIG5vcm1hbGl6ZWRQcm9wZXJ0eSwgdmFsdWUsIGVycm9ycykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGVycm9ycykge1xuICAgICAgICByZXR1cm4gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wZXJ0eU5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1c2VyUHJvdmlkZWRQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gbm9ybWFsaXplZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVTdHlsZVZhbHVlID0gZnVuY3Rpb24gKHVzZXJQcm92aWRlZFByb3BlcnR5LCBub3JtYWxpemVkUHJvcGVydHksIHZhbHVlLCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pdCA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWwgPSB2YWx1ZS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgaWYgKERJTUVOU0lPTkFMX1BST1BfTUFQW25vcm1hbGl6ZWRQcm9wZXJ0eV0gJiYgdmFsdWUgIT09IDAgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbEFuZFN1ZmZpeE1hdGNoID0gdmFsdWUubWF0Y2goL15bKy1dP1tcXGRcXC5dKyhbYS16XSopJC8pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxBbmRTdWZmaXhNYXRjaCAmJiB2YWxBbmRTdWZmaXhNYXRjaFsxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBwcm92aWRlIGEgQ1NTIHVuaXQgdmFsdWUgZm9yIFwiICsgdXNlclByb3ZpZGVkUHJvcGVydHkgKyBcIjpcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0clZhbCArIHVuaXQ7XG4gICAgfTtcbiAgICByZXR1cm4gV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplcjtcbn0oQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyKSk7XG52YXIgRElNRU5TSU9OQUxfUFJPUF9NQVAgPSBtYWtlQm9vbGVhbk1hcCgnd2lkdGgsaGVpZ2h0LG1pbldpZHRoLG1pbkhlaWdodCxtYXhXaWR0aCxtYXhIZWlnaHQsbGVmdCx0b3AsYm90dG9tLHJpZ2h0LGZvbnRTaXplLG91dGxpbmVXaWR0aCxvdXRsaW5lT2Zmc2V0LHBhZGRpbmdUb3AscGFkZGluZ0xlZnQscGFkZGluZ0JvdHRvbSxwYWRkaW5nUmlnaHQsbWFyZ2luVG9wLG1hcmdpbkxlZnQsbWFyZ2luQm90dG9tLG1hcmdpblJpZ2h0LGJvcmRlclJhZGl1cyxib3JkZXJXaWR0aCxib3JkZXJUb3BXaWR0aCxib3JkZXJMZWZ0V2lkdGgsYm9yZGVyUmlnaHRXaWR0aCxib3JkZXJCb3R0b21XaWR0aCx0ZXh0SW5kZW50LHBlcnNwZWN0aXZlJ1xuICAgIC5zcGxpdCgnLCcpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBrZXlzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtYWtlQm9vbGVhbk1hcChrZXlzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG1hcFtrZXldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gKiBAcGFyYW0gez99IGZyb21TdGF0ZVxuICogQHBhcmFtIHs/fSB0b1N0YXRlXG4gKiBAcGFyYW0gez99IGlzUmVtb3ZhbFRyYW5zaXRpb25cbiAqIEBwYXJhbSB7P30gZnJvbVN0eWxlc1xuICogQHBhcmFtIHs/fSB0b1N0eWxlc1xuICogQHBhcmFtIHs/fSB0aW1lbGluZXNcbiAqIEBwYXJhbSB7P30gcXVlcmllZEVsZW1lbnRzXG4gKiBAcGFyYW0gez99IHByZVN0eWxlUHJvcHNcbiAqIEBwYXJhbSB7P30gcG9zdFN0eWxlUHJvcHNcbiAqIEBwYXJhbSB7Pz19IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbkluc3RydWN0aW9uKGVsZW1lbnQsIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUsIGlzUmVtb3ZhbFRyYW5zaXRpb24sIGZyb21TdHlsZXMsIHRvU3R5bGVzLCB0aW1lbGluZXMsIHF1ZXJpZWRFbGVtZW50cywgcHJlU3R5bGVQcm9wcywgcG9zdFN0eWxlUHJvcHMsIGVycm9ycykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogVHJhbnNpdGlvbkFuaW1hdGlvbiAqLyxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgdHJpZ2dlck5hbWU6IHRyaWdnZXJOYW1lLFxuICAgICAgICBpc1JlbW92YWxUcmFuc2l0aW9uOiBpc1JlbW92YWxUcmFuc2l0aW9uLFxuICAgICAgICBmcm9tU3RhdGU6IGZyb21TdGF0ZSxcbiAgICAgICAgZnJvbVN0eWxlczogZnJvbVN0eWxlcyxcbiAgICAgICAgdG9TdGF0ZTogdG9TdGF0ZSxcbiAgICAgICAgdG9TdHlsZXM6IHRvU3R5bGVzLFxuICAgICAgICB0aW1lbGluZXM6IHRpbWVsaW5lcyxcbiAgICAgICAgcXVlcmllZEVsZW1lbnRzOiBxdWVyaWVkRWxlbWVudHMsXG4gICAgICAgIHByZVN0eWxlUHJvcHM6IHByZVN0eWxlUHJvcHMsXG4gICAgICAgIHBvc3RTdHlsZVByb3BzOiBwb3N0U3R5bGVQcm9wcyxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF90cmlnZ2VyTmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBfc3RhdGVTdHlsZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeShfdHJpZ2dlck5hbWUsIGFzdCwgX3N0YXRlU3R5bGVzKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJOYW1lID0gX3RyaWdnZXJOYW1lO1xuICAgICAgICB0aGlzLmFzdCA9IGFzdDtcbiAgICAgICAgdGhpcy5fc3RhdGVTdHlsZXMgPSBfc3RhdGVTdHlsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gb25lT3JNb3JlVHJhbnNpdGlvbnNNYXRjaCh0aGlzLmFzdC5tYXRjaGVycywgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHN1Ykluc3RydWN0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGRyaXZlciwgZWxlbWVudCwgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb25PcHRpb25zID0gbWVyZ2VBbmltYXRpb25PcHRpb25zKHRoaXMuYXN0Lm9wdGlvbnMgfHwge30sIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYWNrdXBTdGF0ZVN0eWxlcyA9IHRoaXMuX3N0YXRlU3R5bGVzWycqJ10gfHwge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRTdGF0ZVN0eWxlcyA9IHRoaXMuX3N0YXRlU3R5bGVzW2N1cnJlbnRTdGF0ZV0gfHwgYmFja3VwU3RhdGVTdHlsZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRTdGF0ZVN0eWxlcyA9IHRoaXMuX3N0YXRlU3R5bGVzW25leHRTdGF0ZV0gfHwgYmFja3VwU3RhdGVTdHlsZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3R5bGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RTdHlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZW1vdmFsID0gbmV4dFN0YXRlID09PSAndm9pZCc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZXMgPSBidWlsZEFuaW1hdGlvblRpbWVsaW5lcyhkcml2ZXIsIGVsZW1lbnQsIHRoaXMuYXN0LmFuaW1hdGlvbiwgY3VycmVudFN0YXRlU3R5bGVzLCBuZXh0U3RhdGVTdHlsZXMsIGFuaW1hdGlvbk9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdGhpcy5fdHJpZ2dlck5hbWUsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBpc1JlbW92YWwsIGN1cnJlbnRTdGF0ZVN0eWxlcywgbmV4dFN0YXRlU3R5bGVzLCBbXSwgW10sIHByZVN0eWxlTWFwLCBwb3N0U3R5bGVNYXAsIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKHRsKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbG0gPSB0bC5lbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlUHJvcHMgPSBnZXRPclNldEFzSW5NYXAocHJlU3R5bGVNYXAsIGVsbSwge30pO1xuICAgICAgICAgICAgdGwucHJlU3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcmVQcm9wc1twcm9wXSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFByb3BzID0gZ2V0T3JTZXRBc0luTWFwKHBvc3RTdHlsZU1hcCwgZWxtLCB7fSk7XG4gICAgICAgICAgICB0bC5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwb3N0UHJvcHNbcHJvcF0gPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIGlmIChlbG0gIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBxdWVyaWVkRWxlbWVudHMuYWRkKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkRWxlbWVudHNMaXN0ID0gaXRlcmF0b3JUb0FycmF5KHF1ZXJpZWRFbGVtZW50cy52YWx1ZXMoKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdGhpcy5fdHJpZ2dlck5hbWUsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBpc1JlbW92YWwsIGN1cnJlbnRTdGF0ZVN0eWxlcywgbmV4dFN0YXRlU3R5bGVzLCB0aW1lbGluZXMsIHF1ZXJpZWRFbGVtZW50c0xpc3QsIHByZVN0eWxlTWFwLCBwb3N0U3R5bGVNYXApO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtYXRjaEZuc1xuICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcbiAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBvbmVPck1vcmVUcmFuc2l0aW9uc01hdGNoKG1hdGNoRm5zLCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiBtYXRjaEZucy5zb21lKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpOyB9KTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJpZ2dlcihuYW1lLCBhc3QpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRyaWdnZXIobmFtZSwgYXN0KTtcbn1cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xudmFyIEFuaW1hdGlvblRyaWdnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uVHJpZ2dlcihuYW1lLCBhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkZhY3RvcmllcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgICAgICBhc3Quc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IF90aGlzLnN0YXRlc1thc3QubmFtZV0gPSB7fTtcbiAgICAgICAgICAgIGFzdC5zdHlsZS5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVUdXBsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVUdXBsZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb3B5U3R5bGVzKHN0eWxlVHVwbGUsIGZhbHNlLCBvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFsYW5jZVByb3BlcnRpZXModGhpcy5zdGF0ZXMsICd0cnVlJywgJzEnKTtcbiAgICAgICAgYmFsYW5jZVByb3BlcnRpZXModGhpcy5zdGF0ZXMsICdmYWxzZScsICcwJyk7XG4gICAgICAgIGFzdC50cmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb25GYWN0b3JpZXMucHVzaChuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkobmFtZSwgYXN0LCBfdGhpcy5zdGF0ZXMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmFsbGJhY2tUcmFuc2l0aW9uID0gY3JlYXRlRmFsbGJhY2tUcmFuc2l0aW9uKG5hbWUsIHRoaXMuc3RhdGVzKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblRyaWdnZXIucHJvdG90eXBlLCBcImNvbnRhaW5zUXVlcmllc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmFzdC5xdWVyeUNvdW50ID4gMDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcbiAgICAgKiBAcGFyYW0gez99IG5leHRTdGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJpZ2dlci5wcm90b3R5cGUubWF0Y2hUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gdGhpcy50cmFuc2l0aW9uRmFjdG9yaWVzLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYubWF0Y2goY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpOyB9KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5IHx8IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uVHJpZ2dlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcbiAqIEBwYXJhbSB7P30gc3RhdGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1RyYW5zaXRpb24odHJpZ2dlck5hbWUsIHN0YXRlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoZXJzID0gW2Z1bmN0aW9uIChmcm9tU3RhdGUsIHRvU3RhdGUpIHsgcmV0dXJuIHRydWU7IH1dO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbiA9IG5ldyBTZXF1ZW5jZUFzdChbXSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uQXN0KG1hdGNoZXJzLCBhbmltYXRpb24pO1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkodHJpZ2dlck5hbWUsIHRyYW5zaXRpb24sIHN0YXRlcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gb2JqXG4gKiBAcGFyYW0gez99IGtleTFcbiAqIEBwYXJhbSB7P30ga2V5MlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYmFsYW5jZVByb3BlcnRpZXMob2JqLCBrZXkxLCBrZXkyKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkxKSkge1xuICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkyKSkge1xuICAgICAgICAgICAgb2JqW2tleTJdID0gb2JqW2tleTFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkyKSkge1xuICAgICAgICBvYmpba2V5MV0gPSBvYmpba2V5Ml07XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVNUFRZX0lOU1RSVUNUSU9OX01BUCA9IG5ldyBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKTtcbnZhciBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZHJpdmVyXG4gICAgICogQHBhcmFtIHs/fSBfbm9ybWFsaXplclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lKF9kcml2ZXIsIF9ub3JtYWxpemVyKSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBfbm9ybWFsaXplcjtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl9wbGF5ZXJzQnlJZCA9IHt9O1xuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChpZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IGJ1aWxkQW5pbWF0aW9uQXN0KG1ldGFkYXRhLCBlcnJvcnMpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGJ1aWxkIHRoZSBhbmltYXRpb24gZHVlIHRvIHRoZSBmb2xsb3dpbmcgZXJyb3JzOiBcIiArIGVycm9ycy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnNbaWRdID0gYXN0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlcbiAgICAgKiBAcGFyYW0gez99IHByZVN0eWxlc1xuICAgICAqIEBwYXJhbSB7Pz19IHBvc3RTdHlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYnVpbGRQbGF5ZXIgPSBmdW5jdGlvbiAoaSwgcHJlU3R5bGVzLCBwb3N0U3R5bGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBpLmVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lcyA9IG5vcm1hbGl6ZUtleWZyYW1lcyh0aGlzLl9kcml2ZXIsIHRoaXMuX25vcm1hbGl6ZXIsIGVsZW1lbnQsIGkua2V5ZnJhbWVzLCBwcmVTdHlsZXMsIHBvc3RTdHlsZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJpdmVyLmFuaW1hdGUoZWxlbWVudCwga2V5ZnJhbWVzLCBpLmR1cmF0aW9uLCBpLmRlbGF5LCBpLmVhc2luZywgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX2FuaW1hdGlvbnNbaWRdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0cnVjdGlvbnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF1dG9TdHlsZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChhc3QpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKHRoaXMuX2RyaXZlciwgZWxlbWVudCwgYXN0LCB7fSwge30sIG9wdGlvbnMsIEVNUFRZX0lOU1RSVUNUSU9OX01BUCwgZXJyb3JzKTtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gZ2V0T3JTZXRBc0luTWFwKGF1dG9TdHlsZXNNYXAsIGluc3QuZWxlbWVudCwge30pO1xuICAgICAgICAgICAgICAgIGluc3QucG9zdFN0eWxlUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gc3R5bGVzW3Byb3BdID0gbnVsbDsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKCdUaGUgcmVxdWVzdGVkIGFuaW1hdGlvbiBkb2VzblxcJ3QgZXhpc3Qgb3IgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIHRoZSBhbmltYXRpb24gZHVlIHRvIHRoZSBmb2xsb3dpbmcgZXJyb3JzOiBcIiArIGVycm9ycy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBhdXRvU3R5bGVzTWFwLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlcywgZWxlbWVudCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHN0eWxlc1twcm9wXSA9IF90aGlzLl9kcml2ZXIuY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3AsIEFVVE9fU1RZTEUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBpbnN0cnVjdGlvbnMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBhdXRvU3R5bGVzTWFwLmdldChpLmVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9idWlsZFBsYXllcihpLCB7fSwgc3R5bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVycyk7XG4gICAgICAgIHRoaXMuX3BsYXllcnNCeUlkW2lkXSA9IHBsYXllcjtcbiAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kZXN0cm95KGlkKTsgfSk7XG4gICAgICAgIHRoaXMucGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSB0aGlzLl9nZXRQbGF5ZXIoaWQpO1xuICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fcGxheWVyc0J5SWRbaWRdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMucGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9nZXRQbGF5ZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gdGhpcy5fcGxheWVyc0J5SWRbaWRdO1xuICAgICAgICBpZiAoIXBsYXllcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIHRpbWVsaW5lIHBsYXllciByZWZlcmVuY2VkIGJ5IFwiICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUgYXJlIGFsbCBpZ25vcmVkIGZvciB0aW1lbGluZSBhbmltYXRpb25zXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VFdmVudCA9IG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCAnJywgJycsICcnKTtcbiAgICAgICAgbGlzdGVuT25QbGF5ZXIodGhpcy5fZ2V0UGxheWVyKGlkKSwgZXZlbnROYW1lLCBiYXNlRXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jb21tYW5kID0gZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBjb21tYW5kLCBhcmdzKSB7XG4gICAgICAgIGlmIChjb21tYW5kID09ICdyZWdpc3RlcicpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoaWQsIC8qKiBAdHlwZSB7P30gKi8gKGFyZ3NbMF0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZCA9PSAnY3JlYXRlJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9ICgoYXJnc1swXSB8fCB7fSkpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGUoaWQsIGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IHRoaXMuX2dldFBsYXllcihpZCk7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSAncGxheSc6XG4gICAgICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhdXNlJzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc3RhcnQnOlxuICAgICAgICAgICAgICAgIHBsYXllci5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaW5pc2gnOlxuICAgICAgICAgICAgICAgIHBsYXllci5maW5pc2goKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAgICAgICAgIHBsYXllci5pbml0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZXRQb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFBvc2l0aW9uKHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAoYXJnc1swXSkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveShpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZTtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUVVFVUVEX0NMQVNTTkFNRSA9ICduZy1hbmltYXRlLXF1ZXVlZCc7XG52YXIgUVVFVUVEX1NFTEVDVE9SID0gJy5uZy1hbmltYXRlLXF1ZXVlZCc7XG52YXIgRElTQUJMRURfQ0xBU1NOQU1FID0gJ25nLWFuaW1hdGUtZGlzYWJsZWQnO1xudmFyIERJU0FCTEVEX1NFTEVDVE9SID0gJy5uZy1hbmltYXRlLWRpc2FibGVkJztcbnZhciBFTVBUWV9QTEFZRVJfQVJSQVkgPSBbXTtcbnZhciBOVUxMX1JFTU9WQUxfU1RBVEUgPSB7XG4gICAgbmFtZXNwYWNlSWQ6ICcnLFxuICAgIHNldEZvclJlbW92YWw6IG51bGwsXG4gICAgaGFzQW5pbWF0aW9uOiBmYWxzZSxcbiAgICByZW1vdmVkQmVmb3JlUXVlcmllZDogZmFsc2Vcbn07XG52YXIgTlVMTF9SRU1PVkVEX1FVRVJJRURfU1RBVEUgPSB7XG4gICAgbmFtZXNwYWNlSWQ6ICcnLFxuICAgIHNldEZvclJlbW92YWw6IG51bGwsXG4gICAgaGFzQW5pbWF0aW9uOiBmYWxzZSxcbiAgICByZW1vdmVkQmVmb3JlUXVlcmllZDogdHJ1ZVxufTtcbnZhciBSRU1PVkFMX0ZMQUcgPSAnX19uZ19yZW1vdmVkJztcbnZhciBTdGF0ZVZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGVWYWx1ZShpbnB1dCkge1xuICAgICAgICB2YXIgaXNPYmogPSBpbnB1dCAmJiBpbnB1dC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaXNPYmogPyBpbnB1dFsndmFsdWUnXSA6IGlucHV0O1xuICAgICAgICB0aGlzLnZhbHVlID0gbm9ybWFsaXplVHJpZ2dlclZhbHVlKHZhbHVlKTtcbiAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvcHlPYmooaW5wdXQpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbJ3ZhbHVlJ107XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZVZhbHVlLnByb3RvdHlwZS5hYnNvcmJPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3UGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIGlmIChuZXdQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFBhcmFtc18yID0gKCh0aGlzLm9wdGlvbnMucGFyYW1zKSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXdQYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkUGFyYW1zXzJbcHJvcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRQYXJhbXNfMltwcm9wXSA9IG5ld1BhcmFtc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlVmFsdWU7XG59KCkpO1xudmFyIFZPSURfVkFMVUUgPSAndm9pZCc7XG52YXIgREVGQVVMVF9TVEFURV9WQUxVRSA9IG5ldyBTdGF0ZVZhbHVlKFZPSURfVkFMVUUpO1xudmFyIERFTEVURURfU1RBVEVfVkFMVUUgPSBuZXcgU3RhdGVWYWx1ZSgnREVMRVRFRCcpO1xudmFyIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBfZW5naW5lXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZShpZCwgaG9zdEVsZW1lbnQsIF9lbmdpbmUpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IF9lbmdpbmU7XG4gICAgICAgIHRoaXMucGxheWVycyA9IFtdO1xuICAgICAgICB0aGlzLl90cmlnZ2VycyA9IHt9O1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLl9lbGVtZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ob3N0Q2xhc3NOYW1lID0gJ25nLXRucy0nICsgaWQ7XG4gICAgICAgIGFkZENsYXNzKGhvc3RFbGVtZW50LCB0aGlzLl9ob3N0Q2xhc3NOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwaGFzZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCBwaGFzZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl90cmlnZ2Vycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxpc3RlbiBvbiB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgXFxcIlwiICsgcGhhc2UgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBkb2Vzbid0IGV4aXN0IVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGhhc2UgPT0gbnVsbCB8fCBwaGFzZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxpc3RlbiBvbiB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBiZWNhdXNlIHRoZSBwcm92aWRlZCBldmVudCBpcyB1bmRlZmluZWQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNUcmlnZ2VyRXZlbnRWYWxpZChwaGFzZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gdHJpZ2dlciBldmVudCBcXFwiXCIgKyBwaGFzZSArIFwiXFxcIiBmb3IgdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdGVuZXJzID0gZ2V0T3JTZXRBc0luTWFwKHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMsIGVsZW1lbnQsIFtdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0YSA9IHsgbmFtZTogbmFtZSwgcGhhc2U6IHBoYXNlLCBjYWxsYmFjazogY2FsbGJhY2sgfTtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goZGF0YSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJzV2l0aFN0YXRlcyA9IGdldE9yU2V0QXNJbk1hcCh0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LCBlbGVtZW50LCB7fSk7XG4gICAgICAgIGlmICghdHJpZ2dlcnNXaXRoU3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBOR19UUklHR0VSX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBOR19UUklHR0VSX0NMQVNTTkFNRSArICctJyArIG5hbWUpO1xuICAgICAgICAgICAgdHJpZ2dlcnNXaXRoU3RhdGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdGhlIGV2ZW50IGxpc3RlbmVyIGlzIHJlbW92ZWQgQUZURVIgdGhlIGZsdXNoIGhhcyBvY2N1cnJlZCBzdWNoXG4gICAgICAgICAgICAvLyB0aGF0IGxlYXZlIGFuaW1hdGlvbnMgY2FsbGJhY2tzIGNhbiBmaXJlIChvdGhlcndpc2UgaWYgdGhlIG5vZGVcbiAgICAgICAgICAgIC8vIGlzIHJlbW92ZWQgaW4gYmV0d2VlbiB0aGVuIHRoZSBsaXN0ZW5lcnMgd291bGQgYmUgZGVyZWdpc3RlcmVkKVxuICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl90cmlnZ2Vyc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHJpZ2dlcnNXaXRoU3RhdGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWUsIGFzdCkge1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIC8vIHRocm93XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2Vyc1tuYW1lXSA9IGFzdDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLl9nZXRUcmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJzW25hbWVdO1xuICAgICAgICBpZiAoIXRyaWdnZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJpZ2dlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFRvRmFsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHJpZ2dlck5hbWUsIHZhbHVlLCBkZWZhdWx0VG9GYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGVmYXVsdFRvRmFsbGJhY2sgPT09IHZvaWQgMCkgeyBkZWZhdWx0VG9GYWxsYmFjayA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlciA9IHRoaXMuX2dldFRyaWdnZXIodHJpZ2dlck5hbWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcih0aGlzLmlkLCB0cmlnZ2VyTmFtZSwgZWxlbWVudCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJzV2l0aFN0YXRlcyA9IHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXRyaWdnZXJzV2l0aFN0YXRlcykge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUgKyAnLScgKyB0cmlnZ2VyTmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LnNldChlbGVtZW50LCB0cmlnZ2Vyc1dpdGhTdGF0ZXMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnJvbVN0YXRlID0gdHJpZ2dlcnNXaXRoU3RhdGVzW3RyaWdnZXJOYW1lXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9TdGF0ZSA9IG5ldyBTdGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPYmogPSB2YWx1ZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgaWYgKCFpc09iaiAmJiBmcm9tU3RhdGUpIHtcbiAgICAgICAgICAgIHRvU3RhdGUuYWJzb3JiT3B0aW9ucyhmcm9tU3RhdGUub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlcnNXaXRoU3RhdGVzW3RyaWdnZXJOYW1lXSA9IHRvU3RhdGU7XG4gICAgICAgIGlmICghZnJvbVN0YXRlKSB7XG4gICAgICAgICAgICBmcm9tU3RhdGUgPSBERUZBVUxUX1NUQVRFX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyb21TdGF0ZSA9PT0gREVMRVRFRF9TVEFURV9WQUxVRSkge1xuICAgICAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1JlbW92YWwgPSB0b1N0YXRlLnZhbHVlID09PSBWT0lEX1ZBTFVFO1xuICAgICAgICAvLyBub3JtYWxseSB0aGlzIGlzbid0IHJlYWNoZWQgYnkgaGVyZSwgaG93ZXZlciwgaWYgYW4gb2JqZWN0IGV4cHJlc3Npb25cbiAgICAgICAgLy8gaXMgcGFzc2VkIGluIHRoZW4gaXQgbWF5IGJlIGEgbmV3IG9iamVjdCBlYWNoIHRpbWUuIENvbXBhcmluZyB0aGUgdmFsdWVcbiAgICAgICAgLy8gaXMgaW1wb3J0YW50IHNpbmNlIHRoYXQgd2lsbCBzdGF5IHRoZSBzYW1lIGRlc3BpdGUgdGhlcmUgYmVpbmcgYSBuZXcgb2JqZWN0LlxuICAgICAgICAvLyBUaGUgcmVtb3ZhbCBhcmMgaGVyZSBpcyBzcGVjaWFsIGNhc2VkIGJlY2F1c2UgdGhlIHNhbWUgZWxlbWVudCBpcyB0cmlnZ2VyZWRcbiAgICAgICAgLy8gdHdpY2UgaW4gdGhlIGV2ZW50IHRoYXQgaXQgY29udGFpbnMgYW5pbWF0aW9ucyBvbiB0aGUgb3V0ZXIvaW5uZXIgcG9ydGlvbnNcbiAgICAgICAgLy8gb2YgdGhlIGhvc3QgY29udGFpbmVyXG4gICAgICAgIGlmICghaXNSZW1vdmFsICYmIGZyb21TdGF0ZS52YWx1ZSA9PT0gdG9TdGF0ZS52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyc09uRWxlbWVudCA9IGdldE9yU2V0QXNJbk1hcCh0aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudCwgZWxlbWVudCwgW10pO1xuICAgICAgICBwbGF5ZXJzT25FbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgLy8gb25seSByZW1vdmUgdGhlIHBsYXllciBpZiBpdCBpcyBxdWV1ZWQgb24gdGhlIEVYQUNUIHNhbWUgdHJpZ2dlci9uYW1lc3BhY2VcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgYWxzbyBkZWFsIHdpdGggcXVldWVkIHBsYXllcnMgaGVyZSBiZWNhdXNlIGlmIHRoZSBhbmltYXRpb24gaGFzXG4gICAgICAgICAgICAvLyBzdGFydGVkIHRoZW4gd2Ugd2FudCB0byBrZWVwIHRoZSBwbGF5ZXIgYWxpdmUgdW50aWwgdGhlIGZsdXNoIGhhcHBlbnNcbiAgICAgICAgICAgIC8vICh3aGljaCBpcyB3aGVyZSB0aGUgcHJldmlvdXNQbGF5ZXJzIGFyZSBwYXNzZWQgaW50byB0aGUgbmV3IHBhbHllcilcbiAgICAgICAgICAgIGlmIChwbGF5ZXIubmFtZXNwYWNlSWQgPT0gX3RoaXMuaWQgJiYgcGxheWVyLnRyaWdnZXJOYW1lID09IHRyaWdnZXJOYW1lICYmIHBsYXllci5xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbiA9IHRyaWdnZXIubWF0Y2hUcmFuc2l0aW9uKGZyb21TdGF0ZS52YWx1ZSwgdG9TdGF0ZS52YWx1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRmFsbGJhY2tUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0VG9GYWxsYmFjaylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmFuc2l0aW9uID0gdHJpZ2dlci5mYWxsYmFja1RyYW5zaXRpb247XG4gICAgICAgICAgICBpc0ZhbGxiYWNrVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5naW5lLnRvdGFsUXVldWVkUGxheWVycysrO1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZWxlbWVudDogZWxlbWVudCwgdHJpZ2dlck5hbWU6IHRyaWdnZXJOYW1lLCB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLCBmcm9tU3RhdGU6IGZyb21TdGF0ZSwgdG9TdGF0ZTogdG9TdGF0ZSwgcGxheWVyOiBwbGF5ZXIsIGlzRmFsbGJhY2tUcmFuc2l0aW9uOiBpc0ZhbGxiYWNrVHJhbnNpdGlvbiB9KTtcbiAgICAgICAgaWYgKCFpc0ZhbGxiYWNrVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgUVVFVUVEX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICBwbGF5ZXIub25TdGFydChmdW5jdGlvbiAoKSB7IHJlbW92ZUNsYXNzKGVsZW1lbnQsIFFVRVVFRF9DTEFTU05BTUUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gX3RoaXMucGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBfdGhpcy5fZW5naW5lLnBsYXllcnNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleF8xID0gcGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4XzEgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnNwbGljZShpbmRleF8xLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICBwbGF5ZXJzT25FbGVtZW50LnB1c2gocGxheWVyKTtcbiAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90cmlnZ2Vyc1tuYW1lXTtcbiAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZU1hcCwgZWxlbWVudCkgeyBkZWxldGUgc3RhdGVNYXBbbmFtZV07IH0pO1xuICAgICAgICB0aGlzLl9lbGVtZW50TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVycywgZWxlbWVudCkge1xuICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5uYW1lICE9IG5hbWU7IH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmNsZWFyRWxlbWVudENhY2hlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50UGxheWVycyA9IHRoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnRQbGF5ZXJzKSB7XG4gICAgICAgICAgICBlbGVtZW50UGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnBsYXllcnNCeUVsZW1lbnQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gYW5pbWF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuX2Rlc3Ryb3lJbm5lck5vZGVzID0gZnVuY3Rpb24gKHJvb3RFbGVtZW50LCBjb250ZXh0LCBhbmltYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChhbmltYXRlID09PSB2b2lkIDApIHsgYW5pbWF0ZSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX2VuZ2luZS5kcml2ZXIucXVlcnkocm9vdEVsZW1lbnQsIE5HX1RSSUdHRVJfU0VMRUNUT1IsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGVsbSkge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGUgJiYgY29udGFpbnNDbGFzcyhlbG0sIF90aGlzLl9ob3N0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyTnMgPSBfdGhpcy5fZW5naW5lLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LmdldChlbG0pO1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgYSBob3N0IGVsZW1lbnQgd2l0aCBhbmltYXRpb25zIG9uIHRoZSBzYW1lIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJOcykge1xuICAgICAgICAgICAgICAgICAgICBpbm5lck5zLnJlbW92ZU5vZGUoZWxtLCBjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlTm9kZShlbG0sIGNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJFbGVtZW50Q2FjaGUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez89fSBkb05vdFJlY3Vyc2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCwgZG9Ob3RSZWN1cnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZ2luZSA9IHRoaXMuX2VuZ2luZTtcbiAgICAgICAgaWYgKCFkb05vdFJlY3Vyc2UgJiYgZWxlbWVudC5jaGlsZEVsZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUlubmVyTm9kZXMoZWxlbWVudCwgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlclN0YXRlcyA9IGVuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAodHJpZ2dlclN0YXRlcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyc18xID0gW107XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0cmlnZ2VyU3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyTmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hlY2sgaXMgaGVyZSBpbiB0aGUgZXZlbnQgdGhhdCBhbiBlbGVtZW50IGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyB0d2ljZSAoYm90aCBvbiB0aGUgaG9zdCBsZXZlbCBhbmQgdGhlIGNvbXBvbmVudCBsZXZlbClcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3RyaWdnZXJzW3RyaWdnZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBfdGhpcy50cmlnZ2VyKGVsZW1lbnQsIHRyaWdnZXJOYW1lLCBWT0lEX1ZBTFVFLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnNfMS5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJzXzEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZW5naW5lLm1hcmtFbGVtZW50QXNSZW1vdmVkKHRoaXMuaWQsIGVsZW1lbnQsIHRydWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVyc18xKS5vbkRvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5naW5lLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHRoZSBwbGF5ZXIgdGhhdCBpcyBhbmltYXRpbmcgYW5kIG1ha2Ugc3VyZSB0aGF0IHRoZVxuICAgICAgICAvLyByZW1vdmFsIGlzIGRlbGF5ZWQgdW50aWwgdGhhdCBwbGF5ZXIgaGFzIGNvbXBsZXRlZFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKGVuZ2luZS50b3RhbEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRQbGF5ZXJzID0gZW5naW5lLnBsYXllcnMubGVuZ3RoID8gZW5naW5lLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LmdldChlbGVtZW50KSA6IFtdO1xuICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGBpZiBzdGF0ZW1lbnRgIGRvZXMgbm90IGNvbnRpbnVlIGZvcndhcmQgaXQgbWVhbnMgdGhhdFxuICAgICAgICAgICAgLy8gYSBwcmV2aW91cyBhbmltYXRpb24gcXVlcnkgaGFzIHNlbGVjdGVkIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kXG4gICAgICAgICAgICAvLyBpcyBhbmltYXRpbmcgaXQuIEluIHRoaXMgc2l0dWF0aW9uIHdhbnQgdG8gY29udGludWUgZm93YXJkcyBhbmRcbiAgICAgICAgICAgIC8vIGFsbG93IHRoZSBlbGVtZW50IHRvIGJlIHF1ZXVlZCB1cCBmb3IgYW5pbWF0aW9uIGxhdGVyLlxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQbGF5ZXJzICYmIGN1cnJlbnRQbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5zUG90ZW50aWFsUGFyZW50VHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VycyA9IGVuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNQb3RlbnRpYWxQYXJlbnRUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgc3RhZ2Ugd2Uga25vdyB0aGF0IHRoZSBlbGVtZW50IHdpbGwgZWl0aGVyIGdldCByZW1vdmVkXG4gICAgICAgIC8vIGR1cmluZyBmbHVzaCBvciB3aWxsIGJlIHBpY2tlZCB1cCBieSBhIHBhcmVudCBxdWVyeS4gRWl0aGVyIHdheVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZpcmUgdGhlIGxpc3RlbmVycyBmb3IgdGhpcyBlbGVtZW50IHdoZW4gaXQgRE9FUyBnZXRcbiAgICAgICAgLy8gcmVtb3ZlZCAob25jZSB0aGUgcXVlcnkgcGFyZW50IGFuaW1hdGlvbiBpcyBkb25lIG9yIGFmdGVyIGZsdXNoKVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ZW5lcnMgPSB0aGlzLl9lbGVtZW50TGlzdGVuZXJzLmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRlZFRyaWdnZXJzXzEgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyTmFtZSA9IGxpc3RlbmVyLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRUcmlnZ2Vyc18xLmhhcyh0cmlnZ2VyTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2aXNpdGVkVHJpZ2dlcnNfMS5hZGQodHJpZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSBfdGhpcy5fdHJpZ2dlcnNbdHJpZ2dlck5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb24gPSB0cmlnZ2VyLmZhbGxiYWNrVHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50U3RhdGVzID0gKChlbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChlbGVtZW50KSkpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZyb21TdGF0ZSA9IGVsZW1lbnRTdGF0ZXNbdHJpZ2dlck5hbWVdIHx8IERFRkFVTFRfU1RBVEVfVkFMVUU7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9TdGF0ZSA9IG5ldyBTdGF0ZVZhbHVlKFZPSURfVkFMVUUpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyKF90aGlzLmlkLCB0cmlnZ2VyTmFtZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS50b3RhbFF1ZXVlZFBsYXllcnMrKztcbiAgICAgICAgICAgICAgICBfdGhpcy5fcXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOYW1lOiB0cmlnZ2VyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZnJvbVN0YXRlOiBmcm9tU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHRvU3RhdGU6IHRvU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHBsYXllcjogcGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrVHJhbnNpdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hldGhlciBvciBub3QgYSBwYXJlbnQgaGFzIGFuIGFuaW1hdGlvbiB3ZSBuZWVkIHRvIGRlbGF5IHRoZSBkZWZlcnJhbCBvZiB0aGUgbGVhdmVcbiAgICAgICAgLy8gb3BlcmF0aW9uIHVudGlsIHdlIGhhdmUgbW9yZSBpbmZvcm1hdGlvbiAod2hpY2ggd2UgZG8gYWZ0ZXIgZmx1c2goKSBoYXMgYmVlbiBjYWxsZWQpXG4gICAgICAgIGlmIChjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGVuZ2luZS5tYXJrRWxlbWVudEFzUmVtb3ZlZCh0aGlzLmlkLCBlbGVtZW50LCBmYWxzZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBkbyB0aGlzIGFmdGVyIHRoZSBmbHVzaCBoYXMgb2NjdXJyZWQgc3VjaFxuICAgICAgICAgICAgLy8gdGhhdCB0aGUgY2FsbGJhY2tzIGNhbiBiZSBmaXJlZFxuICAgICAgICAgICAgZW5naW5lLmFmdGVyRmx1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xlYXJFbGVtZW50Q2FjaGUoZWxlbWVudCk7IH0pO1xuICAgICAgICAgICAgZW5naW5lLmRlc3Ryb3lJbm5lckFuaW1hdGlvbnMoZWxlbWVudCk7XG4gICAgICAgICAgICBlbmdpbmUuX29uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuaW5zZXJ0Tm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQpIHsgYWRkQ2xhc3MoZWxlbWVudCwgdGhpcy5faG9zdENsYXNzTmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtaWNyb3Rhc2tJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuZHJhaW5RdWV1ZWRUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uIChtaWNyb3Rhc2tJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IGVudHJ5LnBsYXllcjtcbiAgICAgICAgICAgIGlmIChwbGF5ZXIuZGVzdHJveWVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBlbnRyeS5lbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdGVuZXJzID0gX3RoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZSA9PSBlbnRyeS50cmlnZ2VyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZUV2ZW50ID0gbWFrZUFuaW1hdGlvbkV2ZW50KGVsZW1lbnQsIGVudHJ5LnRyaWdnZXJOYW1lLCBlbnRyeS5mcm9tU3RhdGUudmFsdWUsIGVudHJ5LnRvU3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKChiYXNlRXZlbnQpKVsnX2RhdGEnXSA9IG1pY3JvdGFza0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuT25QbGF5ZXIoZW50cnkucGxheWVyLCBsaXN0ZW5lci5waGFzZSwgYmFzZUV2ZW50LCBsaXN0ZW5lci5jYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbGF5ZXIubWFya2VkRm9yRGVzdHJveSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9lbmdpbmUuYWZ0ZXJGbHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyB3ZSBjYW4gZGVzdHJveSB0aGUgZWxlbWVudCBwcm9wZXJseSBzaW5jZSB0aGUgZXZlbnQgbGlzdGVuZXJzIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBib3VuZCB0byB0aGUgcGxheWVyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIGlmIGRlcENvdW50ID09IDAgdGhlbSBtb3ZlIHRvIGZyb250XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaWYgYSBjb250YWlucyBiIHRoZW4gbW92ZSBiYWNrXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMCA9IGEudHJhbnNpdGlvbi5hc3QuZGVwQ291bnQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMSA9IGIudHJhbnNpdGlvbi5hc3QuZGVwQ291bnQ7XG4gICAgICAgICAgICBpZiAoZDAgPT0gMCB8fCBkMSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQwIC0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2VuZ2luZS5kcml2ZXIuY29udGFpbnNFbGVtZW50KGEuZWxlbWVudCwgYi5lbGVtZW50KSA/IDEgOiAtMTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLnBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5kZXN0cm95KCk7IH0pO1xuICAgICAgICB0aGlzLl9kZXN0cm95SW5uZXJOb2Rlcyh0aGlzLmhvc3RFbGVtZW50LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuZWxlbWVudENvbnRhaW5zRGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5zRGF0YSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudExpc3RlbmVycy5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICBjb250YWluc0RhdGEgPSB0cnVlO1xuICAgICAgICBjb250YWluc0RhdGEgPVxuICAgICAgICAgICAgKHRoaXMuX3F1ZXVlLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5lbGVtZW50ID09PSBlbGVtZW50OyB9KSA/IHRydWUgOiBmYWxzZSkgfHwgY29udGFpbnNEYXRhO1xuICAgICAgICByZXR1cm4gY29udGFpbnNEYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2U7XG59KCkpO1xudmFyIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZHJpdmVyXG4gICAgICogQHBhcmFtIHs/fSBfbm9ybWFsaXplclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUoZHJpdmVyLCBfbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLmRyaXZlciA9IGRyaXZlcjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplciA9IF9ub3JtYWxpemVyO1xuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGxheWVyc0J5RWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGF0ZXNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy50b3RhbEFuaW1hdGlvbnMgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsUXVldWVkUGxheWVycyA9IDA7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZUxvb2t1cCA9IHt9O1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0ID0gW107XG4gICAgICAgIHRoaXMuX2ZsdXNoRm5zID0gW107XG4gICAgICAgIHRoaXMuX3doZW5RdWlldEZucyA9IFtdO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMub25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9vblJlbW92YWxDb21wbGV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7IHRoaXMub25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLCBcInF1ZXVlZFBsYXllcnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChucykge1xuICAgICAgICAgICAgICAgIG5zLnBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucXVldWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGxheWVycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmNyZWF0ZU5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnMgPSBuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZShuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIHRoaXMpO1xuICAgICAgICBpZiAoaG9zdEVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fYmFsYW5jZU5hbWVzcGFjZUxpc3QobnMsIGhvc3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmVyIHRoaXMgbGF0ZXIgdW50aWwgZmx1c2ggZHVyaW5nIHdoZW4gdGhlIGhvc3QgZWxlbWVudCBoYXNcbiAgICAgICAgICAgIC8vIGJlZW4gaW5zZXJ0ZWQgc28gdGhhdCB3ZSBrbm93IGV4YWN0bHkgd2hlcmUgdG8gcGxhY2UgaXQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBuYW1lc3BhY2UgbGlzdFxuICAgICAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMuc2V0KGhvc3RFbGVtZW50LCBucyk7XG4gICAgICAgICAgICAvLyBnaXZlbiB0aGF0IHRoaXMgaG9zdCBlbGVtZW50IGlzIGFwYXJ0IG9mIHRoZSBhbmltYXRpb24gY29kZSwgaXRcbiAgICAgICAgICAgIC8vIG1heSBvciBtYXkgbm90IGJlIGluc2VydGVkIGJ5IGEgcGFyZW50IG5vZGUgdGhhdCBpcyBhbiBvZiBhblxuICAgICAgICAgICAgLy8gYW5pbWF0aW9uIHJlbmRlcmVyIHR5cGUuIElmIHRoaXMgaGFwcGVucyB0aGVuIHdlIGNhbiBzdGlsbCBoYXZlXG4gICAgICAgICAgICAvLyBhY2Nlc3MgdG8gdGhpcyBpdGVtIHdoZW4gd2UgcXVlcnkgZm9yIDplbnRlciBub2Rlcy4gSWYgdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gaXMgYSByZW5kZXJlciB0aGVuIHRoZSBzZXQgZGF0YS1zdHJ1Y3R1cmUgd2lsbCBub3JtYWxpemUgdGhlIGVudHJ5XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RFbnRlckVsZW1lbnQoaG9zdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lc3BhY2VMb29rdXBbbmFtZXNwYWNlSWRdID0gbnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5zXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2JhbGFuY2VOYW1lc3BhY2VMaXN0ID0gZnVuY3Rpb24gKG5zLCBob3N0RWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW1pdCA9IHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBsaW1pdDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0TmFtZXNwYWNlID0gdGhpcy5fbmFtZXNwYWNlTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcml2ZXIuY29udGFpbnNFbGVtZW50KG5leHROYW1lc3BhY2UuaG9zdEVsZW1lbnQsIGhvc3RFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZShpICsgMSwgMCwgbnMpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZSgwLCAwLCBucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnB1c2gobnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQuc2V0KGhvc3RFbGVtZW50LCBucyk7XG4gICAgICAgIHJldHVybiBucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnMgPSB0aGlzLl9uYW1lc3BhY2VMb29rdXBbbmFtZXNwYWNlSWRdO1xuICAgICAgICBpZiAoIW5zKSB7XG4gICAgICAgICAgICBucyA9IHRoaXMuY3JlYXRlTmFtZXNwYWNlKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdHJpZ2dlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXJUcmlnZ2VyID0gZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBuYW1lLCB0cmlnZ2VyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXTtcbiAgICAgICAgaWYgKG5zICYmIG5zLnJlZ2lzdGVyKG5hbWUsIHRyaWdnZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnRvdGFsQW5pbWF0aW9ucysrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghbmFtZXNwYWNlSWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpO1xuICAgICAgICB0aGlzLmFmdGVyRmx1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQuZGVsZXRlKG5zLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gX3RoaXMuX25hbWVzcGFjZUxpc3QuaW5kZXhPZihucyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFmdGVyRmx1c2hBbmltYXRpb25zRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBucy5kZXN0cm95KGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9mZXRjaE5hbWVzcGFjZSA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdGhpcy5fbmFtZXNwYWNlTG9va3VwW2lkXTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKS50cmlnZ2VyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gaW5zZXJ0QmVmb3JlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5pbnNlcnROb2RlID0gZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwYXJlbnQsIGluc2VydEJlZm9yZSkge1xuICAgICAgICBpZiAoIWlzRWxlbWVudE5vZGUoZWxlbWVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQgYW5kIHJlaW5zZXJ0ZWQgKG1vdmUgb3BlcmF0aW9uKVxuICAgICAgICAvLyB3aGVuIHRoaXMgb2NjdXJzIHdlIGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgZWxlbWVudCBmb3IgZGVsZXRpb24gbGF0ZXJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IChlbGVtZW50W1JFTU9WQUxfRkxBR10pO1xuICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLnNldEZvclJlbW92YWwpIHtcbiAgICAgICAgICAgIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBuYW1lc3BhY2VJZCBpcyBibGFuayB0aGVuIHRoZSBjYWxsZXJcbiAgICAgICAgLy8gY29kZSBkb2VzIG5vdCBjb250YWluIGFueSBhbmltYXRpb24gY29kZSBpbiBpdCwgYnV0IGl0IGlzXG4gICAgICAgIC8vIGp1c3QgYmVpbmcgY2FsbGVkIHNvIHRoYXQgdGhlIG5vZGUgaXMgbWFya2VkIGFzIGJlaW5nIGluc2VydGVkXG4gICAgICAgIGlmIChuYW1lc3BhY2VJZCkge1xuICAgICAgICAgICAgdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpLmluc2VydE5vZGUoZWxlbWVudCwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5ICpkaXJlY3RpdmVzIGFuZCBob3N0IGVsZW1lbnRzIGFyZSBpbnNlcnRlZCBiZWZvcmVcbiAgICAgICAgaWYgKGluc2VydEJlZm9yZSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0RW50ZXJFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmNvbGxlY3RFbnRlckVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMucHVzaChlbGVtZW50KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5tYXJrRWxlbWVudEFzRGlzYWJsZWQgPSBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWROb2Rlcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVkTm9kZXMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIERJU0FCTEVEX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNhYmxlZE5vZGVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZE5vZGVzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIERJU0FCTEVEX0NMQVNTTkFNRSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez89fSBkb05vdFJlY3Vyc2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGNvbnRleHQsIGRvTm90UmVjdXJzZSkge1xuICAgICAgICBpZiAoIWlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gbmFtZXNwYWNlSWQgPyB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkgOiBudWxsO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIG5zLnJlbW92ZU5vZGUoZWxlbWVudCwgY29udGV4dCwgZG9Ob3RSZWN1cnNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFya0VsZW1lbnRBc1JlbW92ZWQobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IGhhc0FuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLm1hcmtFbGVtZW50QXNSZW1vdmVkID0gZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBoYXNBbmltYXRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSA9IHtcbiAgICAgICAgICAgIG5hbWVzcGFjZUlkOiBuYW1lc3BhY2VJZCxcbiAgICAgICAgICAgIHNldEZvclJlbW92YWw6IGNvbnRleHQsIGhhc0FuaW1hdGlvbjogaGFzQW5pbWF0aW9uLFxuICAgICAgICAgICAgcmVtb3ZlZEJlZm9yZVF1ZXJpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwaGFzZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgbmFtZSwgcGhhc2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpLmxpc3RlbihlbGVtZW50LCBuYW1lLCBwaGFzZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJ5XG4gICAgICogQHBhcmFtIHs/fSBzdWJUaW1lbGluZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9idWlsZEluc3RydWN0aW9uID0gZnVuY3Rpb24gKGVudHJ5LCBzdWJUaW1lbGluZXMpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnRyYW5zaXRpb24uYnVpbGQodGhpcy5kcml2ZXIsIGVudHJ5LmVsZW1lbnQsIGVudHJ5LmZyb21TdGF0ZS52YWx1ZSwgZW50cnkudG9TdGF0ZS52YWx1ZSwgZW50cnkudG9TdGF0ZS5vcHRpb25zLCBzdWJUaW1lbGluZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5kZXN0cm95SW5uZXJBbmltYXRpb25zID0gZnVuY3Rpb24gKGNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudHMgPSB0aGlzLmRyaXZlci5xdWVyeShjb250YWluZXJFbGVtZW50LCBOR19UUklHR0VSX1NFTEVDVE9SLCB0cnVlKTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IF90aGlzLnBsYXllcnNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyBzZXQgZm9yIGRlc3RydWN0aW9uLCBidXQgaGFzbid0IHN0YXJ0ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgc2l0dWF0aW9uIHdlIHdhbnQgdG8gZGVsYXkgdGhlIGRlc3RydWN0aW9uIHVudGlsIHRoZSBmbHVzaCBvY2N1cnNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCBhbnkgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoZSBwbGF5ZXIgYXJlIHRyaWdnZXJlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXllci5xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllci5tYXJrZWRGb3JEZXN0cm95ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlTWFwID0gX3RoaXMuc3RhdGVzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzdGF0ZU1hcCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0YXRlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyTmFtZSkgeyByZXR1cm4gc3RhdGVNYXBbdHJpZ2dlck5hbWVdID0gREVMRVRFRF9TVEFURV9WQUxVRTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5kcml2ZXIucXVlcnkoY29udGFpbmVyRWxlbWVudCwgTkdfQU5JTUFUSU5HX1NFTEVDVE9SLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5maW5pc2goKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUud2hlblJlbmRlcmluZ0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGltaXplR3JvdXBQbGF5ZXIoX3RoaXMucGxheWVycykub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5wcm9jZXNzTGVhdmVOb2RlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IChlbGVtZW50W1JFTU9WQUxfRkxBR10pO1xuICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLnNldEZvclJlbW92YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBwcmV2ZW50IGl0IGZyb20gcmVtb3ZpbmcgaXQgdHdpY2VcbiAgICAgICAgICAgIGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSA9IE5VTExfUkVNT1ZBTF9TVEFURTtcbiAgICAgICAgICAgIGlmIChkZXRhaWxzLm5hbWVzcGFjZUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95SW5uZXJBbmltYXRpb25zKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fZmV0Y2hOYW1lc3BhY2UoZGV0YWlscy5uYW1lc3BhY2VJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zLmNsZWFyRWxlbWVudENhY2hlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHJpdmVyLm1hdGNoZXNFbGVtZW50KGVsZW1lbnQsIERJU0FCTEVEX1NFTEVDVE9SKSkge1xuICAgICAgICAgICAgdGhpcy5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJpdmVyLnF1ZXJ5KGVsZW1lbnQsIERJU0FCTEVEX1NFTEVDVE9SLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBfdGhpcy5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChtaWNyb3Rhc2tJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobWljcm90YXNrSWQgPT09IHZvaWQgMCkgeyBtaWNyb3Rhc2tJZCA9IC0xOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubmV3SG9zdEVsZW1lbnRzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5zLCBlbGVtZW50KSB7IHJldHVybiBfdGhpcy5fYmFsYW5jZU5hbWVzcGFjZUxpc3QobnMsIGVsZW1lbnQpOyB9KTtcbiAgICAgICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICAodGhpcy50b3RhbFF1ZXVlZFBsYXllcnMgfHwgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsZWFudXBGbnMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGxheWVycyA9IHRoaXMuX2ZsdXNoQW5pbWF0aW9ucyhjbGVhbnVwRm5zLCBtaWNyb3Rhc2tJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgY2xlYW51cEZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwRm5zW2ldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGVhdmVOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxRdWV1ZWRQbGF5ZXJzID0gMDtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9mbHVzaEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgIHRoaXMuX2ZsdXNoRm5zID0gW107XG4gICAgICAgIGlmICh0aGlzLl93aGVuUXVpZXRGbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB3ZSBtb3ZlIHRoZXNlIG92ZXIgdG8gYSB2YXJpYWJsZSBzbyB0aGF0XG4gICAgICAgICAgICAvLyBpZiBhbnkgbmV3IGNhbGxiYWNrcyBhcmUgcmVnaXN0ZXJlZCBpbiBhbm90aGVyXG4gICAgICAgICAgICAvLyBmbHVzaCB0aGV5IGRvIG5vdCBwb3B1bGF0ZSB0aGUgZXhpc3Rpbmcgc2V0XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWlldEZuc18xID0gdGhpcy5fd2hlblF1aWV0Rm5zO1xuICAgICAgICAgICAgdGhpcy5fd2hlblF1aWV0Rm5zID0gW107XG4gICAgICAgICAgICBpZiAocGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHF1aWV0Rm5zXzEuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1aWV0Rm5zXzEuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNsZWFudXBGbnNcbiAgICAgKiBAcGFyYW0gez99IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fZmx1c2hBbmltYXRpb25zID0gZnVuY3Rpb24gKGNsZWFudXBGbnMsIG1pY3JvdGFza0lkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YlRpbWVsaW5lcyA9IG5ldyBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2tpcHBlZFBsYXllcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2tpcHBlZFBsYXllcnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXVlZEluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkRWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFByZVN0eWxlRWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFBvc3RTdHlsZUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXNhYmxlZEVsZW1lbnRzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRpc2FibGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXNUaGF0QXJlRGlzYWJsZWQgPSBfdGhpcy5kcml2ZXIucXVlcnkobm9kZSwgUVVFVUVEX1NFTEVDVE9SLCB0cnVlKTtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBub2Rlc1RoYXRBcmVEaXNhYmxlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkRWxlbWVudHNTZXQuYWRkKG5vZGVzVGhhdEFyZURpc2FibGVkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvZHlOb2RlID0gZ2V0Qm9keU5vZGUoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsRW50ZXJOb2RlcyA9IHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cy5sZW5ndGggP1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzLmZpbHRlcihjcmVhdGVJc1Jvb3RGaWx0ZXJGbih0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMpKSA6XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgLy8gdGhpcyBtdXN0IG9jY3VyIGJlZm9yZSB0aGUgaW5zdHJ1Y3Rpb25zIGFyZSBidWlsdCBiZWxvdyBzdWNoIHRoYXRcbiAgICAgICAgLy8gdGhlIDplbnRlciBxdWVyaWVzIG1hdGNoIHRoZSBlbGVtZW50cyAoc2luY2UgdGhlIHRpbWVsaW5lIHF1ZXJpZXNcbiAgICAgICAgLy8gYXJlIGZpcmVkIGR1cmluZyBpbnN0cnVjdGlvbiBidWlsZGluZykuXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhbGxFbnRlck5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhhbGxFbnRlck5vZGVzW2ldLCBFTlRFUl9DTEFTU05BTUUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbExlYXZlTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVhdmVOb2Rlc1dpdGhvdXRBbmltYXRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLnNldEZvclJlbW92YWwpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBMRUFWRV9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIGFsbExlYXZlTm9kZXMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWRldGFpbHMuaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGVhbnVwRm5zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWxsRW50ZXJOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBFTlRFUl9DTEFTU05BTUUpOyB9KTtcbiAgICAgICAgICAgIGFsbExlYXZlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIExFQVZFX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvbmVvdXNUcmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLl9uYW1lc3BhY2VMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxpc3RbaV07XG4gICAgICAgICAgICBucy5kcmFpblF1ZXVlZFRyYW5zaXRpb25zKG1pY3JvdGFza0lkKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IGVudHJ5LnBsYXllcjtcbiAgICAgICAgICAgICAgICBhbGxQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gZW50cnkuZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIWJvZHlOb2RlIHx8ICFfdGhpcy5kcml2ZXIuY29udGFpbnNFbGVtZW50KGJvZHlOb2RlLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9uID0gKChfdGhpcy5fYnVpbGRJbnN0cnVjdGlvbihlbnRyeSwgc3ViVGltZWxpbmVzKSkpO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5lcnJvcnMgJiYgaW5zdHJ1Y3Rpb24uZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvbmVvdXNUcmFuc2l0aW9ucy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBhIHVubWF0Y2hlZCB0cmFuc2l0aW9uIGlzIHF1ZXVlZCB0byBnbyB0aGVuIGl0IFNIT1VMRCBOT1QgcmVuZGVyXG4gICAgICAgICAgICAgICAgLy8gYW4gYW5pbWF0aW9uIGFuZCBjYW5jZWwgdGhlIHByZXZpb3VzbHkgcnVubmluZyBhbmltYXRpb25zLlxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZhbGxiYWNrVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIub25TdGFydChmdW5jdGlvbiAoKSB7IHJldHVybiBlcmFzZVN0eWxlcyhlbGVtZW50LCBpbnN0cnVjdGlvbi5mcm9tU3R5bGVzKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0U3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWRQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgaWYgYSBwYXJlbnQgYW5pbWF0aW9uIHVzZXMgdGhpcyBhbmltYXRpb24gYXMgYSBzdWIgdHJpZ2dlclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaXQgd2lsbCBpbnN0cnVjdCB0aGUgdGltZWxpbmUgYnVpbGRlciB0byBub3QgYWRkIGEgcGxheWVyIGRlbGF5LCBidXRcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIHN0cmV0Y2ggdGhlIGZpcnN0IGtleWZyYW1lIGdhcCB1cCB1bnRpbCB0aGUgYW5pbWF0aW9uIHN0YXJ0cy4gVGhlXG4gICAgICAgICAgICAgICAgLy8gcmVhc29uIHRoaXMgaXMgaW1wb3J0YW50IGlzIHRvIHByZXZlbnQgZXh0cmEgaW5pdGlhbGl6YXRpb24gc3R5bGVzIGZyb20gYmVpbmdcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCBieSB0aGUgdXNlciBpbiB0aGUgYW5pbWF0aW9uLlxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnRpbWVsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uICh0bCkgeyByZXR1cm4gdGwuc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgICAgICBzdWJUaW1lbGluZXMuYXBwZW5kKGVsZW1lbnQsIGluc3RydWN0aW9uLnRpbWVsaW5lcyk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHVwbGUgPSB7IGluc3RydWN0aW9uOiBpbnN0cnVjdGlvbiwgcGxheWVyOiBwbGF5ZXIsIGVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICAgICAgICAgICAgICBxdWV1ZWRJbnN0cnVjdGlvbnMucHVzaCh0dXBsZSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucXVlcmllZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGdldE9yU2V0QXNJbk1hcChxdWVyaWVkRWxlbWVudHMsIGVsZW1lbnQsIFtdKS5wdXNoKHBsYXllcik7IH0pO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnByZVN0eWxlUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RyaW5nTWFwLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BzID0gT2JqZWN0LmtleXMoc3RyaW5nTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2V0VmFsXzEgPSAoKGFsbFByZVN0eWxlRWxlbWVudHMuZ2V0KGVsZW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldFZhbF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsUHJlU3R5bGVFbGVtZW50cy5zZXQoZWxlbWVudCwgc2V0VmFsXzEgPSBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gc2V0VmFsXzEuYWRkKHByb3ApOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnBvc3RTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHN0cmluZ01hcCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wcyA9IE9iamVjdC5rZXlzKHN0cmluZ01hcCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNldFZhbCA9ICgoYWxsUG9zdFN0eWxlRWxlbWVudHMuZ2V0KGVsZW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxQb3N0U3R5bGVFbGVtZW50cy5zZXQoZWxlbWVudCwgc2V0VmFsID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBzZXRWYWwuYWRkKHByb3ApOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvbmVvdXNUcmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1zZ18xID0gXCJVbmFibGUgdG8gcHJvY2VzcyBhbmltYXRpb25zIGR1ZSB0byB0aGUgZm9sbG93aW5nIGZhaWxlZCB0cmlnZ2VyIHRyYW5zaXRpb25zXFxuXCI7XG4gICAgICAgICAgICBlcnJvbmVvdXNUcmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIG1zZ18xICs9IFwiQFwiICsgaW5zdHJ1Y3Rpb24udHJpZ2dlck5hbWUgKyBcIiBoYXMgZmFpbGVkIGR1ZSB0bzpcXG5cIjsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICgoaW5zdHJ1Y3Rpb24uZXJyb3JzKSkuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHsgbXNnXzEgKz0gXCItIFwiICsgZXJyb3IgKyBcIlxcblwiOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWxsUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ18xKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBjYW4gb25seSBiZSBkZXRlY3RlZCBoZXJlIHNpbmNlIHdlIGhhdmUgYSBtYXAgb2YgYWxsIHRoZSBlbGVtZW50c1xuICAgICAgICAvLyB0aGF0IGhhdmUgYW5pbWF0aW9ucyBhdHRhY2hlZCB0byB0aGVtLi4uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudGVyTm9kZXNXaXRob3V0QW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYWxsRW50ZXJOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGFsbEVudGVyTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIXN1YlRpbWVsaW5lcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBlbnRlck5vZGVzV2l0aG91dEFuaW1hdGlvbnMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxQcmV2aW91c1BsYXllcnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvcnRlZFBhcmVudEVsZW1lbnRzID0gW107XG4gICAgICAgIHF1ZXVlZEluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc3ViVGltZWxpbmVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHNvcnRlZFBhcmVudEVsZW1lbnRzLnVuc2hpZnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2JlZm9yZUFuaW1hdGlvbkJ1aWxkKGVudHJ5LnBsYXllci5uYW1lc3BhY2VJZCwgZW50cnkuaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBza2lwcGVkUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBwbGF5ZXIuZWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzUGxheWVycyA9IF90aGlzLl9nZXRQcmV2aW91c1BsYXllcnMoZWxlbWVudCwgZmFsc2UsIHBsYXllci5uYW1lc3BhY2VJZCwgcGxheWVyLnRyaWdnZXJOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIHByZXZpb3VzUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2UGxheWVyKSB7IGdldE9yU2V0QXNJbk1hcChhbGxQcmV2aW91c1BsYXllcnNNYXAsIGVsZW1lbnQsIFtdKS5wdXNoKHByZXZQbGF5ZXIpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFsbFByZXZpb3VzUGxheWVyc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXJzKSB7IHJldHVybiBwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7IH0pO1xuICAgICAgICAvLyBQUkUgU1RBR0U6IGZpbGwgdGhlICEgc3R5bGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlc01hcCA9IGFsbFByZVN0eWxlRWxlbWVudHMuc2l6ZSA/XG4gICAgICAgICAgICBjbG9ha0FuZENvbXB1dGVTdHlsZXModGhpcy5kcml2ZXIsIGVudGVyTm9kZXNXaXRob3V0QW5pbWF0aW9ucywgYWxsUHJlU3R5bGVFbGVtZW50cywgybVQUkVfU1RZTEUpIDpcbiAgICAgICAgICAgIG5ldyBNYXAoKTtcbiAgICAgICAgLy8gUE9TVCBTVEFHRTogZmlsbCB0aGUgKiBzdHlsZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFN0eWxlc01hcCA9IGNsb2FrQW5kQ29tcHV0ZVN0eWxlcyh0aGlzLmRyaXZlciwgbGVhdmVOb2Rlc1dpdGhvdXRBbmltYXRpb25zLCBhbGxQb3N0U3R5bGVFbGVtZW50cywgQVVUT19TVFlMRSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RQbGF5ZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YlBsYXllcnMgPSBbXTtcbiAgICAgICAgcXVldWVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQsIHBsYXllciA9IGVudHJ5LnBsYXllciwgaW5zdHJ1Y3Rpb24gPSBlbnRyeS5pbnN0cnVjdGlvbjtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBpdCB3YXMgbmV2ZXIgY29uc3VtZWQgYnkgYSBwYXJlbnQgYW5pbWF0aW9uIHdoaWNoXG4gICAgICAgICAgICAvLyBtZWFucyB0aGF0IGl0IGlzIGluZGVwZW5kZW50IGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHNldCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAoc3ViVGltZWxpbmVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZEVsZW1lbnRzU2V0LmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJQbGF5ZXIgPSBfdGhpcy5fYnVpbGRBbmltYXRpb24ocGxheWVyLm5hbWVzcGFjZUlkLCBpbnN0cnVjdGlvbiwgYWxsUHJldmlvdXNQbGF5ZXJzTWFwLCBza2lwcGVkUGxheWVyc01hcCwgcHJlU3R5bGVzTWFwLCBwb3N0U3R5bGVzTWFwKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2V0UmVhbFBsYXllcihpbm5lclBsYXllcik7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50SGFzUHJpb3JpdHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzb3J0ZWRQYXJlbnRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSBzb3J0ZWRQYXJlbnRFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHJpdmVyLmNvbnRhaW5zRWxlbWVudChwYXJlbnQsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRIYXNQcmlvcml0eSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRIYXNQcmlvcml0eSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRQbGF5ZXJzID0gX3RoaXMucGxheWVyc0J5RWxlbWVudC5nZXQocGFyZW50SGFzUHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50UGxheWVycyAmJiBwYXJlbnRQbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyLnBhcmVudFBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIocGFyZW50UGxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyYXNlU3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLmZyb21TdHlsZXMpO1xuICAgICAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0U3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTsgfSk7XG4gICAgICAgICAgICAgICAgc3ViUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyc0ZvckVsZW1lbnQgPSBza2lwcGVkUGxheWVyc01hcC5nZXQocGxheWVyLmVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBsYXllcnNGb3JFbGVtZW50ICYmIHBsYXllcnNGb3JFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyUGxheWVyID0gb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzRm9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFJlYWxQbGF5ZXIoaW5uZXJQbGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgYWN0dWFsbHkgcGxheSB0aGUgYW5pbWF0aW9uIGlzXG4gICAgICAgIC8vIGJlY2F1c2UgYWxsIHRoYXQgYSBza2lwcGVkIHBsYXllciBpcyBkZXNpZ25lZCB0byBkbyBpcyB0b1xuICAgICAgICAvLyBmaXJlIHRoZSBzdGFydC9kb25lIHRyYW5zaXRpb24gY2FsbGJhY2sgZXZlbnRzXG4gICAgICAgIHNraXBwZWRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgaWYgKHBsYXllci5wYXJlbnRQbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBydW4gdGhyb3VnaCBhbGwgb2YgdGhlIHF1ZXVlZCByZW1vdmFscyBhbmQgc2VlIGlmIHRoZXlcbiAgICAgICAgLy8gd2VyZSBwaWNrZWQgdXAgYnkgYSBxdWVyeS4gSWYgbm90IHRoZW4gcGVyZm9ybSB0aGUgcmVtb3ZhbFxuICAgICAgICAvLyBvcGVyYXRpb24gcmlnaHQgYXdheSB1bmxlc3MgYSBwYXJlbnQgYW5pbWF0aW9uIGlzIG9uZ29pbmcuXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhbGxMZWF2ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gYWxsTGVhdmVOb2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSAoZWxlbWVudFtSRU1PVkFMX0ZMQUddKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIExFQVZFX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoZSBlbGVtZW50IGhhcyBhIHJlbW92YWwgYW5pbWF0aW9uIHRoYXQgaXMgYmVpbmdcbiAgICAgICAgICAgIC8vIHRha2VuIGNhcmUgb2YgYW5kIHRoZXJlZm9yZSB0aGUgaW5uZXIgZWxlbWVudHMgd2lsbCBoYW5nIGFyb3VuZFxuICAgICAgICAgICAgLy8gdW50aWwgdGhhdCBhbmltYXRpb24gaXMgb3ZlciAob3IgdGhlIHBhcmVudCBxdWVyaWVkIGFuaW1hdGlvbilcbiAgICAgICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuaGFzQW5pbWF0aW9uKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IFtdO1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBlbGVtZW50IGlzIHF1ZXJpZWQgb3IgaWYgaXQgY29udGFpbnMgcXVlcmllZCBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhlbiB3ZSB3YW50IGZvciB0aGUgZWxlbWVudCBub3QgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyB1bnRpbCB0aGUgcXVlcmllZCBhbmltYXRpb25zIGhhdmUgZmluaXNoZWRcbiAgICAgICAgICAgIGlmIChxdWVyaWVkRWxlbWVudHMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRQbGF5ZXJSZXN1bHRzID0gcXVlcmllZEVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocXVlcmllZFBsYXllclJlc3VsdHMgJiYgcXVlcmllZFBsYXllclJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaC5hcHBseShwbGF5ZXJzLCBxdWVyaWVkUGxheWVyUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRJbm5lckVsZW1lbnRzID0gdGhpcy5kcml2ZXIucXVlcnkoZWxlbWVudCwgTkdfQU5JTUFUSU5HX1NFTEVDVE9SLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGogPSAwOyBqIDwgcXVlcmllZElubmVyRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZFBsYXllcnMgPSBxdWVyaWVkRWxlbWVudHMuZ2V0KHF1ZXJpZWRJbm5lckVsZW1lbnRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJpZWRQbGF5ZXJzICYmIHF1ZXJpZWRQbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoLmFwcGx5KHBsYXllcnMsIHF1ZXJpZWRQbGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVzQWZ0ZXJBbmltYXRpb25Eb25lKHRoaXMsIGVsZW1lbnQsIHBsYXllcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGVhdmVOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgc28gdGhlIGNsZWFudXAgbWV0aG9kIGRvZXNuJ3QgcmVtb3ZlIHRoZW1cbiAgICAgICAgYWxsTGVhdmVOb2Rlcy5sZW5ndGggPSAwO1xuICAgICAgICByb290UGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLnBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IF90aGlzLnBsYXllcnMuaW5kZXhPZihwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByb290UGxheWVycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmVsZW1lbnRDb250YWluc0RhdGEgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNEYXRhID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSAoZWxlbWVudFtSRU1PVkFMX0ZMQUddKTtcbiAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JSZW1vdmFsKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucGxheWVyc0J5RWxlbWVudC5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICBjb250YWluc0RhdGEgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICBjb250YWluc0RhdGEgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZXNCeUVsZW1lbnQuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKS5lbGVtZW50Q29udGFpbnNEYXRhKGVsZW1lbnQpIHx8IGNvbnRhaW5zRGF0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmFmdGVyRmx1c2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5fZmx1c2hGbnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuYWZ0ZXJGbHVzaEFuaW1hdGlvbnNEb25lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX3doZW5RdWlldEZucy5wdXNoKGNhbGxiYWNrKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGlzUXVlcmllZEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7Pz19IHRyaWdnZXJOYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdG9TdGF0ZVZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fZ2V0UHJldmlvdXNQbGF5ZXJzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGlzUXVlcmllZEVsZW1lbnQsIG5hbWVzcGFjZUlkLCB0cmlnZ2VyTmFtZSwgdG9TdGF0ZVZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKGlzUXVlcmllZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50UGxheWVycyA9IHRoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHF1ZXJpZWRFbGVtZW50UGxheWVycykge1xuICAgICAgICAgICAgICAgIHBsYXllcnMgPSBxdWVyaWVkRWxlbWVudFBsYXllcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50UGxheWVycyA9IHRoaXMucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1JlbW92YWxBbmltYXRpb25fMSA9ICF0b1N0YXRlVmFsdWUgfHwgdG9TdGF0ZVZhbHVlID09IFZPSURfVkFMVUU7XG4gICAgICAgICAgICAgICAgZWxlbWVudFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucXVldWVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVtb3ZhbEFuaW1hdGlvbl8xICYmIHBsYXllci50cmlnZ2VyTmFtZSAhPSB0cmlnZ2VyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzcGFjZUlkIHx8IHRyaWdnZXJOYW1lKSB7XG4gICAgICAgICAgICBwbGF5ZXJzID0gcGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VJZCAmJiBuYW1lc3BhY2VJZCAhPSBwbGF5ZXIubmFtZXNwYWNlSWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck5hbWUgJiYgdHJpZ2dlck5hbWUgIT0gcGxheWVyLnRyaWdnZXJOYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxheWVycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBhbGxQcmV2aW91c1BsYXllcnNNYXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9iZWZvcmVBbmltYXRpb25CdWlsZCA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBpdCdzIGltcG9ydGFudCB0byBkbyB0aGlzIHN0ZXAgYmVmb3JlIGRlc3Ryb3lpbmcgdGhlIHBsYXllcnNcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgb25Eb25lIGNhbGxiYWNrIGJlbG93IHdvbid0IGZpcmUgYmVmb3JlIHRoaXNcbiAgICAgICAgZXJhc2VTdHlsZXMoaW5zdHJ1Y3Rpb24uZWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJOYW1lID0gaW5zdHJ1Y3Rpb24udHJpZ2dlck5hbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RFbGVtZW50ID0gaW5zdHJ1Y3Rpb24uZWxlbWVudDtcbiAgICAgICAgLy8gd2hlbiBhIHJlbW92YWwgYW5pbWF0aW9uIG9jY3VycywgQUxMIHByZXZpb3VzIHBsYXllcnMgYXJlIGNvbGxlY3RlZFxuICAgICAgICAvLyBhbmQgZGVzdHJveWVkIChldmVuIGlmIHRoZXkgYXJlIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgbmFtZXNwYWNlKVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXROYW1lU3BhY2VJZCA9IGluc3RydWN0aW9uLmlzUmVtb3ZhbFRyYW5zaXRpb24gPyB1bmRlZmluZWQgOiBuYW1lc3BhY2VJZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFyZ2V0VHJpZ2dlck5hbWUgPSBpbnN0cnVjdGlvbi5pc1JlbW92YWxUcmFuc2l0aW9uID8gdW5kZWZpbmVkIDogdHJpZ2dlck5hbWU7XG4gICAgICAgIGluc3RydWN0aW9uLnRpbWVsaW5lcy5tYXAoZnVuY3Rpb24gKHRpbWVsaW5lSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSB0aW1lbGluZUluc3RydWN0aW9uLmVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1F1ZXJpZWRFbGVtZW50ID0gZWxlbWVudCAhPT0gcm9vdEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gZ2V0T3JTZXRBc0luTWFwKGFsbFByZXZpb3VzUGxheWVyc01hcCwgZWxlbWVudCwgW10pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNQbGF5ZXJzID0gX3RoaXMuX2dldFByZXZpb3VzUGxheWVycyhlbGVtZW50LCBpc1F1ZXJpZWRFbGVtZW50LCB0YXJnZXROYW1lU3BhY2VJZCwgdGFyZ2V0VHJpZ2dlck5hbWUsIGluc3RydWN0aW9uLnRvU3RhdGUpO1xuICAgICAgICAgICAgcHJldmlvdXNQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlYWxQbGF5ZXIgPSAocGxheWVyLmdldFJlYWxQbGF5ZXIoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWxQbGF5ZXIuYmVmb3JlRGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICByZWFsUGxheWVyLmJlZm9yZURlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gYWxsUHJldmlvdXNQbGF5ZXJzTWFwXG4gICAgICogQHBhcmFtIHs/fSBza2lwcGVkUGxheWVyc01hcFxuICAgICAqIEBwYXJhbSB7P30gcHJlU3R5bGVzTWFwXG4gICAgICogQHBhcmFtIHs/fSBwb3N0U3R5bGVzTWFwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYnVpbGRBbmltYXRpb24gPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGluc3RydWN0aW9uLCBhbGxQcmV2aW91c1BsYXllcnNNYXAsIHNraXBwZWRQbGF5ZXJzTWFwLCBwcmVTdHlsZXNNYXAsIHBvc3RTdHlsZXNNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlck5hbWUgPSBpbnN0cnVjdGlvbi50cmlnZ2VyTmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm9vdEVsZW1lbnQgPSBpbnN0cnVjdGlvbi5lbGVtZW50O1xuICAgICAgICAvLyB3ZSBmaXJzdCBydW4gdGhpcyBzbyB0aGF0IHRoZSBwcmV2aW91cyBhbmltYXRpb24gcGxheWVyXG4gICAgICAgIC8vIGRhdGEgY2FuIGJlIHBhc3NlZCBpbnRvIHRoZSBzdWNjZXNzaXZlIGFuaW1hdGlvbiBwbGF5ZXJzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFF1ZXJpZWRQbGF5ZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbENvbnN1bWVkRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFN1YkVsZW1lbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxOZXdQbGF5ZXJzID0gaW5zdHJ1Y3Rpb24udGltZWxpbmVzLm1hcChmdW5jdGlvbiAodGltZWxpbmVJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRpbWVsaW5lSW5zdHJ1Y3Rpb24uZWxlbWVudDtcbiAgICAgICAgICAgIGFsbENvbnN1bWVkRWxlbWVudHMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gRklYTUUgKG1hdHNrbyk6IG1ha2Ugc3VyZSB0by1iZS1yZW1vdmVkIGFuaW1hdGlvbnMgYXJlIHJlbW92ZWQgcHJvcGVybHlcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSBlbGVtZW50W1JFTU9WQUxfRkxBR107XG4gICAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLnJlbW92ZWRCZWZvcmVRdWVyaWVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNRdWVyaWVkRWxlbWVudCA9IGVsZW1lbnQgIT09IHJvb3RFbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNQbGF5ZXJzID0gZmxhdHRlbkdyb3VwUGxheWVycygoYWxsUHJldmlvdXNQbGF5ZXJzTWFwLmdldChlbGVtZW50KSB8fCBFTVBUWV9QTEFZRVJfQVJSQVkpLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5nZXRSZWFsUGxheWVyKCk7IH0pKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlcyA9IHByZVN0eWxlc01hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0U3R5bGVzID0gcG9zdFN0eWxlc01hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBub3JtYWxpemVLZXlmcmFtZXMoX3RoaXMuZHJpdmVyLCBfdGhpcy5fbm9ybWFsaXplciwgZWxlbWVudCwgdGltZWxpbmVJbnN0cnVjdGlvbi5rZXlmcmFtZXMsIHByZVN0eWxlcywgcG9zdFN0eWxlcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBfdGhpcy5fYnVpbGRQbGF5ZXIodGltZWxpbmVJbnN0cnVjdGlvbiwga2V5ZnJhbWVzLCBwcmV2aW91c1BsYXllcnMpO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoaXMgcGFydGljdWxhciBwbGF5ZXIgYmVsb25ncyB0byBhIHN1YiB0cmlnZ2VyLiBJdCBpc1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50IHRoYXQgd2UgbWF0Y2ggdGhpcyBwbGF5ZXIgdXAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyAoQHRyaWdnZXIubGlzdGVuZXIpXG4gICAgICAgICAgICBpZiAodGltZWxpbmVJbnN0cnVjdGlvbi5zdWJUaW1lbGluZSAmJiBza2lwcGVkUGxheWVyc01hcCkge1xuICAgICAgICAgICAgICAgIGFsbFN1YkVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJpZWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3JhcHBlZFBsYXllciA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyKG5hbWVzcGFjZUlkLCB0cmlnZ2VyTmFtZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZFBsYXllci5zZXRSZWFsUGxheWVyKHBsYXllcik7XG4gICAgICAgICAgICAgICAgYWxsUXVlcmllZFBsYXllcnMucHVzaCh3cmFwcGVkUGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxRdWVyaWVkUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIGdldE9yU2V0QXNJbk1hcChfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCwgcGxheWVyLmVsZW1lbnQsIFtdKS5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZU9yVW5zZXRJbk1hcChfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCwgcGxheWVyLmVsZW1lbnQsIHBsYXllcik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBhZGRDbGFzcyhlbGVtZW50LCBOR19BTklNQVRJTkdfQ0xBU1NOQU1FKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIoYWxsTmV3UGxheWVycyk7XG4gICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBOR19BTklNQVRJTkdfQ0xBU1NOQU1FKTsgfSk7XG4gICAgICAgICAgICBzZXRTdHlsZXMocm9vdEVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgYmFzaWNhbGx5IG1ha2VzIGFsbCBvZiB0aGUgY2FsbGJhY2tzIGZvciBzdWIgZWxlbWVudCBhbmltYXRpb25zXG4gICAgICAgIC8vIGJlIGRlcGVuZGVudCBvbiB0aGUgdXBwZXIgcGxheWVycyBmb3Igd2hlbiB0aGV5IGZpbmlzaFxuICAgICAgICBhbGxTdWJFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IGdldE9yU2V0QXNJbk1hcChza2lwcGVkUGxheWVyc01hcCwgZWxlbWVudCwgW10pLnB1c2gocGxheWVyKTsgfSk7XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IHByZXZpb3VzUGxheWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2J1aWxkUGxheWVyID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCBrZXlmcmFtZXMsIHByZXZpb3VzUGxheWVycykge1xuICAgICAgICBpZiAoa2V5ZnJhbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyaXZlci5hbmltYXRlKGluc3RydWN0aW9uLmVsZW1lbnQsIGtleWZyYW1lcywgaW5zdHJ1Y3Rpb24uZHVyYXRpb24sIGluc3RydWN0aW9uLmRlbGF5LCBpbnN0cnVjdGlvbi5lYXNpbmcsIHByZXZpb3VzUGxheWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB3aGVuIGFuIGVtcHR5IHRyYW5zaXRpb258ZGVmaW5pdGlvbiBpcyBwcm92aWRlZFxuICAgICAgICAvLyAuLi4gdGhlcmUgaXMgbm8gcG9pbnQgaW4gcmVuZGVyaW5nIGFuIGVtcHR5IGFuaW1hdGlvblxuICAgICAgICByZXR1cm4gbmV3IE5vb3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lO1xufSgpKTtcbnZhciBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSB0cmlnZ2VyTmFtZVxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIobmFtZXNwYWNlSWQsIHRyaWdnZXJOYW1lLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlSWQgPSBuYW1lc3BhY2VJZDtcbiAgICAgICAgdGhpcy50cmlnZ2VyTmFtZSA9IHRyaWdnZXJOYW1lO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9wbGF5ZXIgPSBuZXcgTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICB0aGlzLl9jb250YWluc1JlYWxQbGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcXVldWVkQ2FsbGJhY2tzID0ge307XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hcmtlZEZvckRlc3Ryb3kgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLCBcInF1ZXVlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250YWluc1JlYWxQbGF5ZXIgPT0gZmFsc2U7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVzdHJveWVkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBsYXllclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuc2V0UmVhbFBsYXllciA9IGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5zUmVhbFBsYXllcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcGxheWVyID0gcGxheWVyO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9xdWV1ZWRDYWxsYmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHBoYXNlKSB7XG4gICAgICAgICAgICBfdGhpcy5fcXVldWVkQ2FsbGJhY2tzW3BoYXNlXS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gbGlzdGVuT25QbGF5ZXIocGxheWVyLCBwaGFzZSwgdW5kZWZpbmVkLCBjYWxsYmFjayk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcXVldWVkQ2FsbGJhY2tzID0ge307XG4gICAgICAgIHRoaXMuX2NvbnRhaW5zUmVhbFBsYXllciA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmdldFJlYWxQbGF5ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGF5ZXI7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuX3F1ZXVlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgZ2V0T3JTZXRBc0luTWFwKHRoaXMuX3F1ZXVlZENhbGxiYWNrcywgbmFtZSwgW10pLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVFdmVudCgnZG9uZScsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIub25Eb25lKGZuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZUV2ZW50KCdzdGFydCcsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIub25TdGFydChmbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZUV2ZW50KCdkZXN0cm95JywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXllci5vbkRlc3Ryb3koZm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXIuaW5pdCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucXVldWVkID8gZmFsc2UgOiB0aGlzLl9wbGF5ZXIuaGFzU3RhcnRlZCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHsgIXRoaXMucXVldWVkICYmIHRoaXMuX3BsYXllci5wbGF5KCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgIXRoaXMucXVldWVkICYmIHRoaXMuX3BsYXllci5wYXVzZSgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHsgIXRoaXMucXVldWVkICYmIHRoaXMuX3BsYXllci5yZXN0YXJ0KCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllci5maW5pc2goKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BsYXllci5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyAhdGhpcy5xdWV1ZWQgJiYgdGhpcy5fcGxheWVyLnJlc2V0KCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmICghdGhpcy5xdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5zZXRQb3NpdGlvbihwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucXVldWVkID8gMCA6IHRoaXMuX3BsYXllci5nZXRQb3NpdGlvbigpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJ0b3RhbFRpbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyLnRvdGFsVGltZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1hcFxuICogQHBhcmFtIHs/fSBrZXlcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZU9yVW5zZXRJbk1hcChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50VmFsdWVzO1xuICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY3VycmVudFZhbHVlcyA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gY3VycmVudFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIG1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3VycmVudFZhbHVlcyA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBjdXJyZW50VmFsdWVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VmFsdWVzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUcmlnZ2VyVmFsdWUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICcxJyA6ICcwJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUudG9TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGVbJ25vZGVUeXBlJ10gPT09IDE7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1RyaWdnZXJFdmVudFZhbGlkKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBldmVudE5hbWUgPT0gJ3N0YXJ0JyB8fCBldmVudE5hbWUgPT0gJ2RvbmUnO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjbG9ha0VsZW1lbnQoZWxlbWVudCwgdmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRWYWx1ZSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiAnbm9uZSc7XG4gICAgcmV0dXJuIG9sZFZhbHVlO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGRyaXZlclxuICogQHBhcmFtIHs/fSBlbGVtZW50c1xuICogQHBhcmFtIHs/fSBlbGVtZW50UHJvcHNNYXBcbiAqIEBwYXJhbSB7P30gZGVmYXVsdFN0eWxlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjbG9ha0FuZENvbXB1dGVTdHlsZXMoZHJpdmVyLCBlbGVtZW50cywgZWxlbWVudFByb3BzTWFwLCBkZWZhdWx0U3R5bGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9ha1ZhbHMgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGNsb2FrRWxlbWVudChlbGVtZW50KTsgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgIGVsZW1lbnRQcm9wc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcywgZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7fTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBzdHlsZXNbcHJvcF0gPSBkcml2ZXIuY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3AsIGRlZmF1bHRTdHlsZSk7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBlYXN5IHdheSB0byBkZXRlY3QgdGhpcyBiZWNhdXNlIGEgc3ViIGVsZW1lbnQgY291bGQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgLy8gYnkgYSBwYXJlbnQgYW5pbWF0aW9uIGVsZW1lbnQgYmVpbmcgZGV0YWNoZWQuXG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0gTlVMTF9SRU1PVkVEX1FVRVJJRURfU1RBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZXNNYXAuc2V0KGVsZW1lbnQsIHN0eWxlcyk7XG4gICAgfSk7XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaSkgeyByZXR1cm4gY2xvYWtFbGVtZW50KGVsZW1lbnQsIGNsb2FrVmFsc1tpXSk7IH0pO1xuICAgIHJldHVybiB2YWx1ZXNNYXA7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlzUm9vdEZpbHRlckZuKG5vZGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZVNldCA9IG5ldyBTZXQobm9kZXMpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGtub3duUm9vdENvbnRhaW5lciA9IG5ldyBTZXQoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Jvb3Q7XG4gICAgaXNSb290ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChub2RlU2V0Lmhhcyhub2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoa25vd25Sb290Q29udGFpbmVyLmhhcyhub2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChpc1Jvb3Qobm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAga25vd25Sb290Q29udGFpbmVyLmFkZChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBpc1Jvb3Q7XG59XG52YXIgQ0xBU1NFU19DQUNIRV9LRVkgPSAnJCRjbGFzc2VzJztcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc2VzID0gZWxlbWVudFtDTEFTU0VTX0NBQ0hFX0tFWV07XG4gICAgICAgIHJldHVybiBjbGFzc2VzICYmIGNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzZXMgPSBlbGVtZW50W0NMQVNTRVNfQ0FDSEVfS0VZXTtcbiAgICAgICAgaWYgKCFjbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc2VzID0gZWxlbWVudFtDTEFTU0VTX0NBQ0hFX0tFWV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NlcyA9IGVsZW1lbnRbQ0xBU1NFU19DQUNIRV9LRVldO1xuICAgICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgZGVsZXRlIGNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0Qm9keU5vZGUoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZW5naW5lXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gcGxheWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTm9kZXNBZnRlckFuaW1hdGlvbkRvbmUoZW5naW5lLCBlbGVtZW50LCBwbGF5ZXJzKSB7XG4gICAgb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzKS5vbkRvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5naW5lLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7IH0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBsYXllcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5Hcm91cFBsYXllcnMocGxheWVycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbmFsUGxheWVycyA9IFtdO1xuICAgIF9mbGF0dGVuR3JvdXBQbGF5ZXJzUmVjdXIocGxheWVycywgZmluYWxQbGF5ZXJzKTtcbiAgICByZXR1cm4gZmluYWxQbGF5ZXJzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBsYXllcnNcbiAqIEBwYXJhbSB7P30gZmluYWxQbGF5ZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZmxhdHRlbkdyb3VwUGxheWVyc1JlY3VyKHBsYXllcnMsIGZpbmFsUGxheWVycykge1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBwbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IHBsYXllcnNbaV07XG4gICAgICAgIGlmIChwbGF5ZXIgaW5zdGFuY2VvZiDJtUFuaW1hdGlvbkdyb3VwUGxheWVyKSB7XG4gICAgICAgICAgICBfZmxhdHRlbkdyb3VwUGxheWVyc1JlY3VyKHBsYXllci5wbGF5ZXJzLCBmaW5hbFBsYXllcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmluYWxQbGF5ZXJzLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAocGxheWVyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQW5pbWF0aW9uRW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRyaXZlclxuICAgICAqIEBwYXJhbSB7P30gbm9ybWFsaXplclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVuZ2luZShkcml2ZXIsIG5vcm1hbGl6ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNhY2hlID0ge307XG4gICAgICAgIHRoaXMub25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyB9O1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lID0gbmV3IFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUoZHJpdmVyLCBub3JtYWxpemVyKTtcbiAgICAgICAgdGhpcy5fdGltZWxpbmVFbmdpbmUgPSBuZXcgVGltZWxpbmVBbmltYXRpb25FbmdpbmUoZHJpdmVyLCBub3JtYWxpemVyKTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5vblJlbW92YWxDb21wbGV0ZSA9XG4gICAgICAgICAgICBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyBfdGhpcy5vblJlbW92YWxDb21wbGV0ZShlbGVtZW50LCBjb250ZXh0KTsgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlclRyaWdnZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50SWQsIG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCwgbmFtZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FjaGVLZXkgPSBjb21wb25lbnRJZCArICctJyArIG5hbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyQ2FjaGVbY2FjaGVLZXldO1xuICAgICAgICBpZiAoIXRyaWdnZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gKGJ1aWxkQW5pbWF0aW9uQXN0KC8qKiBAdHlwZSB7P30gKi8gKG1ldGFkYXRhKSwgZXJyb3JzKSk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGhhcyBmYWlsZWQgdG8gYnVpbGQgZHVlIHRvIHRoZSBmb2xsb3dpbmcgZXJyb3JzOlxcbiAtIFwiICsgZXJyb3JzLmpvaW4oXCJcXG4gLSBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlciA9IGJ1aWxkVHJpZ2dlcihuYW1lLCBhc3QpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNhY2hlW2NhY2hlS2V5XSA9IHRyaWdnZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5yZWdpc3RlclRyaWdnZXIobmFtZXNwYWNlSWQsIG5hbWUsIHRyaWdnZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUucmVnaXN0ZXIobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmRlc3Ryb3kobmFtZXNwYWNlSWQsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnNlcnRCZWZvcmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUub25JbnNlcnQgPSBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIHBhcmVudCwgaW5zZXJ0QmVmb3JlKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUuaW5zZXJ0Tm9kZShuYW1lc3BhY2VJZCwgZWxlbWVudCwgcGFyZW50LCBpbnNlcnRCZWZvcmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlbW92ZU5vZGUobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBkaXNhYmxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmRpc2FibGVBbmltYXRpb25zID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRpc2FibGUpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZGlzYWJsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eS5jaGFyQXQoMCkgPT0gJ0AnKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXJzZVRpbWVsaW5lQ29tbWFuZChwcm9wZXJ0eSksIGlkID0gX2FbMF0sIGFjdGlvbiA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9ICh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZUVuZ2luZS5jb21tYW5kKGlkLCBlbGVtZW50LCBhY3Rpb24sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS50cmlnZ2VyKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50UGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBAQGxpc3RlblxuICAgICAgICBpZiAoZXZlbnROYW1lLmNoYXJBdCgwKSA9PSAnQCcpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHBhcnNlVGltZWxpbmVDb21tYW5kKGV2ZW50TmFtZSksIGlkID0gX2FbMF0sIGFjdGlvbiA9IF9hWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lRW5naW5lLmxpc3RlbihpZCwgZWxlbWVudCwgYWN0aW9uLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUubGlzdGVuKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBldmVudE5hbWUsIGV2ZW50UGhhc2UsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKG1pY3JvdGFza0lkKSB7XG4gICAgICAgIGlmIChtaWNyb3Rhc2tJZCA9PT0gdm9pZCAwKSB7IG1pY3JvdGFza0lkID0gLTE7IH1cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5mbHVzaChtaWNyb3Rhc2tJZCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZSwgXCJwbGF5ZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoKHRoaXMuX3RyYW5zaXRpb25FbmdpbmUucGxheWVycykpXG4gICAgICAgICAgICAgICAgLmNvbmNhdCgvKiogQHR5cGUgez99ICovICh0aGlzLl90aW1lbGluZUVuZ2luZS5wbGF5ZXJzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS53aGVuUmVuZGVyaW5nRG9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUud2hlblJlbmRlcmluZ0RvbmUoKTsgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRW5naW5lO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBXZWJBbmltYXRpb25zUGxheWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHByZXZpb3VzUGxheWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYkFuaW1hdGlvbnNQbGF5ZXIoZWxlbWVudCwga2V5ZnJhbWVzLCBvcHRpb25zLCBwcmV2aW91c1BsYXllcnMpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzUGxheWVycyA9PT0gdm9pZCAwKSB7IHByZXZpb3VzUGxheWVycyA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnByZXZpb3VzUGxheWVycyA9IHByZXZpb3VzUGxheWVycztcbiAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Rm5zID0gW107XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGltZSA9IDA7XG4gICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91c1N0eWxlcyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRTbmFwc2hvdCA9IHt9O1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IG9wdGlvbnNbJ2R1cmF0aW9uJ107XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gb3B0aW9uc1snZGVsYXknXSB8fCAwO1xuICAgICAgICB0aGlzLnRpbWUgPSB0aGlzLl9kdXJhdGlvbiArIHRoaXMuX2RlbGF5O1xuICAgICAgICBpZiAoYWxsb3dQcmV2aW91c1BsYXllclN0eWxlc01lcmdlKHRoaXMuX2R1cmF0aW9uLCB0aGlzLl9kZWxheSkpIHtcbiAgICAgICAgICAgIHByZXZpb3VzUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gcGxheWVyLmN1cnJlbnRTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIF90aGlzLnByZXZpb3VzU3R5bGVzW3Byb3BdID0gc3R5bGVzW3Byb3BdOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYnVpbGRQbGF5ZXIoKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZVBsYXllckJlZm9yZVN0YXJ0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLl9idWlsZFBsYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoc3R5bGVzKSB7IHJldHVybiBjb3B5U3R5bGVzKHN0eWxlcywgZmFsc2UpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNTdHlsZVByb3BzID0gT2JqZWN0LmtleXModGhpcy5wcmV2aW91c1N0eWxlcyk7XG4gICAgICAgIGlmIChwcmV2aW91c1N0eWxlUHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydGluZ0tleWZyYW1lXzEgPSBrZXlmcmFtZXNbMF07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtaXNzaW5nU3R5bGVQcm9wc18xID0gW107XG4gICAgICAgICAgICBwcmV2aW91c1N0eWxlUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRpbmdLZXlmcmFtZV8xLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdTdHlsZVByb3BzXzEucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdLZXlmcmFtZV8xW3Byb3BdID0gX3RoaXMucHJldmlvdXNTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtaXNzaW5nU3R5bGVQcm9wc18xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGZfMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtmID0ga2V5ZnJhbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU3R5bGVQcm9wc18xLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtmW3Byb3BdID0gX2NvbXB1dGVTdHlsZShzZWxmXzEuZWxlbWVudCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMTsgaSA8IGtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXllciA9IHRoaXMuX3RyaWdnZXJXZWJBbmltYXRpb24odGhpcy5lbGVtZW50LCBrZXlmcmFtZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2ZpbmFsS2V5ZnJhbWUgPSBrZXlmcmFtZXMubGVuZ3RoID8ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXSA6IHt9O1xuICAgICAgICB0aGlzLl9wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZmluaXNoJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmluaXNoKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fcHJlcGFyZVBsYXllckJlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IHN0YXJ0IHRvIGFuaW1hdGUgcmlnaHQgYXdheVxuICAgICAgICBpZiAodGhpcy5fZGVsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RG9tUGxheWVyU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fdHJpZ2dlcldlYkFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8ganNjb21waWxlciBkb2Vzbid0IHNlZW0gdG8ga25vdyBhbmltYXRlIGlzIGEgbmF0aXZlIHByb3BlcnR5IGJlY2F1c2UgaXQncyBub3QgZnVsbHlcbiAgICAgICAgLy8gc3VwcG9ydGVkIHlldCBhY3Jvc3MgY29tbW9uIGJyb3dzZXJzICh3ZSBwb2x5ZmlsbCBpdCBmb3IgRWRnZS9TYWZhcmkpIFtDTCAjMTQzNjMwOTI5XVxuICAgICAgICByZXR1cm4gKGVsZW1lbnRbJ2FuaW1hdGUnXShrZXlmcmFtZXMsIG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZSwgXCJkb21QbGF5ZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uU3RhcnRGbnMucHVzaChmbik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25EZXN0cm95Rm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYnVpbGRQbGF5ZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIucGxheSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuX3BsYXllci5wYXVzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICB0aGlzLl9wbGF5ZXIuZmluaXNoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZXNldERvbVBsYXllclN0YXRlKCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLl9yZXNldERvbVBsYXllclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcGxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREb21QbGF5ZXJTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25EZXN0cm95Rm5zID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocCkgeyB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWUgPSBwICogdGhpcy50aW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWUgLyB0aGlzLnRpbWU7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLCBcInRvdGFsVGltZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWxheSArIHRoaXMuX2R1cmF0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmJlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2ZpbmFsS2V5ZnJhbWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNbcHJvcF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2ZpbmlzaGVkID8gX3RoaXMuX2ZpbmFsS2V5ZnJhbWVbcHJvcF0gOiBfY29tcHV0ZVN0eWxlKF90aGlzLmVsZW1lbnQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFNuYXBzaG90ID0gc3R5bGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNQbGF5ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gcHJvcFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wKSB7XG4gICAgcmV0dXJuICgod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkpKVtwcm9wXTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBXZWJBbmltYXRpb25zRHJpdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zRHJpdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5tYXRjaGVzRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbG0xXG4gICAgICogQHBhcmFtIHs/fSBlbG0yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5jb250YWluc0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxtMSwgZWxtMikgeyByZXR1cm4gY29udGFpbnNFbGVtZW50KGVsbTEsIGVsbTIpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IG11bHRpXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVF1ZXJ5KGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLmNvbXB1dGVTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgoKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKSlbcHJvcF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/PX0gcHJldmlvdXNQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIHByZXZpb3VzUGxheWVycykge1xuICAgICAgICBpZiAocHJldmlvdXNQbGF5ZXJzID09PSB2b2lkIDApIHsgcHJldmlvdXNQbGF5ZXJzID0gW107IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsbCA9IGRlbGF5ID09IDAgPyAnYm90aCcgOiAnZm9yd2FyZHMnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJPcHRpb25zID0geyBkdXJhdGlvbjogZHVyYXRpb24sIGRlbGF5OiBkZWxheSwgZmlsbDogZmlsbCB9O1xuICAgICAgICAvLyB3ZSBjaGVjayBmb3IgdGhpcyB0byBhdm9pZCBoYXZpbmcgYSBudWxsfHVuZGVmaW5lZCB2YWx1ZSBiZSBwcmVzZW50XG4gICAgICAgIC8vIGZvciB0aGUgZWFzaW5nICh3aGljaCByZXN1bHRzIGluIGFuIGVycm9yIGZvciBjZXJ0YWluIGJyb3dzZXJzICM5NzUyKVxuICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICBwbGF5ZXJPcHRpb25zWydlYXNpbmcnXSA9IGVhc2luZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c1dlYkFuaW1hdGlvblBsYXllcnMgPSAocHJldmlvdXNQbGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIgaW5zdGFuY2VvZiBXZWJBbmltYXRpb25zUGxheWVyOyB9KSk7XG4gICAgICAgIHJldHVybiBuZXcgV2ViQW5pbWF0aW9uc1BsYXllcihlbGVtZW50LCBrZXlmcmFtZXMsIHBsYXllck9wdGlvbnMsIHByZXZpb3VzV2ViQW5pbWF0aW9uUGxheWVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gV2ViQW5pbWF0aW9uc0RyaXZlcjtcbn0oKSk7XG4vKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnRzV2ViQW5pbWF0aW9ucygpIHtcbiAgICByZXR1cm4gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiAoKEVsZW1lbnQpKS5wcm90b3R5cGVbJ2FuaW1hdGUnXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIGFuaW1hdGlvbiBBUElzIG9mIHRoZSBhbmltYXRpb24gYnJvd3NlciBwYWNrYWdlLlxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiB0aGUgYW5pbWF0aW9uIHBhY2thZ2UuXG4gKi9cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cbmV4cG9ydCB7IEFuaW1hdGlvbkRyaXZlciwgQW5pbWF0aW9uIGFzIMm1QW5pbWF0aW9uLCBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIgYXMgybVBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIsIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIgYXMgybVOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLCBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyIGFzIMm1V2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplciwgTm9vcEFuaW1hdGlvbkRyaXZlciBhcyDJtU5vb3BBbmltYXRpb25Ecml2ZXIsIEFuaW1hdGlvbkVuZ2luZSBhcyDJtUFuaW1hdGlvbkVuZ2luZSwgV2ViQW5pbWF0aW9uc0RyaXZlciBhcyDJtVdlYkFuaW1hdGlvbnNEcml2ZXIsIHN1cHBvcnRzV2ViQW5pbWF0aW9ucyBhcyDJtXN1cHBvcnRzV2ViQW5pbWF0aW9ucywgV2ViQW5pbWF0aW9uc1BsYXllciBhcyDJtVdlYkFuaW1hdGlvbnNQbGF5ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXIuZXM1LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL2FuaW1hdGlvbnMvQGFuZ3VsYXIvYW5pbWF0aW9ucy9icm93c2VyLmVzNS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvYW5pbWF0aW9ucy9AYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXIuZXM1LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMy4zXG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdNb2R1bGUsIE5nWm9uZSwgUmVuZGVyZXJGYWN0b3J5MiwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJyb3dzZXJNb2R1bGUsIMm1RG9tUmVuZGVyZXJGYWN0b3J5MiB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgQW5pbWF0aW9uQnVpbGRlciwgQW5pbWF0aW9uRmFjdG9yeSwgc2VxdWVuY2UgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEFuaW1hdGlvbkRyaXZlciwgybVBbmltYXRpb25FbmdpbmUsIMm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLCDJtU5vb3BBbmltYXRpb25Ecml2ZXIsIMm1V2ViQW5pbWF0aW9uc0RyaXZlciwgybVXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyLCDJtXN1cHBvcnRzV2ViQW5pbWF0aW9ucyB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3Nlcic7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEJyb3dzZXJBbmltYXRpb25CdWlsZGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm9vdFJlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIocm9vdFJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9uZXh0QW5pbWF0aW9uSWQgPSAwO1xuICAgICAgICB2YXIgdHlwZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogJzAnLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIHN0eWxlczogW10sXG4gICAgICAgICAgICBkYXRhOiB7IGFuaW1hdGlvbjogW10gfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fcmVuZGVyZXIgPSByb290UmVuZGVyZXIuY3JlYXRlUmVuZGVyZXIoZG9jdW1lbnQuYm9keSwgdHlwZURhdGEpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCcm93c2VyQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gdGhpcy5fbmV4dEFuaW1hdGlvbklkLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX25leHRBbmltYXRpb25JZCsrO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IEFycmF5LmlzQXJyYXkoYW5pbWF0aW9uKSA/IHNlcXVlbmNlKGFuaW1hdGlvbikgOiBhbmltYXRpb247XG4gICAgICAgIGlzc3VlQW5pbWF0aW9uQ29tbWFuZCh0aGlzLl9yZW5kZXJlciwgbnVsbCwgaWQsICdyZWdpc3RlcicsIFtlbnRyeV0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXJBbmltYXRpb25GYWN0b3J5KGlkLCB0aGlzLl9yZW5kZXJlcik7XG4gICAgfTtcbiAgICByZXR1cm4gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXI7XG59KEFuaW1hdGlvbkJ1aWxkZXIpKTtcbkJyb3dzZXJBbmltYXRpb25CdWlsZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Ccm93c2VyQW5pbWF0aW9uQnVpbGRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyRmFjdG9yeTIsIH0sXG5dOyB9O1xudmFyIEJyb3dzZXJBbmltYXRpb25GYWN0b3J5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCcm93c2VyQW5pbWF0aW9uRmFjdG9yeSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pZFxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkoX2lkLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2lkID0gX2lkO1xuICAgICAgICBfdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIodGhpcy5faWQsIGVsZW1lbnQsIG9wdGlvbnMgfHwge30sIHRoaXMuX3JlbmRlcmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeTtcbn0oQW5pbWF0aW9uRmFjdG9yeSkpO1xudmFyIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlckFuaW1hdGlvblBsYXllcihpZCwgZWxlbWVudCwgb3B0aW9ucywgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XG4gICAgICAgIHRoaXMuX2NvbW1hbmQoJ2NyZWF0ZScsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fbGlzdGVuID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmxpc3Rlbih0aGlzLmVsZW1lbnQsIFwiQEBcIiArIHRoaXMuaWQgKyBcIjpcIiArIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tYW5kXG4gICAgICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuX2NvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNzdWVBbmltYXRpb25Db21tYW5kKHRoaXMuX3JlbmRlcmVyLCB0aGlzLmVsZW1lbnQsIHRoaXMuaWQsIGNvbW1hbmQsIGFyZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9saXN0ZW4oJ2RvbmUnLCBmbik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fbGlzdGVuKCdzdGFydCcsIGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX2xpc3RlbignZGVzdHJveScsIGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdpbml0Jyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29tbWFuZCgncGxheScpO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdwYXVzZScpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbW1hbmQoJ3Jlc3RhcnQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbW1hbmQoJ2ZpbmlzaCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbW1hbmQoJ2Rlc3Ryb3knKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgncmVzZXQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwKSB7IHRoaXMuX2NvbW1hbmQoJ3NldFBvc2l0aW9uJywgcCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuICAgIHJldHVybiBSZW5kZXJlckFuaW1hdGlvblBsYXllcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBpZFxuICogQHBhcmFtIHs/fSBjb21tYW5kXG4gKiBAcGFyYW0gez99IGFyZ3NcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzc3VlQW5pbWF0aW9uQ29tbWFuZChyZW5kZXJlciwgZWxlbWVudCwgaWQsIGNvbW1hbmQsIGFyZ3MpIHtcbiAgICByZXR1cm4gcmVuZGVyZXIuc2V0UHJvcGVydHkoZWxlbWVudCwgXCJAQFwiICsgaWQgKyBcIjpcIiArIGNvbW1hbmQsIGFyZ3MpO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFOSU1BVElPTl9QUkVGSVggPSAnQCc7XG52YXIgRElTQUJMRV9BTklNQVRJT05TX0ZMQUcgPSAnQC5kaXNhYmxlZCc7XG52YXIgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGVnYXRlXG4gICAgICogQHBhcmFtIHs/fSBlbmdpbmVcbiAgICAgKiBAcGFyYW0gez99IF96b25lXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5KGRlbGVnYXRlLCBlbmdpbmUsIF96b25lKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fY3VycmVudElkID0gMDtcbiAgICAgICAgdGhpcy5fbWljcm90YXNrSWQgPSAxO1xuICAgICAgICB0aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2RSZWN1ckRlcHRoID0gMDtcbiAgICAgICAgZW5naW5lLm9uUmVtb3ZhbENvbXBsZXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBpZiBhbiBjb21wb25lbnQgZWxlbWVudCBoYXMgYSBsZWF2ZSBhbmltYXRpb24sIGFuZCB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBhIGhvc3QgbGVhdmUgYW5pbWF0aW9uLCB0aGUgdmlldyBlbmdpbmUgd2lsbCBjYWxsIGByZW1vdmVDaGlsZGAgZm9yIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCByZW5kZXJlciBhcyB3ZWxsIGFzIGZvciB0aGUgY2hpbGQgY29tcG9uZW50IHJlbmRlcmVyLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGFscmVhZHkgcmVtb3ZlZCB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS5wYXJlbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGUucmVtb3ZlQ2hpbGQoZWxlbWVudC5wYXJlbnROb2RlLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBFTVBUWV9OQU1FU1BBQ0VfSUQgPSAnJztcbiAgICAgICAgLy8gY2FjaGUgdGhlIGRlbGVnYXRlcyB0byBmaW5kIG91dCB3aGljaCBjYWNoZWQgZGVsZWdhdGUgY2FuXG4gICAgICAgIC8vIGJlIHVzZWQgYnkgd2hpY2ggY2FjaGVkIHJlbmRlcmVyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGVnYXRlID0gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVSZW5kZXJlcihob3N0RWxlbWVudCwgdHlwZSk7XG4gICAgICAgIGlmICghaG9zdEVsZW1lbnQgfHwgIXR5cGUgfHwgIXR5cGUuZGF0YSB8fCAhdHlwZS5kYXRhWydhbmltYXRpb24nXSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckNhY2hlLmdldChkZWxlZ2F0ZSk7XG4gICAgICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgQmFzZUFuaW1hdGlvblJlbmRlcmVyKEVNUFRZX05BTUVTUEFDRV9JRCwgZGVsZWdhdGUsIHRoaXMuZW5naW5lKTtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNhY2hlIHRoaXMgcmVzdWx0IHdoZW4gdGhlIGJhc2UgcmVuZGVyZXIgaXMgdXNlZFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyQ2FjaGUuc2V0KGRlbGVnYXRlLCByZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50SWQgPSB0eXBlLmlkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lc3BhY2VJZCA9IHR5cGUuaWQgKyAnLScgKyB0aGlzLl9jdXJyZW50SWQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRJZCsrO1xuICAgICAgICB0aGlzLmVuZ2luZS5yZWdpc3RlcihuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb25UcmlnZ2VycyA9ICh0eXBlLmRhdGFbJ2FuaW1hdGlvbiddKTtcbiAgICAgICAgYW5pbWF0aW9uVHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikgeyByZXR1cm4gX3RoaXMuZW5naW5lLnJlZ2lzdGVyVHJpZ2dlcihjb21wb25lbnRJZCwgbmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50LCB0cmlnZ2VyLm5hbWUsIHRyaWdnZXIpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25SZW5kZXJlcih0aGlzLCBuYW1lc3BhY2VJZCwgZGVsZWdhdGUsIHRoaXMuZW5naW5lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2RSZWN1ckRlcHRoKys7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmJlZ2luKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5fc2NoZWR1bGVDb3VudFRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnaW5jcmVtZW5ldCB0aGUgYW5pbWF0aW9uIG1pY3JvdGFzaycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9taWNyb3Rhc2tJZCsrOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY291bnRcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHBhcmFtIHs/fSBkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLnNjaGVkdWxlTGlzdGVuZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChjb3VudCwgZm4sIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvdW50ID49IDAgJiYgY291bnQgPCB0aGlzLl9taWNyb3Rhc2tJZCkge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oZGF0YSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKHR1cGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSB0dXBsZVswXSwgZGF0YSA9IHR1cGxlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIucHVzaChbZm4sIGRhdGFdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NkUmVjdXJEZXB0aC0tO1xuICAgICAgICAvLyB0aGlzIGlzIHRvIHByZXZlbnQgYW5pbWF0aW9ucyBmcm9tIHJ1bm5pbmcgdHdpY2Ugd2hlbiBhbiBpbm5lclxuICAgICAgICAvLyBjb21wb25lbnQgZG9lcyBDRCB3aGVuIGEgcGFyZW50IGNvbXBvbmVudCBpbnN0ZWQgaGFzIGluc2VydGVkIGl0XG4gICAgICAgIGlmICh0aGlzLl9jZFJlY3VyRGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NjaGVkdWxlQ291bnRUYXNrKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5naW5lLmZsdXNoKF90aGlzLl9taWNyb3Rhc2tJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS53aGVuUmVuZGVyaW5nRG9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW5naW5lLndoZW5SZW5kZXJpbmdEb25lKCk7IH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeTtcbn0oKSk7XG5BbmltYXRpb25SZW5kZXJlckZhY3RvcnkuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyRmFjdG9yeTIsIH0sXG4gICAgeyB0eXBlOiDJtUFuaW1hdGlvbkVuZ2luZSwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbl07IH07XG52YXIgQmFzZUFuaW1hdGlvblJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBkZWxlZ2F0ZVxuICAgICAqIEBwYXJhbSB7P30gZW5naW5lXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmFzZUFuaW1hdGlvblJlbmRlcmVyKG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgZW5naW5lKSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlSWQgPSBuYW1lc3BhY2VJZDtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgdGhpcy5kZXN0cm95Tm9kZSA9IHRoaXMuZGVsZWdhdGUuZGVzdHJveU5vZGUgPyBmdW5jdGlvbiAobikgeyByZXR1cm4gZGVsZWdhdGUuZGVzdHJveU5vZGUobik7IH0gOiBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZGF0YTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmRlc3Ryb3kodGhpcy5uYW1lc3BhY2VJZCwgdGhpcy5kZWxlZ2F0ZSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAobmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmNyZWF0ZUVsZW1lbnQobmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVDb21tZW50KHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuY3JlYXRlVGV4dCh2YWx1ZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKHBhcmVudCwgbmV3Q2hpbGQpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRDaGlsZChwYXJlbnQsIG5ld0NoaWxkKTtcbiAgICAgICAgdGhpcy5lbmdpbmUub25JbnNlcnQodGhpcy5uYW1lc3BhY2VJZCwgbmV3Q2hpbGQsIHBhcmVudCwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXG4gICAgICogQHBhcmFtIHs/fSByZWZDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAocGFyZW50LCBuZXdDaGlsZCwgcmVmQ2hpbGQpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5pbnNlcnRCZWZvcmUocGFyZW50LCBuZXdDaGlsZCwgcmVmQ2hpbGQpO1xuICAgICAgICB0aGlzLmVuZ2luZS5vbkluc2VydCh0aGlzLm5hbWVzcGFjZUlkLCBuZXdDaGlsZCwgcGFyZW50LCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBvbGRDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIG9sZENoaWxkKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLm9uUmVtb3ZlKHRoaXMubmFtZXNwYWNlSWQsIG9sZENoaWxkLCB0aGlzLmRlbGVnYXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JPck5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuc2VsZWN0Um9vdEVsZW1lbnQoc2VsZWN0b3JPck5vZGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5wYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUucGFyZW50Tm9kZShub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubmV4dFNpYmxpbmcgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5uZXh0U2libGluZyhub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZUF0dHJpYnV0ZShlbCwgbmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgdGhpcy5kZWxlZ2F0ZS5hZGRDbGFzcyhlbCwgbmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgbmFtZSkgeyB0aGlzLmRlbGVnYXRlLnJlbW92ZUNsYXNzKGVsLCBuYW1lKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIHZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/PX0gZmxhZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlU3R5bGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlLCBmbGFncykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZVN0eWxlKGVsLCBzdHlsZSwgZmxhZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PSBBTklNQVRJT05fUFJFRklYICYmIG5hbWUgPT0gRElTQUJMRV9BTklNQVRJT05TX0ZMQUcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFuaW1hdGlvbnMoZWwsICEhdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRQcm9wZXJ0eShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7IHRoaXMuZGVsZWdhdGUuc2V0VmFsdWUobm9kZSwgdmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmRpc2FibGVBbmltYXRpb25zID0gZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmRpc2FibGVBbmltYXRpb25zKGVsZW1lbnQsIHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlQW5pbWF0aW9uUmVuZGVyZXI7XG59KCkpO1xudmFyIEFuaW1hdGlvblJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBbmltYXRpb25SZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZhY3RvcnlcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBkZWxlZ2F0ZVxuICAgICAqIEBwYXJhbSB7P30gZW5naW5lXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uUmVuZGVyZXIoZmFjdG9yeSwgbmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICBfdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PSBBTklNQVRJT05fUFJFRklYKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMSkgPT0gJy4nICYmIG5hbWUgPT0gRElTQUJMRV9BTklNQVRJT05TX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVBbmltYXRpb25zKGVsLCAhIXZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLnByb2Nlc3ModGhpcy5uYW1lc3BhY2VJZCwgZWwsIG5hbWUuc3Vic3RyKDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmNoYXJBdCgwKSA9PSBBTklNQVRJT05fUFJFRklYKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gcmVzb2x2ZUVsZW1lbnRGcm9tVGFyZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gZXZlbnROYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoYXNlID0gJyc7XG4gICAgICAgICAgICAvLyBAbGlzdGVuZXIucGhhc2UgaXMgZm9yIHRyaWdnZXIgYW5pbWF0aW9uIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gQEBsaXN0ZW5lciBpcyBmb3IgYW5pbWF0aW9uIGJ1aWxkZXIgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIF9hID0gcGFyc2VUcmlnZ2VyQ2FsbGJhY2tOYW1lKG5hbWUpLCBuYW1lID0gX2FbMF0sIHBoYXNlID0gX2FbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUubGlzdGVuKHRoaXMubmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWUsIHBoYXNlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb3VudElkID0gKChldmVudCkpWydfZGF0YSddIHx8IC0xO1xuICAgICAgICAgICAgICAgIF90aGlzLmZhY3Rvcnkuc2NoZWR1bGVMaXN0ZW5lckNhbGxiYWNrKGNvdW50SWQsIGNhbGxiYWNrLCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5saXN0ZW4odGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblJlbmRlcmVyO1xufShCYXNlQW5pbWF0aW9uUmVuZGVyZXIpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0YXJnZXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVFbGVtZW50RnJvbVRhcmdldCh0YXJnZXQpIHtcbiAgICBzd2l0Y2ggKHRhcmdldCkge1xuICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIGNhc2UgJ3dpbmRvdyc6XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVHJpZ2dlckNhbGxiYWNrTmFtZSh0cmlnZ2VyTmFtZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRvdEluZGV4ID0gdHJpZ2dlck5hbWUuaW5kZXhPZignLicpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSB0cmlnZ2VyTmFtZS5zdWJzdHJpbmcoMCwgZG90SW5kZXgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoYXNlID0gdHJpZ2dlck5hbWUuc3Vic3RyKGRvdEluZGV4ICsgMSk7XG4gICAgcmV0dXJuIFt0cmlnZ2VyLCBwaGFzZV07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRyaXZlclxuICAgICAqIEBwYXJhbSB7P30gbm9ybWFsaXplclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluamVjdGFibGVBbmltYXRpb25FbmdpbmUoZHJpdmVyLCBub3JtYWxpemVyKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBkcml2ZXIsIG5vcm1hbGl6ZXIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lO1xufSjJtUFuaW1hdGlvbkVuZ2luZSkpO1xuSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEFuaW1hdGlvbkRyaXZlciwgfSxcbiAgICB7IHR5cGU6IMm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLCB9LFxuXTsgfTtcbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVTdXBwb3J0ZWRBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgaWYgKMm1c3VwcG9ydHNXZWJBbmltYXRpb25zKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyDJtVdlYkFuaW1hdGlvbnNEcml2ZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyDJtU5vb3BBbmltYXRpb25Ecml2ZXIoKTtcbn1cbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVEZWZhdWx0U3R5bGVOb3JtYWxpemVyKCkge1xuICAgIHJldHVybiBuZXcgybVXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyKCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAqIEBwYXJhbSB7P30gZW5naW5lXG4gKiBAcGFyYW0gez99IHpvbmVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVuZGVyZXJGYWN0b3J5KHJlbmRlcmVyLCBlbmdpbmUsIHpvbmUpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKTtcbn1cbnZhciBTSEFSRURfQU5JTUFUSU9OX1BST1ZJREVSUyA9IFtcbiAgICB7IHByb3ZpZGU6IEFuaW1hdGlvbkJ1aWxkZXIsIHVzZUNsYXNzOiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlciB9LFxuICAgIHsgcHJvdmlkZTogybVBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIsIHVzZUZhY3Rvcnk6IGluc3RhbnRpYXRlRGVmYXVsdFN0eWxlTm9ybWFsaXplciB9LFxuICAgIHsgcHJvdmlkZTogybVBbmltYXRpb25FbmdpbmUsIHVzZUNsYXNzOiBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lIH0sIHtcbiAgICAgICAgcHJvdmlkZTogUmVuZGVyZXJGYWN0b3J5MixcbiAgICAgICAgdXNlRmFjdG9yeTogaW5zdGFudGlhdGVSZW5kZXJlckZhY3RvcnksXG4gICAgICAgIGRlcHM6IFvJtURvbVJlbmRlcmVyRmFjdG9yeTIsIMm1QW5pbWF0aW9uRW5naW5lLCBOZ1pvbmVdXG4gICAgfVxuXTtcbi8qKlxuICogU2VwYXJhdGUgcHJvdmlkZXJzIGZyb20gdGhlIGFjdHVhbCBtb2R1bGUgc28gdGhhdCB3ZSBjYW4gZG8gYSBsb2NhbCBtb2RpZmljYXRpb24gaW4gR29vZ2xlMyB0b1xuICogaW5jbHVkZSB0aGVtIGluIHRoZSBCcm93c2VyTW9kdWxlLlxuICovXG52YXIgQlJPV1NFUl9BTklNQVRJT05TX1BST1ZJREVSUyA9IFtcbiAgICB7IHByb3ZpZGU6IEFuaW1hdGlvbkRyaXZlciwgdXNlRmFjdG9yeTogaW5zdGFudGlhdGVTdXBwb3J0ZWRBbmltYXRpb25Ecml2ZXIgfVxuXS5jb25jYXQoU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlMpO1xuLyoqXG4gKiBTZXBhcmF0ZSBwcm92aWRlcnMgZnJvbSB0aGUgYWN0dWFsIG1vZHVsZSBzbyB0aGF0IHdlIGNhbiBkbyBhIGxvY2FsIG1vZGlmaWNhdGlvbiBpbiBHb29nbGUzIHRvXG4gKiBpbmNsdWRlIHRoZW0gaW4gdGhlIEJyb3dzZXJUZXN0aW5nTW9kdWxlLlxuICovXG52YXIgQlJPV1NFUl9OT09QX0FOSU1BVElPTlNfUFJPVklERVJTID0gW3sgcHJvdmlkZTogQW5pbWF0aW9uRHJpdmVyLCB1c2VDbGFzczogybVOb29wQW5pbWF0aW9uRHJpdmVyIH1dLmNvbmNhdChTSEFSRURfQU5JTUFUSU9OX1BST1ZJREVSUyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKi9cbnZhciBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZTtcbn0oKSk7XG5Ccm93c2VyQW5pbWF0aW9uc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0Jyb3dzZXJNb2R1bGVdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogQlJPV1NFUl9BTklNQVRJT05TX1BST1ZJREVSUyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xudmFyIE5vb3BBbmltYXRpb25zTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uc01vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25zTW9kdWxlO1xufSgpKTtcbk5vb3BBbmltYXRpb25zTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbQnJvd3Nlck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBCUk9XU0VSX05PT1BfQU5JTUFUSU9OU19QUk9WSURFUlMsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk5vb3BBbmltYXRpb25zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBhbmltYXRpb24gQVBJcyBvZiB0aGUgYW5pbWF0aW9uIGJyb3dzZXIgcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIGFuaW1hdGlvbiBwYWNrYWdlLlxuICovXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5leHBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgTm9vcEFuaW1hdGlvbnNNb2R1bGUsIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyIGFzIMm1QnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIsIEJyb3dzZXJBbmltYXRpb25GYWN0b3J5IGFzIMm1QnJvd3NlckFuaW1hdGlvbkZhY3RvcnksIEFuaW1hdGlvblJlbmRlcmVyIGFzIMm1QW5pbWF0aW9uUmVuZGVyZXIsIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeSBhcyDJtUFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeSwgQmFzZUFuaW1hdGlvblJlbmRlcmVyIGFzIMm1YSwgQlJPV1NFUl9BTklNQVRJT05TX1BST1ZJREVSUyBhcyDJtWYsIEJST1dTRVJfTk9PUF9BTklNQVRJT05TX1BST1ZJREVSUyBhcyDJtWcsIEluamVjdGFibGVBbmltYXRpb25FbmdpbmUgYXMgybViLCBpbnN0YW50aWF0ZURlZmF1bHRTdHlsZU5vcm1hbGl6ZXIgYXMgybVkLCBpbnN0YW50aWF0ZVJlbmRlcmVyRmFjdG9yeSBhcyDJtWUsIGluc3RhbnRpYXRlU3VwcG9ydGVkQW5pbWF0aW9uRHJpdmVyIGFzIMm1YyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9ucy5lczUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2FuaW1hdGlvbnMuZXM1LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucy5lczUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGFuaW1hdGlvbnNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9hbmltYXRpb25zXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc2hhcmVkXCIpO1xudmFyIEFjY29yZGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWNjb3JkaW9uKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk9wZW4gPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnRhYnMgPSBbXTtcbiAgICB9XG4gICAgQWNjb3JkaW9uLnByb3RvdHlwZS5hZGRUYWIgPSBmdW5jdGlvbiAodGFiKSB7XG4gICAgICAgIHRoaXMudGFicy5wdXNoKHRhYik7XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLmdldEJsb2NrYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWNjb3JkaW9uLnByb3RvdHlwZSwgXCJhY3RpdmVJbmRleFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUluZGV4ID0gdmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMudGFicyAmJiB0aGlzLnRhYnMubGVuZ3RoICYmIHRoaXMuX2FjdGl2ZUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm11bHRpcGxlID8gdGhpcy5fYWN0aXZlSW5kZXguaW5jbHVkZXMoaSkgOiAoaSA9PT0gdGhpcy5fYWN0aXZlSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZCA9IHNlbGVjdGVkICE9PSB0aGlzLnRhYnNbaV0uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYnNbaV0uYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJzW2ldLnNlbGVjdGVkQ2hhbmdlLmVtaXQoc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEFjY29yZGlvbjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEFjY29yZGlvbi5wcm90b3R5cGUsIFwibXVsdGlwbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEFjY29yZGlvbi5wcm90b3R5cGUsIFwib25DbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgQWNjb3JkaW9uLnByb3RvdHlwZSwgXCJvbk9wZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBY2NvcmRpb24ucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQWNjb3JkaW9uLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEFjY29yZGlvbi5wcm90b3R5cGUsIFwibGF6eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgQWNjb3JkaW9uLnByb3RvdHlwZSwgXCJhY3RpdmVJbmRleFwiLCBudWxsKTtcbkFjY29yZGlvbiA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtYWNjb3JkaW9uJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwiJ3VpLWFjY29yZGlvbiB1aS13aWRnZXQgdWktaGVscGVyLXJlc2V0J1xcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWZdKVxuXSwgQWNjb3JkaW9uKTtcbmV4cG9ydHMuQWNjb3JkaW9uID0gQWNjb3JkaW9uO1xudmFyIEFjY29yZGlvblRhYiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWNjb3JkaW9uVGFiKGFjY29yZGlvbikge1xuICAgICAgICB0aGlzLmFjY29yZGlvbiA9IGFjY29yZGlvbjtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWNjb3JkaW9uLmFkZFRhYih0aGlzKTtcbiAgICB9XG4gICAgQWNjb3JkaW9uVGFiLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5hbmltYXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZFRhYkluZGV4KCk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvbi5vbkNsb3NlLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgaW5kZXg6IGluZGV4IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjY29yZGlvbi5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY2NvcmRpb24udGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY29yZGlvbi50YWJzW2ldLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjb3JkaW9uLnRhYnNbaV0uc2VsZWN0ZWRDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvbi5vbk9wZW4uZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBpbmRleDogaW5kZXggfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgQWNjb3JkaW9uVGFiLnByb3RvdHlwZS5maW5kVGFiSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWNjb3JkaW9uLnRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjY29yZGlvbi50YWJzW2ldID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY29yZGlvblRhYi5wcm90b3R5cGUsIFwibGF6eVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3JkaW9uLmxhenk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY2NvcmRpb25UYWIucHJvdG90eXBlLCBcImhhc0hlYWRlckZhY2V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJGYWNldCAmJiB0aGlzLmhlYWRlckZhY2V0Lmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFjY29yZGlvblRhYi5wcm90b3R5cGUub25Ub2dnbGVEb25lID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBBY2NvcmRpb25UYWIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbi50YWJzLnNwbGljZSh0aGlzLmZpbmRUYWJJbmRleCgpLCAxKTtcbiAgICB9O1xuICAgIHJldHVybiBBY2NvcmRpb25UYWI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEFjY29yZGlvblRhYi5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEFjY29yZGlvblRhYi5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQWNjb3JkaW9uVGFiLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgQWNjb3JkaW9uVGFiLnByb3RvdHlwZSwgXCJzZWxlY3RlZENoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZHJlbihzaGFyZWRfMS5IZWFkZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuUXVlcnlMaXN0KVxuXSwgQWNjb3JkaW9uVGFiLnByb3RvdHlwZSwgXCJoZWFkZXJGYWNldFwiLCB2b2lkIDApO1xuQWNjb3JkaW9uVGFiID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1hY2NvcmRpb25UYWInLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWFjY29yZGlvbi1oZWFkZXIgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXFxcIiBbbmdDbGFzc109XFxcInsndWktc3RhdGUtYWN0aXZlJzogc2VsZWN0ZWQsJ3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZH1cXFwiXFxuICAgICAgICAgICAgKGNsaWNrKT1cXFwidG9nZ2xlKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1md1xcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhLWNhcmV0LWRvd24nOiBzZWxlY3RlZCwgJ2ZhLWNhcmV0LXJpZ2h0JzogIXNlbGVjdGVkfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiICpuZ0lmPVxcXCIhaGFzSGVhZGVyRmFjZXRcXFwiIHJvbGU9XFxcInRhYlxcXCIgW2F0dHIuYXJpYS1leHBhbmRlZF09XFxcInNlbGVjdGVkXFxcIiBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cXFwic2VsZWN0ZWRcXFwiPnt7aGVhZGVyfX08L2E+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgKm5nSWY9XFxcImhhc0hlYWRlckZhY2V0XFxcIiByb2xlPVxcXCJ0YWJcXFwiIFthdHRyLmFyaWEtZXhwYW5kZWRdPVxcXCJzZWxlY3RlZFxcXCIgW2F0dHIuYXJpYS1zZWxlY3RlZF09XFxcInNlbGVjdGVkXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJwLWhlYWRlclxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktYWNjb3JkaW9uLWNvbnRlbnQtd3JhcHBlclxcXCIgW0B0YWJDb250ZW50XT1cXFwic2VsZWN0ZWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1xcXCIgKEB0YWJDb250ZW50LmRvbmUpPVxcXCJvblRvZ2dsZURvbmUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktYWNjb3JkaW9uLWNvbnRlbnQtd3JhcHBlci1vdmVyZmxvd24nOiAhc2VsZWN0ZWR8fGFuaW1hdGluZ31cXFwiIHJvbGU9XFxcInRhYnBhbmVsXFxcIiBbYXR0ci5hcmlhLWhpZGRlbl09XFxcIiFzZWxlY3RlZFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktYWNjb3JkaW9uLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcXFwiICpuZ0lmPVxcXCJsYXp5ID8gc2VsZWN0ZWQgOiB0cnVlXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICBhbmltYXRpb25zXzEudHJpZ2dlcigndGFiQ29udGVudCcsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuc3RhdGUoJ2hpZGRlbicsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzAnXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5zdGF0ZSgndmlzaWJsZScsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJyonXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS50cmFuc2l0aW9uKCd2aXNpYmxlIDw9PiBoaWRkZW4nLCBhbmltYXRpb25zXzEuYW5pbWF0ZSgnNDAwbXMgY3ViaWMtYmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpJykpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBY2NvcmRpb25dKVxuXSwgQWNjb3JkaW9uVGFiKTtcbmV4cG9ydHMuQWNjb3JkaW9uVGFiID0gQWNjb3JkaW9uVGFiO1xudmFyIEFjY29yZGlvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWNjb3JkaW9uTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gQWNjb3JkaW9uTW9kdWxlO1xufSgpKTtcbkFjY29yZGlvbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbQWNjb3JkaW9uLCBBY2NvcmRpb25UYWJdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtBY2NvcmRpb24sIEFjY29yZGlvblRhYl1cbiAgICB9KVxuXSwgQWNjb3JkaW9uTW9kdWxlKTtcbmV4cG9ydHMuQWNjb3JkaW9uTW9kdWxlID0gQWNjb3JkaW9uTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3JkaW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBpbnB1dHRleHRfMSA9IHJlcXVpcmUoXCIuLi9pbnB1dHRleHQvaW5wdXR0ZXh0XCIpO1xudmFyIGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL2J1dHRvbi9idXR0b25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgb2JqZWN0dXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9vYmplY3R1dGlsc1wiKTtcbnZhciBmb3Jtc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpO1xuZXhwb3J0cy5BVVRPQ09NUExFVEVfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogZm9ybXNfMS5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gQXV0b0NvbXBsZXRlOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBBdXRvQ29tcGxldGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dG9Db21wbGV0ZShlbCwgZG9tSGFuZGxlciwgcmVuZGVyZXIsIG9iamVjdFV0aWxzLCBjZCwgZGlmZmVycykge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5vYmplY3RVdGlscyA9IG9iamVjdFV0aWxzO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuZGlmZmVycyA9IGRpZmZlcnM7XG4gICAgICAgIHRoaXMubWluTGVuZ3RoID0gMTtcbiAgICAgICAgdGhpcy5kZWxheSA9IDMwMDtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLmNvbXBsZXRlTWV0aG9kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vblNlbGVjdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25VbnNlbGVjdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkRyb3Bkb3duQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQ2xlYXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uS2V5VXAgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNjcm9sbEhlaWdodCA9ICcyMDBweCc7XG4gICAgICAgIHRoaXMuaW1tdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0aGlzLnBhbmVsVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlmZmVyID0gZGlmZmVycy5maW5kKFtdKS5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcInN1Z2dlc3Rpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VnZ2VzdGlvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fc3VnZ2VzdGlvbnMgPSB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1Z2dlc3Rpb25zQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYodGhpcy5zdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3VnZ2VzdGlvbnNDaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5oYW5kbGVTdWdnZXN0aW9uc0NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWxFTCAmJiB0aGlzLnBhbmVsRUwubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N1Z2dlc3Rpb25zICYmIHRoaXMuX3N1Z2dlc3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9SZXN1bHRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWdnZXN0aW9uc1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9IaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRPcHRpb24gPSB0aGlzLl9zdWdnZXN0aW9uc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vUmVzdWx0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW1wdHlNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Z2dlc3Rpb25zVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0uZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLml0ZW1UZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdGVkSXRlbSc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdGVkSXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUbyA9PT0gJ2JvZHknKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wYW5lbEVMLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hcHBlbmRDaGlsZCh0aGlzLnBhbmVsRUwubmF0aXZlRWxlbWVudCwgdGhpcy5hcHBlbmRUbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvL1VzZSB0aW1lb3V0cyBhcyBzaW5jZSBBbmd1bGFyIDQuMiwgQWZ0ZXJWaWV3Q2hlY2tlZCBpcyBicm9rZW4gYW5kIG5vdCBjYWxsZWQgYWZ0ZXIgcGFuZWwgaXMgdXBkYXRlZFxuICAgICAgICBpZiAodGhpcy5zdWdnZXN0aW9uc1VwZGF0ZWQgJiYgdGhpcy5wYW5lbEVMLm5hdGl2ZUVsZW1lbnQgJiYgdGhpcy5wYW5lbEVMLm5hdGl2ZUVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFsaWduKCk7IH0sIDEpO1xuICAgICAgICAgICAgdGhpcy5zdWdnZXN0aW9uc1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRPcHRpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdEl0ZW0gPSBfdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUoX3RoaXMucGFuZWxFTC5uYXRpdmVFbGVtZW50LCAnbGkudWktc3RhdGUtaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbUhhbmRsZXIuc2Nyb2xsSW5WaWV3KF90aGlzLnBhbmVsRUwubmF0aXZlRWxlbWVudCwgbGlzdEl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRPcHRpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZmlsbGVkID0gdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlICE9ICcnO1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZm47XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB2YWw7XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLm9uSW5wdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0S2V5RG93bikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkNsZWFyLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gdGhpcy5taW5MZW5ndGgpIHtcbiAgICAgICAgICAgIC8vQ2FuY2VsIHRoZSBzZWFyY2ggcmVxdWVzdCBpZiB1c2VyIHR5cGVzIHdpdGhpbiB0aGUgdGltZW91dFxuICAgICAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VhcmNoKGV2ZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRmlsbGVkU3RhdGUoKTtcbiAgICAgICAgdGhpcy5pbnB1dEtleURvd24gPSBmYWxzZTtcbiAgICB9O1xuICAgIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUub25JbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5pbnB1dENsaWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAoZXZlbnQsIHF1ZXJ5KSB7XG4gICAgICAgIC8vYWxsb3cgZW1wdHkgc3RyaW5nIGJ1dCBub3QgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgaWYgKHF1ZXJ5ID09PSB1bmRlZmluZWQgfHwgcXVlcnkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBsZXRlTWV0aG9kLmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLnNlbGVjdEl0ZW0gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLm11bHRpSW5wdXRFTC5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSB8fCBbXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5jb25jYXQoW29wdGlvbl0pO1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFTC5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5maWVsZCA/IHRoaXMub2JqZWN0VXRpbHMucmVzb2x2ZUZpZWxkRGF0YShvcHRpb24sIHRoaXMuZmllbGQpIHx8ICcnIDogb3B0aW9uO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbjtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0LmVtaXQob3B0aW9uKTtcbiAgICAgICAgdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm11bHRpSW5wdXRFTCB8fCB0aGlzLmlucHV0RUwpIHtcbiAgICAgICAgICAgIHZhciBoYXNGb2N1cyA9IHRoaXMubXVsdGlwbGUgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHRoaXMubXVsdGlJbnB1dEVMLm5hdGl2ZUVsZW1lbnQgOiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHRoaXMuaW5wdXRFTC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhbmVsVmlzaWJsZSAmJiBoYXNGb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWxWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmVsRUwubmF0aXZlRWxlbWVudC5zdHlsZS56SW5kZXggPSArK2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLnppbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuZmFkZUluKHRoaXMucGFuZWxFTC5uYXRpdmVFbGVtZW50LCAyMDApO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLmFsaWduID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRUbylcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hYnNvbHV0ZVBvc2l0aW9uKHRoaXMucGFuZWxFTC5uYXRpdmVFbGVtZW50LCAodGhpcy5tdWx0aXBsZSA/IHRoaXMubXVsdGlDb250YWluZXJFTC5uYXRpdmVFbGVtZW50IDogdGhpcy5pbnB1dEVMLm5hdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLnJlbGF0aXZlUG9zaXRpb24odGhpcy5wYW5lbEVMLm5hdGl2ZUVsZW1lbnQsICh0aGlzLm11bHRpcGxlID8gdGhpcy5tdWx0aUNvbnRhaW5lckVMLm5hdGl2ZUVsZW1lbnQgOiB0aGlzLmlucHV0RUwubmF0aXZlRWxlbWVudCkpO1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhbmVsVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5oYW5kbGVEcm9wZG93bkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgICAgICB2YXIgcXVlcnlWYWx1ZSA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLm11bHRpSW5wdXRFTC5uYXRpdmVFbGVtZW50LnZhbHVlIDogdGhpcy5pbnB1dEVMLm5hdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICAgIHRoaXMub25Ecm9wZG93bkNsaWNrLmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnlWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUuZm9jdXNJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpXG4gICAgICAgICAgICB0aGlzLm11bHRpSW5wdXRFTC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFTC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaXRlbUluZGV4ID0gdGhpcy5kb21IYW5kbGVyLmluZGV4KGl0ZW0pO1xuICAgICAgICB2YXIgcmVtb3ZlZFZhbHVlID0gdGhpcy52YWx1ZVtpdGVtSW5kZXhdO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBpdGVtSW5kZXg7IH0pO1xuICAgICAgICB0aGlzLm9uVW5zZWxlY3QuZW1pdChyZW1vdmVkVmFsdWUpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLm9uS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbFZpc2libGUpIHtcbiAgICAgICAgICAgIHZhciBoaWdobGlnaHRJdGVtSW5kZXggPSB0aGlzLmZpbmRPcHRpb25JbmRleCh0aGlzLmhpZ2hsaWdodE9wdGlvbik7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgICAgICAgLy9kb3duXG4gICAgICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodEl0ZW1JbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRJdGVtSW5kZXggPSBoaWdobGlnaHRJdGVtSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJdGVtSW5kZXggIT0gKHRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0T3B0aW9uID0gdGhpcy5zdWdnZXN0aW9uc1tuZXh0SXRlbUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodE9wdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRPcHRpb24gPSB0aGlzLnN1Z2dlc3Rpb25zWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vdXBcbiAgICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0SXRlbUluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZJdGVtSW5kZXggPSBoaWdobGlnaHRJdGVtSW5kZXggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRPcHRpb24gPSB0aGlzLnN1Z2dlc3Rpb25zW3ByZXZJdGVtSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRPcHRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvL2VudGVyXG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0T3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0odGhpcy5oaWdobGlnaHRPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy9lc2NhcGVcbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy90YWJcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodE9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RJdGVtKHRoaXMuaGlnaGxpZ2h0T3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDQwICYmIHRoaXMuc3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaChldmVudCwgZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC53aGljaCkge1xuICAgICAgICAgICAgICAgIC8vYmFja3NwYWNlXG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCAmJiAhdGhpcy5tdWx0aUlucHV0RUwubmF0aXZlRWxlbWVudC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkVmFsdWUgPSB0aGlzLnZhbHVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblVuc2VsZWN0LmVtaXQocmVtb3ZlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0S2V5RG93biA9IHRydWU7XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLm9uS2V5dXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vbktleVVwLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHRydWU7XG4gICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUub25JbnB1dEJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkKCk7XG4gICAgICAgIHRoaXMub25CbHVyLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iamVjdFV0aWxzLmVxdWFscyh0aGlzLnZhbHVlW2ldLCB2YWwsIHRoaXMuZGF0YUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5maW5kT3B0aW9uSW5kZXggPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5zdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1Z2dlc3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqZWN0VXRpbHMuZXF1YWxzKG9wdGlvbiwgdGhpcy5zdWdnZXN0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS51cGRhdGVGaWxsZWRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpXG4gICAgICAgICAgICB0aGlzLmZpbGxlZCA9ICh0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUubGVuZ3RoKSB8fCAodGhpcy5tdWx0aUlucHV0RUwgJiYgdGhpcy5tdWx0aUlucHV0RUwubmF0aXZlRWxlbWVudCAmJiB0aGlzLm11bHRpSW5wdXRFTC5uYXRpdmVFbGVtZW50LnZhbHVlICE9ICcnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5maWxsZWQgPSB0aGlzLmlucHV0RUwgJiYgdGhpcy5pbnB1dEVMLm5hdGl2ZUVsZW1lbnQgJiYgdGhpcy5pbnB1dEVMLm5hdGl2ZUVsZW1lbnQudmFsdWUgIT0gJyc7XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlucHV0Q2xpY2spXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlucHV0Q2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLnVuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRUbykge1xuICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucGFuZWxFTC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEF1dG9Db21wbGV0ZTtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJtaW5MZW5ndGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcImRlbGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwiaW5wdXRTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwiaW5wdXRTdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcIm1heGxlbmd0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwiYXBwZW5kVG9cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJhdXRvSGlnaGxpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcImNvbXBsZXRlTWV0aG9kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcIm9uU2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcIm9uVW5zZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwib25Gb2N1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwib25Ecm9wZG93bkNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcIm9uQ2xlYXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwib25LZXlVcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwiZmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcInNjcm9sbEhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcImRyb3Bkb3duXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwibXVsdGlwbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBBdXRvQ29tcGxldGUucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJkYXRhS2V5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJlbXB0eU1lc3NhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJpbW11dGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2luJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJpbnB1dEVMXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdtdWx0aUluJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJtdWx0aUlucHV0RUxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3BhbmVsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJwYW5lbEVMXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdtdWx0aUNvbnRhaW5lcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwibXVsdGlDb250YWluZXJFTFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZHJlbihzaGFyZWRfMS5QcmltZVRlbXBsYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlF1ZXJ5TGlzdClcbl0sIEF1dG9Db21wbGV0ZS5wcm90b3R5cGUsIFwidGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgQXV0b0NvbXBsZXRlLnByb3RvdHlwZSwgXCJzdWdnZXN0aW9uc1wiLCBudWxsKTtcbkF1dG9Db21wbGV0ZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtYXV0b0NvbXBsZXRlJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8c3BhbiBbbmdDbGFzc109XFxcInsndWktYXV0b2NvbXBsZXRlIHVpLXdpZGdldCc6dHJ1ZSwndWktYXV0b2NvbXBsZXRlLWRkJzpkcm9wZG93biwndWktYXV0b2NvbXBsZXRlLW11bHRpcGxlJzptdWx0aXBsZX1cXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCAqbmdJZj1cXFwiIW11bHRpcGxlXFxcIiAjaW4gW2F0dHIudHlwZV09XFxcInR5cGVcXFwiIFthdHRyLmlkXT1cXFwiaW5wdXRJZFxcXCIgW25nU3R5bGVdPVxcXCJpbnB1dFN0eWxlXFxcIiBbY2xhc3NdPVxcXCJpbnB1dFN0eWxlQ2xhc3NcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBcXG4gICAgICAgICAgICBbbmdDbGFzc109XFxcIid1aS1pbnB1dHRleHQgdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCB1aS1hdXRvY29tcGxldGUtaW5wdXQnXFxcIiBbdmFsdWVdPVxcXCJ2YWx1ZSA/IChmaWVsZCA/IG9iamVjdFV0aWxzLnJlc29sdmVGaWVsZERhdGEodmFsdWUsZmllbGQpfHwnJyA6IHZhbHVlKSA6IG51bGxcXFwiIFxcbiAgICAgICAgICAgIChjbGljayk9XFxcIm9uSW5wdXRDbGljaygkZXZlbnQpXFxcIiAoaW5wdXQpPVxcXCJvbklucHV0KCRldmVudClcXFwiIChrZXlkb3duKT1cXFwib25LZXlkb3duKCRldmVudClcXFwiIChrZXl1cCk9XFxcIm9uS2V5dXAoJGV2ZW50KVxcXCIgKGZvY3VzKT1cXFwib25JbnB1dEZvY3VzKCRldmVudClcXFwiIChibHVyKT1cXFwib25JbnB1dEJsdXIoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XFxcInBsYWNlaG9sZGVyXFxcIiBbYXR0ci5zaXplXT1cXFwic2l6ZVxcXCIgW2F0dHIubWF4bGVuZ3RoXT1cXFwibWF4bGVuZ3RoXFxcIiBbYXR0ci50YWJpbmRleF09XFxcInRhYmluZGV4XFxcIiBbcmVhZG9ubHldPVxcXCJyZWFkb25seVxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgPjx1bCAqbmdJZj1cXFwibXVsdGlwbGVcXFwiICNtdWx0aUNvbnRhaW5lciBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lciB1aS13aWRnZXQgdWktaW5wdXR0ZXh0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZCwndWktc3RhdGUtZm9jdXMnOmZvY3VzfVxcXCIgKGNsaWNrKT1cXFwibXVsdGlJbi5mb2N1cygpXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpICN0b2tlbiAqbmdGb3I9XFxcImxldCB2YWwgb2YgdmFsdWVcXFwiIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtdG9rZW4gdWktc3RhdGUtaGlnaGxpZ2h0IHVpLWNvcm5lci1hbGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS10b2tlbi1pY29uIGZhIGZhLWZ3IGZhLWNsb3NlXFxcIiAoY2xpY2spPVxcXCJyZW1vdmVJdGVtKHRva2VuKVxcXCIgKm5nSWY9XFxcIiFkaXNhYmxlZFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiFzZWxlY3RlZEl0ZW1UZW1wbGF0ZVxcXCIgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS10b2tlbi1sYWJlbFxcXCI+e3tmaWVsZCA/IHZhbFtmaWVsZF0gOiB2YWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cXFwic2VsZWN0ZWRJdGVtVGVtcGxhdGVcXFwiIFtwVGVtcGxhdGVXcmFwcGVyXT1cXFwic2VsZWN0ZWRJdGVtVGVtcGxhdGVcXFwiIFtpdGVtXT1cXFwidmFsXFxcIj48L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgI211bHRpSW4gW2F0dHIudHlwZV09XFxcInR5cGVcXFwiIFthdHRyLmlkXT1cXFwiaW5wdXRJZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFthdHRyLnBsYWNlaG9sZGVyXT1cXFwiKHZhbHVlJiZ2YWx1ZS5sZW5ndGggPyBudWxsIDogcGxhY2Vob2xkZXIpXFxcIiBbYXR0ci50YWJpbmRleF09XFxcInRhYmluZGV4XFxcIiAoaW5wdXQpPVxcXCJvbklucHV0KCRldmVudClcXFwiICAoY2xpY2spPVxcXCJvbklucHV0Q2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGtleWRvd24pPVxcXCJvbktleWRvd24oJGV2ZW50KVxcXCIgKGtleXVwKT1cXFwib25LZXl1cCgkZXZlbnQpXFxcIiAoZm9jdXMpPVxcXCJvbklucHV0Rm9jdXMoJGV2ZW50KVxcXCIgKGJsdXIpPVxcXCJvbklucHV0Qmx1cigkZXZlbnQpXFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgW25nU3R5bGVdPVxcXCJpbnB1dFN0eWxlXFxcIiBbY2xhc3NdPVxcXCJpbnB1dFN0eWxlQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDwvdWxcXG4gICAgICAgICAgICA+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtZncgZmEtY2FyZXQtZG93blxcXCIgY2xhc3M9XFxcInVpLWF1dG9jb21wbGV0ZS1kcm9wZG93blxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIChjbGljayk9XFxcImhhbmRsZURyb3Bkb3duQ2xpY2soJGV2ZW50KVxcXCIgKm5nSWY9XFxcImRyb3Bkb3duXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICA8ZGl2ICNwYW5lbCBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktc2hhZG93XFxcIiBbc3R5bGUuZGlzcGxheV09XFxcInBhbmVsVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSdcXFwiIFtzdHlsZS53aWR0aF09XFxcImFwcGVuZFRvID8gJ2F1dG8nIDogJzEwMCUnXFxcIiBbc3R5bGUubWF4LWhlaWdodF09XFxcInNjcm9sbEhlaWdodFxcXCI+XFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwidWktYXV0b2NvbXBsZXRlLWl0ZW1zIHVpLWF1dG9jb21wbGV0ZS1saXN0IHVpLXdpZGdldC1jb250ZW50IHVpLXdpZGdldCB1aS1jb3JuZXItYWxsIHVpLWhlbHBlci1yZXNldFxcXCIgKm5nSWY9XFxcInBhbmVsVmlzaWJsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGkgKm5nRm9yPVxcXCJsZXQgb3B0aW9uIG9mIHN1Z2dlc3Rpb25zOyBsZXQgaWR4ID0gaW5kZXhcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1hdXRvY29tcGxldGUtbGlzdC1pdGVtIHVpLWNvcm5lci1hbGwnOnRydWUsJ3VpLXN0YXRlLWhpZ2hsaWdodCc6KGhpZ2hsaWdodE9wdGlvbj09b3B0aW9uKX1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgKG1vdXNlZW50ZXIpPVxcXCJoaWdobGlnaHRPcHRpb249b3B0aW9uXFxcIiAobW91c2VsZWF2ZSk9XFxcImhpZ2hsaWdodE9wdGlvbj1udWxsXFxcIiAoY2xpY2spPVxcXCJzZWxlY3RJdGVtKG9wdGlvbilcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVxcXCIhaXRlbVRlbXBsYXRlXFxcIj57e2ZpZWxkID8gb3B0aW9uW2ZpZWxkXSA6IG9wdGlvbn19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cXFwiaXRlbVRlbXBsYXRlXFxcIiBbcFRlbXBsYXRlV3JhcHBlcl09XFxcIml0ZW1UZW1wbGF0ZVxcXCIgW2l0ZW1dPVxcXCJvcHRpb25cXFwiIFtpbmRleF09XFxcImlkeFxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICA8bGkgKm5nSWY9XFxcIm5vUmVzdWx0cyAmJiBlbXB0eU1lc3NhZ2VcXFwiIGNsYXNzPVxcXCJ1aS1hdXRvY29tcGxldGUtbGlzdC1pdGVtIHVpLWNvcm5lci1hbGxcXFwiPnt7ZW1wdHlNZXNzYWdlfX08L2xpPlxcbiAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9zcGFuPlxcbiAgICBcIixcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ1tjbGFzcy51aS1pbnB1dHdyYXBwZXItZmlsbGVkXSc6ICdmaWxsZWQnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS1pbnB1dHdyYXBwZXItZm9jdXNdJzogJ2ZvY3VzJ1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgb2JqZWN0dXRpbHNfMS5PYmplY3RVdGlscywgZXhwb3J0cy5BVVRPQ09NUExFVEVfVkFMVUVfQUNDRVNTT1JdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIGNvcmVfMS5SZW5kZXJlcjIsIG9iamVjdHV0aWxzXzEuT2JqZWN0VXRpbHMsIGNvcmVfMS5DaGFuZ2VEZXRlY3RvclJlZiwgY29yZV8xLkl0ZXJhYmxlRGlmZmVyc10pXG5dLCBBdXRvQ29tcGxldGUpO1xuZXhwb3J0cy5BdXRvQ29tcGxldGUgPSBBdXRvQ29tcGxldGU7XG52YXIgQXV0b0NvbXBsZXRlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRvQ29tcGxldGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBBdXRvQ29tcGxldGVNb2R1bGU7XG59KCkpO1xuQXV0b0NvbXBsZXRlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgaW5wdXR0ZXh0XzEuSW5wdXRUZXh0TW9kdWxlLCBidXR0b25fMS5CdXR0b25Nb2R1bGUsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtBdXRvQ29tcGxldGUsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW0F1dG9Db21wbGV0ZV1cbiAgICB9KVxuXSwgQXV0b0NvbXBsZXRlTW9kdWxlKTtcbmV4cG9ydHMuQXV0b0NvbXBsZXRlTW9kdWxlID0gQXV0b0NvbXBsZXRlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b2NvbXBsZXRlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2F1dG9jb21wbGV0ZS9hdXRvY29tcGxldGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgQmxvY2tVSSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmxvY2tVSShlbCwgZG9tSGFuZGxlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9ja1VJLnByb3RvdHlwZSwgXCJibG9ja2VkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9ibG9ja2VkID0gdmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFzay5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Jsb2NrZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2soKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCbG9ja1VJLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAmJiAhdGhpcy50YXJnZXQuZ2V0QmxvY2thYmxlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgJ1RhcmdldCBvZiBCbG9ja1VJIG11c3QgaW1wbGVtZW50IEJsb2NrYWJsZVVJIGludGVyZmFjZSc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJsb2NrVUkucHJvdG90eXBlLmJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmdldEJsb2NrYWJsZUVsZW1lbnQoKS5hcHBlbmRDaGlsZCh0aGlzLm1hc2submF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnRhcmdldC5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubWFzay5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hc2submF0aXZlRWxlbWVudC5zdHlsZS56SW5kZXggPSBTdHJpbmcoKytkb21oYW5kbGVyXzEuRG9tSGFuZGxlci56aW5kZXgpO1xuICAgIH07XG4gICAgQmxvY2tVSS5wcm90b3R5cGUudW5ibG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMubWFzay5uYXRpdmVFbGVtZW50KTtcbiAgICB9O1xuICAgIEJsb2NrVUkucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrVUk7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEJsb2NrVUkucHJvdG90eXBlLCBcInRhcmdldFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnbWFzaycpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIEJsb2NrVUkucHJvdG90eXBlLCBcIm1hc2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgQmxvY2tVSS5wcm90b3R5cGUsIFwiYmxvY2tlZFwiLCBudWxsKTtcbkJsb2NrVUkgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWJsb2NrVUknLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgI21hc2sgY2xhc3M9XFxcInVpLWJsb2NrdWkgdWktd2lkZ2V0LW92ZXJsYXlcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1ibG9ja3VpLWRvY3VtZW50JzohdGFyZ2V0fVxcXCIgW25nU3R5bGVdPVxcXCJ7ZGlzcGxheTogYmxvY2tlZCA/ICdibG9jaycgOiAnbm9uZSd9XFxcIj5cXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIEJsb2NrVUkpO1xuZXhwb3J0cy5CbG9ja1VJID0gQmxvY2tVSTtcbnZhciBCbG9ja1VJTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCbG9ja1VJTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gQmxvY2tVSU1vZHVsZTtcbn0oKSk7XG5CbG9ja1VJTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtCbG9ja1VJXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQmxvY2tVSV1cbiAgICB9KVxuXSwgQmxvY2tVSU1vZHVsZSk7XG5leHBvcnRzLkJsb2NrVUlNb2R1bGUgPSBCbG9ja1VJTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2t1aS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2Jsb2NrdWkvYmxvY2t1aS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2Jsb2NrdWkvYmxvY2t1aS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL3JvdXRlclwiKTtcbnZhciBCcmVhZGNydW1iID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcmVhZGNydW1iKCkge1xuICAgIH1cbiAgICBCcmVhZGNydW1iLnByb3RvdHlwZS5pdGVtQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpdGVtLnVybCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5jb21tYW5kKSB7XG4gICAgICAgICAgICBpdGVtLmNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCcmVhZGNydW1iLnByb3RvdHlwZS5vbkhvbWVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5ob21lKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1DbGljayhldmVudCwgdGhpcy5ob21lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJyZWFkY3J1bWI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgQnJlYWRjcnVtYi5wcm90b3R5cGUsIFwibW9kZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBCcmVhZGNydW1iLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEJyZWFkY3J1bWIucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBCcmVhZGNydW1iLnByb3RvdHlwZSwgXCJob21lXCIsIHZvaWQgMCk7XG5CcmVhZGNydW1iID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1icmVhZGNydW1iJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtuZ0NsYXNzXT1cXFwiJ3VpLWJyZWFkY3J1bWIgdWktd2lkZ2V0IHVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGwnXFxcIj5cXG4gICAgICAgICAgICA8dWw+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktYnJlYWRjcnVtYi1ob21lIGZhIGZhLWhvbWVcXFwiICpuZ0lmPVxcXCIhaG9tZVxcXCI+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1icmVhZGNydW1iLWhvbWVcXFwiICpuZ0lmPVxcXCJob21lXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCIhaG9tZS5yb3V0ZXJMaW5rXFxcIiBbaHJlZl09XFxcImhvbWUudXJsfHwnIydcXFwiIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1saW5rXFxcIiAoY2xpY2spPVxcXCJpdGVtQ2xpY2soJGV2ZW50LCBob21lKVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzpob21lLmRpc2FibGVkfVxcXCIgW2F0dHIudGFyZ2V0XT1cXFwiaG9tZS50YXJnZXRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1ob21lXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiaG9tZS5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua109XFxcImhvbWUucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCIndWktc3RhdGUtYWN0aXZlJ1xcXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cXFwiaG9tZS5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc3x8e2V4YWN0OmZhbHNlfVxcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtLWxpbmtcXFwiIChjbGljayk9XFxcIml0ZW1DbGljaygkZXZlbnQsIGhvbWUpXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtZGlzYWJsZWQnOmhvbWUuZGlzYWJsZWR9XFxcIiBbYXR0ci50YXJnZXRdPVxcXCJob21lLnRhcmdldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWhvbWVcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1icmVhZGNydW1iLWNoZXZyb24gZmEgZmEtY2hldnJvbi1yaWdodFxcXCIgKm5nSWY9XFxcIm1vZGVsXFxcIj48L2xpPlxcbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWl0ZW0gbGV0LWVuZD1cXFwibGFzdFxcXCIgW25nRm9yT2ZdPVxcXCJtb2RlbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGkgcm9sZT1cXFwibWVudWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCIhaXRlbS5yb3V0ZXJMaW5rXFxcIiBbaHJlZl09XFxcIml0ZW0udXJsfHwnIydcXFwiIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1saW5rXFxcIiAoY2xpY2spPVxcXCJpdGVtQ2xpY2soJGV2ZW50LCBpdGVtKVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1kaXNhYmxlZCc6aXRlbS5kaXNhYmxlZH1cXFwiIFthdHRyLnRhcmdldF09XFxcIml0ZW0udGFyZ2V0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLXRleHRcXFwiPnt7aXRlbS5sYWJlbH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiaXRlbS5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua109XFxcIml0ZW0ucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCIndWktc3RhdGUtYWN0aXZlJ1xcXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cXFwiaXRlbS5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc3x8e2V4YWN0OmZhbHNlfVxcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtLWxpbmtcXFwiIChjbGljayk9XFxcIml0ZW1DbGljaygkZXZlbnQsIGl0ZW0pXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzppdGVtLmRpc2FibGVkfVxcXCIgW2F0dHIudGFyZ2V0XT1cXFwiaXRlbS50YXJnZXRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0tdGV4dFxcXCI+e3tpdGVtLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktYnJlYWRjcnVtYi1jaGV2cm9uIGZhIGZhLWNoZXZyb24tcmlnaHRcXFwiICpuZ0lmPVxcXCIhZW5kXFxcIj48L2xpPlxcbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCJcbiAgICB9KVxuXSwgQnJlYWRjcnVtYik7XG5leHBvcnRzLkJyZWFkY3J1bWIgPSBCcmVhZGNydW1iO1xudmFyIEJyZWFkY3J1bWJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyZWFkY3J1bWJNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBCcmVhZGNydW1iTW9kdWxlO1xufSgpKTtcbkJyZWFkY3J1bWJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlLCByb3V0ZXJfMS5Sb3V0ZXJNb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbQnJlYWRjcnVtYiwgcm91dGVyXzEuUm91dGVyTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQnJlYWRjcnVtYl1cbiAgICB9KVxuXSwgQnJlYWRjcnVtYk1vZHVsZSk7XG5leHBvcnRzLkJyZWFkY3J1bWJNb2R1bGUgPSBCcmVhZGNydW1iTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJlYWRjcnVtYi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2JyZWFkY3J1bWIvYnJlYWRjcnVtYi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2JyZWFkY3J1bWIvYnJlYWRjcnVtYi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBCdXR0b24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1dHRvbihlbCwgZG9tSGFuZGxlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMuaWNvblBvcyA9ICdsZWZ0JztcbiAgICAgICAgdGhpcy5jb3JuZXJTdHlsZUNsYXNzID0gJ3VpLWNvcm5lci1hbGwnO1xuICAgIH1cbiAgICBCdXR0b24ucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFkZE11bHRpcGxlQ2xhc3Nlcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZ2V0U3R5bGVDbGFzcygpKTtcbiAgICAgICAgaWYgKHRoaXMuaWNvbikge1xuICAgICAgICAgICAgdmFyIGljb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICB2YXIgaWNvblBvc0NsYXNzID0gKHRoaXMuaWNvblBvcyA9PSAncmlnaHQnKSA/ICd1aS1idXR0b24taWNvbi1yaWdodCcgOiAndWktYnV0dG9uLWljb24tbGVmdCc7XG4gICAgICAgICAgICBpY29uRWxlbWVudC5jbGFzc05hbWUgPSBpY29uUG9zQ2xhc3MgKyAnIHVpLWNsaWNrYWJsZSBmYSBmYS1mdyAnICsgdGhpcy5pY29uO1xuICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGxhYmVsRWxlbWVudC5jbGFzc05hbWUgPSAndWktYnV0dG9uLXRleHQgdWktY2xpY2thYmxlJztcbiAgICAgICAgbGFiZWxFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubGFiZWwgfHwgJ3VpLWJ0bicpKTtcbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWxlbWVudCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgQnV0dG9uLnByb3RvdHlwZS5nZXRTdHlsZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGVDbGFzcyA9ICd1aS1idXR0b24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgJyArIHRoaXMuY29ybmVyU3R5bGVDbGFzcztcbiAgICAgICAgaWYgKHRoaXMuaWNvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWwgIT0gbnVsbCAmJiB0aGlzLmxhYmVsICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmljb25Qb3MgPT0gJ2xlZnQnKVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUNsYXNzID0gc3R5bGVDbGFzcyArICcgdWktYnV0dG9uLXRleHQtaWNvbi1sZWZ0JztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlQ2xhc3MgPSBzdHlsZUNsYXNzICsgJyB1aS1idXR0b24tdGV4dC1pY29uLXJpZ2h0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlQ2xhc3MgPSBzdHlsZUNsYXNzICsgJyB1aS1idXR0b24taWNvbi1vbmx5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlQ2xhc3MgPSBzdHlsZUNsYXNzICsgJyB1aS1idXR0b24tdGV4dC1vbmx5JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVDbGFzcztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdXR0b24ucHJvdG90eXBlLCBcImxhYmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJy51aS1idXR0b24tdGV4dCcpLnRleHRDb250ZW50ID0gdGhpcy5fbGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdXR0b24ucHJvdG90eXBlLCBcImljb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pY29uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljb24gPSB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHZhciBpY29uUG9zQ2xhc3MgPSAodGhpcy5pY29uUG9zID09ICdyaWdodCcpID8gJ3VpLWJ1dHRvbi1pY29uLXJpZ2h0JyA6ICd1aS1idXR0b24taWNvbi1sZWZ0JztcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICcuZmEnKS5jbGFzc05hbWUgPVxuICAgICAgICAgICAgICAgICAgICBpY29uUG9zQ2xhc3MgKyAnIHVpLWNsaWNrYWJsZSBmYSBmYS1mdyAnICsgdGhpcy5pY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCdXR0b24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5lbC5uYXRpdmVFbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWwubmF0aXZlRWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBCdXR0b247XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEJ1dHRvbi5wcm90b3R5cGUsIFwiaWNvblBvc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEJ1dHRvbi5wcm90b3R5cGUsIFwiY29ybmVyU3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQnV0dG9uLnByb3RvdHlwZSwgXCJsYWJlbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIEJ1dHRvbi5wcm90b3R5cGUsIFwiaWNvblwiLCBudWxsKTtcbkJ1dHRvbiA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5EaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1twQnV0dG9uXScsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIEJ1dHRvbik7XG5leHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcbnZhciBCdXR0b25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1dHRvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEJ1dHRvbk1vZHVsZTtcbn0oKSk7XG5CdXR0b25Nb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0J1dHRvbl0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW0J1dHRvbl1cbiAgICB9KVxuXSwgQnV0dG9uTW9kdWxlKTtcbmV4cG9ydHMuQnV0dG9uTW9kdWxlID0gQnV0dG9uTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2J1dHRvbi9idXR0b24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGFuaW1hdGlvbnNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9hbmltYXRpb25zXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi9idXR0b24vYnV0dG9uXCIpO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbnZhciBmb3Jtc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpO1xuZXhwb3J0cy5DQUxFTkRBUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBmb3Jtc18xLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBDYWxlbmRhcjsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG5leHBvcnRzLkNBTEVOREFSX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBmb3Jtc18xLk5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENhbGVuZGFyOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBDYWxlbmRhciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXIoZWwsIGRvbUhhbmRsZXIsIHJlbmRlcmVyLCBjZCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmRhdGVGb3JtYXQgPSAnbW0vZGQveXknO1xuICAgICAgICB0aGlzLmlubGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3dPdGhlck1vbnRocyA9IHRydWU7XG4gICAgICAgIHRoaXMuaWNvbiA9ICdmYS1jYWxlbmRhcic7XG4gICAgICAgIHRoaXMuc2hvcnRZZWFyQ3V0b2ZmID0gJysxMCc7XG4gICAgICAgIHRoaXMuaG91ckZvcm1hdCA9ICcyNCc7XG4gICAgICAgIHRoaXMuc3RlcEhvdXIgPSAxO1xuICAgICAgICB0aGlzLnN0ZXBNaW51dGUgPSAxO1xuICAgICAgICB0aGlzLnN0ZXBTZWNvbmQgPSAxO1xuICAgICAgICB0aGlzLnNob3dTZWNvbmRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvd09uRm9jdXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRhdGFUeXBlID0gJ2RhdGUnO1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25DbG9zZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25TZWxlY3QgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uSW5wdXQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSB7XG4gICAgICAgICAgICBmaXJzdERheU9mV2VlazogMCxcbiAgICAgICAgICAgIGRheU5hbWVzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICAgICAgICAgIGRheU5hbWVzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICAgICAgICAgIGRheU5hbWVzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbG9zZU92ZXJsYXkgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYWxlbmRhci5wcm90b3R5cGUsIFwibWluRGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbkRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21pbkRhdGUgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVNb250aCh0aGlzLmN1cnJlbnRNb250aCwgdGhpcy5jdXJyZW50WWVhcik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYWxlbmRhci5wcm90b3R5cGUsIFwibWF4RGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heERhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21heERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVNb250aCh0aGlzLmN1cnJlbnRNb250aCwgdGhpcy5jdXJyZW50WWVhcik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYWxlbmRhci5wcm90b3R5cGUsIFwibG9jYWxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMb2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlV2Vla0RheXMoKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTW9udGgodGhpcy5jdXJyZW50TW9udGgsIHRoaXMuY3VycmVudFllYXIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5kZWZhdWx0RGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZVdlZWtEYXlzKCk7XG4gICAgICAgIHRoaXMuY3VycmVudE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB0aGlzLnBtID0gZGF0ZS5nZXRIb3VycygpID4gMTE7XG4gICAgICAgIGlmICh0aGlzLnNob3dUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNaW51dGUgPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlY29uZCA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaG91ckZvcm1hdCA9PSAnMTInKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEhvdXIgPSBkYXRlLmdldEhvdXJzKCkgPT0gMCA/IDEyIDogZGF0ZS5nZXRIb3VycygpICUgMTI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SG91ciA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRpbWVPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNaW51dGUgPSAwO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SG91ciA9IDA7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWNvbmQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGgodGhpcy5jdXJyZW50TW9udGgsIHRoaXMuY3VycmVudFllYXIpO1xuICAgICAgICB0aGlzLnRpY2tzVG8xOTcwID0gKCgoMTk3MCAtIDEpICogMzY1ICsgTWF0aC5mbG9vcigxOTcwIC8gNCkgLSBNYXRoLmZsb29yKDE5NzAgLyAxMDApICtcbiAgICAgICAgICAgIE1hdGguZmxvb3IoMTk3MCAvIDQwMCkpICogMjQgKiA2MCAqIDYwICogMTAwMDAwMDApO1xuICAgICAgICBpZiAodGhpcy55ZWFyTmF2aWdhdG9yICYmIHRoaXMueWVhclJhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnllYXJPcHRpb25zID0gW107XG4gICAgICAgICAgICB2YXIgeWVhcnMgPSB0aGlzLnllYXJSYW5nZS5zcGxpdCgnOicpLCB5ZWFyU3RhcnQgPSBwYXJzZUludCh5ZWFyc1swXSksIHllYXJFbmQgPSBwYXJzZUludCh5ZWFyc1sxXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0geWVhclN0YXJ0OyBpIDw9IHllYXJFbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMueWVhck9wdGlvbnMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlubGluZSAmJiB0aGlzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUbyA9PT0gJ2JvZHknKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCwgdGhpcy5hcHBlbmRUbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlTaG93bikge1xuICAgICAgICAgICAgdGhpcy5hbGlnbk92ZXJsYXkoKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVNob3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jcmVhdGVXZWVrRGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53ZWVrRGF5cyA9IFtdO1xuICAgICAgICB2YXIgZGF5SW5kZXggPSB0aGlzLmxvY2FsZS5maXJzdERheU9mV2VlaztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud2Vla0RheXMucHVzaCh0aGlzLmxvY2FsZS5kYXlOYW1lc01pbltkYXlJbmRleF0pO1xuICAgICAgICAgICAgZGF5SW5kZXggPSAoZGF5SW5kZXggPT0gNikgPyAwIDogKytkYXlJbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNyZWF0ZU1vbnRoID0gZnVuY3Rpb24gKG1vbnRoLCB5ZWFyKSB7XG4gICAgICAgIHRoaXMuZGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50TW9udGggPSBtb250aDtcbiAgICAgICAgdGhpcy5jdXJyZW50WWVhciA9IHllYXI7XG4gICAgICAgIHRoaXMuY3VycmVudE1vbnRoVGV4dCA9IHRoaXMubG9jYWxlLm1vbnRoTmFtZXNbbW9udGhdO1xuICAgICAgICB2YXIgZmlyc3REYXkgPSB0aGlzLmdldEZpcnN0RGF5T2ZNb250aEluZGV4KG1vbnRoLCB5ZWFyKTtcbiAgICAgICAgdmFyIGRheXNMZW5ndGggPSB0aGlzLmdldERheXNDb3VudEluTW9udGgobW9udGgsIHllYXIpO1xuICAgICAgICB2YXIgcHJldk1vbnRoRGF5c0xlbmd0aCA9IHRoaXMuZ2V0RGF5c0NvdW50SW5QcmV2TW9udGgobW9udGgsIHllYXIpO1xuICAgICAgICB2YXIgc3VuZGF5SW5kZXggPSB0aGlzLmdldFN1bmRheUluZGV4KCk7XG4gICAgICAgIHZhciBkYXlObyA9IDE7XG4gICAgICAgIHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgd2VlayA9IFtdO1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAocHJldk1vbnRoRGF5c0xlbmd0aCAtIGZpcnN0RGF5ICsgMSk7IGogPD0gcHJldk1vbnRoRGF5c0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXRQcmV2aW91c01vbnRoQW5kWWVhcihtb250aCwgeWVhcik7XG4gICAgICAgICAgICAgICAgICAgIHdlZWsucHVzaCh7IGRheTogaiwgbW9udGg6IHByZXYubW9udGgsIHllYXI6IHByZXYueWVhciwgb3RoZXJNb250aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZGF5OiB0aGlzLmlzVG9kYXkodG9kYXksIGosIHByZXYubW9udGgsIHByZXYueWVhciksIHNlbGVjdGFibGU6IHRoaXMuaXNTZWxlY3RhYmxlKGosIHByZXYubW9udGgsIHByZXYueWVhcikgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdEYXlzTGVuZ3RoID0gNyAtIHdlZWsubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVtYWluaW5nRGF5c0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWsucHVzaCh7IGRheTogZGF5Tm8sIG1vbnRoOiBtb250aCwgeWVhcjogeWVhciwgdG9kYXk6IHRoaXMuaXNUb2RheSh0b2RheSwgZGF5Tm8sIG1vbnRoLCB5ZWFyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IHRoaXMuaXNTZWxlY3RhYmxlKGRheU5vLCBtb250aCwgeWVhcikgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRheU5vKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRheU5vID4gZGF5c0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHRNb250aEFuZFllYXIobW9udGgsIHllYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Vlay5wdXNoKHsgZGF5OiBkYXlObyAtIGRheXNMZW5ndGgsIG1vbnRoOiBuZXh0Lm1vbnRoLCB5ZWFyOiBuZXh0LnllYXIsIG90aGVyTW9udGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9kYXk6IHRoaXMuaXNUb2RheSh0b2RheSwgZGF5Tm8gLSBkYXlzTGVuZ3RoLCBuZXh0Lm1vbnRoLCBuZXh0LnllYXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IHRoaXMuaXNTZWxlY3RhYmxlKChkYXlObyAtIGRheXNMZW5ndGgpLCBuZXh0Lm1vbnRoLCBuZXh0LnllYXIpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Vlay5wdXNoKHsgZGF5OiBkYXlObywgbW9udGg6IG1vbnRoLCB5ZWFyOiB5ZWFyLCB0b2RheTogdGhpcy5pc1RvZGF5KHRvZGF5LCBkYXlObywgbW9udGgsIHllYXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IHRoaXMuaXNTZWxlY3RhYmxlKGRheU5vLCBtb250aCwgeWVhcikgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF5Tm8rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGVzLnB1c2god2Vlayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2TW9udGggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1vbnRoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNb250aCA9IDExO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50WWVhci0tO1xuICAgICAgICAgICAgaWYgKHRoaXMueWVhck5hdmlnYXRvciAmJiB0aGlzLmN1cnJlbnRZZWFyIDwgdGhpcy55ZWFyT3B0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFllYXIgPSB0aGlzLnllYXJPcHRpb25zW3RoaXMueWVhck9wdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNb250aC0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGgodGhpcy5jdXJyZW50TW9udGgsIHRoaXMuY3VycmVudFllYXIpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHRNb250aCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50TW9udGggPT09IDExKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNb250aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRZZWFyKys7XG4gICAgICAgICAgICBpZiAodGhpcy55ZWFyTmF2aWdhdG9yICYmIHRoaXMuY3VycmVudFllYXIgPiB0aGlzLnllYXJPcHRpb25zW3RoaXMueWVhck9wdGlvbnMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRZZWFyID0gdGhpcy55ZWFyT3B0aW9uc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1vbnRoKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVNb250aCh0aGlzLmN1cnJlbnRNb250aCwgdGhpcy5jdXJyZW50WWVhcik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub25EYXRlU2VsZWN0ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRlTWV0YSkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhZGF0ZU1ldGEuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZU1ldGEub3RoZXJNb250aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0T3RoZXJNb250aHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNb250aCA9IGRhdGVNZXRhLm1vbnRoO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFllYXIgPSBkYXRlTWV0YS55ZWFyO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlTW9udGgodGhpcy5jdXJyZW50TW9udGgsIHRoaXMuY3VycmVudFllYXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0RGF0ZShkYXRlTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdERhdGUoZGF0ZU1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVJbnB1dGZpZWxkKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlSW5wdXRmaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVPbmx5KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLmZvcm1hdFRpbWUodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZm9ybWF0RGF0ZSh0aGlzLnZhbHVlLCB0aGlzLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3dUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlICs9ICcgJyArIHRoaXMuZm9ybWF0VGltZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkVmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgICAgIGlmICh0aGlzLmlucHV0ZmllbGRWaWV3Q2hpbGQgJiYgdGhpcy5pbnB1dGZpZWxkVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRmaWVsZFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5pbnB1dEZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5zZWxlY3REYXRlID0gZnVuY3Rpb24gKGRhdGVNZXRhKSB7XG4gICAgICAgIGlmICh0aGlzLnV0YylcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgRGF0ZShEYXRlLlVUQyhkYXRlTWV0YS55ZWFyLCBkYXRlTWV0YS5tb250aCwgZGF0ZU1ldGEuZGF5KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgRGF0ZShkYXRlTWV0YS55ZWFyLCBkYXRlTWV0YS5tb250aCwgZGF0ZU1ldGEuZGF5KTtcbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdXJGb3JtYXQgPT09ICcxMicgJiYgdGhpcy5wbSAmJiB0aGlzLmN1cnJlbnRIb3VyICE9IDEyKVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuc2V0SG91cnModGhpcy5jdXJyZW50SG91ciArIDEyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnNldEhvdXJzKHRoaXMuY3VycmVudEhvdXIpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5zZXRNaW51dGVzKHRoaXMuY3VycmVudE1pbnV0ZSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnNldFNlY29uZHModGhpcy5jdXJyZW50U2Vjb25kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbCgpO1xuICAgICAgICB0aGlzLm9uU2VsZWN0LmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFUeXBlID09ICdkYXRlJykge1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGF0YVR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVPbmx5KVxuICAgICAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLmZvcm1hdFRpbWUodGhpcy52YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLmZvcm1hdERhdGUodGhpcy52YWx1ZSwgdGhpcy5kYXRlRm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRGaXJzdERheU9mTW9udGhJbmRleCA9IGZ1bmN0aW9uIChtb250aCwgeWVhcikge1xuICAgICAgICB2YXIgZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgZGF5LnNldERhdGUoMSk7XG4gICAgICAgIGRheS5zZXRNb250aChtb250aCk7XG4gICAgICAgIGRheS5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgICAgdmFyIGRheUluZGV4ID0gZGF5LmdldERheSgpICsgdGhpcy5nZXRTdW5kYXlJbmRleCgpO1xuICAgICAgICByZXR1cm4gZGF5SW5kZXggPj0gNyA/IGRheUluZGV4IC0gNyA6IGRheUluZGV4O1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldERheXNDb3VudEluTW9udGggPSBmdW5jdGlvbiAobW9udGgsIHllYXIpIHtcbiAgICAgICAgcmV0dXJuIDMyIC0gdGhpcy5kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMzIpKS5nZXREYXRlKCk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RGF5c0NvdW50SW5QcmV2TW9udGggPSBmdW5jdGlvbiAobW9udGgsIHllYXIpIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLmdldFByZXZpb3VzTW9udGhBbmRZZWFyKG1vbnRoLCB5ZWFyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF5c0NvdW50SW5Nb250aChwcmV2Lm1vbnRoLCBwcmV2LnllYXIpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldFByZXZpb3VzTW9udGhBbmRZZWFyID0gZnVuY3Rpb24gKG1vbnRoLCB5ZWFyKSB7XG4gICAgICAgIHZhciBtLCB5O1xuICAgICAgICBpZiAobW9udGggPT09IDApIHtcbiAgICAgICAgICAgIG0gPSAxMTtcbiAgICAgICAgICAgIHkgPSB5ZWFyIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBtb250aCAtIDE7XG4gICAgICAgICAgICB5ID0geWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAnbW9udGgnOiBtLCAneWVhcic6IHkgfTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXROZXh0TW9udGhBbmRZZWFyID0gZnVuY3Rpb24gKG1vbnRoLCB5ZWFyKSB7XG4gICAgICAgIHZhciBtLCB5O1xuICAgICAgICBpZiAobW9udGggPT09IDExKSB7XG4gICAgICAgICAgICBtID0gMDtcbiAgICAgICAgICAgIHkgPSB5ZWFyICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBtb250aCArIDE7XG4gICAgICAgICAgICB5ID0geWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAnbW9udGgnOiBtLCAneWVhcic6IHkgfTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRTdW5kYXlJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlLmZpcnN0RGF5T2ZXZWVrID4gMCA/IDcgLSB0aGlzLmxvY2FsZS5maXJzdERheU9mV2VlayA6IDA7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIChkYXRlTWV0YSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmdldERhdGUoKSA9PT0gZGF0ZU1ldGEuZGF5ICYmIHRoaXMudmFsdWUuZ2V0TW9udGgoKSA9PT0gZGF0ZU1ldGEubW9udGggJiYgdGhpcy52YWx1ZS5nZXRGdWxsWWVhcigpID09PSBkYXRlTWV0YS55ZWFyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXNUb2RheSA9IGZ1bmN0aW9uICh0b2RheSwgZGF5LCBtb250aCwgeWVhcikge1xuICAgICAgICByZXR1cm4gdG9kYXkuZ2V0RGF0ZSgpID09PSBkYXkgJiYgdG9kYXkuZ2V0TW9udGgoKSA9PT0gbW9udGggJiYgdG9kYXkuZ2V0RnVsbFllYXIoKSA9PT0geWVhcjtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pc1NlbGVjdGFibGUgPSBmdW5jdGlvbiAoZGF5LCBtb250aCwgeWVhcikge1xuICAgICAgICB2YXIgdmFsaWRNaW4gPSB0cnVlO1xuICAgICAgICB2YXIgdmFsaWRNYXggPSB0cnVlO1xuICAgICAgICB2YXIgdmFsaWREYXRlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHZhbGlkRGF5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubWluRGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWluRGF0ZS5nZXRGdWxsWWVhcigpID4geWVhcikge1xuICAgICAgICAgICAgICAgIHZhbGlkTWluID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pbkRhdGUuZ2V0TW9udGgoKSA+IG1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkTWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWluRGF0ZS5nZXRNb250aCgpID09PSBtb250aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5EYXRlLmdldERhdGUoKSA+IGRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRNaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhEYXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkgPCB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRNYXggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF4RGF0ZS5nZXRGdWxsWWVhcigpID09PSB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4RGF0ZS5nZXRNb250aCgpIDwgbW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRNYXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXhEYXRlLmdldE1vbnRoKCkgPT09IG1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heERhdGUuZ2V0RGF0ZSgpIDwgZGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZE1heCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkRGF0ZXMpIHtcbiAgICAgICAgICAgIHZhbGlkRGF0ZSA9ICF0aGlzLmlzRGF0ZURpc2FibGVkKGRheSwgbW9udGgsIHllYXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkRGF5cykge1xuICAgICAgICAgICAgdmFsaWREYXkgPSAhdGhpcy5pc0RheURpc2FibGVkKGRheSwgbW9udGgsIHllYXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZE1pbiAmJiB2YWxpZE1heCAmJiB2YWxpZERhdGUgJiYgdmFsaWREYXk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXNEYXRlRGlzYWJsZWQgPSBmdW5jdGlvbiAoZGF5LCBtb250aCwgeWVhcikge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZERhdGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5kaXNhYmxlZERhdGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZERhdGUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkRGF0ZS5nZXRGdWxsWWVhcigpID09PSB5ZWFyICYmIGRpc2FibGVkRGF0ZS5nZXRNb250aCgpID09PSBtb250aCAmJiBkaXNhYmxlZERhdGUuZ2V0RGF0ZSgpID09PSBkYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pc0RheURpc2FibGVkID0gZnVuY3Rpb24gKGRheSwgbW9udGgsIHllYXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWREYXlzKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgICAgICAgICAgdmFyIHdlZWtkYXlOdW1iZXIgPSB3ZWVrZGF5LmdldERheSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWREYXlzLmluZGV4T2Yod2Vla2RheU51bWJlcikgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnNob3dPbkZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm9uSW5wdXRCbHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkJsdXIuZW1pdChldmVudCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5wdXRmaWVsZCgpO1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkKCk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub25CdXR0b25DbGljayA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRmaWVsZCkge1xuICAgICAgICB0aGlzLmNsb3NlT3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMub3ZlcmxheVZpZXdDaGlsZC5uYXRpdmVFbGVtZW50Lm9mZnNldFBhcmVudCB8fCB0aGlzLm92ZXJsYXlWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGlucHV0ZmllbGQuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd092ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNsb3NlT3ZlcmxheSA9IHRydWU7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub25JbnB1dEtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pc0tleWRvd24gPSB0cnVlO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gOSkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub25Nb250aERyb3Bkb3duQ2hhbmdlID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TW9udGggPSBwYXJzZUludChtKTtcbiAgICAgICAgdGhpcy5jcmVhdGVNb250aCh0aGlzLmN1cnJlbnRNb250aCwgdGhpcy5jdXJyZW50WWVhcik7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub25ZZWFyRHJvcGRvd25DaGFuZ2UgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRZZWFyID0gcGFyc2VJbnQoeSk7XG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGgodGhpcy5jdXJyZW50TW9udGgsIHRoaXMuY3VycmVudFllYXIpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluY3JlbWVudEhvdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5ld0hvdXIgPSB0aGlzLmN1cnJlbnRIb3VyICsgdGhpcy5zdGVwSG91cjtcbiAgICAgICAgaWYgKHRoaXMuaG91ckZvcm1hdCA9PSAnMjQnKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SG91ciA9IChuZXdIb3VyID49IDI0KSA/IChuZXdIb3VyIC0gMjQpIDogbmV3SG91cjtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5ob3VyRm9ybWF0ID09ICcxMicpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRIb3VyID0gKG5ld0hvdXIgPj0gMTMpID8gKG5ld0hvdXIgLSAxMikgOiBuZXdIb3VyO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5kZWNyZW1lbnRIb3VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBuZXdIb3VyID0gdGhpcy5jdXJyZW50SG91ciAtIHRoaXMuc3RlcEhvdXI7XG4gICAgICAgIGlmICh0aGlzLmhvdXJGb3JtYXQgPT0gJzI0JylcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEhvdXIgPSAobmV3SG91ciA8IDApID8gKDI0ICsgbmV3SG91cikgOiBuZXdIb3VyO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmhvdXJGb3JtYXQgPT0gJzEyJylcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEhvdXIgPSAobmV3SG91ciA8PSAwKSA/ICgxMiArIG5ld0hvdXIpIDogbmV3SG91cjtcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5jcmVtZW50TWludXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBuZXdNaW51dGUgPSB0aGlzLmN1cnJlbnRNaW51dGUgKyB0aGlzLnN0ZXBNaW51dGU7XG4gICAgICAgIHRoaXMuY3VycmVudE1pbnV0ZSA9IChuZXdNaW51dGUgPiA1OSkgPyBuZXdNaW51dGUgLSA2MCA6IG5ld01pbnV0ZTtcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZGVjcmVtZW50TWludXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBuZXdNaW51dGUgPSB0aGlzLmN1cnJlbnRNaW51dGUgLSB0aGlzLnN0ZXBNaW51dGU7XG4gICAgICAgIHRoaXMuY3VycmVudE1pbnV0ZSA9IChuZXdNaW51dGUgPCAwKSA/IDYwICsgbmV3TWludXRlIDogbmV3TWludXRlO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbmNyZW1lbnRTZWNvbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5ld1NlY29uZCA9IHRoaXMuY3VycmVudFNlY29uZCArIHRoaXMuc3RlcFNlY29uZDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2Vjb25kID0gKG5ld1NlY29uZCA+IDU5KSA/IG5ld1NlY29uZCAtIDYwIDogbmV3U2Vjb25kO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5kZWNyZW1lbnRTZWNvbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5ld1NlY29uZCA9IHRoaXMuY3VycmVudFNlY29uZCAtIHRoaXMuc3RlcFNlY29uZDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2Vjb25kID0gKG5ld1NlY29uZCA8IDApID8gNjAgKyBuZXdTZWNvbmQgOiBuZXdTZWNvbmQ7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZVRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLmhvdXJGb3JtYXQgPT09ICcxMicgJiYgdGhpcy5wbSAmJiB0aGlzLmN1cnJlbnRIb3VyICE9IDEyKVxuICAgICAgICAgICAgdGhpcy52YWx1ZS5zZXRIb3Vycyh0aGlzLmN1cnJlbnRIb3VyICsgMTIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnNldEhvdXJzKHRoaXMuY3VycmVudEhvdXIpO1xuICAgICAgICB0aGlzLnZhbHVlLnNldE1pbnV0ZXModGhpcy5jdXJyZW50TWludXRlKTtcbiAgICAgICAgdGhpcy52YWx1ZS5zZXRTZWNvbmRzKHRoaXMuY3VycmVudFNlY29uZCk7XG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWwoKTtcbiAgICAgICAgdGhpcy5vblNlbGVjdC5lbWl0KHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUlucHV0ZmllbGQoKTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS50b2dnbGVBTVBNID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG0gPSAhdGhpcy5wbTtcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub25Vc2VySW5wdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gSUUgMTEgV29ya2Fyb3VuZCBmb3IgaW5wdXQgcGxhY2Vob2xkZXIgOiBodHRwczovL2dpdGh1Yi5jb20vcHJpbWVmYWNlcy9wcmltZW5nL2lzc3Vlcy8yMDI2XG4gICAgICAgIGlmICghdGhpcy5pc0tleWRvd24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzS2V5ZG93biA9IGZhbHNlO1xuICAgICAgICB2YXIgdmFsID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMucGFyc2VWYWx1ZUZyb21TdHJpbmcodmFsKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVUkoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vaW52YWxpZCBkYXRlXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGxlZCA9IHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGg7XG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWwoKTtcbiAgICAgICAgdGhpcy5vbklucHV0LmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnBhcnNlVmFsdWVGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgaWYgKCF0ZXh0IHx8IHRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGVWYWx1ZTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGV4dC5zcGxpdCgnICcpO1xuICAgICAgICBpZiAodGhpcy50aW1lT25seSkge1xuICAgICAgICAgICAgZGF0ZVZhbHVlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVUaW1lKGRhdGVWYWx1ZSwgcGFydHNbMF0sIHBhcnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dUaW1lKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVZhbHVlID0gdGhpcy5wYXJzZURhdGUocGFydHNbMF0sIHRoaXMuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZVRpbWUoZGF0ZVZhbHVlLCBwYXJ0c1sxXSwgcGFydHNbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZVZhbHVlID0gdGhpcy5wYXJzZURhdGUodGV4dCwgdGhpcy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnBvcHVsYXRlVGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdGltZVN0cmluZywgYW1wbSkge1xuICAgICAgICBpZiAodGhpcy5ob3VyRm9ybWF0ID09ICcxMicgJiYgIWFtcG0pIHtcbiAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIFRpbWUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG0gPSAoYW1wbSA9PT0gJ1BNJyB8fCBhbXBtID09PSAncG0nKTtcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLnBhcnNlVGltZSh0aW1lU3RyaW5nKTtcbiAgICAgICAgdmFsdWUuc2V0SG91cnModGltZS5ob3VyKTtcbiAgICAgICAgdmFsdWUuc2V0TWludXRlcyh0aW1lLm1pbnV0ZSk7XG4gICAgICAgIHZhbHVlLnNldFNlY29uZHModGltZS5zZWNvbmQpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZVVJID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZSB8fCB0aGlzLmRlZmF1bHREYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGgodmFsLmdldE1vbnRoKCksIHZhbC5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWUgfHwgdGhpcy50aW1lT25seSkge1xuICAgICAgICAgICAgdmFyIGhvdXJzID0gdmFsLmdldEhvdXJzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ob3VyRm9ybWF0ID09ICcxMicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPj0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SG91ciA9IChob3VycyA9PSAxMikgPyAxMiA6IGhvdXJzIC0gMTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRIb3VyID0gKGhvdXJzID09IDApID8gMTIgOiBob3VycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRIb3VyID0gdmFsLmdldEhvdXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNaW51dGUgPSB2YWwuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2Vjb25kID0gdmFsLmdldFNlY29uZHMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm9uRGF0ZVBpY2tlckNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuY2xvc2VPdmVybGF5ID0gdGhpcy5kYXRlQ2xpY2s7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuc2hvd092ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheVZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm92ZXJsYXlTaG93biA9IHRydWU7XG4gICAgICAgIHRoaXMub3ZlcmxheVZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLnpJbmRleCA9IFN0cmluZygrK2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLnppbmRleCk7XG4gICAgICAgIHRoaXMuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmFsaWduT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pXG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbih0aGlzLm92ZXJsYXlWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCwgdGhpcy5pbnB1dGZpZWxkVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIucmVsYXRpdmVQb3NpdGlvbih0aGlzLm92ZXJsYXlWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCwgdGhpcy5pbnB1dGZpZWxkVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAmJiB0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnBhcnNlVmFsdWVGcm9tU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlSW5wdXRmaWVsZCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZm47XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHZhbDtcbiAgICB9O1xuICAgIC8vIFBvcnRlZCBmcm9tIGpxdWVyeS11aSBkYXRlcGlja2VyIGZvcm1hdERhdGUgICAgXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmZvcm1hdERhdGUgPSBmdW5jdGlvbiAoZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlGb3JtYXQsIGxvb2tBaGVhZCA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09PSBtYXRjaCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGlGb3JtYXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9LCBmb3JtYXROdW1iZXIgPSBmdW5jdGlvbiAobWF0Y2gsIHZhbHVlLCBsZW4pIHtcbiAgICAgICAgICAgIHZhciBudW0gPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICBpZiAobG9va0FoZWFkKG1hdGNoKSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChudW0ubGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bSA9IFwiMFwiICsgbnVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH0sIGZvcm1hdE5hbWUgPSBmdW5jdGlvbiAobWF0Y2gsIHZhbHVlLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lc1t2YWx1ZV0gOiBzaG9ydE5hbWVzW3ZhbHVlXSk7XG4gICAgICAgIH0sIG91dHB1dCA9IFwiXCIsIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgIGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJkXCIsIGRhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGZvcm1hdE5hbWUoXCJEXCIsIGRhdGUuZ2V0RGF5KCksIHRoaXMubG9jYWxlLmRheU5hbWVzU2hvcnQsIHRoaXMubG9jYWxlLmRheU5hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGZvcm1hdE51bWJlcihcIm9cIiwgTWF0aC5yb3VuZCgobmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDApLmdldFRpbWUoKSkgLyA4NjQwMDAwMCksIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKFwibVwiLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGZvcm1hdE5hbWUoXCJNXCIsIGRhdGUuZ2V0TW9udGgoKSwgdGhpcy5sb2NhbGUubW9udGhOYW1lc1Nob3J0LCB0aGlzLmxvY2FsZS5tb250aE5hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IChsb29rQWhlYWQoXCJ5XCIpID8gZGF0ZS5nZXRGdWxsWWVhcigpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGUuZ2V0RnVsbFllYXIoKSAlIDEwMCA8IDEwID8gXCIwXCIgOiBcIlwiKSArIGRhdGUuZ2V0RnVsbFllYXIoKSAlIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpICogMTAwMDAgKyB0aGlzLnRpY2tzVG8xOTcwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkKFwiJ1wiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IFwiJ1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZm9ybWF0VGltZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgICB2YXIgbWludXRlcyA9IGRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICB2YXIgc2Vjb25kcyA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICBpZiAodGhpcy5ob3VyRm9ybWF0ID09ICcxMicgJiYgaG91cnMgPiAxMSAmJiBob3VycyAhPSAxMikge1xuICAgICAgICAgICAgaG91cnMgLT0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IChob3VycyA8IDEwKSA/ICcwJyArIGhvdXJzIDogaG91cnM7XG4gICAgICAgIG91dHB1dCArPSAnOic7XG4gICAgICAgIG91dHB1dCArPSAobWludXRlcyA8IDEwKSA/ICcwJyArIG1pbnV0ZXMgOiBtaW51dGVzO1xuICAgICAgICBpZiAodGhpcy5zaG93U2Vjb25kcykge1xuICAgICAgICAgICAgb3V0cHV0ICs9ICc6JztcbiAgICAgICAgICAgIG91dHB1dCArPSAoc2Vjb25kcyA8IDEwKSA/ICcwJyArIHNlY29uZHMgOiBzZWNvbmRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvdXJGb3JtYXQgPT0gJzEyJykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGRhdGUuZ2V0SG91cnMoKSA+IDExID8gJyBQTScgOiAnIEFNJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnBhcnNlVGltZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdG9rZW5zID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdmFyIHZhbGlkVG9rZW5MZW5ndGggPSB0aGlzLnNob3dTZWNvbmRzID8gMyA6IDI7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoICE9PSB2YWxpZFRva2VuTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGltZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoID0gcGFyc2VJbnQodG9rZW5zWzBdKTtcbiAgICAgICAgdmFyIG0gPSBwYXJzZUludCh0b2tlbnNbMV0pO1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2hvd1NlY29uZHMgPyBwYXJzZUludCh0b2tlbnNbMl0pIDogbnVsbDtcbiAgICAgICAgaWYgKGlzTmFOKGgpIHx8IGlzTmFOKG0pIHx8IGggPiAyMyB8fCBtID4gNTkgfHwgKHRoaXMuaG91ckZvcm1hdCA9PSAnMTInICYmIGggPiAxMikgfHwgKHRoaXMuc2hvd1NlY29uZHMgJiYgKGlzTmFOKHMpIHx8IHMgPiA1OSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGltZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaG91ckZvcm1hdCA9PSAnMTInICYmIGggIT09IDEyICYmIHRoaXMucG0pIHtcbiAgICAgICAgICAgICAgICBoICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgaG91cjogaCwgbWludXRlOiBtLCBzZWNvbmQ6IHMgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUG9ydGVkIGZyb20ganF1ZXJ5LXVpIGRhdGVwaWNrZXIgcGFyc2VEYXRlIFxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wYXJzZURhdGUgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGFyZ3VtZW50c1wiO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSArIFwiXCIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpRm9ybWF0LCBkaW0sIGV4dHJhLCBpVmFsdWUgPSAwLCBzaG9ydFllYXJDdXRvZmYgPSAodHlwZW9mIHRoaXMuc2hvcnRZZWFyQ3V0b2ZmICE9PSBcInN0cmluZ1wiID8gdGhpcy5zaG9ydFllYXJDdXRvZmYgOiBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyBwYXJzZUludCh0aGlzLnNob3J0WWVhckN1dG9mZiwgMTApKSwgeWVhciA9IC0xLCBtb250aCA9IC0xLCBkYXkgPSAtMSwgZG95ID0gLTEsIGxpdGVyYWwgPSBmYWxzZSwgZGF0ZSwgbG9va0FoZWFkID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgaUZvcm1hdCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgIH0sIGdldE51bWJlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIGlzRG91YmxlZCA9IGxvb2tBaGVhZChtYXRjaCksIHNpemUgPSAobWF0Y2ggPT09IFwiQFwiID8gMTQgOiAobWF0Y2ggPT09IFwiIVwiID8gMjAgOlxuICAgICAgICAgICAgICAgIChtYXRjaCA9PT0gXCJ5XCIgJiYgaXNEb3VibGVkID8gNCA6IChtYXRjaCA9PT0gXCJvXCIgPyAzIDogMikpKSksIG1pblNpemUgPSAobWF0Y2ggPT09IFwieVwiID8gc2l6ZSA6IDEpLCBkaWdpdHMgPSBuZXcgUmVnRXhwKFwiXlxcXFxke1wiICsgbWluU2l6ZSArIFwiLFwiICsgc2l6ZSArIFwifVwiKSwgbnVtID0gdmFsdWUuc3Vic3RyaW5nKGlWYWx1ZSkubWF0Y2goZGlnaXRzKTtcbiAgICAgICAgICAgIGlmICghbnVtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJNaXNzaW5nIG51bWJlciBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlWYWx1ZSArPSBudW1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bVswXSwgMTApO1xuICAgICAgICB9LCBnZXROYW1lID0gZnVuY3Rpb24gKG1hdGNoLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGFyciA9IGxvb2tBaGVhZChtYXRjaCkgPyBsb25nTmFtZXMgOiBzaG9ydE5hbWVzO1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goW2ksIGFycltpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtKGFbMV0ubGVuZ3RoIC0gYlsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVzW2ldWzFdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdWJzdHIoaVZhbHVlLCBuYW1lXzEubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBuYW1lXzEudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG5hbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBpVmFsdWUgKz0gbmFtZV8xLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlVua25vd24gbmFtZSBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY2hlY2tMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJBdChpVmFsdWUpICE9PSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGxpdGVyYWwgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpVmFsdWUrKztcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKykge1xuICAgICAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tMaXRlcmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPSBnZXROdW1iZXIoXCJkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXROYW1lKFwiRFwiLCB0aGlzLmxvY2FsZS5kYXlOYW1lc1Nob3J0LCB0aGlzLmxvY2FsZS5kYXlOYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRveSA9IGdldE51bWJlcihcIm9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gZ2V0TnVtYmVyKFwibVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSBnZXROYW1lKFwiTVwiLCB0aGlzLmxvY2FsZS5tb250aE5hbWVzU2hvcnQsIHRoaXMubG9jYWxlLm1vbnRoTmFtZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB5ZWFyID0gZ2V0TnVtYmVyKFwieVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGdldE51bWJlcihcIkBcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKGdldE51bWJlcihcIiFcIikgLSB0aGlzLnRpY2tzVG8xOTcwKSAvIDEwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZChcIidcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0xpdGVyYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0xpdGVyYWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlWYWx1ZSA8IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgZXh0cmEgPSB2YWx1ZS5zdWJzdHIoaVZhbHVlKTtcbiAgICAgICAgICAgIGlmICghL15cXHMrLy50ZXN0KGV4dHJhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiRXh0cmEvdW5wYXJzZWQgY2hhcmFjdGVycyBmb3VuZCBpbiBkYXRlOiBcIiArIGV4dHJhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh5ZWFyID09PSAtMSkge1xuICAgICAgICAgICAgeWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgICAgICB5ZWFyICs9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArXG4gICAgICAgICAgICAgICAgKHllYXIgPD0gc2hvcnRZZWFyQ3V0b2ZmID8gMCA6IC0xMDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb3kgPiAtMSkge1xuICAgICAgICAgICAgbW9udGggPSAxO1xuICAgICAgICAgICAgZGF5ID0gZG95O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGRpbSA9IHRoaXMuZ2V0RGF5c0NvdW50SW5Nb250aCh5ZWFyLCBtb250aCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChkYXkgPD0gZGltKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb250aCsrO1xuICAgICAgICAgICAgICAgIGRheSAtPSBkaW07XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRlID0gdGhpcy5kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuICAgICAgICBpZiAoZGF0ZS5nZXRGdWxsWWVhcigpICE9PSB5ZWFyIHx8IGRhdGUuZ2V0TW9udGgoKSArIDEgIT09IG1vbnRoIHx8IGRhdGUuZ2V0RGF0ZSgpICE9PSBkYXkpIHtcbiAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBkYXRlXCI7IC8vIEUuZy4gMzEvMDIvMDBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5kYXlsaWdodFNhdmluZ0FkanVzdCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCkgPiAxMiA/IGRhdGUuZ2V0SG91cnMoKSArIDIgOiAwKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlRmlsbGVkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlsbGVkID0gdGhpcy5pbnB1dEZpZWxkVmFsdWUgJiYgdGhpcy5pbnB1dEZpZWxkVmFsdWUgIT0gJyc7XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2xvc2VPdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm92ZXJsYXlWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2xvc2UuZW1pdChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlT3ZlcmxheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0ZUNsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS51bmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICBpZiAoIXRoaXMuaW5saW5lICYmIHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW52YWxpZERhdGU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJkZWZhdWx0RGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcImlucHV0U3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJpbnB1dFN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwiZGF0ZUZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwiaW5saW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJzaG93T3RoZXJNb250aHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcInNlbGVjdE90aGVyTW9udGhzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJzaG93SWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJpY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcImFwcGVuZFRvXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJyZWFkb25seUlucHV0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcInNob3J0WWVhckN1dG9mZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwibW9udGhOYXZpZ2F0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcInllYXJOYXZpZ2F0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwieWVhclJhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJzaG93VGltZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJob3VyRm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJ0aW1lT25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJzdGVwSG91clwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJzdGVwTWludXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcInN0ZXBTZWNvbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcInNob3dTZWNvbmRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwic2hvd09uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwiZGF0YVR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJkaXNhYmxlZERhdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwiZGlzYWJsZWREYXlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJ1dGNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwib25DbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcIm9uU2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBDYWxlbmRhci5wcm90b3R5cGUsIFwib25JbnB1dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnZGF0ZXBpY2tlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJvdmVybGF5Vmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdpbnB1dGZpZWxkJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcImlucHV0ZmllbGRWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcIm1pbkRhdGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcbl0sIENhbGVuZGFyLnByb3RvdHlwZSwgXCJtYXhEYXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgQ2FsZW5kYXIucHJvdG90eXBlLCBcImxvY2FsZVwiLCBudWxsKTtcbkNhbGVuZGFyID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1jYWxlbmRhcicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPHNwYW4gW25nQ2xhc3NdPVxcXCJ7J3VpLWNhbGVuZGFyJzp0cnVlLCd1aS1jYWxlbmRhci13LWJ0bic6c2hvd0ljb259XFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVxcXCIhaW5saW5lXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0ICNpbnB1dGZpZWxkIHR5cGU9XFxcInRleHRcXFwiIFthdHRyLmlkXT1cXFwiaW5wdXRJZFxcXCIgW2F0dHIucmVxdWlyZWRdPVxcXCJyZXF1aXJlZFxcXCIgW3ZhbHVlXT1cXFwiaW5wdXRGaWVsZFZhbHVlXFxcIiAoZm9jdXMpPVxcXCJvbklucHV0Rm9jdXMoJGV2ZW50KVxcXCIgKGtleWRvd24pPVxcXCJvbklucHV0S2V5ZG93bigkZXZlbnQpXFxcIiAoY2xpY2spPVxcXCJjbG9zZU92ZXJsYXk9ZmFsc2VcXFwiIChibHVyKT1cXFwib25JbnB1dEJsdXIoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtyZWFkb25seV09XFxcInJlYWRvbmx5SW5wdXRcXFwiIChpbnB1dCk9XFxcIm9uVXNlcklucHV0KCRldmVudClcXFwiIFtuZ1N0eWxlXT1cXFwiaW5wdXRTdHlsZVxcXCIgW2NsYXNzXT1cXFwiaW5wdXRTdHlsZUNsYXNzXFxcIiBbcGxhY2Vob2xkZXJdPVxcXCJwbGFjZWhvbGRlcnx8JydcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbYXR0ci50YWJpbmRleF09XFxcInRhYmluZGV4XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCIndWktaW5wdXR0ZXh0IHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGwnXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBbaWNvbl09XFxcImljb25cXFwiIHBCdXR0b24gKm5nSWY9XFxcInNob3dJY29uXFxcIiAoY2xpY2spPVxcXCJvbkJ1dHRvbkNsaWNrKCRldmVudCxpbnB1dGZpZWxkKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1kYXRlcGlja2VyLXRyaWdnZXInOnRydWUsJ3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZH1cXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgPGRpdiAjZGF0ZXBpY2tlciBjbGFzcz1cXFwidWktZGF0ZXBpY2tlciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGxcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1kYXRlcGlja2VyLWlubGluZSc6aW5saW5lLCd1aS1zaGFkb3cnOiFpbmxpbmUsJ3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZCwndWktZGF0ZXBpY2tlci10aW1lb25seSc6dGltZU9ubHl9XFxcIiBcXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPVxcXCJ7J2Rpc3BsYXknOiBpbmxpbmUgPyAnaW5saW5lLWJsb2NrJyA6IChvdmVybGF5VmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZScpfVxcXCIgKGNsaWNrKT1cXFwib25EYXRlUGlja2VyQ2xpY2soJGV2ZW50KVxcXCIgW0BvdmVybGF5U3RhdGVdPVxcXCJpbmxpbmUgPyAndmlzaWJsZScgOiAob3ZlcmxheVZpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJylcXFwiPlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kYXRlcGlja2VyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsXFxcIiAqbmdJZj1cXFwiIXRpbWVPbmx5ICYmIChvdmVybGF5VmlzaWJsZSB8fCBpbmxpbmUpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwicC1oZWFkZXJcXFwiPjwvbmctY29udGVudD5cXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJ1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbFxcXCIgaHJlZj1cXFwiI1xcXCIgKGNsaWNrKT1cXFwicHJldk1vbnRoKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1sZWZ0XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwidWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGxcXFwiIGhyZWY9XFxcIiNcXFwiIChjbGljayk9XFxcIm5leHRNb250aCgkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtcmlnaHRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWRhdGVwaWNrZXItdGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1kYXRlcGlja2VyLW1vbnRoXFxcIiAqbmdJZj1cXFwiIW1vbnRoTmF2aWdhdG9yXFxcIj57e2xvY2FsZS5tb250aE5hbWVzW2N1cnJlbnRNb250aF19fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVxcXCJ1aS1kYXRlcGlja2VyLW1vbnRoXFxcIiAqbmdJZj1cXFwibW9udGhOYXZpZ2F0b3JcXFwiIChjaGFuZ2UpPVxcXCJvbk1vbnRoRHJvcGRvd25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIFt2YWx1ZV09XFxcImlcXFwiICpuZ0Zvcj1cXFwibGV0IG1vbnRoIG9mIGxvY2FsZS5tb250aE5hbWVzO2xldCBpID0gaW5kZXhcXFwiIFtzZWxlY3RlZF09XFxcImkgPT0gY3VycmVudE1vbnRoXFxcIj57e21vbnRofX08L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVxcXCJ1aS1kYXRlcGlja2VyLXllYXJcXFwiICpuZ0lmPVxcXCJ5ZWFyTmF2aWdhdG9yXFxcIiAoY2hhbmdlKT1cXFwib25ZZWFyRHJvcGRvd25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIFt2YWx1ZV09XFxcInllYXJcXFwiICpuZ0Zvcj1cXFwibGV0IHllYXIgb2YgeWVhck9wdGlvbnNcXFwiIFtzZWxlY3RlZF09XFxcInllYXIgPT0gY3VycmVudFllYXJcXFwiPnt7eWVhcn19PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWRhdGVwaWNrZXIteWVhclxcXCIgKm5nSWY9XFxcIiF5ZWFyTmF2aWdhdG9yXFxcIj57e2N1cnJlbnRZZWFyfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cXFwidWktZGF0ZXBpY2tlci1jYWxlbmRhclxcXCIgKm5nSWY9XFxcIiF0aW1lT25seSAmJiAob3ZlcmxheVZpc2libGUgfHwgaW5saW5lKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9XFxcImNvbFxcXCIgKm5nRm9yPVxcXCJsZXQgd2Vla0RheSBvZiB3ZWVrRGF5cztsZXQgYmVnaW4gPSBmaXJzdDsgbGV0IGVuZCA9IGxhc3RcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3t3ZWVrRGF5fX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyICpuZ0Zvcj1cXFwibGV0IHdlZWsgb2YgZGF0ZXNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgKm5nRm9yPVxcXCJsZXQgZGF0ZSBvZiB3ZWVrXFxcIiBbbmdDbGFzc109XFxcInsndWktZGF0ZXBpY2tlci1vdGhlci1tb250aCB1aS1zdGF0ZS1kaXNhYmxlZCc6ZGF0ZS5vdGhlck1vbnRoLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VpLWRhdGVwaWNrZXItY3VycmVudC1kYXknOmlzU2VsZWN0ZWQoZGF0ZSksJ3VpLWRhdGVwaWNrZXItdG9kYXknOmRhdGUudG9kYXl9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJ1aS1zdGF0ZS1kZWZhdWx0XFxcIiBocmVmPVxcXCIjXFxcIiAqbmdJZj1cXFwiZGF0ZS5vdGhlck1vbnRoID8gc2hvd090aGVyTW9udGhzIDogdHJ1ZVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWFjdGl2ZSc6aXNTZWxlY3RlZChkYXRlKSwgJ3VpLXN0YXRlLWhpZ2hsaWdodCc6ZGF0ZS50b2RheSwgJ3VpLXN0YXRlLWRpc2FibGVkJzohZGF0ZS5zZWxlY3RhYmxlfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJvbkRhdGVTZWxlY3QoJGV2ZW50LGRhdGUpXFxcIj57e2RhdGUuZGF5fX08L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRpbWVwaWNrZXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXFxcIiAqbmdJZj1cXFwic2hvd1RpbWV8fHRpbWVPbmx5XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWhvdXItcGlja2VyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiAoY2xpY2spPVxcXCJpbmNyZW1lbnRIb3VyKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtdXBcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gW25nU3R5bGVdPVxcXCJ7J2Rpc3BsYXknOiBjdXJyZW50SG91ciA8IDEwID8gJ2lubGluZSc6ICdub25lJ31cXFwiPjA8L3NwYW4+PHNwYW4+e3tjdXJyZW50SG91cn19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIChjbGljayk9XFxcImRlY3JlbWVudEhvdXIoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1kb3duXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1zZXBhcmF0b3JcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtdXBcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+Ojwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWRvd25cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW1pbnV0ZS1waWNrZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIChjbGljayk9XFxcImluY3JlbWVudE1pbnV0ZSgkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWFuZ2xlLXVwXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtuZ1N0eWxlXT1cXFwieydkaXNwbGF5JzogY3VycmVudE1pbnV0ZSA8IDEwID8gJ2lubGluZSc6ICdub25lJ31cXFwiPjA8L3NwYW4+PHNwYW4+e3tjdXJyZW50TWludXRlfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgKGNsaWNrKT1cXFwiZGVjcmVtZW50TWludXRlKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtZG93blxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2VwYXJhdG9yXFxcIiAqbmdJZj1cXFwic2hvd1NlY29uZHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtdXBcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+Ojwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWRvd25cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXNlY29uZC1waWNrZXJcXFwiICpuZ0lmPVxcXCJzaG93U2Vjb25kc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgKGNsaWNrKT1cXFwiaW5jcmVtZW50U2Vjb25kKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtdXBcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gW25nU3R5bGVdPVxcXCJ7J2Rpc3BsYXknOiBjdXJyZW50U2Vjb25kIDwgMTAgPyAnaW5saW5lJzogJ25vbmUnfVxcXCI+MDwvc3Bhbj48c3Bhbj57e2N1cnJlbnRTZWNvbmR9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiAoY2xpY2spPVxcXCJkZWNyZW1lbnRTZWNvbmQoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1kb3duXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1hbXBtLXBpY2tlclxcXCIgKm5nSWY9XFxcImhvdXJGb3JtYXQ9PScxMidcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIChjbGljayk9XFxcInRvZ2dsZUFNUE0oJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS11cFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57e3BtID8gJ1BNJyA6ICdBTSd9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiAoY2xpY2spPVxcXCJ0b2dnbGVBTVBNKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtZG93blxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJwLWZvb3RlclxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9zcGFuPlxcbiAgICBcIixcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyaWdnZXIoJ292ZXJsYXlTdGF0ZScsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuc3RhdGUoJ2hpZGRlbicsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCd2aXNpYmxlJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEudHJhbnNpdGlvbigndmlzaWJsZSA9PiBoaWRkZW4nLCBhbmltYXRpb25zXzEuYW5pbWF0ZSgnNDAwbXMgZWFzZS1pbicpKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEudHJhbnNpdGlvbignaGlkZGVuID0+IHZpc2libGUnLCBhbmltYXRpb25zXzEuYW5pbWF0ZSgnNDAwbXMgZWFzZS1vdXQnKSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0sXG4gICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICdbY2xhc3MudWktaW5wdXR3cmFwcGVyLWZpbGxlZF0nOiAnZmlsbGVkJyxcbiAgICAgICAgICAgICdbY2xhc3MudWktaW5wdXR3cmFwcGVyLWZvY3VzXSc6ICdmb2N1cydcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIGV4cG9ydHMuQ0FMRU5EQVJfVkFMVUVfQUNDRVNTT1IsIGV4cG9ydHMuQ0FMRU5EQVJfVkFMSURBVE9SXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuUmVuZGVyZXIyLCBjb3JlXzEuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgQ2FsZW5kYXIpO1xuZXhwb3J0cy5DYWxlbmRhciA9IENhbGVuZGFyO1xudmFyIENhbGVuZGFyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWxlbmRhck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIENhbGVuZGFyTW9kdWxlO1xufSgpKTtcbkNhbGVuZGFyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgYnV0dG9uXzEuQnV0dG9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0NhbGVuZGFyLCBidXR0b25fMS5CdXR0b25Nb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDYWxlbmRhcl1cbiAgICB9KVxuXSwgQ2FsZW5kYXJNb2R1bGUpO1xuZXhwb3J0cy5DYWxlbmRhck1vZHVsZSA9IENhbGVuZGFyTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsZW5kYXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jYWxlbmRhci9jYWxlbmRhci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2NhbGVuZGFyL2NhbGVuZGFyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgQ2FwdGNoYSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FwdGNoYShlbCwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuc2l0ZUtleSA9IG51bGw7XG4gICAgICAgIHRoaXMudGhlbWUgPSAnbGlnaHQnO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaW1hZ2UnO1xuICAgICAgICB0aGlzLnNpemUgPSAnbm9ybWFsJztcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRDYWxsYmFjayA9IFwiaW5pdFJlY2FwdGNoYVwiO1xuICAgICAgICB0aGlzLm9uUmVzcG9uc2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRXhwaXJlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICBDYXB0Y2hhLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh3aW5kb3cuZ3JlY2FwdGNoYSkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3dbdGhpcy5pbml0Q2FsbGJhY2tdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmluaXQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhcHRjaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gd2luZG93LmdyZWNhcHRjaGEucmVuZGVyKHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXSwge1xuICAgICAgICAgICAgJ3NpdGVrZXknOiB0aGlzLnNpdGVLZXksXG4gICAgICAgICAgICAndGhlbWUnOiB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgJ3R5cGUnOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAnc2l6ZSc6IHRoaXMuc2l6ZSxcbiAgICAgICAgICAgICd0YWJpbmRleCc6IHRoaXMudGFiaW5kZXgsXG4gICAgICAgICAgICAnaGwnOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgICAgICAgJ2NhbGxiYWNrJzogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZWNhcHRjaGFDYWxsYmFjayhyZXNwb25zZSk7IH0pOyB9LFxuICAgICAgICAgICAgJ2V4cGlyZWQtY2FsbGJhY2snOiBmdW5jdGlvbiAoKSB7IF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZWNhcHRjaGFFeHBpcmVkQ2FsbGJhY2soKTsgfSk7IH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYXB0Y2hhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB3aW5kb3cuZ3JlY2FwdGNoYS5yZXNldCh0aGlzLl9pbnN0YW5jZSk7XG4gICAgfTtcbiAgICBDYXB0Y2hhLnByb3RvdHlwZS5nZXRSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ3JlY2FwdGNoYS5nZXRSZXNwb25zZSh0aGlzLl9pbnN0YW5jZSk7XG4gICAgfTtcbiAgICBDYXB0Y2hhLnByb3RvdHlwZS5yZWNhcHRjaGFDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aGlzLm9uUmVzcG9uc2UuZW1pdCh7XG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYXB0Y2hhLnByb3RvdHlwZS5yZWNhcHRjaGFFeHBpcmVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25FeHBpcmUuZW1pdCgpO1xuICAgIH07XG4gICAgQ2FwdGNoYS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuZ3JlY2FwdGNoYS5yZXNldCh0aGlzLl9pbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYXB0Y2hhO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXB0Y2hhLnByb3RvdHlwZSwgXCJzaXRlS2V5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2FwdGNoYS5wcm90b3R5cGUsIFwidGhlbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXB0Y2hhLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2FwdGNoYS5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhcHRjaGEucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2FwdGNoYS5wcm90b3R5cGUsIFwibGFuZ3VhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXB0Y2hhLnByb3RvdHlwZSwgXCJpbml0Q2FsbGJhY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIENhcHRjaGEucHJvdG90eXBlLCBcIm9uUmVzcG9uc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIENhcHRjaGEucHJvdG90eXBlLCBcIm9uRXhwaXJlXCIsIHZvaWQgMCk7XG5DYXB0Y2hhID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1jYXB0Y2hhJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj48L2Rpdj5cIlxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGNvcmVfMS5OZ1pvbmVdKVxuXSwgQ2FwdGNoYSk7XG5leHBvcnRzLkNhcHRjaGEgPSBDYXB0Y2hhO1xudmFyIENhcHRjaGFNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcHRjaGFNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBDYXB0Y2hhTW9kdWxlO1xufSgpKTtcbkNhcHRjaGFNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0NhcHRjaGFdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDYXB0Y2hhXVxuICAgIH0pXG5dLCBDYXB0Y2hhTW9kdWxlKTtcbmV4cG9ydHMuQ2FwdGNoYU1vZHVsZSA9IENhcHRjaGFNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXB0Y2hhLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvY2FwdGNoYS9jYXB0Y2hhLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvY2FwdGNoYS9jYXB0Y2hhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgQ2Fyb3VzZWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcm91c2VsKGVsLCBkb21IYW5kbGVyLCByZW5kZXJlciwgY2QpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5udW1WaXNpYmxlID0gMztcbiAgICAgICAgdGhpcy5maXJzdFZpc2libGUgPSAwO1xuICAgICAgICB0aGlzLmNpcmN1bGFyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnJlYWtwb2ludCA9IDU2MDtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRvcGxheUludGVydmFsID0gMDtcbiAgICAgICAgdGhpcy5lZmZlY3REdXJhdGlvbiA9ICcxcyc7XG4gICAgICAgIHRoaXMuZWFzaW5nID0gJ2Vhc2Utb3V0JztcbiAgICAgICAgdGhpcy5wYWdlTGlua3MgPSAzO1xuICAgICAgICB0aGlzLm9uUGFnZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgfVxuICAgIENhcm91c2VsLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5nZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcm91c2VsLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ2hhbmdlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5oYW5kbGVEYXRhQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICYmIHRoaXMuZmlyc3RWaXNpYmxlID49IHRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYWdlKHRoaXMudG90YWxQYWdlcyAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRQYWdlKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzQ2hhbmdlZCA9IHRydWU7XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXNDaGFuZ2VkICYmIHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZXNwb25zaXZlTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbignd2luZG93JywgJ3Jlc2l6ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnVwZGF0ZUxpbmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFuY2hvclBhZ2VMaW5rcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG90YWxQYWdlczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvclBhZ2VMaW5rcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUudXBkYXRlRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RHJvcGRvd25PcHRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50b3RhbFBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RHJvcGRvd25PcHRpb25zLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS51cGRhdGVNb2JpbGVEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tb2JpbGVEcm9wZG93bk9wdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1vYmlsZURyb3Bkb3duT3B0aW9ucy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvcGxheUludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLmRvbUhhbmRsZXIuZmluZCh0aGlzLml0ZW1zVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQsICdsaScpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVJdGVtV2lkdGhzKCk7XG4gICAgICAgIGlmICghdGhpcy5yZXNwb25zaXZlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLndpZHRoID0gKHRoaXMuZG9tSGFuZGxlci53aWR0aCh0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50KSkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9wbGF5SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuY2lyY3VsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFydEF1dG9wbGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVNb2JpbGVEcm9wZG93bigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxpbmtzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRHJvcGRvd24oKTtcbiAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuY2FsY3VsYXRlSXRlbVdpZHRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpcnN0SXRlbSA9ICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoKSA/IHRoaXMuaXRlbXNbMF0gOiBudWxsO1xuICAgICAgICBpZiAoZmlyc3RJdGVtKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2ldLnN0eWxlLndpZHRoID0gKCh0aGlzLmRvbUhhbmRsZXIuaW5uZXJXaWR0aCh0aGlzLnZpZXdwb3J0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpIC0gKHRoaXMuZG9tSGFuZGxlci5nZXRIb3Jpem9udGFsTWFyZ2luKGZpcnN0SXRlbSkgKiB0aGlzLmNvbHVtbnMpKSAvIHRoaXMuY29sdW1ucykgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuY2FsY3VsYXRlQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDw9IHRoaXMuYnJlYWtwb2ludCkge1xuICAgICAgICAgICAgdGhpcy5zaHJpbmtlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaHJpbmtlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gdGhpcy5udW1WaXNpYmxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFnZSA9IE1hdGguZmxvb3IodGhpcy5maXJzdFZpc2libGUgLyB0aGlzLmNvbHVtbnMpO1xuICAgIH07XG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLm9uTmV4dE5hdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhc3RQYWdlID0gKHRoaXMucGFnZSA9PT0gKHRoaXMudG90YWxQYWdlcyAtIDEpKTtcbiAgICAgICAgaWYgKCFsYXN0UGFnZSlcbiAgICAgICAgICAgIHRoaXMuc2V0UGFnZSh0aGlzLnBhZ2UgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jaXJjdWxhcilcbiAgICAgICAgICAgIHRoaXMuc2V0UGFnZSgwKTtcbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5vblByZXZOYXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhZ2UgIT09IDApXG4gICAgICAgICAgICB0aGlzLnNldFBhZ2UodGhpcy5wYWdlIC0gMSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2lyY3VsYXIpXG4gICAgICAgICAgICB0aGlzLnNldFBhZ2UodGhpcy50b3RhbFBhZ2VzIC0gMSk7XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuc2V0UGFnZVdpdGhMaW5rID0gZnVuY3Rpb24gKGV2ZW50LCBwKSB7XG4gICAgICAgIHRoaXMuc2V0UGFnZShwKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5zZXRQYWdlID0gZnVuY3Rpb24gKHAsIGVuZm9yY2UpIHtcbiAgICAgICAgaWYgKHAgIT09IHRoaXMucGFnZSB8fCBlbmZvcmNlKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSBwO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gKC0xICogKHRoaXMuZG9tSGFuZGxlci5pbm5lcldpZHRoKHRoaXMudmlld3BvcnRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCkgKiB0aGlzLnBhZ2UpKTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RWaXNpYmxlID0gdGhpcy5wYWdlICogdGhpcy5jb2x1bW5zO1xuICAgICAgICAgICAgdGhpcy5vblBhZ2UuZW1pdCh7XG4gICAgICAgICAgICAgICAgcGFnZTogdGhpcy5wYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLm9uRHJvcGRvd25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHRoaXMuc2V0UGFnZShwYXJzZUludCh2YWwpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJvdXNlbC5wcm90b3R5cGUsIFwiZGlzcGxheVBhZ2VMaW5rc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnRvdGFsUGFnZXMgPD0gdGhpcy5wYWdlTGlua3MgJiYgIXRoaXMuc2hyaW5rZWQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2Fyb3VzZWwucHJvdG90eXBlLCBcImRpc3BsYXlQYWdlRHJvcGRvd25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy50b3RhbFBhZ2VzID4gdGhpcy5wYWdlTGlua3MgJiYgIXRoaXMuc2hyaW5rZWQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2Fyb3VzZWwucHJvdG90eXBlLCBcInRvdGFsUGFnZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCkgPyBNYXRoLmNlaWwodGhpcy52YWx1ZS5sZW5ndGggLyB0aGlzLmNvbHVtbnMpIDogMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnJvdXRlckRpc3BsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aW4gPSB3aW5kb3c7XG4gICAgICAgIGlmICh3aW4uaW5uZXJXaWR0aCA8PSB0aGlzLmJyZWFrcG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luID0gd2luZG93O1xuICAgICAgICBpZiAod2luLmlubmVyV2lkdGggPD0gdGhpcy5icmVha3BvaW50KSB7XG4gICAgICAgICAgICB0aGlzLnNocmlua2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaHJpbmtlZCkge1xuICAgICAgICAgICAgdGhpcy5zaHJpbmtlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gdGhpcy5udW1WaXNpYmxlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5rcygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVEcm9wZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlSXRlbVdpZHRocygpO1xuICAgICAgICB0aGlzLnNldFBhZ2UoTWF0aC5mbG9vcih0aGlzLmZpcnN0VmlzaWJsZSAvIHRoaXMuY29sdW1ucyksIHRydWUpO1xuICAgIH07XG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnN0YXJ0QXV0b3BsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucGFnZSA9PT0gKF90aGlzLnRvdGFsUGFnZXMgLSAxKSlcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRQYWdlKDApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFBhZ2UoX3RoaXMucGFnZSArIDEpO1xuICAgICAgICB9LCB0aGlzLmF1dG9wbGF5SW50ZXJ2YWwpO1xuICAgIH07XG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnN0b3BBdXRvcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRSZXNwb25zaXZlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZXNwb25zaXZlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvcGxheUludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2Fyb3VzZWw7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhcm91c2VsLnByb3RvdHlwZSwgXCJudW1WaXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2Fyb3VzZWwucHJvdG90eXBlLCBcImZpcnN0VmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhcm91c2VsLnByb3RvdHlwZSwgXCJoZWFkZXJUZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhcm91c2VsLnByb3RvdHlwZSwgXCJjaXJjdWxhclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhcm91c2VsLnByb3RvdHlwZSwgXCJicmVha3BvaW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhcm91c2VsLnByb3RvdHlwZSwgXCJyZXNwb25zaXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2Fyb3VzZWwucHJvdG90eXBlLCBcImF1dG9wbGF5SW50ZXJ2YWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXJvdXNlbC5wcm90b3R5cGUsIFwiZWZmZWN0RHVyYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXJvdXNlbC5wcm90b3R5cGUsIFwiZWFzaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2Fyb3VzZWwucHJvdG90eXBlLCBcInBhZ2VMaW5rc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhcm91c2VsLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhcm91c2VsLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBDYXJvdXNlbC5wcm90b3R5cGUsIFwib25QYWdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkcmVuKHNoYXJlZF8xLlByaW1lVGVtcGxhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuUXVlcnlMaXN0KVxuXSwgQ2Fyb3VzZWwucHJvdG90eXBlLCBcInRlbXBsYXRlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnY29udGFpbmVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQ2Fyb3VzZWwucHJvdG90eXBlLCBcImNvbnRhaW5lclZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgndmlld3BvcnQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBDYXJvdXNlbC5wcm90b3R5cGUsIFwidmlld3BvcnRWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2l0ZW1zJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQ2Fyb3VzZWwucHJvdG90eXBlLCBcIml0ZW1zVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgQ2Fyb3VzZWwucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuQ2Fyb3VzZWwgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWNhcm91c2VsJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2ICNjb250YWluZXIgW25nQ2xhc3NdPVxcXCJ7J3VpLWNhcm91c2VsIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsJzp0cnVlfVxcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY2Fyb3VzZWwtaGVhZGVyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1jYXJvdXNlbC1oZWFkZXItdGl0bGVcXFwiPnt7aGVhZGVyVGV4dH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY2Fyb3VzZWwtYnV0dG9uIHVpLWNhcm91c2VsLW5leHQtYnV0dG9uIGZhIGZhLWFycm93LWNpcmNsZS1yaWdodFxcXCIgKGNsaWNrKT1cXFwib25OZXh0TmF2KClcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1kaXNhYmxlZCc6KHBhZ2UgPT09ICh0b3RhbFBhZ2VzLTEpKSAmJiAhY2lyY3VsYXJ9XFxcIiAqbmdJZj1cXFwidmFsdWUmJnZhbHVlLmxlbmd0aFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY2Fyb3VzZWwtYnV0dG9uIHVpLWNhcm91c2VsLXByZXYtYnV0dG9uIGZhIGZhLWFycm93LWNpcmNsZS1sZWZ0XFxcIiAoY2xpY2spPVxcXCJvblByZXZOYXYoKVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzoocGFnZSA9PT0gMCAmJiAhY2lyY3VsYXIpfVxcXCIgKm5nSWY9XFxcInZhbHVlJiZ2YWx1ZS5sZW5ndGhcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cXFwiZGlzcGxheVBhZ2VMaW5rc1xcXCIgY2xhc3M9XFxcInVpLWNhcm91c2VsLXBhZ2UtbGlua3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgKGNsaWNrKT1cXFwic2V0UGFnZVdpdGhMaW5rKCRldmVudCxpKVxcXCIgY2xhc3M9XFxcInVpLWNhcm91c2VsLXBhZ2UtbGluayBmYSBmYS1jaXJjbGUtb1xcXCIgKm5nRm9yPVxcXCJsZXQgbGlua3Mgb2YgYW5jaG9yUGFnZUxpbmtzO2xldCBpPWluZGV4XFxcIiBbbmdDbGFzc109XFxcInsnZmEtZG90LWNpcmNsZS1vJzpwYWdlPT09aX1cXFwiPjwvYT5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxzZWxlY3QgKm5nSWY9XFxcImRpc3BsYXlQYWdlRHJvcGRvd25cXFwiIGNsYXNzPVxcXCJ1aS1jYXJvdXNlbC1kcm9wZG93biB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItbGVmdFxcXCIgW3ZhbHVlXT1cXFwicGFnZVxcXCIgKGNoYW5nZSk9XFxcIm9uRHJvcGRvd25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiAqbmdGb3I9XFxcImxldCBvcHRpb24gb2Ygc2VsZWN0RHJvcGRvd25PcHRpb25zXFxcIiBbdmFsdWVdPVxcXCJvcHRpb25cXFwiIFtzZWxlY3RlZF09XFxcInZhbHVlID09IG9wdGlvblxcXCI+e3tvcHRpb24rMX19PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICA8c2VsZWN0ICpuZ0lmPVxcXCJyZXNwb25zaXZlJiZ2YWx1ZSYmdmFsdWUubGVuZ3RoXFxcIiBjbGFzcz1cXFwidWktY2Fyb3VzZWwtbW9iaWxlZHJvcGRvd24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWxlZnRcXFwiIFt2YWx1ZV09XFxcInBhZ2VcXFwiIChjaGFuZ2UpPVxcXCJvbkRyb3Bkb3duQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmRpc3BsYXldPVxcXCJzaHJpbmtlZCA/ICdibG9jaycgOiAnbm9uZSdcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiAqbmdGb3I9XFxcImxldCBvcHRpb24gb2YgbW9iaWxlRHJvcGRvd25PcHRpb25zXFxcIiBbdmFsdWVdPVxcXCJvcHRpb25cXFwiIFtzZWxlY3RlZF09XFxcInZhbHVlID09IG9wdGlvblxcXCI+e3tvcHRpb24rMX19PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgI3ZpZXdwb3J0IGNsYXNzPVxcXCJ1aS1jYXJvdXNlbC12aWV3cG9ydFxcXCI+XFxuICAgICAgICAgICAgICAgIDx1bCAjaXRlbXMgY2xhc3M9XFxcInVpLWNhcm91c2VsLWl0ZW1zXFxcIiBbc3R5bGUubGVmdC5weF09XFxcImxlZnRcXFwiIFtzdHlsZS50cmFuc2l0aW9uUHJvcGVydHldPVxcXCInbGVmdCdcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXT1cXFwiZWZmZWN0RHVyYXRpb25cXFwiIFtzdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb25dPVxcXCJlYXNpbmdcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGxpICpuZ0Zvcj1cXFwibGV0IGl0ZW0gb2YgdmFsdWVcXFwiIGNsYXNzPVxcXCJ1aS1jYXJvdXNlbC1pdGVtIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbcFRlbXBsYXRlV3JhcHBlcl09XFxcIml0ZW1UZW1wbGF0ZVxcXCIgW2l0ZW1dPVxcXCJpdGVtXFxcIj48L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIGNvcmVfMS5SZW5kZXJlcjIsIGNvcmVfMS5DaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBDYXJvdXNlbCk7XG5leHBvcnRzLkNhcm91c2VsID0gQ2Fyb3VzZWw7XG52YXIgQ2Fyb3VzZWxNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcm91c2VsTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ2Fyb3VzZWxNb2R1bGU7XG59KCkpO1xuQ2Fyb3VzZWxNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbQ2Fyb3VzZWwsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW0Nhcm91c2VsXVxuICAgIH0pXG5dLCBDYXJvdXNlbE1vZHVsZSk7XG5leHBvcnRzLkNhcm91c2VsTW9kdWxlID0gQ2Fyb3VzZWxNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJvdXNlbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2Nhcm91c2VsL2Nhcm91c2VsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvY2Fyb3VzZWwvY2Fyb3VzZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBVSUNoYXJ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVSUNoYXJ0KGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5vbkRhdGFTZWxlY3QgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVUlDaGFydC5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMucmVpbml0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFVJQ2hhcnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0Q2hhcnQoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfTtcbiAgICBVSUNoYXJ0LnByb3RvdHlwZS5vbkNhbnZhc0NsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmNoYXJ0KSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudEF0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRBdEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnRbMF0gJiYgZGF0YXNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhU2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgZWxlbWVudDogZWxlbWVudFswXSwgZGF0YXNldDogZGF0YXNldCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVUlDaGFydC5wcm90b3R5cGUuaW5pdENoYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5jaGlsZHJlblswXSwge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVUlDaGFydC5wcm90b3R5cGUuZ2V0Q2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdO1xuICAgIH07XG4gICAgVUlDaGFydC5wcm90b3R5cGUuZ2V0QmFzZTY0SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnRvQmFzZTY0SW1hZ2UoKTtcbiAgICB9O1xuICAgIFVJQ2hhcnQucHJvdG90eXBlLmdlbmVyYXRlTGVnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFydCkge1xuICAgICAgICAgICAgdGhpcy5jaGFydC5nZW5lcmF0ZUxlZ2VuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVSUNoYXJ0LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFydCkge1xuICAgICAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVUlDaGFydC5wcm90b3R5cGUucmVpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFydCkge1xuICAgICAgICAgICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFydCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVSUNoYXJ0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jaGFydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBVSUNoYXJ0O1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBVSUNoYXJ0LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVUlDaGFydC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFVJQ2hhcnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVUlDaGFydC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBVSUNoYXJ0LnByb3RvdHlwZSwgXCJvbkRhdGFTZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIFVJQ2hhcnQucHJvdG90eXBlLCBcImRhdGFcIiwgbnVsbCk7XG5VSUNoYXJ0ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1jaGFydCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICA8Y2FudmFzIFthdHRyLndpZHRoXT1cXFwid2lkdGhcXFwiIFthdHRyLmhlaWdodF09XFxcImhlaWdodFxcXCIgKGNsaWNrKT1cXFwib25DYW52YXNDbGljaygkZXZlbnQpXFxcIj48L2NhbnZhcz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIlxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWZdKVxuXSwgVUlDaGFydCk7XG5leHBvcnRzLlVJQ2hhcnQgPSBVSUNoYXJ0O1xudmFyIENoYXJ0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFydE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIENoYXJ0TW9kdWxlO1xufSgpKTtcbkNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtVSUNoYXJ0XSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbVUlDaGFydF1cbiAgICB9KVxuXSwgQ2hhcnRNb2R1bGUpO1xuZXhwb3J0cy5DaGFydE1vZHVsZSA9IENoYXJ0TW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jaGFydC9jaGFydC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2NoYXJ0L2NoYXJ0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZm9ybXNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKTtcbmV4cG9ydHMuQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogZm9ybXNfMS5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2hlY2tib3g7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIENoZWNrYm94ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGVja2JveChjZCkge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgQ2hlY2tib3gucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGNoZWNrYm94LCBmb2N1cykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWwoKTtcbiAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICBjaGVja2JveC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGVja2JveC5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5iaW5hcnkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRWYWx1ZSgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLmNoZWNrZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh0aGlzLmNoZWNrZWQpO1xuICAgIH07XG4gICAgQ2hlY2tib3gucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSBldmVudC50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbCgpO1xuICAgIH07XG4gICAgQ2hlY2tib3gucHJvdG90eXBlLmlzQ2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuaW5kZXhPZih0aGlzLnZhbHVlKSA+IC0xO1xuICAgIH07XG4gICAgQ2hlY2tib3gucHJvdG90eXBlLnJlbW92ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5tb2RlbC5maWx0ZXIoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsICE9PSBfdGhpcy52YWx1ZTsgfSk7XG4gICAgfTtcbiAgICBDaGVja2JveC5wcm90b3R5cGUuYWRkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsKVxuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMubW9kZWwuY29uY2F0KFt0aGlzLnZhbHVlXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBbdGhpcy52YWx1ZV07XG4gICAgfTtcbiAgICBDaGVja2JveC5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgIH07XG4gICAgQ2hlY2tib3gucHJvdG90eXBlLm9uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCgpO1xuICAgIH07XG4gICAgQ2hlY2tib3gucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZCgpO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgQ2hlY2tib3gucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICBDaGVja2JveC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgQ2hlY2tib3gucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB2YWw7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hlY2tib3g7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoZWNrYm94LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoZWNrYm94LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENoZWNrYm94LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoZWNrYm94LnByb3RvdHlwZSwgXCJiaW5hcnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDaGVja2JveC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDaGVja2JveC5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDaGVja2JveC5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoZWNrYm94LnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoZWNrYm94LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBDaGVja2JveC5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbkNoZWNrYm94ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1jaGVja2JveCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbbmdDbGFzc109XFxcIid1aS1jaGtib3ggdWktd2lkZ2V0J1xcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0ICNjYiB0eXBlPVxcXCJjaGVja2JveFxcXCIgW2F0dHIuaWRdPVxcXCJpbnB1dElkXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFt2YWx1ZV09XFxcInZhbHVlXFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIChmb2N1cyk9XFxcIm9uRm9jdXMoJGV2ZW50KVxcXCIgKGJsdXIpPVxcXCJvbkJsdXIoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWZvY3VzJzpmb2N1c2VkfVxcXCIgKGNoYW5nZSk9XFxcImhhbmRsZUNoYW5nZSgkZXZlbnQpXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW2F0dHIudGFiaW5kZXhdPVxcXCJ0YWJpbmRleFxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY2hrYm94LWJveCB1aS13aWRnZXQgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kZWZhdWx0XFxcIiAoY2xpY2spPVxcXCJvbkNsaWNrKCRldmVudCxjYix0cnVlKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtYWN0aXZlJzpjaGVja2VkLCd1aS1zdGF0ZS1kaXNhYmxlZCc6ZGlzYWJsZWQsJ3VpLXN0YXRlLWZvY3VzJzpmb2N1c2VkfVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1jaGtib3gtaWNvbiB1aS1jbGlja2FibGVcXFwiIFtuZ0NsYXNzXT1cXFwieydmYSBmYS1jaGVjayc6Y2hlY2tlZH1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ1aS1jaGtib3gtbGFiZWxcXFwiIChjbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50LGNiLHRydWUpXFxcIiAqbmdJZj1cXFwibGFiZWxcXFwiPnt7bGFiZWx9fTwvbGFiZWw+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLkNIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkNoYW5nZURldGVjdG9yUmVmXSlcbl0sIENoZWNrYm94KTtcbmV4cG9ydHMuQ2hlY2tib3ggPSBDaGVja2JveDtcbnZhciBDaGVja2JveE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hlY2tib3hNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBDaGVja2JveE1vZHVsZTtcbn0oKSk7XG5DaGVja2JveE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbQ2hlY2tib3hdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDaGVja2JveF1cbiAgICB9KVxuXSwgQ2hlY2tib3hNb2R1bGUpO1xuZXhwb3J0cy5DaGVja2JveE1vZHVsZSA9IENoZWNrYm94TW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2NoZWNrYm94L2NoZWNrYm94LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBpbnB1dHRleHRfMSA9IHJlcXVpcmUoXCIuLi9pbnB1dHRleHQvaW5wdXR0ZXh0XCIpO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbnZhciBmb3Jtc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpO1xuZXhwb3J0cy5DSElQU19WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBmb3Jtc18xLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBDaGlwczsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgQ2hpcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoaXBzKGVsLCBkb21IYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5vbkFkZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25SZW1vdmUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFsbG93RHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIH1cbiAgICBDaGlwcy5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0uZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLml0ZW1UZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLml0ZW1UZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoaXBzLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIENoaXBzLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgQ2hpcHMucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIENoaXBzLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdmFsO1xuICAgIH07XG4gICAgQ2hpcHMucHJvdG90eXBlLnJlc29sdmVGaWVsZERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZmllbGQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5pbmRleE9mKCcuJykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtmaWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtmaWVsZHNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hpcHMucHJvdG90eXBlLm9uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm9jdXMgPSB0cnVlO1xuICAgIH07XG4gICAgQ2hpcHMucHJvdG90eXBlLm9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkKCk7XG4gICAgfTtcbiAgICBDaGlwcy5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChldmVudCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVtb3ZlZEl0ZW0gPSB0aGlzLnZhbHVlW2luZGV4XTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuZmlsdGVyKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIGkgIT0gaW5kZXg7IH0pO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25SZW1vdmUuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHZhbHVlOiByZW1vdmVkSXRlbVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoaXBzLnByb3RvdHlwZS5vbktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0RUwpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC53aGljaCkge1xuICAgICAgICAgICAgLy9iYWNrc3BhY2VcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRFTC52YWx1ZS5sZW5ndGggPT09IDAgJiYgdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRJdGVtID0gdGhpcy52YWx1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVtb3ZlLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVtb3ZlZEl0ZW1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy9lbnRlclxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRFTC52YWx1ZSAmJiBpbnB1dEVMLnZhbHVlLnRyaW0oKS5sZW5ndGggJiYgKCF0aGlzLm1heCB8fCB0aGlzLm1heCA+IHRoaXMudmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd0R1cGxpY2F0ZSB8fCAhdGhpcy52YWx1ZS5pbmNsdWRlcyhpbnB1dEVMLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuY29uY2F0KFtpbnB1dEVMLnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQWRkLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dEVMLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dEVMLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ICYmIHRoaXMudmFsdWUgJiYgdGhpcy5tYXggPT09IHRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hpcHMucHJvdG90eXBlLCBcIm1heGVkT3V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXggJiYgdGhpcy52YWx1ZSAmJiB0aGlzLm1heCA9PT0gdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDaGlwcztcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hpcHMucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2hpcHMucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2hpcHMucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBDaGlwcy5wcm90b3R5cGUsIFwib25BZGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIENoaXBzLnByb3RvdHlwZSwgXCJvblJlbW92ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoaXBzLnByb3RvdHlwZSwgXCJmaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoaXBzLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENoaXBzLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDaGlwcy5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDaGlwcy5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDaGlwcy5wcm90b3R5cGUsIFwiYWxsb3dEdXBsaWNhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGlwcy5wcm90b3R5cGUsIFwiaW5wdXRTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoaXBzLnByb3RvdHlwZSwgXCJpbnB1dFN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oc2hhcmVkXzEuUHJpbWVUZW1wbGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5RdWVyeUxpc3QpXG5dLCBDaGlwcy5wcm90b3R5cGUsIFwidGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5DaGlwcyA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtY2hpcHMnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCIndWktY2hpcHMgdWktd2lkZ2V0J1xcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPHVsIFtuZ0NsYXNzXT1cXFwieyd1aS1pbnB1dHRleHQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1zdGF0ZS1mb2N1cyc6Zm9jdXMsJ3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZH1cXFwiIChjbGljayk9XFxcImlucHV0dGV4dC5mb2N1cygpXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpICN0b2tlbiAqbmdGb3I9XFxcImxldCBpdGVtIG9mIHZhbHVlOyBsZXQgaSA9IGluZGV4O1xcXCIgY2xhc3M9XFxcInVpLWNoaXBzLXRva2VuIHVpLXN0YXRlLWhpZ2hsaWdodCB1aS1jb3JuZXItYWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVxcXCIhZGlzYWJsZWRcXFwiIGNsYXNzPVxcXCJ1aS1jaGlwcy10b2tlbi1pY29uIGZhIGZhLWZ3IGZhLWNsb3NlXFxcIiAoY2xpY2spPVxcXCJyZW1vdmVJdGVtKCRldmVudCxpKVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiFpdGVtVGVtcGxhdGVcXFwiIGNsYXNzPVxcXCJ1aS1jaGlwcy10b2tlbi1sYWJlbFxcXCI+e3tmaWVsZCA/IHJlc29sdmVGaWVsZERhdGEoaXRlbSxmaWVsZCkgOiBpdGVtfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XFxcIml0ZW1UZW1wbGF0ZVxcXCIgW3BUZW1wbGF0ZVdyYXBwZXJdPVxcXCJpdGVtVGVtcGxhdGVcXFwiIFtpdGVtXT1cXFwiaXRlbVxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1jaGlwcy1pbnB1dC10b2tlblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgI2lucHV0dGV4dCB0eXBlPVxcXCJ0ZXh0XFxcIiBbYXR0ci5pZF09XFxcImlucHV0SWRcXFwiIFthdHRyLnBsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiIFthdHRyLnRhYmluZGV4XT1cXFwidGFiaW5kZXhcXFwiIChrZXlkb3duKT1cXFwib25LZXlkb3duKCRldmVudCxpbnB1dHRleHQpXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAoZm9jdXMpPVxcXCJvbkZvY3VzKClcXFwiIChibHVyKT1cXFwib25CbHVyKClcXFwiIFtkaXNhYmxlZF09XFxcIm1heGVkT3V0fHxkaXNhYmxlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFtuZ1N0eWxlXT1cXFwiaW5wdXRTdHlsZVxcXCIgW2NsYXNzXT1cXFwiaW5wdXRTdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgZXhwb3J0cy5DSElQU19WQUxVRV9BQ0NFU1NPUl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl0pXG5dLCBDaGlwcyk7XG5leHBvcnRzLkNoaXBzID0gQ2hpcHM7XG52YXIgQ2hpcHNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoaXBzTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ2hpcHNNb2R1bGU7XG59KCkpO1xuQ2hpcHNNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlLCBpbnB1dHRleHRfMS5JbnB1dFRleHRNb2R1bGUsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtDaGlwcywgaW5wdXR0ZXh0XzEuSW5wdXRUZXh0TW9kdWxlLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDaGlwc11cbiAgICB9KVxuXSwgQ2hpcHNNb2R1bGUpO1xuZXhwb3J0cy5DaGlwc01vZHVsZSA9IENoaXBzTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpcHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jaGlwcy9jaGlwcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2NoaXBzL2NoaXBzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgQ29kZUhpZ2hsaWdodGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2RlSGlnaGxpZ2h0ZXIoZWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgIH1cbiAgICBDb2RlSGlnaGxpZ2h0ZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBQcmlzbS5oaWdobGlnaHRFbGVtZW50KHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZUhpZ2hsaWdodGVyO1xufSgpKTtcbkNvZGVIaWdobGlnaHRlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5EaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1twQ29kZV0nXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZl0pXG5dLCBDb2RlSGlnaGxpZ2h0ZXIpO1xuZXhwb3J0cy5Db2RlSGlnaGxpZ2h0ZXIgPSBDb2RlSGlnaGxpZ2h0ZXI7XG52YXIgQ29kZUhpZ2hsaWdodGVyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2RlSGlnaGxpZ2h0ZXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb2RlSGlnaGxpZ2h0ZXJNb2R1bGU7XG59KCkpO1xuQ29kZUhpZ2hsaWdodGVyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtDb2RlSGlnaGxpZ2h0ZXJdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDb2RlSGlnaGxpZ2h0ZXJdXG4gICAgfSlcbl0sIENvZGVIaWdobGlnaHRlck1vZHVsZSk7XG5leHBvcnRzLkNvZGVIaWdobGlnaHRlck1vZHVsZSA9IENvZGVIaWdobGlnaHRlck1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVoaWdobGlnaHRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2NvZGVoaWdobGlnaHRlci9jb2RlaGlnaGxpZ2h0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9jb2RlaGlnaGxpZ2h0ZXIvY29kZWhpZ2hsaWdodGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBhbmltYXRpb25zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvYW5pbWF0aW9uc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIGZvcm1zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIik7XG5leHBvcnRzLkNPTE9SUElDS0VSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IGZvcm1zXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbG9yUGlja2VyOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBDb2xvclBpY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sb3JQaWNrZXIoZWwsIGRvbUhhbmRsZXIsIHJlbmRlcmVyLCBjZCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmZvcm1hdCA9ICdoZXgnO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29sb3IgPSAnZmYwMDAwJztcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIH1cbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaG93bikge1xuICAgICAgICAgICAgdGhpcy5vblNob3coKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sb3JQaWNrZXIucHJvdG90eXBlLm9uSHVlTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnRNb3VzZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmJpbmREb2N1bWVudE1vdXNldXBMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmh1ZURyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5waWNrSHVlKGV2ZW50KTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5waWNrSHVlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLmh1ZVZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWxpZGF0ZUhTQih7XG4gICAgICAgICAgICBoOiBNYXRoLmZsb29yKDM2MCAqICgxNTAgLSBNYXRoLm1heCgwLCBNYXRoLm1pbigxNTAsIChldmVudC5wYWdlWSAtIHRvcCkpKSkgLyAxNTApLFxuICAgICAgICAgICAgczogMTAwLFxuICAgICAgICAgICAgYjogMTAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yU2VsZWN0b3IoKTtcbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCB2YWx1ZTogdGhpcy52YWx1ZSB9KTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5vbkNvbG9yTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnRNb3VzZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmJpbmREb2N1bWVudE1vdXNldXBMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmNvbG9yRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnBpY2tDb2xvcihldmVudCk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUucGlja0NvbG9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jb2xvclNlbGVjdG9yVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB0b3AgPSByZWN0LnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgbGVmdCA9IHJlY3QubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHNhdHVyYXRpb24gPSBNYXRoLmZsb29yKDEwMCAqIChNYXRoLm1heCgwLCBNYXRoLm1pbigxNTAsIChldmVudC5wYWdlWCAtIGxlZnQpKSkpIC8gMTUwKTtcbiAgICAgICAgdmFyIGJyaWdodG5lc3MgPSBNYXRoLmZsb29yKDEwMCAqICgxNTAgLSBNYXRoLm1heCgwLCBNYXRoLm1pbigxNTAsIChldmVudC5wYWdlWSAtIHRvcCkpKSkgLyAxNTApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWxpZGF0ZUhTQih7XG4gICAgICAgICAgICBoOiB0aGlzLnZhbHVlLmgsXG4gICAgICAgICAgICBzOiBzYXR1cmF0aW9uLFxuICAgICAgICAgICAgYjogYnJpZ2h0bmVzc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCB2YWx1ZTogdGhpcy5nZXRWYWx1ZVRvVXBkYXRlKCkgfSk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUuZ2V0VmFsdWVUb1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgc3dpdGNoICh0aGlzLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgICAgICAgICB2YWwgPSAnIycgKyB0aGlzLkhTQnRvSEVYKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLkhTQnRvUkdCKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaHNiJzpcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLmdldFZhbHVlVG9VcGRhdGUoKSk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdoZXgnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5IRVh0b0hTQih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLlJHQnRvSFNCKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaHNiJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLkhFWHRvSFNCKHRoaXMuZGVmYXVsdENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yU2VsZWN0b3IoKTtcbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgIH07XG4gICAgQ29sb3JQaWNrZXIucHJvdG90eXBlLnVwZGF0ZUNvbG9yU2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sb3JTZWxlY3RvclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjJyArIHRoaXMuSFNCdG9IRVgodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUudXBkYXRlVUkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sb3JIYW5kbGVWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gTWF0aC5mbG9vcigxNTAgKiB0aGlzLnZhbHVlLnMgLyAxMDApICsgJ3B4JztcbiAgICAgICAgdGhpcy5jb2xvckhhbmRsZVZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IE1hdGguZmxvb3IoMTUwICogKDEwMCAtIHRoaXMudmFsdWUuYikgLyAxMDApICsgJ3B4JztcbiAgICAgICAgdGhpcy5odWVIYW5kbGVWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AgPSBNYXRoLmZsb29yKDE1MCAtICgxNTAgKiB0aGlzLnZhbHVlLmggLyAzNjApKSArICdweCc7XG4gICAgICAgIHRoaXMuaW5wdXRCZ0NvbG9yID0gJyMnICsgdGhpcy5IU0J0b0hFWCh0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQoKTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhbmVsVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUuekluZGV4ID0gU3RyaW5nKCsrZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4KTtcbiAgICAgICAgdGhpcy5wYW5lbFZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNob3duID0gdHJ1ZTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhbmVsVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgIH07XG4gICAgQ29sb3JQaWNrZXIucHJvdG90eXBlLm9uU2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hbGlnblBhbmVsKCk7XG4gICAgICAgIHRoaXMuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgIH07XG4gICAgQ29sb3JQaWNrZXIucHJvdG90eXBlLmFsaWduUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKVxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24odGhpcy5wYW5lbFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LCB0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIucmVsYXRpdmVQb3NpdGlvbih0aGlzLnBhbmVsVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQsIHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUub25JbnB1dENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGZDbGljayA9IHRydWU7XG4gICAgICAgIHRoaXMudG9nZ2xlUGFuZWwoKTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS50b2dnbGVQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhbmVsVmlzaWJsZSlcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5vbklucHV0S2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgICAvL3NwYWNlXG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlUGFuZWwoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy9lc2NhcGUgYW5kIHRhYlxuICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sb3JQaWNrZXIucHJvdG90eXBlLm9uUGFuZWxDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxmQ2xpY2sgPSB0cnVlO1xuICAgIH07XG4gICAgQ29sb3JQaWNrZXIucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgQ29sb3JQaWNrZXIucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB2YWw7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zZWxmQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFuZWxWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zZWxmQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUudW5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5iaW5kRG9jdW1lbnRNb3VzZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50TW91c2Vtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRNb3VzZW1vdmVMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29sb3JEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5waWNrQ29sb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaHVlRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGlja0h1ZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS51bmJpbmREb2N1bWVudE1vdXNlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudE1vdXNlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50TW91c2Vtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRNb3VzZW1vdmVMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5iaW5kRG9jdW1lbnRNb3VzZXVwTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5kb2N1bWVudE1vdXNldXBMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudE1vdXNldXBMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdtb3VzZXVwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbG9yRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5odWVEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLnVuYmluZERvY3VtZW50TW91c2Vtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy51bmJpbmREb2N1bWVudE1vdXNldXBMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS51bmJpbmREb2N1bWVudE1vdXNldXBMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRNb3VzZXVwTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRNb3VzZXVwTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRNb3VzZXVwTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUudmFsaWRhdGVIU0IgPSBmdW5jdGlvbiAoaHNiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoOiBNYXRoLm1pbigzNjAsIE1hdGgubWF4KDAsIGhzYi5oKSksXG4gICAgICAgICAgICBzOiBNYXRoLm1pbigxMDAsIE1hdGgubWF4KDAsIGhzYi5zKSksXG4gICAgICAgICAgICBiOiBNYXRoLm1pbigxMDAsIE1hdGgubWF4KDAsIGhzYi5iKSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS52YWxpZGF0ZVJHQiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgcmdiLnIpKSxcbiAgICAgICAgICAgIGc6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgcmdiLmcpKSxcbiAgICAgICAgICAgIGI6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgcmdiLmIpKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29sb3JQaWNrZXIucHJvdG90eXBlLnZhbGlkYXRlSEVYID0gZnVuY3Rpb24gKGhleCkge1xuICAgICAgICB2YXIgbGVuID0gNiAtIGhleC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICB2YXIgbyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG8ucHVzaCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgby5wdXNoKGhleCk7XG4gICAgICAgICAgICBoZXggPSBvLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXg7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUuSEVYdG9SR0IgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgIHZhciBoZXhWYWx1ZSA9IHBhcnNlSW50KCgoaGV4LmluZGV4T2YoJyMnKSA+IC0xKSA/IGhleC5zdWJzdHJpbmcoMSkgOiBoZXgpLCAxNik7XG4gICAgICAgIHJldHVybiB7IHI6IGhleFZhbHVlID4+IDE2LCBnOiAoaGV4VmFsdWUgJiAweDAwRkYwMCkgPj4gOCwgYjogKGhleFZhbHVlICYgMHgwMDAwRkYpIH07XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUuSEVYdG9IU0IgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlJHQnRvSFNCKHRoaXMuSEVYdG9SR0IoaGV4KSk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUuUkdCdG9IU0IgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICAgIHZhciBoc2IgPSB7XG4gICAgICAgICAgICBoOiAwLFxuICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgIGI6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgocmdiLnIsIHJnYi5nLCByZ2IuYik7XG4gICAgICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgICAgICAgaHNiLmIgPSBtYXg7XG4gICAgICAgIGlmIChtYXggIT0gMCkge1xuICAgICAgICB9XG4gICAgICAgIGhzYi5zID0gbWF4ICE9IDAgPyAyNTUgKiBkZWx0YSAvIG1heCA6IDA7XG4gICAgICAgIGlmIChoc2IucyAhPSAwKSB7XG4gICAgICAgICAgICBpZiAocmdiLnIgPT0gbWF4KSB7XG4gICAgICAgICAgICAgICAgaHNiLmggPSAocmdiLmcgLSByZ2IuYikgLyBkZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJnYi5nID09IG1heCkge1xuICAgICAgICAgICAgICAgIGhzYi5oID0gMiArIChyZ2IuYiAtIHJnYi5yKSAvIGRlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaHNiLmggPSA0ICsgKHJnYi5yIC0gcmdiLmcpIC8gZGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoc2IuaCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGhzYi5oICo9IDYwO1xuICAgICAgICBpZiAoaHNiLmggPCAwKSB7XG4gICAgICAgICAgICBoc2IuaCArPSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgaHNiLnMgKj0gMTAwIC8gMjU1O1xuICAgICAgICBoc2IuYiAqPSAxMDAgLyAyNTU7XG4gICAgICAgIHJldHVybiBoc2I7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUuSFNCdG9SR0IgPSBmdW5jdGlvbiAoaHNiKSB7XG4gICAgICAgIHZhciByZ2IgPSB7XG4gICAgICAgICAgICByOiBudWxsLCBnOiBudWxsLCBiOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBoID0gTWF0aC5yb3VuZChoc2IuaCk7XG4gICAgICAgIHZhciBzID0gTWF0aC5yb3VuZChoc2IucyAqIDI1NSAvIDEwMCk7XG4gICAgICAgIHZhciB2ID0gTWF0aC5yb3VuZChoc2IuYiAqIDI1NSAvIDEwMCk7XG4gICAgICAgIGlmIChzID09IDApIHtcbiAgICAgICAgICAgIHJnYiA9IHtcbiAgICAgICAgICAgICAgICByOiB2LFxuICAgICAgICAgICAgICAgIGc6IHYsXG4gICAgICAgICAgICAgICAgYjogdlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0MSA9IHY7XG4gICAgICAgICAgICB2YXIgdDIgPSAoMjU1IC0gcykgKiB2IC8gMjU1O1xuICAgICAgICAgICAgdmFyIHQzID0gKHQxIC0gdDIpICogKGggJSA2MCkgLyA2MDtcbiAgICAgICAgICAgIGlmIChoID09IDM2MClcbiAgICAgICAgICAgICAgICBoID0gMDtcbiAgICAgICAgICAgIGlmIChoIDwgNjApIHtcbiAgICAgICAgICAgICAgICByZ2IuciA9IHQxO1xuICAgICAgICAgICAgICAgIHJnYi5iID0gdDI7XG4gICAgICAgICAgICAgICAgcmdiLmcgPSB0MiArIHQzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaCA8IDEyMCkge1xuICAgICAgICAgICAgICAgIHJnYi5nID0gdDE7XG4gICAgICAgICAgICAgICAgcmdiLmIgPSB0MjtcbiAgICAgICAgICAgICAgICByZ2IuciA9IHQxIC0gdDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoIDwgMTgwKSB7XG4gICAgICAgICAgICAgICAgcmdiLmcgPSB0MTtcbiAgICAgICAgICAgICAgICByZ2IuciA9IHQyO1xuICAgICAgICAgICAgICAgIHJnYi5iID0gdDIgKyB0MztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGggPCAyNDApIHtcbiAgICAgICAgICAgICAgICByZ2IuYiA9IHQxO1xuICAgICAgICAgICAgICAgIHJnYi5yID0gdDI7XG4gICAgICAgICAgICAgICAgcmdiLmcgPSB0MSAtIHQzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaCA8IDMwMCkge1xuICAgICAgICAgICAgICAgIHJnYi5iID0gdDE7XG4gICAgICAgICAgICAgICAgcmdiLmcgPSB0MjtcbiAgICAgICAgICAgICAgICByZ2IuciA9IHQyICsgdDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoIDwgMzYwKSB7XG4gICAgICAgICAgICAgICAgcmdiLnIgPSB0MTtcbiAgICAgICAgICAgICAgICByZ2IuZyA9IHQyO1xuICAgICAgICAgICAgICAgIHJnYi5iID0gdDEgLSB0MztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJnYi5yID0gMDtcbiAgICAgICAgICAgICAgICByZ2IuZyA9IDA7XG4gICAgICAgICAgICAgICAgcmdiLmIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHI6IE1hdGgucm91bmQocmdiLnIpLCBnOiBNYXRoLnJvdW5kKHJnYi5nKSwgYjogTWF0aC5yb3VuZChyZ2IuYikgfTtcbiAgICB9O1xuICAgIENvbG9yUGlja2VyLnByb3RvdHlwZS5SR0J0b0hFWCA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgICAgdmFyIGhleCA9IFtcbiAgICAgICAgICAgIHJnYi5yLnRvU3RyaW5nKDE2KSxcbiAgICAgICAgICAgIHJnYi5nLnRvU3RyaW5nKDE2KSxcbiAgICAgICAgICAgIHJnYi5iLnRvU3RyaW5nKDE2KVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGV4KSB7XG4gICAgICAgICAgICBpZiAoaGV4W2tleV0ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBoZXhba2V5XSA9ICcwJyArIGhleFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXguam9pbignJyk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUuSFNCdG9IRVggPSBmdW5jdGlvbiAoaHNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlJHQnRvSEVYKHRoaXMuSFNCdG9SR0IoaHNiKSk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29sb3JQaWNrZXI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbG9yUGlja2VyLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yUGlja2VyLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbG9yUGlja2VyLnByb3RvdHlwZSwgXCJpbmxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2xvclBpY2tlci5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLCBcImFwcGVuZFRvXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbG9yUGlja2VyLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yUGlja2VyLnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yUGlja2VyLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBDb2xvclBpY2tlci5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3BhbmVsJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLCBcInBhbmVsVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdjb2xvclNlbGVjdG9yJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLCBcImNvbG9yU2VsZWN0b3JWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2NvbG9ySGFuZGxlJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLCBcImNvbG9ySGFuZGxlVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdodWUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBDb2xvclBpY2tlci5wcm90b3R5cGUsIFwiaHVlVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdodWVIYW5kbGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBDb2xvclBpY2tlci5wcm90b3R5cGUsIFwiaHVlSGFuZGxlVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdpbnB1dCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIENvbG9yUGlja2VyLnByb3RvdHlwZSwgXCJpbnB1dFZpZXdDaGlsZFwiLCB2b2lkIDApO1xuQ29sb3JQaWNrZXIgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWNvbG9yUGlja2VyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1jb2xvcnBpY2tlciB1aS13aWRnZXQnOnRydWUsJ3VpLWNvbG9ycGlja2VyLW92ZXJsYXknOiFpbmxpbmUsJ3VpLWNvbG9ycGlja2VyLWRyYWdnaW5nJzpjb2xvckRyYWdnaW5nfHxodWVEcmFnZ2luZ31cXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCAjaW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgKm5nSWY9XFxcIiFpbmxpbmVcXFwiIGNsYXNzPVxcXCJ1aS1jb2xvcnBpY2tlci1wcmV2aWV3IHVpLWlucHV0dGV4dCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiIHJlYWRvbmx5PVxcXCJyZWFkb25seVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzogZGlzYWJsZWR9XFxcIlxcbiAgICAgICAgICAgICAgICAoZm9jdXMpPVxcXCJvbklucHV0Rm9jdXMoKVxcXCIgKGNsaWNrKT1cXFwib25JbnB1dENsaWNrKClcXFwiIChrZXlkb3duKT1cXFwib25JbnB1dEtleWRvd24oJGV2ZW50KVxcXCIgW2F0dHIuaWRdPVxcXCJpbnB1dElkXFxcIiBbYXR0ci50YWJpbmRleF09XFxcInRhYmluZGV4XFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XFxcImlucHV0QmdDb2xvclxcXCI+XFxuICAgICAgICAgICAgPGRpdiAjcGFuZWwgW25nQ2xhc3NdPVxcXCJ7J3VpLWNvbG9ycGlja2VyLXBhbmVsIHVpLWNvcm5lci1hbGwnOiB0cnVlLCAndWktY29sb3JwaWNrZXItb3ZlcmxheS1wYW5lbCB1aS1zaGFkb3cnOiFpbmxpbmUsICd1aS1zdGF0ZS1kaXNhYmxlZCc6IGRpc2FibGVkfVxcXCIgKGNsaWNrKT1cXFwib25QYW5lbENsaWNrKClcXFwiXFxuICAgICAgICAgICAgICAgIFtAcGFuZWxTdGF0ZV09XFxcImlubGluZSA/ICd2aXNpYmxlJyA6IChwYW5lbFZpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJylcXFwiIFtzdHlsZS5kaXNwbGF5XT1cXFwiaW5saW5lID8gJ2Jsb2NrJyA6IChwYW5lbFZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnKVxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWNvbG9ycGlja2VyLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiAjY29sb3JTZWxlY3RvciBjbGFzcz1cXFwidWktY29sb3JwaWNrZXItY29sb3Itc2VsZWN0b3JcXFwiIChtb3VzZWRvd24pPVxcXCJvbkNvbG9yTW91c2Vkb3duKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWNvbG9ycGlja2VyLWNvbG9yXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiAjY29sb3JIYW5kbGUgY2xhc3M9XFxcInVpLWNvbG9ycGlja2VyLWNvbG9yLWhhbmRsZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgI2h1ZSBjbGFzcz1cXFwidWktY29sb3JwaWNrZXItaHVlXFxcIiAobW91c2Vkb3duKT1cXFwib25IdWVNb3VzZWRvd24oJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiAjaHVlSGFuZGxlIGNsYXNzPVxcXCJ1aS1jb2xvcnBpY2tlci1odWUtaGFuZGxlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyaWdnZXIoJ3BhbmVsU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCdoaWRkZW4nLCBhbmltYXRpb25zXzEuc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5zdGF0ZSgndmlzaWJsZScsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyYW5zaXRpb24oJ3Zpc2libGUgPT4gaGlkZGVuJywgYW5pbWF0aW9uc18xLmFuaW1hdGUoJzQwMG1zIGVhc2UtaW4nKSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyYW5zaXRpb24oJ2hpZGRlbiA9PiB2aXNpYmxlJywgYW5pbWF0aW9uc18xLmFuaW1hdGUoJzQwMG1zIGVhc2Utb3V0JykpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgZXhwb3J0cy5DT0xPUlBJQ0tFUl9WQUxVRV9BQ0NFU1NPUl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMiwgY29yZV8xLkNoYW5nZURldGVjdG9yUmVmXSlcbl0sIENvbG9yUGlja2VyKTtcbmV4cG9ydHMuQ29sb3JQaWNrZXIgPSBDb2xvclBpY2tlcjtcbnZhciBDb2xvclBpY2tlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sb3JQaWNrZXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb2xvclBpY2tlck1vZHVsZTtcbn0oKSk7XG5Db2xvclBpY2tlck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbQ29sb3JQaWNrZXJdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDb2xvclBpY2tlcl1cbiAgICB9KVxuXSwgQ29sb3JQaWNrZXJNb2R1bGUpO1xuZXhwb3J0cy5Db2xvclBpY2tlck1vZHVsZSA9IENvbG9yUGlja2VyTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3JwaWNrZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jb2xvcnBpY2tlci9jb2xvcnBpY2tlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2NvbG9ycGlja2VyL2NvbG9ycGlja2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbmV4cG9ydHMuRG9tSGFuZGxlciA9IGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyO1xudmFyIHRyZWVkcmFnZHJvcHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3RyZWVkcmFnZHJvcHNlcnZpY2VcIik7XG5leHBvcnRzLlRyZWVEcmFnRHJvcFNlcnZpY2UgPSB0cmVlZHJhZ2Ryb3BzZXJ2aWNlXzEuVHJlZURyYWdEcm9wU2VydmljZTtcbnZhciBjb25maXJtYXRpb25zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9jb25maXJtYXRpb25zZXJ2aWNlXCIpO1xuZXhwb3J0cy5Db25maXJtYXRpb25TZXJ2aWNlID0gY29uZmlybWF0aW9uc2VydmljZV8xLkNvbmZpcm1hdGlvblNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jb21tb24vYXBpLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvY29tbW9uL2FwaS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKFwicnhqcy9TdWJqZWN0XCIpO1xudmFyIENvbmZpcm1hdGlvblNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmZpcm1hdGlvblNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMucmVxdWlyZUNvbmZpcm1hdGlvblNvdXJjZSA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmFjY2VwdENvbmZpcm1hdGlvblNvdXJjZSA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnJlcXVpcmVDb25maXJtYXRpb24kID0gdGhpcy5yZXF1aXJlQ29uZmlybWF0aW9uU291cmNlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmFjY2VwdCA9IHRoaXMuYWNjZXB0Q29uZmlybWF0aW9uU291cmNlLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBDb25maXJtYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24gKGNvbmZpcm1hdGlvbikge1xuICAgICAgICB0aGlzLnJlcXVpcmVDb25maXJtYXRpb25Tb3VyY2UubmV4dChjb25maXJtYXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENvbmZpcm1hdGlvblNlcnZpY2UucHJvdG90eXBlLm9uQWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjY2VwdENvbmZpcm1hdGlvblNvdXJjZS5uZXh0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZmlybWF0aW9uU2VydmljZTtcbn0oKSk7XG5Db25maXJtYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkluamVjdGFibGUoKVxuXSwgQ29uZmlybWF0aW9uU2VydmljZSk7XG5leHBvcnRzLkNvbmZpcm1hdGlvblNlcnZpY2UgPSBDb25maXJtYXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlybWF0aW9uc2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2NvbW1vbi9jb25maXJtYXRpb25zZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvY29tbW9uL2NvbmZpcm1hdGlvbnNlcnZpY2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBjb3JlXzIgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBIZWFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRlcjtcbn0oKSk7XG5IZWFkZXIgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzIuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWhlYWRlcicsXG4gICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PidcbiAgICB9KVxuXSwgSGVhZGVyKTtcbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xudmFyIEZvb3RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9vdGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gRm9vdGVyO1xufSgpKTtcbkZvb3RlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMi5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtZm9vdGVyJyxcbiAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xuICAgIH0pXG5dLCBGb290ZXIpO1xuZXhwb3J0cy5Gb290ZXIgPSBGb290ZXI7XG52YXIgUHJpbWVUZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJpbWVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIFByaW1lVGVtcGxhdGUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpbWVUZW1wbGF0ZTtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUHJpbWVUZW1wbGF0ZS5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCdwVGVtcGxhdGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUHJpbWVUZW1wbGF0ZS5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuUHJpbWVUZW1wbGF0ZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5EaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1twVGVtcGxhdGVdJyxcbiAgICAgICAgaG9zdDoge31cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5UZW1wbGF0ZVJlZl0pXG5dLCBQcmltZVRlbXBsYXRlKTtcbmV4cG9ydHMuUHJpbWVUZW1wbGF0ZSA9IFByaW1lVGVtcGxhdGU7XG52YXIgVGVtcGxhdGVXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVdyYXBwZXIodmlld0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICAgIH1cbiAgICBUZW1wbGF0ZVdyYXBwZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGVSZWYsIHtcbiAgICAgICAgICAgICdcXCRpbXBsaWNpdCc6IHRoaXMuaXRlbSxcbiAgICAgICAgICAgICdpbmRleCc6IHRoaXMuaW5kZXhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVdyYXBwZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlV3JhcHBlcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGVtcGxhdGVXcmFwcGVyLnByb3RvdHlwZSwgXCJpdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVGVtcGxhdGVXcmFwcGVyLnByb3RvdHlwZSwgXCJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCdwVGVtcGxhdGVXcmFwcGVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5UZW1wbGF0ZVJlZilcbl0sIFRlbXBsYXRlV3JhcHBlci5wcm90b3R5cGUsIFwidGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcblRlbXBsYXRlV3JhcHBlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5EaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1twVGVtcGxhdGVXcmFwcGVyXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5WaWV3Q29udGFpbmVyUmVmXSlcbl0sIFRlbXBsYXRlV3JhcHBlcik7XG5leHBvcnRzLlRlbXBsYXRlV3JhcHBlciA9IFRlbXBsYXRlV3JhcHBlcjtcbnZhciBDb2x1bW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtbigpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJUeXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLnNvcnRGdW5jdGlvbiA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIENvbHVtbi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0uZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGVhZGVyVGVtcGxhdGUgPSBpdGVtLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYm9keVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZm9vdGVyVGVtcGxhdGUgPSBpdGVtLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maWx0ZXJUZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRvcic6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVkaXRvclRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYm9keVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbHVtbjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sdW1uLnByb3RvdHlwZSwgXCJmaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwiY29sSWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2x1bW4ucHJvdG90eXBlLCBcInNvcnRGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29sdW1uLnByb3RvdHlwZSwgXCJmb290ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW4ucHJvdG90eXBlLCBcInNvcnRhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwiZWRpdGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uLnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2x1bW4ucHJvdG90eXBlLCBcImZpbHRlck1hdGNoTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwiZmlsdGVyVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwicm93c3BhblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwiY29sc3BhblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb2x1bW4ucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uLnByb3RvdHlwZSwgXCJoaWRkZW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29sdW1uLnByb3RvdHlwZSwgXCJleHBhbmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwic2VsZWN0aW9uTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbi5wcm90b3R5cGUsIFwiZmlsdGVyUGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDb2x1bW4ucHJvdG90eXBlLCBcImZpbHRlck1heGxlbmd0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb2x1bW4ucHJvdG90eXBlLCBcImZyb3plblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgQ29sdW1uLnByb3RvdHlwZSwgXCJzb3J0RnVuY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oUHJpbWVUZW1wbGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5RdWVyeUxpc3QpXG5dLCBDb2x1bW4ucHJvdG90eXBlLCBcInRlbXBsYXRlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChjb3JlXzEuVGVtcGxhdGVSZWYpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuVGVtcGxhdGVSZWYpXG5dLCBDb2x1bW4ucHJvdG90eXBlLCBcInRlbXBsYXRlXCIsIHZvaWQgMCk7XG5Db2x1bW4gPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzIuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWNvbHVtbicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlwiXG4gICAgfSlcbl0sIENvbHVtbik7XG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcbnZhciBSb3cgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdygpIHtcbiAgICB9XG4gICAgcmV0dXJuIFJvdztcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkcmVuKENvbHVtbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5RdWVyeUxpc3QpXG5dLCBSb3cucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgdm9pZCAwKTtcblJvdyA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMi5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3Atcm93JyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXCJcbiAgICB9KVxuXSwgUm93KTtcbmV4cG9ydHMuUm93ID0gUm93O1xudmFyIEhlYWRlckNvbHVtbkdyb3VwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWFkZXJDb2x1bW5Hcm91cCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRlckNvbHVtbkdyb3VwO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oUm93KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlF1ZXJ5TGlzdClcbl0sIEhlYWRlckNvbHVtbkdyb3VwLnByb3RvdHlwZSwgXCJyb3dzXCIsIHZvaWQgMCk7XG5IZWFkZXJDb2x1bW5Hcm91cCA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMi5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtaGVhZGVyQ29sdW1uR3JvdXAnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcIlxuICAgIH0pXG5dLCBIZWFkZXJDb2x1bW5Hcm91cCk7XG5leHBvcnRzLkhlYWRlckNvbHVtbkdyb3VwID0gSGVhZGVyQ29sdW1uR3JvdXA7XG52YXIgRm9vdGVyQ29sdW1uR3JvdXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvb3RlckNvbHVtbkdyb3VwKCkge1xuICAgIH1cbiAgICByZXR1cm4gRm9vdGVyQ29sdW1uR3JvdXA7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZHJlbihSb3cpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuUXVlcnlMaXN0KVxuXSwgRm9vdGVyQ29sdW1uR3JvdXAucHJvdG90eXBlLCBcInJvd3NcIiwgdm9pZCAwKTtcbkZvb3RlckNvbHVtbkdyb3VwID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8yLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1mb290ZXJDb2x1bW5Hcm91cCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlwiXG4gICAgfSlcbl0sIEZvb3RlckNvbHVtbkdyb3VwKTtcbmV4cG9ydHMuRm9vdGVyQ29sdW1uR3JvdXAgPSBGb290ZXJDb2x1bW5Hcm91cDtcbnZhciBDb2x1bW5Cb2R5VGVtcGxhdGVMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlcih2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XG4gICAgfVxuICAgIENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5jb2x1bW4uYm9keVRlbXBsYXRlLCB7XG4gICAgICAgICAgICAnXFwkaW1wbGljaXQnOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICdyb3dEYXRhJzogdGhpcy5yb3dEYXRhLFxuICAgICAgICAgICAgJ3Jvd0luZGV4JzogdGhpcy5yb3dJbmRleFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMudmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgncm93SW5kZXgnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5jb250ZXh0LnJvd0luZGV4ID0gY2hhbmdlc1sncm93SW5kZXgnXS5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29sdW1uQm9keVRlbXBsYXRlTG9hZGVyO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5Cb2R5VGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLCBcImNvbHVtblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUsIFwicm93RGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUsIFwicm93SW5kZXhcIiwgdm9pZCAwKTtcbkNvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMi5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtY29sdW1uQm9keVRlbXBsYXRlTG9hZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5WaWV3Q29udGFpbmVyUmVmXSlcbl0sIENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlcik7XG5leHBvcnRzLkNvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlciA9IENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlcjtcbnZhciBDb2x1bW5IZWFkZXJUZW1wbGF0ZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sdW1uSGVhZGVyVGVtcGxhdGVMb2FkZXIodmlld0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICAgIH1cbiAgICBDb2x1bW5IZWFkZXJUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5jb2x1bW4uaGVhZGVyVGVtcGxhdGUsIHtcbiAgICAgICAgICAgICdcXCRpbXBsaWNpdCc6IHRoaXMuY29sdW1uXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29sdW1uSGVhZGVyVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbHVtbkhlYWRlclRlbXBsYXRlTG9hZGVyO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5IZWFkZXJUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUsIFwiY29sdW1uXCIsIHZvaWQgMCk7XG5Db2x1bW5IZWFkZXJUZW1wbGF0ZUxvYWRlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMi5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtY29sdW1uSGVhZGVyVGVtcGxhdGVMb2FkZXInLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcIlxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLlZpZXdDb250YWluZXJSZWZdKVxuXSwgQ29sdW1uSGVhZGVyVGVtcGxhdGVMb2FkZXIpO1xuZXhwb3J0cy5Db2x1bW5IZWFkZXJUZW1wbGF0ZUxvYWRlciA9IENvbHVtbkhlYWRlclRlbXBsYXRlTG9hZGVyO1xudmFyIENvbHVtbkZvb3RlclRlbXBsYXRlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2x1bW5Gb290ZXJUZW1wbGF0ZUxvYWRlcih2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XG4gICAgfVxuICAgIENvbHVtbkZvb3RlclRlbXBsYXRlTG9hZGVyLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLmNvbHVtbi5mb290ZXJUZW1wbGF0ZSwge1xuICAgICAgICAgICAgJ1xcJGltcGxpY2l0JzogdGhpcy5jb2x1bW5cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2x1bW5Gb290ZXJUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29sdW1uRm9vdGVyVGVtcGxhdGVMb2FkZXI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkZvb3RlclRlbXBsYXRlTG9hZGVyLnByb3RvdHlwZSwgXCJjb2x1bW5cIiwgdm9pZCAwKTtcbkNvbHVtbkZvb3RlclRlbXBsYXRlTG9hZGVyID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8yLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1jb2x1bW5Gb290ZXJUZW1wbGF0ZUxvYWRlcicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlwiXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuVmlld0NvbnRhaW5lclJlZl0pXG5dLCBDb2x1bW5Gb290ZXJUZW1wbGF0ZUxvYWRlcik7XG5leHBvcnRzLkNvbHVtbkZvb3RlclRlbXBsYXRlTG9hZGVyID0gQ29sdW1uRm9vdGVyVGVtcGxhdGVMb2FkZXI7XG52YXIgQ29sdW1uRmlsdGVyVGVtcGxhdGVMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtbkZpbHRlclRlbXBsYXRlTG9hZGVyKHZpZXdDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgQ29sdW1uRmlsdGVyVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuY29sdW1uLmZpbHRlclRlbXBsYXRlLCB7XG4gICAgICAgICAgICAnXFwkaW1wbGljaXQnOiB0aGlzLmNvbHVtblxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbHVtbkZpbHRlclRlbXBsYXRlTG9hZGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBDb2x1bW5GaWx0ZXJUZW1wbGF0ZUxvYWRlcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uRmlsdGVyVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLCBcImNvbHVtblwiLCB2b2lkIDApO1xuQ29sdW1uRmlsdGVyVGVtcGxhdGVMb2FkZXIgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzIuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWNvbHVtbkZpbHRlclRlbXBsYXRlTG9hZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5WaWV3Q29udGFpbmVyUmVmXSlcbl0sIENvbHVtbkZpbHRlclRlbXBsYXRlTG9hZGVyKTtcbmV4cG9ydHMuQ29sdW1uRmlsdGVyVGVtcGxhdGVMb2FkZXIgPSBDb2x1bW5GaWx0ZXJUZW1wbGF0ZUxvYWRlcjtcbnZhciBDb2x1bW5FZGl0b3JUZW1wbGF0ZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sdW1uRWRpdG9yVGVtcGxhdGVMb2FkZXIodmlld0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICAgIH1cbiAgICBDb2x1bW5FZGl0b3JUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5jb2x1bW4uZWRpdG9yVGVtcGxhdGUsIHtcbiAgICAgICAgICAgICdcXCRpbXBsaWNpdCc6IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgJ3Jvd0RhdGEnOiB0aGlzLnJvd0RhdGEsXG4gICAgICAgICAgICAncm93SW5kZXgnOiB0aGlzLnJvd0luZGV4XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29sdW1uRWRpdG9yVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbHVtbkVkaXRvclRlbXBsYXRlTG9hZGVyO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5FZGl0b3JUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUsIFwiY29sdW1uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uRWRpdG9yVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLCBcInJvd0RhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5FZGl0b3JUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUsIFwicm93SW5kZXhcIiwgdm9pZCAwKTtcbkNvbHVtbkVkaXRvclRlbXBsYXRlTG9hZGVyID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8yLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1jb2x1bW5FZGl0b3JUZW1wbGF0ZUxvYWRlcicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlwiXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuVmlld0NvbnRhaW5lclJlZl0pXG5dLCBDb2x1bW5FZGl0b3JUZW1wbGF0ZUxvYWRlcik7XG5leHBvcnRzLkNvbHVtbkVkaXRvclRlbXBsYXRlTG9hZGVyID0gQ29sdW1uRWRpdG9yVGVtcGxhdGVMb2FkZXI7XG52YXIgVGVtcGxhdGVMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlTG9hZGVyKHZpZXdDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlLCB7XG4gICAgICAgICAgICAgICAgJ1xcJGltcGxpY2l0JzogdGhpcy5kYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3KVxuICAgICAgICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBUZW1wbGF0ZUxvYWRlcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlRlbXBsYXRlUmVmKVxuXSwgVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLCBcInRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcblRlbXBsYXRlTG9hZGVyID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8yLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC10ZW1wbGF0ZUxvYWRlcicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlwiXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuVmlld0NvbnRhaW5lclJlZl0pXG5dLCBUZW1wbGF0ZUxvYWRlcik7XG5leHBvcnRzLlRlbXBsYXRlTG9hZGVyID0gVGVtcGxhdGVMb2FkZXI7XG52YXIgU2hhcmVkTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaGFyZWRNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBTaGFyZWRNb2R1bGU7XG59KCkpO1xuU2hhcmVkTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtIZWFkZXIsIEZvb3RlciwgQ29sdW1uLCBUZW1wbGF0ZVdyYXBwZXIsIENvbHVtbkhlYWRlclRlbXBsYXRlTG9hZGVyLCBDb2x1bW5Cb2R5VGVtcGxhdGVMb2FkZXIsIENvbHVtbkZvb3RlclRlbXBsYXRlTG9hZGVyLCBDb2x1bW5GaWx0ZXJUZW1wbGF0ZUxvYWRlciwgUHJpbWVUZW1wbGF0ZSwgVGVtcGxhdGVMb2FkZXIsIFJvdywgSGVhZGVyQ29sdW1uR3JvdXAsIEZvb3RlckNvbHVtbkdyb3VwLCBDb2x1bW5FZGl0b3JUZW1wbGF0ZUxvYWRlcl0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW0hlYWRlciwgRm9vdGVyLCBDb2x1bW4sIFRlbXBsYXRlV3JhcHBlciwgQ29sdW1uSGVhZGVyVGVtcGxhdGVMb2FkZXIsIENvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlciwgQ29sdW1uRm9vdGVyVGVtcGxhdGVMb2FkZXIsIENvbHVtbkZpbHRlclRlbXBsYXRlTG9hZGVyLCBQcmltZVRlbXBsYXRlLCBUZW1wbGF0ZUxvYWRlciwgUm93LCBIZWFkZXJDb2x1bW5Hcm91cCwgRm9vdGVyQ29sdW1uR3JvdXAsIENvbHVtbkVkaXRvclRlbXBsYXRlTG9hZGVyXVxuICAgIH0pXG5dLCBTaGFyZWRNb2R1bGUpO1xuZXhwb3J0cy5TaGFyZWRNb2R1bGUgPSBTaGFyZWRNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9jb21tb24vc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvY29tbW9uL3NoYXJlZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKFwicnhqcy9TdWJqZWN0XCIpO1xudmFyIFRyZWVEcmFnRHJvcFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyZWVEcmFnRHJvcFNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuZHJhZ1N0b3BTb3VyY2UgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQkID0gdGhpcy5kcmFnU3RhcnRTb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuZHJhZ1N0b3AkID0gdGhpcy5kcmFnU3RvcFNvdXJjZS5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgVHJlZURyYWdEcm9wU2VydmljZS5wcm90b3R5cGUuc3RhcnREcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlLm5leHQoZXZlbnQpO1xuICAgIH07XG4gICAgVHJlZURyYWdEcm9wU2VydmljZS5wcm90b3R5cGUuc3RvcERyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnU3RvcFNvdXJjZS5uZXh0KGV2ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBUcmVlRHJhZ0Ryb3BTZXJ2aWNlO1xufSgpKTtcblRyZWVEcmFnRHJvcFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5qZWN0YWJsZSgpXG5dLCBUcmVlRHJhZ0Ryb3BTZXJ2aWNlKTtcbmV4cG9ydHMuVHJlZURyYWdEcm9wU2VydmljZSA9IFRyZWVEcmFnRHJvcFNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVlZHJhZ2Ryb3BzZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvY29tbW9uL3RyZWVkcmFnZHJvcHNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9jb21tb24vdHJlZWRyYWdkcm9wc2VydmljZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYW5pbWF0aW9uc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2FuaW1hdGlvbnNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc2hhcmVkXCIpO1xudmFyIGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL2J1dHRvbi9idXR0b25cIik7XG52YXIgY29uZmlybWF0aW9uc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb25maXJtYXRpb25zZXJ2aWNlXCIpO1xudmFyIENvbmZpcm1EaWFsb2cgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmZpcm1EaWFsb2coZWwsIGRvbUhhbmRsZXIsIHJlbmRlcmVyLCBjb25maXJtYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNvbmZpcm1hdGlvblNlcnZpY2UgPSBjb25maXJtYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmFjY2VwdEljb24gPSAnZmEtY2hlY2snO1xuICAgICAgICB0aGlzLmFjY2VwdExhYmVsID0gJ1llcyc7XG4gICAgICAgIHRoaXMuYWNjZXB0VmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVqZWN0SWNvbiA9ICdmYS1jbG9zZSc7XG4gICAgICAgIHRoaXMucmVqZWN0TGFiZWwgPSAnTm8nO1xuICAgICAgICB0aGlzLnJlamVjdFZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlT25Fc2NhcGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBjb25maXJtYXRpb25TZXJ2aWNlLnJlcXVpcmVDb25maXJtYXRpb24kLnN1YnNjcmliZShmdW5jdGlvbiAoY29uZmlybWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uLmtleSA9PT0gX3RoaXMua2V5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29uZmlybWF0aW9uID0gY29uZmlybWF0aW9uO1xuICAgICAgICAgICAgICAgIF90aGlzLm1lc3NhZ2UgPSBfdGhpcy5jb25maXJtYXRpb24ubWVzc2FnZSB8fCBfdGhpcy5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIF90aGlzLmljb24gPSBfdGhpcy5jb25maXJtYXRpb24uaWNvbiB8fCBfdGhpcy5pY29uO1xuICAgICAgICAgICAgICAgIF90aGlzLmhlYWRlciA9IF90aGlzLmNvbmZpcm1hdGlvbi5oZWFkZXIgfHwgX3RoaXMuaGVhZGVyO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlamVjdFZpc2libGUgPSBfdGhpcy5jb25maXJtYXRpb24ucmVqZWN0VmlzaWJsZSA9PSBudWxsID8gX3RoaXMucmVqZWN0VmlzaWJsZSA6IF90aGlzLmNvbmZpcm1hdGlvbi5yZWplY3RWaXNpYmxlO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY2VwdFZpc2libGUgPSBfdGhpcy5jb25maXJtYXRpb24uYWNjZXB0VmlzaWJsZSA9PSBudWxsID8gX3RoaXMuYWNjZXB0VmlzaWJsZSA6IF90aGlzLmNvbmZpcm1hdGlvbi5hY2NlcHRWaXNpYmxlO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb25maXJtYXRpb24uYWNjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpcm1hdGlvbi5hY2NlcHRFdmVudCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpcm1hdGlvbi5hY2NlcHRFdmVudC5zdWJzY3JpYmUoX3RoaXMuY29uZmlybWF0aW9uLmFjY2VwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb25maXJtYXRpb24ucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpcm1hdGlvbi5yZWplY3RFdmVudCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpcm1hdGlvbi5yZWplY3RFdmVudC5zdWJzY3JpYmUoX3RoaXMuY29uZmlybWF0aW9uLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbmZpcm1EaWFsb2cucHJvdG90eXBlLCBcInZpc2libGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3NpdGlvbkluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25Jbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5zdHlsZS56SW5kZXggPSArK2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLnppbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVQb3N0U2hvd0FjdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVNb2RhbGl0eSgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZU1vZGFsaXR5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250ZW50Q29udGFpbmVyID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnLnVpLWRpYWxvZy1jb250ZW50Jyk7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZXNwb25zaXZlTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbignd2luZG93JywgJ3Jlc2l6ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNlbnRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VPbkVzY2FwZSAmJiB0aGlzLmNsb3NhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50RXNjYXBlTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PSAyNykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5zdHlsZS56SW5kZXggPT0gZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcHBlbmRUbykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8gPT09ICdib2R5JylcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFwcGVuZENoaWxkKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgdGhpcy5hcHBlbmRUbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhlY3V0ZVBvc3RTaG93QWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLCAnYnV0dG9uJykuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZVBvc3RTaG93QWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25maXJtRGlhbG9nLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIHZhciBlbGVtZW50V2lkdGggPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aChjb250YWluZXIpO1xuICAgICAgICB2YXIgZWxlbWVudEhlaWdodCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlckhlaWdodChjb250YWluZXIpO1xuICAgICAgICBpZiAoZWxlbWVudFdpZHRoID09IDAgJiYgZWxlbWVudEhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgZWxlbWVudFdpZHRoID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVyV2lkdGgoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJIZWlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5kb21IYW5kbGVyLmdldFZpZXdwb3J0KCk7XG4gICAgICAgIHZhciB4ID0gKHZpZXdwb3J0LndpZHRoIC0gZWxlbWVudFdpZHRoKSAvIDI7XG4gICAgICAgIHZhciB5ID0gKHZpZXdwb3J0LmhlaWdodCAtIGVsZW1lbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIH07XG4gICAgQ29uZmlybURpYWxvZy5wcm90b3R5cGUuZW5hYmxlTW9kYWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXNrKSB7XG4gICAgICAgICAgICB0aGlzLm1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMubWFzay5zdHlsZS56SW5kZXggPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uc3R5bGUuekluZGV4IC0gMTtcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hZGRNdWx0aXBsZUNsYXNzZXModGhpcy5tYXNrLCAndWktd2lkZ2V0LW92ZXJsYXkgdWktZGlhbG9nLW1hc2snKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5tYXNrKTtcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAndWktb3ZlcmZsb3ctaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLmRpc2FibGVNb2RhbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm1hc2spO1xuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICd1aS1vdmVyZmxvdy1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMubWFzayA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpcm1hdGlvbi5yZWplY3RFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb25maXJtYXRpb24ucmVqZWN0RXZlbnQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgQ29uZmlybURpYWxvZy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgfTtcbiAgICBDb25maXJtRGlhbG9nLnByb3RvdHlwZS5tb3ZlT25Ub3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5zdHlsZS56SW5kZXggPSArK2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLnppbmRleDtcbiAgICB9O1xuICAgIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc2FibGVNb2RhbGl0eSgpO1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudFJlc3BvbnNpdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFJlc3BvbnNpdmVMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50RXNjYXBlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRFc2NhcGVMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvICYmIHRoaXMuYXBwZW5kVG8gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBDb25maXJtRGlhbG9nLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpcm1hdGlvbi5hY2NlcHRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb25maXJtYXRpb24uYWNjZXB0RXZlbnQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLmNvbmZpcm1hdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBDb25maXJtRGlhbG9nLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpcm1hdGlvbi5yZWplY3RFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb25maXJtYXRpb24ucmVqZWN0RXZlbnQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLmNvbmZpcm1hdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZmlybURpYWxvZztcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb25maXJtRGlhbG9nLnByb3RvdHlwZSwgXCJhY2NlcHRJY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwiYWNjZXB0TGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwiYWNjZXB0VmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLCBcInJlamVjdEljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb25maXJtRGlhbG9nLnByb3RvdHlwZSwgXCJyZWplY3RMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb25maXJtRGlhbG9nLnByb3RvdHlwZSwgXCJyZWplY3RWaXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb25maXJtRGlhbG9nLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwiY2xvc2VPbkVzY2FwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDb25maXJtRGlhbG9nLnByb3RvdHlwZSwgXCJydGxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwiY2xvc2FibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwicmVzcG9uc2l2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLCBcImFwcGVuZFRvXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ29uZmlybURpYWxvZy5wcm90b3R5cGUsIFwia2V5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkKHNoYXJlZF8xLkZvb3RlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbmZpcm1EaWFsb2cucHJvdG90eXBlLCBcImZvb3RlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBDb25maXJtRGlhbG9nLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIG51bGwpO1xuQ29uZmlybURpYWxvZyA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtY29uZmlybURpYWxvZycsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcInsndWktZGlhbG9nIHVpLWNvbmZpcm1kaWFsb2cgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktc2hhZG93Jzp0cnVlLCd1aS1kaWFsb2ctcnRsJzpydGx9XFxcIiBcXG4gICAgICAgICAgICBbc3R5bGUuZGlzcGxheV09XFxcInZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnXFxcIiBbc3R5bGUud2lkdGgucHhdPVxcXCJ3aWR0aFxcXCIgW3N0eWxlLmhlaWdodC5weF09XFxcImhlaWdodFxcXCIgKG1vdXNlZG93bik9XFxcIm1vdmVPblRvcCgpXFxcIiBbQGRpYWxvZ1N0YXRlXT1cXFwidmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kaWFsb2ctdGl0bGViYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLXRvcFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1kaWFsb2ctdGl0bGVcXFwiICpuZ0lmPVxcXCJoZWFkZXJcXFwiPnt7aGVhZGVyfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCJjbG9zYWJsZVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLWRpYWxvZy10aXRsZWJhci1pY29uIHVpLWRpYWxvZy10aXRsZWJhci1jbG9zZSB1aS1jb3JuZXItYWxsJzp0cnVlfVxcXCIgaHJlZj1cXFwiI1xcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIiAoY2xpY2spPVxcXCJjbG9zZSgkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1jbG9zZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZGlhbG9nLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBbbmdDbGFzc109XFxcIidmYSdcXFwiIFtjbGFzc109XFxcImljb25cXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWNvbmZpcm1kaWFsb2ctbWVzc2FnZVxcXCIgW2lubmVySFRNTF09XFxcIm1lc3NhZ2VcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kaWFsb2ctZm9vdGVyIHVpLXdpZGdldC1jb250ZW50XFxcIiAqbmdJZj1cXFwiZm9vdGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJwLWZvb3RlclxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWRpYWxvZy1mb290ZXIgdWktd2lkZ2V0LWNvbnRlbnRcXFwiICpuZ0lmPVxcXCIhZm9vdGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gW2ljb25dPVxcXCJhY2NlcHRJY29uXFxcIiBbbGFiZWxdPVxcXCJhY2NlcHRMYWJlbFxcXCIgKGNsaWNrKT1cXFwiYWNjZXB0KClcXFwiICpuZ0lmPVxcXCJhY2NlcHRWaXNpYmxlXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gW2ljb25dPVxcXCJyZWplY3RJY29uXFxcIiBbbGFiZWxdPVxcXCJyZWplY3RMYWJlbFxcXCIgKGNsaWNrKT1cXFwicmVqZWN0KClcXFwiICpuZ0lmPVxcXCJyZWplY3RWaXNpYmxlXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyaWdnZXIoJ2RpYWxvZ1N0YXRlJywgW1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5zdGF0ZSgnaGlkZGVuJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuc3RhdGUoJ3Zpc2libGUnLCBhbmltYXRpb25zXzEuc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS50cmFuc2l0aW9uKCd2aXNpYmxlID0+IGhpZGRlbicsIGFuaW1hdGlvbnNfMS5hbmltYXRlKCc0MDBtcyBlYXNlLWluJykpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS50cmFuc2l0aW9uKCdoaWRkZW4gPT4gdmlzaWJsZScsIGFuaW1hdGlvbnNfMS5hbmltYXRlKCc0MDBtcyBlYXNlLW91dCcpKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsXG4gICAgICAgIGNvcmVfMS5SZW5kZXJlcjIsIGNvbmZpcm1hdGlvbnNlcnZpY2VfMS5Db25maXJtYXRpb25TZXJ2aWNlXSlcbl0sIENvbmZpcm1EaWFsb2cpO1xuZXhwb3J0cy5Db25maXJtRGlhbG9nID0gQ29uZmlybURpYWxvZztcbnZhciBDb25maXJtRGlhbG9nTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25maXJtRGlhbG9nTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29uZmlybURpYWxvZ01vZHVsZTtcbn0oKSk7XG5Db25maXJtRGlhbG9nTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgYnV0dG9uXzEuQnV0dG9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0NvbmZpcm1EaWFsb2csIGJ1dHRvbl8xLkJ1dHRvbk1vZHVsZSwgc2hhcmVkXzEuU2hhcmVkTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQ29uZmlybURpYWxvZ11cbiAgICB9KVxuXSwgQ29uZmlybURpYWxvZ01vZHVsZSk7XG5leHBvcnRzLkNvbmZpcm1EaWFsb2dNb2R1bGUgPSBDb25maXJtRGlhbG9nTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlybWRpYWxvZy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2NvbmZpcm1kaWFsb2cvY29uZmlybWRpYWxvZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2NvbmZpcm1kaWFsb2cvY29uZmlybWRpYWxvZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL3JvdXRlclwiKTtcbnZhciBDb250ZXh0TWVudVN1YiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dE1lbnVTdWIoZG9tSGFuZGxlciwgY29udGV4dE1lbnUpIHtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudSA9IGNvbnRleHRNZW51O1xuICAgIH1cbiAgICBDb250ZXh0TWVudVN1Yi5wcm90b3R5cGUub25JdGVtTW91c2VFbnRlciA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSwgbWVudWl0ZW0pIHtcbiAgICAgICAgaWYgKG1lbnVpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gaXRlbTtcbiAgICAgICAgdmFyIG5leHRFbGVtZW50ID0gaXRlbS5jaGlsZHJlblswXS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGlmIChuZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHN1Ymxpc3QgPSBuZXh0RWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHN1Ymxpc3Quc3R5bGUuekluZGV4ID0gKytkb21oYW5kbGVyXzEuRG9tSGFuZGxlci56aW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKHN1Ymxpc3QsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZXh0TWVudVN1Yi5wcm90b3R5cGUub25JdGVtTW91c2VMZWF2ZSA9IGZ1bmN0aW9uIChldmVudCwgbGluaykge1xuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSBudWxsO1xuICAgIH07XG4gICAgQ29udGV4dE1lbnVTdWIucHJvdG90eXBlLml0ZW1DbGljayA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWl0ZW0udXJsKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmNvbW1hbmQpIHtcbiAgICAgICAgICAgIGl0ZW0uY29tbWFuZCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRleHRNZW51U3ViLnByb3RvdHlwZS5saXN0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gbnVsbDtcbiAgICB9O1xuICAgIENvbnRleHRNZW51U3ViLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uIChzdWJsaXN0LCBpdGVtKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyTGVmdCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPZmZzZXQoaXRlbS5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5kb21IYW5kbGVyLmdldFZpZXdwb3J0KCk7XG4gICAgICAgIHZhciBzdWJsaXN0V2lkdGggPSBzdWJsaXN0Lm9mZnNldFBhcmVudCA/IHN1Ymxpc3Qub2Zmc2V0V2lkdGggOiB0aGlzLmRvbUhhbmRsZXIuZ2V0SGlkZGVuRWxlbWVudE91dGVyV2lkdGgoc3VibGlzdCk7XG4gICAgICAgIHZhciBpdGVtT3V0ZXJXaWR0aCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlcldpZHRoKGl0ZW0uY2hpbGRyZW5bMF0pO1xuICAgICAgICBzdWJsaXN0LnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICBpZiAoKHBhcnNlSW50KHRoaXMuY29udGFpbmVyTGVmdC5sZWZ0KSArIGl0ZW1PdXRlcldpZHRoICsgc3VibGlzdFdpZHRoKSA+ICh2aWV3cG9ydC53aWR0aCAtIHRoaXMuY2FsY3VsYXRlU2Nyb2xsYmFyV2lkdGgoKSkpIHtcbiAgICAgICAgICAgIHN1Ymxpc3Quc3R5bGUubGVmdCA9IC1zdWJsaXN0V2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VibGlzdC5zdHlsZS5sZWZ0ID0gaXRlbU91dGVyV2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZXh0TWVudVN1Yi5wcm90b3R5cGUuY2FsY3VsYXRlU2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gXCJ1aS1zY3JvbGxiYXItbWVhc3VyZVwiO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGV4dE1lbnVTdWI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbnRleHRNZW51U3ViLnByb3RvdHlwZSwgXCJpdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbnRleHRNZW51U3ViLnByb3RvdHlwZSwgXCJyb290XCIsIHZvaWQgMCk7XG5Db250ZXh0TWVudVN1YiA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtY29udGV4dE1lbnVTdWInLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDx1bCBbbmdDbGFzc109XFxcInsndWktaGVscGVyLXJlc2V0Jzpyb290LCAndWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXggdWktbWVudS1jaGlsZCB1aS1zaGFkb3cnOiFyb290fVxcXCIgY2xhc3M9XFxcInVpLW1lbnUtbGlzdFxcXCJcXG4gICAgICAgICAgICAoY2xpY2spPVxcXCJsaXN0Q2xpY2soJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jaGlsZCBbbmdGb3JPZl09XFxcIihyb290ID8gaXRlbSA6IGl0ZW0uaXRlbXMpXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpICpuZ0lmPVxcXCJjaGlsZC5zZXBhcmF0b3JcXFwiIGNsYXNzPVxcXCJ1aS1tZW51LXNlcGFyYXRvciB1aS13aWRnZXQtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSAqbmdJZj1cXFwiIWNoaWxkLnNlcGFyYXRvclxcXCIgI2l0ZW0gW25nQ2xhc3NdPVxcXCJ7J3VpLW1lbnVpdGVtIHVpLXdpZGdldCB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1tZW51LXBhcmVudCc6Y2hpbGQuaXRlbXMsJ3VpLW1lbnVpdGVtLWFjdGl2ZSc6aXRlbT09YWN0aXZlSXRlbX1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAobW91c2VlbnRlcik9XFxcIm9uSXRlbU1vdXNlRW50ZXIoJGV2ZW50LGl0ZW0sY2hpbGQpXFxcIiAobW91c2VsZWF2ZSk9XFxcIm9uSXRlbU1vdXNlTGVhdmUoJGV2ZW50LGl0ZW0pXFxcIiBbc3R5bGUuZGlzcGxheV09XFxcImNoaWxkLnZpc2libGUgPT09IGZhbHNlID8gJ25vbmUnIDogJ2Jsb2NrJ1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiIWNoaWxkLnJvdXRlckxpbmtcXFwiIFtocmVmXT1cXFwiY2hpbGQudXJsfHwnIydcXFwiIFthdHRyLnRhcmdldF09XFxcImNoaWxkLnRhcmdldFxcXCIgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgY2hpbGQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1tZW51aXRlbS1saW5rIHVpLWNvcm5lci1hbGwnOnRydWUsJ3VpLXN0YXRlLWRpc2FibGVkJzpjaGlsZC5kaXNhYmxlZH1cXFwiIFtuZ1N0eWxlXT1cXFwiY2hpbGQuc3R5bGVcXFwiIFtjbGFzc109XFxcImNoaWxkLnN0eWxlQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1zdWJtZW51LWljb24gZmEgZmEtZncgZmEtY2FyZXQtcmlnaHRcXFwiICpuZ0lmPVxcXCJjaGlsZC5pdGVtc1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1pY29uIGZhIGZhLWZ3XFxcIiAqbmdJZj1cXFwiY2hpbGQuaWNvblxcXCIgW25nQ2xhc3NdPVxcXCJjaGlsZC5pY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLXRleHRcXFwiPnt7Y2hpbGQubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCJjaGlsZC5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua109XFxcImNoaWxkLnJvdXRlckxpbmtcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiJ3VpLXN0YXRlLWFjdGl2ZSdcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc109XFxcImNoaWxkLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zfHx7ZXhhY3Q6ZmFsc2V9XFxcIiBbYXR0ci50YXJnZXRdPVxcXCJjaGlsZC50YXJnZXRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgY2hpbGQpXFxcIiBbbmdDbGFzc109XFxcInsndWktbWVudWl0ZW0tbGluayB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1zdGF0ZS1kaXNhYmxlZCc6Y2hpbGQuZGlzYWJsZWR9XFxcIiBbbmdTdHlsZV09XFxcImNoaWxkLnN0eWxlXFxcIiBbY2xhc3NdPVxcXCJjaGlsZC5zdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktc3VibWVudS1pY29uIGZhIGZhLWZ3IGZhLWNhcmV0LXJpZ2h0XFxcIiAqbmdJZj1cXFwiY2hpbGQuaXRlbXNcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYSBmYS1md1xcXCIgKm5nSWY9XFxcImNoaWxkLmljb25cXFwiIFtuZ0NsYXNzXT1cXFwiY2hpbGQuaWNvblxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS10ZXh0XFxcIj57e2NoaWxkLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8cC1jb250ZXh0TWVudVN1YiBjbGFzcz1cXFwidWktc3VibWVudVxcXCIgW2l0ZW1dPVxcXCJjaGlsZFxcXCIgKm5nSWY9XFxcImNoaWxkLml0ZW1zXFxcIj48L3AtY29udGV4dE1lbnVTdWI+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgIDwvdWw+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX3BhcmFtKDEsIGNvcmVfMS5JbmplY3QoY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29udGV4dE1lbnU7IH0pKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgQ29udGV4dE1lbnVdKVxuXSwgQ29udGV4dE1lbnVTdWIpO1xuZXhwb3J0cy5Db250ZXh0TWVudVN1YiA9IENvbnRleHRNZW51U3ViO1xudmFyIENvbnRleHRNZW51ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0TWVudShlbCwgZG9tSGFuZGxlciwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5nbG9iYWwpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvdyhldmVudCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMudGFyZ2V0LCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zaG93KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvID09PSAnYm9keScpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyLCB0aGlzLmFwcGVuZFRvKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbihldmVudCk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5mYWRlSW4odGhpcy5jb250YWluZXIsIDI1MCk7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH07XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKVxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hvdyhldmVudCk7XG4gICAgfTtcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGV2ZW50LnBhZ2VYICsgMTtcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IGV2ZW50LnBhZ2VZICsgMTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFBhcmVudCA/IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIDogdGhpcy5kb21IYW5kbGVyLmdldEhpZGRlbkVsZW1lbnRPdXRlcldpZHRoKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRQYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgOiB0aGlzLmRvbUhhbmRsZXIuZ2V0SGlkZGVuRWxlbWVudE91dGVySGVpZ2h0KHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuZG9tSGFuZGxlci5nZXRWaWV3cG9ydCgpO1xuICAgICAgICAgICAgLy9mbGlwXG4gICAgICAgICAgICBpZiAobGVmdCArIHdpZHRoIC0gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID4gdmlld3BvcnQud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9mbGlwXG4gICAgICAgICAgICBpZiAodG9wXzEgKyBoZWlnaHQgLSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA+IHZpZXdwb3J0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvcF8xIC09IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vZml0XG4gICAgICAgICAgICBpZiAobGVmdCA8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2ZpdFxuICAgICAgICAgICAgaWYgKHRvcF8xIDwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICB0b3BfMSA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudG9wID0gdG9wXzEgKyAncHgnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yaWdodENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0TWVudTtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDb250ZXh0TWVudS5wcm90b3R5cGUsIFwibW9kZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ29udGV4dE1lbnUucHJvdG90eXBlLCBcImdsb2JhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbnRleHRNZW51LnByb3RvdHlwZSwgXCJ0YXJnZXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb250ZXh0TWVudS5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDb250ZXh0TWVudS5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbnRleHRNZW51LnByb3RvdHlwZSwgXCJhcHBlbmRUb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnY29udGFpbmVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgQ29udGV4dE1lbnUucHJvdG90eXBlLCBcImNvbnRhaW5lclZpZXdDaGlsZFwiLCB2b2lkIDApO1xuQ29udGV4dE1lbnUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWNvbnRleHRNZW51JyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2ICNjb250YWluZXIgW25nQ2xhc3NdPVxcXCIndWktY29udGV4dG1lbnUgdWktbWVudSB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXggdWktbWVudS1keW5hbWljIHVpLXNoYWRvdydcXFwiIFxcbiAgICAgICAgICAgIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtzdHlsZS5kaXNwbGF5XT1cXFwidmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSdcXFwiPlxcbiAgICAgICAgICAgIDxwLWNvbnRleHRNZW51U3ViIFtpdGVtXT1cXFwibW9kZWxcXFwiIHJvb3Q9XFxcInJvb3RcXFwiPjwvcC1jb250ZXh0TWVudVN1Yj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIGNvcmVfMS5SZW5kZXJlcjJdKVxuXSwgQ29udGV4dE1lbnUpO1xuZXhwb3J0cy5Db250ZXh0TWVudSA9IENvbnRleHRNZW51O1xudmFyIENvbnRleHRNZW51TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0TWVudU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIENvbnRleHRNZW51TW9kdWxlO1xufSgpKTtcbkNvbnRleHRNZW51TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgcm91dGVyXzEuUm91dGVyTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0NvbnRleHRNZW51LCByb3V0ZXJfMS5Sb3V0ZXJNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDb250ZXh0TWVudSwgQ29udGV4dE1lbnVTdWJdXG4gICAgfSlcbl0sIENvbnRleHRNZW51TW9kdWxlKTtcbmV4cG9ydHMuQ29udGV4dE1lbnVNb2R1bGUgPSBDb250ZXh0TWVudU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHRtZW51LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvY29udGV4dG1lbnUvY29udGV4dG1lbnUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9jb250ZXh0bWVudS9jb250ZXh0bWVudS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zaGFyZWRcIik7XG52YXIgcGFnaW5hdG9yXzEgPSByZXF1aXJlKFwiLi4vcGFnaW5hdG9yL3BhZ2luYXRvclwiKTtcbnZhciBEYXRhR3JpZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YUdyaWQoZWwsIGRpZmZlcnMpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRpZmZlcnMgPSBkaWZmZXJzO1xuICAgICAgICB0aGlzLnBhZ2VMaW5rcyA9IDU7XG4gICAgICAgIHRoaXMuZW1wdHlNZXNzYWdlID0gJ05vIHJlY29yZHMgZm91bmQnO1xuICAgICAgICB0aGlzLm9uTGF6eUxvYWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnBhZ2luYXRvclBvc2l0aW9uID0gJ2JvdHRvbSc7XG4gICAgICAgIHRoaXMuYWx3YXlzU2hvd1BhZ2luYXRvciA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkgeyByZXR1cm4gaXRlbTsgfTtcbiAgICAgICAgdGhpcy5pbW11dGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uUGFnZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZmlyc3QgPSAwO1xuICAgICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgICB0aGlzLmRpZmZlciA9IGRpZmZlcnMuZmluZChbXSkuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICAgICAgICB0aGlzLm9uTGF6eUxvYWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5yb3dzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YUdyaWQucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgc3dpdGNoIChpdGVtLmdldFR5cGUoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pdGVtVGVtcGxhdGUgPSBpdGVtLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pdGVtVGVtcGxhdGUgPSBpdGVtLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUdyaWQucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURhdGFDaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGF0YUdyaWQucHJvdG90eXBlLmhhbmRsZURhdGFDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhZ2luYXRvcikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdpbmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZURhdGFUb1JlbmRlcih0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5kaWZmZXIuZGlmZih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS51cGRhdGVQYWdpbmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vdG90YWwgcmVjb3Jkc1xuICAgICAgICB0aGlzLnRvdGFsUmVjb3JkcyA9IHRoaXMubGF6eSA/IHRoaXMudG90YWxSZWNvcmRzIDogKHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmxlbmd0aCA6IDApO1xuICAgICAgICAvL2ZpcnN0XG4gICAgICAgIGlmICh0aGlzLnRvdGFsUmVjb3JkcyAmJiB0aGlzLmZpcnN0ID49IHRoaXMudG90YWxSZWNvcmRzKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyT2ZQYWdlcyA9IE1hdGguY2VpbCh0aGlzLnRvdGFsUmVjb3JkcyAvIHRoaXMucm93cyk7XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gTWF0aC5tYXgoKG51bWJlck9mUGFnZXMgLSAxKSAqIHRoaXMucm93cywgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5wYWdpbmF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZpcnN0ID0gZXZlbnQuZmlyc3Q7XG4gICAgICAgIHRoaXMucm93cyA9IGV2ZW50LnJvd3M7XG4gICAgICAgIGlmICh0aGlzLmxhenkpIHtcbiAgICAgICAgICAgIHRoaXMub25MYXp5TG9hZC5lbWl0KHRoaXMuY3JlYXRlTGF6eUxvYWRNZXRhZGF0YSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25QYWdlLmVtaXQoe1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICByb3dzOiB0aGlzLnJvd3NcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEYXRhR3JpZC5wcm90b3R5cGUudXBkYXRlRGF0YVRvUmVuZGVyID0gZnVuY3Rpb24gKGRhdGFzb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucGFnaW5hdG9yICYmIGRhdGFzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVRvUmVuZGVyID0gW107XG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMubGF6eSA/IDAgOiB0aGlzLmZpcnN0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCAoc3RhcnRJbmRleCArIHRoaXMucm93cyk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID49IGRhdGFzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFUb1JlbmRlci5wdXNoKGRhdGFzb3VyY2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhVG9SZW5kZXIgPSBkYXRhc291cmNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRhdGFUb1JlbmRlciB8fCAodGhpcy5kYXRhVG9SZW5kZXIubGVuZ3RoID09IDApO1xuICAgIH07XG4gICAgRGF0YUdyaWQucHJvdG90eXBlLmNyZWF0ZUxhenlMb2FkTWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgIHJvd3M6IHRoaXMucm93c1xuICAgICAgICB9O1xuICAgIH07XG4gICAgRGF0YUdyaWQucHJvdG90eXBlLmdldEJsb2NrYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YUdyaWQ7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhR3JpZC5wcm90b3R5cGUsIFwicGFnaW5hdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGF0YUdyaWQucHJvdG90eXBlLCBcInJvd3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRhR3JpZC5wcm90b3R5cGUsIFwidG90YWxSZWNvcmRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGF0YUdyaWQucHJvdG90eXBlLCBcInBhZ2VMaW5rc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgRGF0YUdyaWQucHJvdG90eXBlLCBcInJvd3NQZXJQYWdlT3B0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhR3JpZC5wcm90b3R5cGUsIFwibGF6eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGFHcmlkLnByb3RvdHlwZSwgXCJlbXB0eU1lc3NhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFHcmlkLnByb3RvdHlwZSwgXCJvbkxhenlMb2FkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0YUdyaWQucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YUdyaWQucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRhR3JpZC5wcm90b3R5cGUsIFwicGFnaW5hdG9yUG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0YUdyaWQucHJvdG90eXBlLCBcImFsd2F5c1Nob3dQYWdpbmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIERhdGFHcmlkLnByb3RvdHlwZSwgXCJ0cmFja0J5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFHcmlkLnByb3RvdHlwZSwgXCJpbW11dGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFHcmlkLnByb3RvdHlwZSwgXCJvblBhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGQoc2hhcmVkXzEuSGVhZGVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0YUdyaWQucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMS5Gb290ZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhR3JpZC5wcm90b3R5cGUsIFwiZm9vdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkcmVuKHNoYXJlZF8xLlByaW1lVGVtcGxhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuUXVlcnlMaXN0KVxuXSwgRGF0YUdyaWQucHJvdG90eXBlLCBcInRlbXBsYXRlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIERhdGFHcmlkLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbkRhdGFHcmlkID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1kYXRhR3JpZCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcIid1aS1kYXRhZ3JpZCB1aS13aWRnZXQnXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kYXRhZ3JpZC1oZWFkZXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItdG9wXFxcIiAqbmdJZj1cXFwiaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJwLWhlYWRlclxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxwLXBhZ2luYXRvciBbcm93c109XFxcInJvd3NcXFwiIFtmaXJzdF09XFxcImZpcnN0XFxcIiBbdG90YWxSZWNvcmRzXT1cXFwidG90YWxSZWNvcmRzXFxcIiBbcGFnZUxpbmtTaXplXT1cXFwicGFnZUxpbmtzXFxcIiBbYWx3YXlzU2hvd109XFxcImFsd2F5c1Nob3dQYWdpbmF0b3JcXFwiXFxuICAgICAgICAgICAgICAgIChvblBhZ2VDaGFuZ2UpPVxcXCJwYWdpbmF0ZSgkZXZlbnQpXFxcIiBzdHlsZUNsYXNzPVxcXCJ1aS1wYWdpbmF0b3ItYm90dG9tXFxcIiBbcm93c1BlclBhZ2VPcHRpb25zXT1cXFwicm93c1BlclBhZ2VPcHRpb25zXFxcIiAqbmdJZj1cXFwicGFnaW5hdG9yICYmIHBhZ2luYXRvclBvc2l0aW9uIT0nYm90dG9tJyB8fCBwYWdpbmF0b3JQb3NpdGlvbiA9PSdib3RoJ1xcXCI+PC9wLXBhZ2luYXRvcj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kYXRhZ3JpZC1jb250ZW50IHVpLXdpZGdldC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZ1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgW25nRm9yT2ZdPVxcXCJkYXRhVG9SZW5kZXJcXFwiIFtuZ0ZvclRlbXBsYXRlXT1cXFwiaXRlbVRlbXBsYXRlXFxcIiBbbmdGb3JUcmFja0J5XT1cXFwidHJhY2tCeVxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcImlzRW1wdHkoKVxcXCIgY2xhc3M9XFxcInVpLXdpZGdldC1jb250ZW50IHVpLWctMTJcXFwiPnt7ZW1wdHlNZXNzYWdlfX08L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPHAtcGFnaW5hdG9yIFtyb3dzXT1cXFwicm93c1xcXCIgW2ZpcnN0XT1cXFwiZmlyc3RcXFwiIFt0b3RhbFJlY29yZHNdPVxcXCJ0b3RhbFJlY29yZHNcXFwiIFtwYWdlTGlua1NpemVdPVxcXCJwYWdlTGlua3NcXFwiIFthbHdheXNTaG93XT1cXFwiYWx3YXlzU2hvd1BhZ2luYXRvclxcXCJcXG4gICAgICAgICAgICAgICAgKG9uUGFnZUNoYW5nZSk9XFxcInBhZ2luYXRlKCRldmVudClcXFwiIHN0eWxlQ2xhc3M9XFxcInVpLXBhZ2luYXRvci1ib3R0b21cXFwiIFtyb3dzUGVyUGFnZU9wdGlvbnNdPVxcXCJyb3dzUGVyUGFnZU9wdGlvbnNcXFwiICpuZ0lmPVxcXCJwYWdpbmF0b3IgJiYgcGFnaW5hdG9yUG9zaXRpb24hPSd0b3AnIHx8IHBhZ2luYXRvclBvc2l0aW9uID09J2JvdGgnXFxcIj48L3AtcGFnaW5hdG9yPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWRhdGFncmlkLWZvb3RlciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci10b3BcXFwiICpuZ0lmPVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcInAtZm9vdGVyXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBjb3JlXzEuSXRlcmFibGVEaWZmZXJzXSlcbl0sIERhdGFHcmlkKTtcbmV4cG9ydHMuRGF0YUdyaWQgPSBEYXRhR3JpZDtcbnZhciBEYXRhR3JpZE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YUdyaWRNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBEYXRhR3JpZE1vZHVsZTtcbn0oKSk7XG5EYXRhR3JpZE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZSwgcGFnaW5hdG9yXzEuUGFnaW5hdG9yTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0RhdGFHcmlkLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtEYXRhR3JpZF1cbiAgICB9KVxuXSwgRGF0YUdyaWRNb2R1bGUpO1xuZXhwb3J0cy5EYXRhR3JpZE1vZHVsZSA9IERhdGFHcmlkTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YWdyaWQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9kYXRhZ3JpZC9kYXRhZ3JpZC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2RhdGFncmlkL2RhdGFncmlkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBwYWdpbmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9wYWdpbmF0b3IvcGFnaW5hdG9yXCIpO1xudmFyIERhdGFMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhTGlzdChlbCwgZGlmZmVycykge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZGlmZmVycyA9IGRpZmZlcnM7XG4gICAgICAgIHRoaXMucGFnZUxpbmtzID0gNTtcbiAgICAgICAgdGhpcy5vbkxhenlMb2FkID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wYWdpbmF0b3JQb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICB0aGlzLmVtcHR5TWVzc2FnZSA9ICdObyByZWNvcmRzIGZvdW5kJztcbiAgICAgICAgdGhpcy5hbHdheXNTaG93UGFnaW5hdG9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7IHJldHVybiBpdGVtOyB9O1xuICAgICAgICB0aGlzLmltbXV0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25QYWdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5maXJzdCA9IDA7XG4gICAgICAgIHRoaXMucGFnZSA9IDA7XG4gICAgICAgIHRoaXMuZGlmZmVyID0gZGlmZmVycy5maW5kKFtdKS5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIERhdGFMaXN0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5nZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGF0YUxpc3QucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgICAgICAgdGhpcy5vbkxhenlMb2FkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGZpcnN0OiB0aGlzLmZpcnN0LFxuICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMucm93c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTGlzdC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEYXRhTGlzdC5wcm90b3R5cGUuaGFuZGxlRGF0YUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFnaW5hdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2luYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgRGF0YUxpc3QucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLmRpZmZlci5kaWZmKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURhdGFDaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YUxpc3QucHJvdG90eXBlLnVwZGF0ZVBhZ2luYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy90b3RhbCByZWNvcmRzXG4gICAgICAgIHRoaXMudG90YWxSZWNvcmRzID0gdGhpcy5sYXp5ID8gdGhpcy50b3RhbFJlY29yZHMgOiAodGhpcy52YWx1ZSA/IHRoaXMudmFsdWUubGVuZ3RoIDogMCk7XG4gICAgICAgIC8vZmlyc3RcbiAgICAgICAgaWYgKHRoaXMudG90YWxSZWNvcmRzICYmIHRoaXMuZmlyc3QgPj0gdGhpcy50b3RhbFJlY29yZHMpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJPZlBhZ2VzID0gTWF0aC5jZWlsKHRoaXMudG90YWxSZWNvcmRzIC8gdGhpcy5yb3dzKTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBNYXRoLm1heCgobnVtYmVyT2ZQYWdlcyAtIDEpICogdGhpcy5yb3dzLCAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YUxpc3QucHJvdG90eXBlLnBhZ2luYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZmlyc3QgPSBldmVudC5maXJzdDtcbiAgICAgICAgdGhpcy5yb3dzID0gZXZlbnQucm93cztcbiAgICAgICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgICAgICAgdGhpcy5vbkxhenlMb2FkLmVtaXQodGhpcy5jcmVhdGVMYXp5TG9hZE1ldGFkYXRhKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhVG9SZW5kZXIodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblBhZ2UuZW1pdCh7XG4gICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgIHJvd3M6IHRoaXMucm93c1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhdGFMaXN0LnByb3RvdHlwZS51cGRhdGVEYXRhVG9SZW5kZXIgPSBmdW5jdGlvbiAoZGF0YXNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5wYWdpbmF0b3IgJiYgZGF0YXNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhVG9SZW5kZXIgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5sYXp5ID8gMCA6IHRoaXMuZmlyc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IChzdGFydEluZGV4ICsgdGhpcy5yb3dzKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gZGF0YXNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVRvUmVuZGVyLnB1c2goZGF0YXNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFUb1JlbmRlciA9IGRhdGFzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFMaXN0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0YVRvUmVuZGVyIHx8ICh0aGlzLmRhdGFUb1JlbmRlci5sZW5ndGggPT0gMCk7XG4gICAgfTtcbiAgICBEYXRhTGlzdC5wcm90b3R5cGUuY3JlYXRlTGF6eUxvYWRNZXRhZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcnN0OiB0aGlzLmZpcnN0LFxuICAgICAgICAgICAgcm93czogdGhpcy5yb3dzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEYXRhTGlzdC5wcm90b3R5cGUuZ2V0QmxvY2thYmxlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRhTGlzdDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFMaXN0LnByb3RvdHlwZSwgXCJwYWdpbmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRhTGlzdC5wcm90b3R5cGUsIFwicm93c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERhdGFMaXN0LnByb3RvdHlwZSwgXCJ0b3RhbFJlY29yZHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRhTGlzdC5wcm90b3R5cGUsIFwicGFnZUxpbmtzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBEYXRhTGlzdC5wcm90b3R5cGUsIFwicm93c1BlclBhZ2VPcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFMaXN0LnByb3RvdHlwZSwgXCJsYXp5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhTGlzdC5wcm90b3R5cGUsIFwib25MYXp5TG9hZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGFMaXN0LnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGFMaXN0LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YUxpc3QucHJvdG90eXBlLCBcInBhZ2luYXRvclBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YUxpc3QucHJvdG90eXBlLCBcImVtcHR5TWVzc2FnZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhTGlzdC5wcm90b3R5cGUsIFwiYWx3YXlzU2hvd1BhZ2luYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgRGF0YUxpc3QucHJvdG90eXBlLCBcInRyYWNrQnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0YUxpc3QucHJvdG90eXBlLCBcImltbXV0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhTGlzdC5wcm90b3R5cGUsIFwic2Nyb2xsYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGFMaXN0LnByb3RvdHlwZSwgXCJzY3JvbGxIZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFMaXN0LnByb3RvdHlwZSwgXCJvblBhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGQoc2hhcmVkXzEuSGVhZGVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0YUxpc3QucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMS5Gb290ZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhTGlzdC5wcm90b3R5cGUsIFwiZm9vdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkcmVuKHNoYXJlZF8xLlByaW1lVGVtcGxhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuUXVlcnlMaXN0KVxuXSwgRGF0YUxpc3QucHJvdG90eXBlLCBcInRlbXBsYXRlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIERhdGFMaXN0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbkRhdGFMaXN0ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1kYXRhTGlzdCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcInsndWktZGF0YWxpc3QgdWktd2lkZ2V0JzogdHJ1ZSwgJ3VpLWRhdGFsaXN0LXNjcm9sbGFibGUnOiBzY3JvbGxhYmxlfVxcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZGF0YWxpc3QtaGVhZGVyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLXRvcFxcXCIgKm5nSWY9XFxcImhlYWRlclxcXCI+XFxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwicC1oZWFkZXJcXFwiPjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8cC1wYWdpbmF0b3IgW3Jvd3NdPVxcXCJyb3dzXFxcIiBbZmlyc3RdPVxcXCJmaXJzdFxcXCIgW3RvdGFsUmVjb3Jkc109XFxcInRvdGFsUmVjb3Jkc1xcXCIgW3BhZ2VMaW5rU2l6ZV09XFxcInBhZ2VMaW5rc1xcXCIgW2Fsd2F5c1Nob3ddPVxcXCJhbHdheXNTaG93UGFnaW5hdG9yXFxcIlxcbiAgICAgICAgICAgIChvblBhZ2VDaGFuZ2UpPVxcXCJwYWdpbmF0ZSgkZXZlbnQpXFxcIiBzdHlsZUNsYXNzPVxcXCJ1aS1wYWdpbmF0b3ItYm90dG9tXFxcIiBbcm93c1BlclBhZ2VPcHRpb25zXT1cXFwicm93c1BlclBhZ2VPcHRpb25zXFxcIiAqbmdJZj1cXFwicGFnaW5hdG9yICAmJiBwYWdpbmF0b3JQb3NpdGlvbiE9J2JvdHRvbScgfHwgcGFnaW5hdG9yUG9zaXRpb24gPT0nYm90aCdcXFwiPjwvcC1wYWdpbmF0b3I+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZGF0YWxpc3QtY29udGVudCB1aS13aWRnZXQtY29udGVudFxcXCIgW25nU3R5bGVdPVxcXCJ7J21heC1oZWlnaHQnOiBzY3JvbGxIZWlnaHR9XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cXFwiaXNFbXB0eSgpXFxcIiBjbGFzcz1cXFwidWktZGF0YWxpc3QtZW1wdHltZXNzYWdlXFxcIj57e2VtcHR5TWVzc2FnZX19PC9kaXY+XFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwidWktZGF0YWxpc3QtZGF0YVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGkgKm5nRm9yPVxcXCJsZXQgaXRlbSBvZiBkYXRhVG9SZW5kZXI7bGV0IGkgPSBpbmRleDt0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW3BUZW1wbGF0ZVdyYXBwZXJdPVxcXCJpdGVtVGVtcGxhdGVcXFwiIFtpdGVtXT1cXFwiaXRlbVxcXCIgW2luZGV4XT1cXFwiaVxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPHAtcGFnaW5hdG9yIFtyb3dzXT1cXFwicm93c1xcXCIgW2ZpcnN0XT1cXFwiZmlyc3RcXFwiIFt0b3RhbFJlY29yZHNdPVxcXCJ0b3RhbFJlY29yZHNcXFwiIFtwYWdlTGlua1NpemVdPVxcXCJwYWdlTGlua3NcXFwiIFthbHdheXNTaG93XT1cXFwiYWx3YXlzU2hvd1BhZ2luYXRvclxcXCJcXG4gICAgICAgICAgICAob25QYWdlQ2hhbmdlKT1cXFwicGFnaW5hdGUoJGV2ZW50KVxcXCIgc3R5bGVDbGFzcz1cXFwidWktcGFnaW5hdG9yLWJvdHRvbVxcXCIgW3Jvd3NQZXJQYWdlT3B0aW9uc109XFxcInJvd3NQZXJQYWdlT3B0aW9uc1xcXCIgKm5nSWY9XFxcInBhZ2luYXRvciAgJiYgcGFnaW5hdG9yUG9zaXRpb24hPSd0b3AnIHx8IHBhZ2luYXRvclBvc2l0aW9uID09J2JvdGgnXFxcIj48L3AtcGFnaW5hdG9yPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWRhdGFsaXN0LWZvb3RlciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1ib3R0b21cXFwiICpuZ0lmPVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcInAtZm9vdGVyXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBjb3JlXzEuSXRlcmFibGVEaWZmZXJzXSlcbl0sIERhdGFMaXN0KTtcbmV4cG9ydHMuRGF0YUxpc3QgPSBEYXRhTGlzdDtcbnZhciBEYXRhTGlzdE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YUxpc3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBEYXRhTGlzdE1vZHVsZTtcbn0oKSk7XG5EYXRhTGlzdE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZSwgcGFnaW5hdG9yXzEuUGFnaW5hdG9yTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0RhdGFMaXN0LCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtEYXRhTGlzdF1cbiAgICB9KVxuXSwgRGF0YUxpc3RNb2R1bGUpO1xuZXhwb3J0cy5EYXRhTGlzdE1vZHVsZSA9IERhdGFMaXN0TW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YWxpc3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9kYXRhbGlzdC9kYXRhbGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2RhdGFsaXN0L2RhdGFsaXN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgRGF0YVNjcm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhU2Nyb2xsZXIoZWwsIHJlbmRlcmVyLCBkb21IYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLm9uTGF6eUxvYWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IDAuOTtcbiAgICAgICAgdGhpcy5kYXRhVG9SZW5kZXIgPSBbXTtcbiAgICAgICAgdGhpcy5maXJzdCA9IDA7XG4gICAgfVxuICAgIERhdGFTY3JvbGxlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRnVuY3Rpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmxvYWRlciwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvYWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaW5kU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVNjcm9sbGVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5nZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFTY3JvbGxlci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5nZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEYXRhU2Nyb2xsZXIucHJvdG90eXBlLmhhbmRsZURhdGFDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhenkpXG4gICAgICAgICAgICB0aGlzLmRhdGFUb1JlbmRlciA9IHRoaXMudmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgIH07XG4gICAgRGF0YVNjcm9sbGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICAgICAgICB0aGlzLm9uTGF6eUxvYWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5yb3dzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSB0aGlzLmZpcnN0ICsgdGhpcy5yb3dzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5maXJzdDsgaSA8ICh0aGlzLmZpcnN0ICsgdGhpcy5yb3dzKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IHRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFUb1JlbmRlci5wdXNoKHRoaXMudmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0ID0gdGhpcy5maXJzdCArIHRoaXMucm93cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVNjcm9sbGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YVRvUmVuZGVyID0gW107XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgIH07XG4gICAgRGF0YVNjcm9sbGVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0YVRvUmVuZGVyIHx8ICh0aGlzLmRhdGFUb1JlbmRlci5sZW5ndGggPT0gMCk7XG4gICAgfTtcbiAgICBEYXRhU2Nyb2xsZXIucHJvdG90eXBlLmNyZWF0ZUxhenlMb2FkTWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgIHJvd3M6IHRoaXMucm93c1xuICAgICAgICB9O1xuICAgIH07XG4gICAgRGF0YVNjcm9sbGVyLnByb3RvdHlwZS5iaW5kU2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudCA9IHRoaXMuY29udGVudFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxGdW5jdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuY29udGVudEVsZW1lbnQsICdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IF90aGlzLmNvbnRlbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gX3RoaXMuY29udGVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydEhlaWdodCA9IF90aGlzLmNvbnRlbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoKHNjcm9sbFRvcCA+PSAoKHNjcm9sbEhlaWdodCAqIF90aGlzLmJ1ZmZlcikgLSAodmlld3BvcnRIZWlnaHQpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxGdW5jdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCd3aW5kb3cnLCAnc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkb2NCb2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICB2YXIgd2luSGVpZ2h0ID0gZG9jRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGRvY0hlaWdodCA9IE1hdGgubWF4KGRvY0JvZHkuc2Nyb2xsSGVpZ2h0LCBkb2NCb2R5Lm9mZnNldEhlaWdodCwgd2luSGVpZ2h0LCBkb2NFbGVtZW50LnNjcm9sbEhlaWdodCwgZG9jRWxlbWVudC5vZmZzZXRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUb3AgPj0gKChkb2NIZWlnaHQgKiBfdGhpcy5idWZmZXIpIC0gd2luSGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTY3JvbGxlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vdW5iaW5kXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEZ1bmN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERhdGFTY3JvbGxlcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGF0YVNjcm9sbGVyLnByb3RvdHlwZSwgXCJyb3dzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFTY3JvbGxlci5wcm90b3R5cGUsIFwibGF6eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVNjcm9sbGVyLnByb3RvdHlwZSwgXCJvbkxhenlMb2FkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0YVNjcm9sbGVyLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGFTY3JvbGxlci5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERhdGFTY3JvbGxlci5wcm90b3R5cGUsIFwiYnVmZmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFTY3JvbGxlci5wcm90b3R5cGUsIFwiaW5saW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0YVNjcm9sbGVyLnByb3RvdHlwZSwgXCJzY3JvbGxIZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhU2Nyb2xsZXIucHJvdG90eXBlLCBcImxvYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnY29udGVudCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIERhdGFTY3JvbGxlci5wcm90b3R5cGUsIFwiY29udGVudFZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMS5IZWFkZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhU2Nyb2xsZXIucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMS5Gb290ZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhU2Nyb2xsZXIucHJvdG90eXBlLCBcImZvb3RlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZHJlbihzaGFyZWRfMS5QcmltZVRlbXBsYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlF1ZXJ5TGlzdClcbl0sIERhdGFTY3JvbGxlci5wcm90b3R5cGUsIFwidGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgRGF0YVNjcm9sbGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbkRhdGFTY3JvbGxlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtZGF0YVNjcm9sbGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJ7J3VpLWRhdGFzY3JvbGxlciB1aS13aWRnZXQnOiB0cnVlLCAndWktZGF0YXNjcm9sbGVyLWlubGluZSc6IGlubGluZX1cXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZGF0YXNjcm9sbGVyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci10b3BcXFwiICpuZ0lmPVxcXCJoZWFkZXJcXFwiPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwicC1oZWFkZXJcXFwiPjwvbmctY29udGVudD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiAjY29udGVudCBjbGFzcz1cXFwidWktZGF0YXNjcm9sbGVyLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcXFwiIFtuZ1N0eWxlXT1cXFwieydtYXgtaGVpZ2h0Jzogc2Nyb2xsSGVpZ2h0fVxcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS1kYXRhc2Nyb2xsZXItbGlzdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSAqbmdGb3I9XFxcImxldCBpdGVtIG9mIGRhdGFUb1JlbmRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW3BUZW1wbGF0ZVdyYXBwZXJdPVxcXCJpdGVtVGVtcGxhdGVcXFwiIFtpdGVtXT1cXFwiaXRlbVxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kYXRhc2Nyb2xsZXItZm9vdGVyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWJvdHRvbVxcXCIgKm5nSWY9XFxcImZvb3RlclxcXCI+XFxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJwLWZvb3RlclxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgY29yZV8xLlJlbmRlcmVyMiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdKVxuXSwgRGF0YVNjcm9sbGVyKTtcbmV4cG9ydHMuRGF0YVNjcm9sbGVyID0gRGF0YVNjcm9sbGVyO1xudmFyIERhdGFTY3JvbGxlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YVNjcm9sbGVyTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gRGF0YVNjcm9sbGVyTW9kdWxlO1xufSgpKTtcbkRhdGFTY3JvbGxlck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtEYXRhU2Nyb2xsZXIsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW0RhdGFTY3JvbGxlcl1cbiAgICB9KVxuXSwgRGF0YVNjcm9sbGVyTW9kdWxlKTtcbmV4cG9ydHMuRGF0YVNjcm9sbGVyTW9kdWxlID0gRGF0YVNjcm9sbGVyTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YXNjcm9sbGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvZGF0YXNjcm9sbGVyL2RhdGFzY3JvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2RhdGFzY3JvbGxlci9kYXRhc2Nyb2xsZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGZvcm1zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBwYWdpbmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9wYWdpbmF0b3IvcGFnaW5hdG9yXCIpO1xudmFyIHNoYXJlZF8yID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zaGFyZWRcIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIG9iamVjdHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvb2JqZWN0dXRpbHNcIik7XG52YXIgRFRSYWRpb0J1dHRvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRFRSYWRpb0J1dHRvbigpIHtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgRFRSYWRpb0J1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vbkNsaWNrLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIERUUmFkaW9CdXR0b247XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEVFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEVFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJvbkNsaWNrXCIsIHZvaWQgMCk7XG5EVFJhZGlvQnV0dG9uID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1kdFJhZGlvQnV0dG9uJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYWRpb2J1dHRvbiB1aS13aWRnZXRcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgW2NoZWNrZWRdPVxcXCJjaGVja2VkXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1yYWRpb2J1dHRvbi1ib3ggdWktd2lkZ2V0IHVpLXJhZGlvYnV0dG9uLXJlbGF0aXZlIHVpLXN0YXRlLWRlZmF1bHRcXFwiIChjbGljayk9XFxcImhhbmRsZUNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgKG1vdXNlZW50ZXIpPVxcXCJob3Zlcj10cnVlXFxcIiAobW91c2VsZWF2ZSk9XFxcImhvdmVyPWZhbHNlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1ob3Zlcic6aG92ZXIsJ3VpLXN0YXRlLWFjdGl2ZSc6Y2hlY2tlZH1cXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktcmFkaW9idXR0b24taWNvbiB1aS1jbGlja2FibGVcXFwiIFtuZ0NsYXNzXT1cXFwieydmYSBmYS1jaXJjbGUnOmNoZWNrZWR9XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCJcbiAgICB9KVxuXSwgRFRSYWRpb0J1dHRvbik7XG5leHBvcnRzLkRUUmFkaW9CdXR0b24gPSBEVFJhZGlvQnV0dG9uO1xudmFyIERUQ2hlY2tib3ggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERUQ2hlY2tib3goKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBEVENoZWNrYm94LnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBjaGVja2VkOiAhdGhpcy5jaGVja2VkIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRFRDaGVja2JveDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERUQ2hlY2tib3gucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRFRDaGVja2JveC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERUQ2hlY2tib3gucHJvdG90eXBlLCBcIm9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5EVENoZWNrYm94ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1kdENoZWNrYm94JyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jaGtib3ggdWktd2lkZ2V0XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY2hrYm94LWJveCB1aS13aWRnZXQgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kZWZhdWx0XFxcIiAoY2xpY2spPVxcXCJoYW5kbGVDbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIChtb3VzZW92ZXIpPVxcXCJob3Zlcj10cnVlXFxcIiAobW91c2VvdXQpPVxcXCJob3Zlcj1mYWxzZVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWhvdmVyJzpob3ZlciYmIWRpc2FibGVkLCd1aS1zdGF0ZS1hY3RpdmUnOmNoZWNrZWQmJiFkaXNhYmxlZCwndWktc3RhdGUtZGlzYWJsZWQnOmRpc2FibGVkfVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1jaGtib3gtaWNvbiB1aS1jbGlja2FibGVcXFwiIFtuZ0NsYXNzXT1cXFwieydmYSBmYS1jaGVjayc6Y2hlY2tlZH1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIlxuICAgIH0pXG5dLCBEVENoZWNrYm94KTtcbmV4cG9ydHMuRFRDaGVja2JveCA9IERUQ2hlY2tib3g7XG52YXIgUm93RXhwYW5zaW9uTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3dFeHBhbnNpb25Mb2FkZXIodmlld0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICAgIH1cbiAgICBSb3dFeHBhbnNpb25Mb2FkZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUsIHtcbiAgICAgICAgICAgICdcXCRpbXBsaWNpdCc6IHRoaXMucm93RGF0YSxcbiAgICAgICAgICAgICdyb3dJbmRleCc6IHRoaXMucm93SW5kZXhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3dFeHBhbnNpb25Mb2FkZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJvd0V4cGFuc2lvbkxvYWRlcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlRlbXBsYXRlUmVmKVxuXSwgUm93RXhwYW5zaW9uTG9hZGVyLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFJvd0V4cGFuc2lvbkxvYWRlci5wcm90b3R5cGUsIFwicm93RGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFJvd0V4cGFuc2lvbkxvYWRlci5wcm90b3R5cGUsIFwicm93SW5kZXhcIiwgdm9pZCAwKTtcblJvd0V4cGFuc2lvbkxvYWRlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3Atcm93RXhwYW5zaW9uTG9hZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5WaWV3Q29udGFpbmVyUmVmXSlcbl0sIFJvd0V4cGFuc2lvbkxvYWRlcik7XG5leHBvcnRzLlJvd0V4cGFuc2lvbkxvYWRlciA9IFJvd0V4cGFuc2lvbkxvYWRlcjtcbnZhciBDb2x1bW5IZWFkZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2x1bW5IZWFkZXJzKGR0KSB7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9XG4gICAgcmV0dXJuIENvbHVtbkhlYWRlcnM7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KFwicENvbHVtbkhlYWRlcnNcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgQ29sdW1uSGVhZGVycy5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuQ29sdW1uSGVhZGVycyA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1twQ29sdW1uSGVhZGVyc10nLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY29sIFtuZ0Zvck9mXT1cXFwiY29sdW1uc1xcXCIgbGV0LWxhc3RDb2w9XFxcImxhc3RcXFwiPlxcbiAgICAgICAgICAgIDx0aCAjaGVhZGVyQ2VsbCBbYXR0ci5pZF09XFxcImNvbC5jb2xJZFxcXCIgW25nU3R5bGVdPVxcXCJjb2wuc3R5bGVcXFwiIFtjbGFzc109XFxcImNvbC5zdHlsZUNsYXNzXFxcIiBbc3R5bGUuZGlzcGxheV09XFxcImNvbC5oaWRkZW4gPyAnbm9uZScgOiAndGFibGUtY2VsbCdcXFwiIChjbGljayk9XFxcImR0LnNvcnQoJGV2ZW50LGNvbClcXFwiIFthdHRyLmNvbHNwYW5dPVxcXCJjb2wuY29sc3BhblxcXCIgW2F0dHIucm93c3Bhbl09XFxcImNvbC5yb3dzcGFuXFxcIlxcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtZGVmYXVsdCB1aS11bnNlbGVjdGFibGUtdGV4dCc6dHJ1ZSwgJ3VpLXNvcnRhYmxlLWNvbHVtbic6IGNvbC5zb3J0YWJsZSwgJ3VpLXN0YXRlLWFjdGl2ZSc6IGR0LmlzU29ydGVkKGNvbCksICd1aS1yZXNpemFibGUtY29sdW1uJzogZHQucmVzaXphYmxlQ29sdW1ucywgJ3VpLXNlbGVjdGlvbi1jb2x1bW4nOmNvbC5zZWxlY3Rpb25Nb2RlfVxcXCIgXFxuICAgICAgICAgICAgICAgIChkcmFnc3RhcnQpPVxcXCJkdC5vbkNvbHVtbkRyYWdTdGFydCgkZXZlbnQpXFxcIiAoZHJhZ2xlYXZlKT1cXFwiZHQub25Db2x1bW5EcmFnbGVhdmUoJGV2ZW50KVxcXCIgKGRyb3ApPVxcXCJkdC5vbkNvbHVtbkRyb3AoJGV2ZW50KVxcXCIgKG1vdXNlZG93bik9XFxcImR0Lm9uSGVhZGVyTW91c2Vkb3duKCRldmVudCxoZWFkZXJDZWxsKVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVxcXCJjb2wuc29ydGFibGUgPyB0YWJpbmRleCA6IG51bGxcXFwiIChrZXlkb3duKT1cXFwiZHQub25IZWFkZXJLZXlkb3duKCRldmVudCxjb2wpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWNvbHVtbi1yZXNpemVyIHVpLWNsaWNrYWJsZVxcXCIgKm5nSWY9XFxcImR0LnJlc2l6YWJsZUNvbHVtbnMgJiYgKChkdC5jb2x1bW5SZXNpemVNb2RlID09ICdmaXQnICYmICFsYXN0Q29sKSB8fCBkdC5jb2x1bW5SZXNpemVNb2RlID09ICdleHBhbmQnKVxcXCIgKG1vdXNlZG93bik9XFxcImR0LmluaXRDb2x1bW5SZXNpemUoJGV2ZW50KVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY29sdW1uLXRpdGxlXFxcIiAqbmdJZj1cXFwiIWNvbC5zZWxlY3Rpb25Nb2RlJiYhY29sLmhlYWRlclRlbXBsYXRlXFxcIj57e2NvbC5oZWFkZXJ9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWNvbHVtbi10aXRsZVxcXCIgKm5nSWY9XFxcImNvbC5oZWFkZXJUZW1wbGF0ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8cC1jb2x1bW5IZWFkZXJUZW1wbGF0ZUxvYWRlciBbY29sdW1uXT1cXFwiY29sXFxcIj48L3AtY29sdW1uSGVhZGVyVGVtcGxhdGVMb2FkZXI+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXNvcnRhYmxlLWNvbHVtbi1pY29uIGZhIGZhLWZ3IGZhLXNvcnRcXFwiICpuZ0lmPVxcXCJjb2wuc29ydGFibGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J2ZhLXNvcnQtZGVzYyc6IChkdC5nZXRTb3J0T3JkZXIoY29sKSA9PSAtMSksJ2ZhLXNvcnQtYXNjJzogKGR0LmdldFNvcnRPcmRlcihjb2wpID09IDEpfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgW2F0dHIudHlwZV09XFxcImNvbC5maWx0ZXJUeXBlXFxcIiBjbGFzcz1cXFwidWktY29sdW1uLWZpbHRlciB1aS1pbnB1dHRleHQgdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFxcXCIgW2F0dHIubWF4bGVuZ3RoXT1cXFwiY29sLmZpbHRlck1heGxlbmd0aFxcXCIgW2F0dHIucGxhY2Vob2xkZXJdPVxcXCJjb2wuZmlsdGVyUGxhY2Vob2xkZXJcXFwiICpuZ0lmPVxcXCJjb2wuZmlsdGVyJiYhY29sLmZpbHRlclRlbXBsYXRlXFxcIiBbdmFsdWVdPVxcXCJkdC5maWx0ZXJzW2NvbC5maWVsZF0gPyBkdC5maWx0ZXJzW2NvbC5maWVsZF0udmFsdWUgOiAnJ1xcXCIgXFxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJkdC5vbkZpbHRlcklucHV0Q2xpY2soJGV2ZW50KVxcXCIgKGlucHV0KT1cXFwiZHQub25GaWx0ZXJLZXl1cCgkZXZlbnQudGFyZ2V0LnZhbHVlLCBjb2wuZmllbGQsIGNvbC5maWx0ZXJNYXRjaE1vZGUpXFxcIi8+XFxuICAgICAgICAgICAgICAgIDxwLWNvbHVtbkZpbHRlclRlbXBsYXRlTG9hZGVyIFtjb2x1bW5dPVxcXCJjb2xcXFwiICpuZ0lmPVxcXCJjb2wuZmlsdGVyVGVtcGxhdGVcXFwiPjwvcC1jb2x1bW5GaWx0ZXJUZW1wbGF0ZUxvYWRlcj5cXG4gICAgICAgICAgICAgICAgPHAtZHRDaGVja2JveCAqbmdJZj1cXFwiY29sLnNlbGVjdGlvbk1vZGU9PSdtdWx0aXBsZSdcXFwiIChvbkNoYW5nZSk9XFxcImR0LnRvZ2dsZVJvd3NXaXRoQ2hlY2tib3goJGV2ZW50KVxcXCIgW2NoZWNrZWRdPVxcXCJkdC5hbGxTZWxlY3RlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZHQuaXNFbXB0eSgpXFxcIj48L3AtZHRDaGVja2JveD5cXG4gICAgICAgICAgICA8L3RoPlxcbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgXCJcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIGNvcmVfMS5JbmplY3QoY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRGF0YVRhYmxlOyB9KSkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGF0YVRhYmxlXSlcbl0sIENvbHVtbkhlYWRlcnMpO1xuZXhwb3J0cy5Db2x1bW5IZWFkZXJzID0gQ29sdW1uSGVhZGVycztcbnZhciBDb2x1bW5Gb290ZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2x1bW5Gb290ZXJzKGR0KSB7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9XG4gICAgcmV0dXJuIENvbHVtbkZvb3RlcnM7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KFwicENvbHVtbkZvb3RlcnNcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgQ29sdW1uRm9vdGVycy5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuQ29sdW1uRm9vdGVycyA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1twQ29sdW1uRm9vdGVyc10nLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDx0ZCAqbmdGb3I9XFxcImxldCBjb2wgb2YgY29sdW1uc1xcXCIgW25nU3R5bGVdPVxcXCJjb2wuc3R5bGVcXFwiIFtjbGFzc109XFxcImNvbC5zdHlsZUNsYXNzXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmNvbHNwYW5dPVxcXCJjb2wuY29sc3BhblxcXCIgW2F0dHIucm93c3Bhbl09XFxcImNvbC5yb3dzcGFuXFxcIlxcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1kZWZhdWx0Jzp0cnVlfVxcXCIgW3N0eWxlLmRpc3BsYXldPVxcXCJjb2wuaGlkZGVuID8gJ25vbmUnIDogJ3RhYmxlLWNlbGwnXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY29sdW1uLWZvb3RlclxcXCIgKm5nSWY9XFxcIiFjb2wuZm9vdGVyVGVtcGxhdGVcXFwiPnt7Y29sLmZvb3Rlcn19PC9zcGFuPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1jb2x1bW4tZm9vdGVyXFxcIiAqbmdJZj1cXFwiY29sLmZvb3RlclRlbXBsYXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgPHAtY29sdW1uRm9vdGVyVGVtcGxhdGVMb2FkZXIgW2NvbHVtbl09XFxcImNvbFxcXCI+PC9wLWNvbHVtbkZvb3RlclRlbXBsYXRlTG9hZGVyPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDwvdGQ+XFxuICAgIFwiXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBjb3JlXzEuSW5qZWN0KGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERhdGFUYWJsZTsgfSkpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGFUYWJsZV0pXG5dLCBDb2x1bW5Gb290ZXJzKTtcbmV4cG9ydHMuQ29sdW1uRm9vdGVycyA9IENvbHVtbkZvb3RlcnM7XG52YXIgVGFibGVCb2R5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZUJvZHkoZHQpIHtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgIH1cbiAgICBUYWJsZUJvZHkucHJvdG90eXBlLnZpc2libGVDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zID8gdGhpcy5jb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIWMuaGlkZGVuOyB9KSA6IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlQm9keTtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoXCJwVGFibGVCb2R5XCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFRhYmxlQm9keS5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuVGFibGVCb2R5ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnW3BUYWJsZUJvZHldJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LXJvd0RhdGEgW25nRm9yT2ZdPVxcXCJkdC5kYXRhVG9SZW5kZXJcXFwiIGxldC1ldmVuPVxcXCJldmVuXFxcIiBsZXQtb2RkPVxcXCJvZGRcXFwiIGxldC1yb3dJbmRleD1cXFwiaW5kZXhcXFwiIFtuZ0ZvclRyYWNrQnldPVxcXCJkdC5yb3dUcmFja0J5XFxcIj5cXG4gICAgICAgICAgICA8dHIgI3Jvd0dyb3VwRWxlbWVudCBjbGFzcz1cXFwidWktd2lkZ2V0LWhlYWRlciB1aS1yb3dncm91cC1oZWFkZXJcXFwiIFxcbiAgICAgICAgICAgICAgICAqbmdJZj1cXFwiZHQucm93R3JvdXBNb2RlPT0nc3ViaGVhZGVyJyAmJiAocm93SW5kZXggPT09IDB8fChkdC5yZXNvbHZlRmllbGREYXRhKHJvd0RhdGEsZHQuZ3JvdXBGaWVsZCkgIT09IGR0LnJlc29sdmVGaWVsZERhdGEoZHQuZGF0YVRvUmVuZGVyW3Jvd0luZGV4IC0gMV0sIGR0Lmdyb3VwRmllbGQpKSlcXFwiXFxuICAgICAgICAgICAgICAgIChjbGljayk9XFxcImR0Lm9uUm93R3JvdXBDbGljaygkZXZlbnQpXFxcIiBbbmdTdHlsZV09XFxcInsnY3Vyc29yJzogZHQuc29ydGFibGVSb3dHcm91cCA/ICdwb2ludGVyJyA6ICdhdXRvJ31cXFwiPlxcbiAgICAgICAgICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XFxcImR0LnZpc2libGVDb2x1bW5zKCkubGVuZ3RoXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiICpuZ0lmPVxcXCJkdC5leHBhbmRhYmxlUm93R3JvdXBzXFxcIiAoY2xpY2spPVxcXCJkdC50b2dnbGVSb3dHcm91cCgkZXZlbnQscm93RGF0YSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1md1xcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhLWNoZXZyb24tY2lyY2xlLWRvd24nOmR0LmlzUm93R3JvdXBFeHBhbmRlZChyb3dEYXRhKSwgJ2ZhLWNoZXZyb24tY2lyY2xlLXJpZ2h0JzogIWR0LmlzUm93R3JvdXBFeHBhbmRlZChyb3dEYXRhKX1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1yb3dncm91cC1oZWFkZXItbmFtZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHAtdGVtcGxhdGVMb2FkZXIgW3RlbXBsYXRlXT1cXFwiZHQucm93R3JvdXBIZWFkZXJUZW1wbGF0ZVxcXCIgW2RhdGFdPVxcXCJyb3dEYXRhXFxcIj48L3AtdGVtcGxhdGVMb2FkZXI+XFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICA8dHIgI3Jvd0VsZW1lbnQgKm5nSWY9XFxcIiFkdC5leHBhbmRhYmxlUm93R3JvdXBzfHxkdC5pc1Jvd0dyb3VwRXhwYW5kZWQocm93RGF0YSlcXFwiIFtjbGFzc109XFxcImR0LmdldFJvd1N0eWxlQ2xhc3Mocm93RGF0YSxyb3dJbmRleClcXFwiXFxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJkdC5oYW5kbGVSb3dDbGljaygkZXZlbnQsIHJvd0RhdGEsIHJvd0luZGV4KVxcXCIgKGRibGNsaWNrKT1cXFwiZHQucm93RGJsY2xpY2soJGV2ZW50LHJvd0RhdGEpXFxcIiAoY29udGV4dG1lbnUpPVxcXCJkdC5vblJvd1JpZ2h0Q2xpY2soJGV2ZW50LHJvd0RhdGEpXFxcIiAodG91Y2hlbmQpPVxcXCJkdC5oYW5kbGVSb3dUb3VjaEVuZCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLWRhdGF0YWJsZS1ldmVuJzpldmVuJiZkdC5yb3dHcm91cE1vZGUhPSdyb3dzcGFuJywndWktZGF0YXRhYmxlLW9kZCc6b2RkJiZkdC5yb3dHcm91cE1vZGUhPSdyb3dzcGFuJywndWktc3RhdGUtaGlnaGxpZ2h0JzogZHQuaXNTZWxlY3RlZChyb3dEYXRhKX1cXFwiPlxcbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWNvbCBbbmdGb3JPZl09XFxcImNvbHVtbnNcXFwiIGxldC1jb2xJbmRleD1cXFwiaW5kZXhcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkICNjZWxsICpuZ0lmPVxcXCIhZHQucm93R3JvdXBNb2RlIHx8IChkdC5yb3dHcm91cE1vZGUgPT0gJ3N1YmhlYWRlcicpIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgKGR0LnJvd0dyb3VwTW9kZT09J3Jvd3NwYW4nICYmICgoZHQuc29ydEZpZWxkPT1jb2wuZmllbGQgJiYgZHQucm93R3JvdXBNZXRhZGF0YVtkdC5yZXNvbHZlRmllbGREYXRhKHJvd0RhdGEsZHQuc29ydEZpZWxkKV0uaW5kZXggPT0gcm93SW5kZXgpIHx8IChkdC5zb3J0RmllbGQhPWNvbC5maWVsZCkpKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XFxcImNvbC5zdHlsZVxcXCIgW2NsYXNzXT1cXFwiY29sLnN0eWxlQ2xhc3NcXFwiIFtzdHlsZS5kaXNwbGF5XT1cXFwiY29sLmhpZGRlbiA/ICdub25lJyA6ICd0YWJsZS1jZWxsJ1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktZWRpdGFibGUtY29sdW1uJzpjb2wuZWRpdGFibGUsJ3VpLXNlbGVjdGlvbi1jb2x1bW4nOmNvbC5zZWxlY3Rpb25Nb2RlfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5yb3dzcGFuXT1cXFwiKGR0LnJvd0dyb3VwTW9kZT09J3Jvd3NwYW4nICYmIGR0LnNvcnRGaWVsZCA9PSBjb2wuZmllbGQgJiYgZHQucm93R3JvdXBNZXRhZGF0YVtkdC5yZXNvbHZlRmllbGREYXRhKHJvd0RhdGEsZHQuc29ydEZpZWxkKV0uaW5kZXggPT0gcm93SW5kZXgpID8gZHQucm93R3JvdXBNZXRhZGF0YVtkdC5yZXNvbHZlRmllbGREYXRhKHJvd0RhdGEsZHQuc29ydEZpZWxkKV0uc2l6ZSA6IG51bGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1jb2x1bW4tdGl0bGVcXFwiICpuZ0lmPVxcXCJkdC5yZXNwb25zaXZlXFxcIj57e2NvbC5oZWFkZXJ9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY2VsbC1kYXRhXFxcIiAqbmdJZj1cXFwiIWNvbC5ib2R5VGVtcGxhdGUgJiYgIWNvbC5leHBhbmRlciAmJiAhY29sLnNlbGVjdGlvbk1vZGVcXFwiPnt7ZHQucmVzb2x2ZUZpZWxkRGF0YShyb3dEYXRhLGNvbC5maWVsZCl9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY2VsbC1kYXRhXFxcIiAqbmdJZj1cXFwiY29sLmJvZHlUZW1wbGF0ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwLWNvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlciBbY29sdW1uXT1cXFwiY29sXFxcIiBbcm93RGF0YV09XFxcInJvd0RhdGFcXFwiIFtyb3dJbmRleF09XFxcInJvd0luZGV4ICsgZHQuZmlyc3RcXFwiPjwvcC1jb2x1bW5Cb2R5VGVtcGxhdGVMb2FkZXI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWNlbGwtZWRpdG9yXFxcIiAqbmdJZj1cXFwiY29sLmVkaXRhYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0ICpuZ0lmPVxcXCIhY29sLmVkaXRvclRlbXBsYXRlXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBbKG5nTW9kZWwpXT1cXFwicm93RGF0YVtjb2wuZmllbGRdXFxcIiByZXF1aXJlZD1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChrZXlkb3duKT1cXFwiZHQub25DZWxsRWRpdG9yS2V5ZG93bigkZXZlbnQsIGNvbCwgcm93RGF0YSwgcm93SW5kZXgpXFxcIiBjbGFzcz1cXFwidWktaW5wdXR0ZXh0IHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcImNvbC5lZGl0b3JUZW1wbGF0ZVxcXCIgY2xhc3M9XFxcInVpLWNlbGwtZWRpdG9yLXByb3h5LWZvY3VzXFxcIiBocmVmPVxcXCIjXFxcIiAoZm9jdXMpPVxcXCJkdC5vbkN1c3RvbUVkaXRvckZvY3VzUHJldigkZXZlbnQsIGNvbEluZGV4KVxcXCI+PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cC1jb2x1bW5FZGl0b3JUZW1wbGF0ZUxvYWRlciAqbmdJZj1cXFwiY29sLmVkaXRvclRlbXBsYXRlXFxcIiBbY29sdW1uXT1cXFwiY29sXFxcIiBbcm93RGF0YV09XFxcInJvd0RhdGFcXFwiIFtyb3dJbmRleF09XFxcInJvd0luZGV4XFxcIj48L3AtY29sdW1uRWRpdG9yVGVtcGxhdGVMb2FkZXI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCJjb2wuZWRpdG9yVGVtcGxhdGVcXFwiIGNsYXNzPVxcXCJ1aS1jZWxsLWVkaXRvci1wcm94eS1mb2N1c1xcXCIgaHJlZj1cXFwiI1xcXCIgKGZvY3VzKT1cXFwiZHQub25DdXN0b21FZGl0b3JGb2N1c05leHQoJGV2ZW50LCBjb2xJbmRleClcXFwiPjwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiAqbmdJZj1cXFwiY29sLmV4cGFuZGVyXFxcIiAoY2xpY2spPVxcXCJkdC50b2dnbGVSb3cocm93RGF0YSwkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXJvdy10b2dnbGVyIGZhIGZhLWZ3IHVpLWNsaWNrYWJsZVxcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhLWNoZXZyb24tY2lyY2xlLWRvd24nOmR0LmlzUm93RXhwYW5kZWQocm93RGF0YSksICdmYS1jaGV2cm9uLWNpcmNsZS1yaWdodCc6ICFkdC5pc1Jvd0V4cGFuZGVkKHJvd0RhdGEpfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8cC1kdFJhZGlvQnV0dG9uICpuZ0lmPVxcXCJjb2wuc2VsZWN0aW9uTW9kZT09J3NpbmdsZSdcXFwiIChvbkNsaWNrKT1cXFwiZHQuc2VsZWN0Um93V2l0aFJhZGlvKCRldmVudCwgcm93RGF0YSlcXFwiIFtjaGVja2VkXT1cXFwiZHQuaXNTZWxlY3RlZChyb3dEYXRhKVxcXCI+PC9wLWR0UmFkaW9CdXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHAtZHRDaGVja2JveCAqbmdJZj1cXFwiY29sLnNlbGVjdGlvbk1vZGU9PSdtdWx0aXBsZSdcXFwiIChvbkNoYW5nZSk9XFxcImR0LnRvZ2dsZVJvd1dpdGhDaGVja2JveCgkZXZlbnQscm93RGF0YSlcXFwiIFtjaGVja2VkXT1cXFwiZHQuaXNTZWxlY3RlZChyb3dEYXRhKVxcXCI+PC9wLWR0Q2hlY2tib3g+XFxuICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgPHRyIGNsYXNzPVxcXCJ1aS13aWRnZXQtaGVhZGVyXFxcIiAqbmdJZj1cXFwiZHQucm93R3JvdXBGb290ZXJUZW1wbGF0ZSAmJiBkdC5yb3dHcm91cE1vZGU9PSdzdWJoZWFkZXInICYmICgocm93SW5kZXggPT09IGR0LmRhdGFUb1JlbmRlci5sZW5ndGggLSAxKXx8KGR0LnJlc29sdmVGaWVsZERhdGEocm93RGF0YSxkdC5ncm91cEZpZWxkKSAhPT0gZHQucmVzb2x2ZUZpZWxkRGF0YShkdC5kYXRhVG9SZW5kZXJbcm93SW5kZXggKyAxXSxkdC5ncm91cEZpZWxkKSkpICYmICghZHQuZXhwYW5kYWJsZVJvd0dyb3VwcyB8fCBkdC5pc1Jvd0dyb3VwRXhwYW5kZWQocm93RGF0YSkpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHAtdGVtcGxhdGVMb2FkZXIgY2xhc3M9XFxcInVpLWhlbHBlci1oaWRkZW5cXFwiIFtkYXRhXT1cXFwicm93RGF0YVxcXCIgW3RlbXBsYXRlXT1cXFwiZHQucm93R3JvdXBGb290ZXJUZW1wbGF0ZVxcXCI+PC9wLXRlbXBsYXRlTG9hZGVyPlxcbiAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgPHRyICpuZ0lmPVxcXCJkdC5leHBhbmRhYmxlUm93cyAmJiBkdC5pc1Jvd0V4cGFuZGVkKHJvd0RhdGEpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVxcXCJkdC52aXNpYmxlQ29sdW1ucygpLmxlbmd0aFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8cC1yb3dFeHBhbnNpb25Mb2FkZXIgW3Jvd0RhdGFdPVxcXCJyb3dEYXRhXFxcIiBbcm93SW5kZXhdPVxcXCJyb3dJbmRleFxcXCIgW3RlbXBsYXRlXT1cXFwiZHQucm93RXhwYW5zaW9uVGVtcGxhdGVcXFwiPjwvcC1yb3dFeHBhbnNpb25Mb2FkZXI+XFxuICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgIDwvbmctdGVtcGxhdGU+XFxuXFxuICAgICAgICA8dHIgKm5nSWY9XFxcImR0LmlzRW1wdHkoKVxcXCIgY2xhc3M9XFxcInVpLXdpZGdldC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XFxcImR0LnZpc2libGVDb2x1bW5zKCkubGVuZ3RoXFxcIiBjbGFzcz1cXFwidWktZGF0YXRhYmxlLWVtcHR5bWVzc2FnZVxcXCI+e3tkdC5lbXB0eU1lc3NhZ2V9fTwvdGQ+XFxuICAgICAgICA8L3RyPlxcbiAgICBcIlxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgY29yZV8xLkluamVjdChjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRhVGFibGU7IH0pKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRhVGFibGVdKVxuXSwgVGFibGVCb2R5KTtcbmV4cG9ydHMuVGFibGVCb2R5ID0gVGFibGVCb2R5O1xudmFyIFNjcm9sbGFibGVWaWV3ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxhYmxlVmlldyhkdCwgZG9tSGFuZGxlciwgZWwsIHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMub25WaXJ0dWFsU2Nyb2xsID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgU2Nyb2xsYWJsZVZpZXcucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0U2Nyb2xsaW5nKCk7XG4gICAgfTtcbiAgICBTY3JvbGxhYmxlVmlldy5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52aXJ0dWFsU2Nyb2xsICYmICF0aGlzLnJvd0hlaWdodCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuc2Nyb2xsVGFibGUsICd0ci51aS13aWRnZXQtY29udGVudCcpO1xuICAgICAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgICAgIHRoaXMucm93SGVpZ2h0ID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmZyb3plbikge1xuICAgICAgICAgICAgdGhpcy5hbGlnblNjcm9sbEJhcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxhYmxlVmlldy5wcm90b3R5cGUuaW5pdFNjcm9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zY3JvbGxIZWFkZXIgPSB0aGlzLnNjcm9sbEhlYWRlclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnNjcm9sbEhlYWRlckJveCA9IHRoaXMuc2Nyb2xsSGVhZGVyQm94Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsQm9keSA9IHRoaXMuc2Nyb2xsQm9keVZpZXdDaGlsZC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnNjcm9sbFRhYmxlID0gdGhpcy5zY3JvbGxUYWJsZVZpZXdDaGlsZC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnNjcm9sbFRhYmxlV3JhcHBlciA9IHRoaXMuc2Nyb2xsVGFibGVXcmFwcGVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsRm9vdGVyID0gdGhpcy5zY3JvbGxGb290ZXJWaWV3Q2hpbGQgPyB0aGlzLnNjcm9sbEZvb3RlclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50IDogbnVsbDtcbiAgICAgICAgdGhpcy5zY3JvbGxGb290ZXJCb3ggPSB0aGlzLnNjcm9sbEZvb3RlckJveFZpZXdDaGlsZCA/IHRoaXMuc2Nyb2xsRm9vdGVyQm94Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQgOiBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuZnJvemVuKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbEhlYWRlci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBfdGhpcy5vbkhlYWRlclNjcm9sbC5iaW5kKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQm9keS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBfdGhpcy5vbkJvZHlTY3JvbGwuYmluZChfdGhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmZyb3plbilcbiAgICAgICAgICAgIHRoaXMuYWxpZ25TY3JvbGxCYXIoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxCb2R5LnN0eWxlLnBhZGRpbmdCb3R0b20gPSB0aGlzLmRvbUhhbmRsZXIuY2FsY3VsYXRlU2Nyb2xsYmFyV2lkdGgoKSArICdweCc7XG4gICAgfTtcbiAgICBTY3JvbGxhYmxlVmlldy5wcm90b3R5cGUub25Cb2R5U2Nyb2xsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBmcm96ZW5WaWV3ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGlmIChmcm96ZW5WaWV3KSB7XG4gICAgICAgICAgICB2YXIgZnJvemVuU2Nyb2xsQm9keSA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKGZyb3plblZpZXcsICcudWktZGF0YXRhYmxlLXNjcm9sbGFibGUtYm9keScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsSGVhZGVyQm94LnN0eWxlLm1hcmdpbkxlZnQgPSAtMSAqIHRoaXMuc2Nyb2xsQm9keS5zY3JvbGxMZWZ0ICsgJ3B4JztcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsRm9vdGVyQm94KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEZvb3RlckJveC5zdHlsZS5tYXJnaW5MZWZ0ID0gLTEgKiB0aGlzLnNjcm9sbEJvZHkuc2Nyb2xsTGVmdCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb3plblNjcm9sbEJvZHkpIHtcbiAgICAgICAgICAgIGZyb3plblNjcm9sbEJvZHkuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxCb2R5LnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXJ0dWFsU2Nyb2xsKSB7XG4gICAgICAgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJIZWlnaHQodGhpcy5zY3JvbGxCb2R5KTtcbiAgICAgICAgICAgIHZhciB0YWJsZUhlaWdodCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlckhlaWdodCh0aGlzLnNjcm9sbFRhYmxlKTtcbiAgICAgICAgICAgIHZhciBwYWdlSGVpZ2h0ID0gdGhpcy5yb3dIZWlnaHQgKiB0aGlzLmR0LnJvd3M7XG4gICAgICAgICAgICB2YXIgdmlydHVhbFRhYmxlSGVpZ2h0ID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHRoaXMuc2Nyb2xsVGFibGVXcmFwcGVyKTtcbiAgICAgICAgICAgIHZhciBwYWdlQ291bnQgPSAodmlydHVhbFRhYmxlSGVpZ2h0IC8gcGFnZUhlaWdodCkgfHwgMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbEJvZHkuc2Nyb2xsVG9wICsgdmlld3BvcnQgPiBwYXJzZUZsb2F0KHRoaXMuc2Nyb2xsVGFibGUuc3R5bGUudG9wKSArIHRhYmxlSGVpZ2h0IHx8IHRoaXMuc2Nyb2xsQm9keS5zY3JvbGxUb3AgPCBwYXJzZUZsb2F0KHRoaXMuc2Nyb2xsVGFibGUuc3R5bGUudG9wKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYWdlID0gTWF0aC5mbG9vcigodGhpcy5zY3JvbGxCb2R5LnNjcm9sbFRvcCAqIHBhZ2VDb3VudCkgLyAodGhpcy5zY3JvbGxCb2R5LnNjcm9sbEhlaWdodCkpICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmlydHVhbFNjcm9sbC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFibGUuc3R5bGUudG9wID0gKChwYWdlIC0gMSkgKiBwYWdlSGVpZ2h0KSArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbGFibGVWaWV3LnByb3RvdHlwZS5vbkhlYWRlclNjcm9sbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnNjcm9sbEhlYWRlci5zY3JvbGxMZWZ0ID0gMDtcbiAgICB9O1xuICAgIFNjcm9sbGFibGVWaWV3LnByb3RvdHlwZS5oYXNWZXJ0aWNhbE92ZXJmbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHRoaXMuc2Nyb2xsVGFibGUpID4gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHRoaXMuc2Nyb2xsQm9keSk7XG4gICAgfTtcbiAgICBTY3JvbGxhYmxlVmlldy5wcm90b3R5cGUuYWxpZ25TY3JvbGxCYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGxCYXJXaWR0aCA9IHRoaXMuaGFzVmVydGljYWxPdmVyZmxvdygpID8gdGhpcy5kb21IYW5kbGVyLmNhbGN1bGF0ZVNjcm9sbGJhcldpZHRoKCkgOiAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhlYWRlckJveC5zdHlsZS5tYXJnaW5SaWdodCA9IHNjcm9sbEJhcldpZHRoICsgJ3B4JztcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsRm9vdGVyQm94KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEZvb3RlckJveC5zdHlsZS5tYXJnaW5SaWdodCA9IHNjcm9sbEJhcldpZHRoICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsYWJsZVZpZXcucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjcm9sbEhlYWRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLm9uSGVhZGVyU2Nyb2xsKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCb2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMub25Cb2R5U2Nyb2xsKTtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxhYmxlVmlldztcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoXCJwU2Nyb2xsYWJsZVZpZXdcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgU2Nyb2xsYWJsZVZpZXcucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3Njcm9sbEhlYWRlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFNjcm9sbGFibGVWaWV3LnByb3RvdHlwZSwgXCJzY3JvbGxIZWFkZXJWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3Njcm9sbEhlYWRlckJveCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFNjcm9sbGFibGVWaWV3LnByb3RvdHlwZSwgXCJzY3JvbGxIZWFkZXJCb3hWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3Njcm9sbEJvZHknKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBTY3JvbGxhYmxlVmlldy5wcm90b3R5cGUsIFwic2Nyb2xsQm9keVZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnc2Nyb2xsVGFibGUnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBTY3JvbGxhYmxlVmlldy5wcm90b3R5cGUsIFwic2Nyb2xsVGFibGVWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3Njcm9sbFRhYmxlV3JhcHBlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFNjcm9sbGFibGVWaWV3LnByb3RvdHlwZSwgXCJzY3JvbGxUYWJsZVdyYXBwZXJWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3Njcm9sbEZvb3RlcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFNjcm9sbGFibGVWaWV3LnByb3RvdHlwZSwgXCJzY3JvbGxGb290ZXJWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3Njcm9sbEZvb3RlckJveCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFNjcm9sbGFibGVWaWV3LnByb3RvdHlwZSwgXCJzY3JvbGxGb290ZXJCb3hWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2Nyb2xsYWJsZVZpZXcucHJvdG90eXBlLCBcImZyb3plblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNjcm9sbGFibGVWaWV3LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTY3JvbGxhYmxlVmlldy5wcm90b3R5cGUsIFwidmlydHVhbFNjcm9sbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU2Nyb2xsYWJsZVZpZXcucHJvdG90eXBlLCBcIm9uVmlydHVhbFNjcm9sbFwiLCB2b2lkIDApO1xuU2Nyb2xsYWJsZVZpZXcgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdbcFNjcm9sbGFibGVWaWV3XScsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiAjc2Nyb2xsSGVhZGVyIGNsYXNzPVxcXCJ1aS13aWRnZXQtaGVhZGVyIHVpLWRhdGF0YWJsZS1zY3JvbGxhYmxlLWhlYWRlclxcXCIgW25nU3R5bGVdPVxcXCJ7J3dpZHRoJzogd2lkdGh9XFxcIj5cXG4gICAgICAgICAgICA8ZGl2ICNzY3JvbGxIZWFkZXJCb3ggIGNsYXNzPVxcXCJ1aS1kYXRhdGFibGUtc2Nyb2xsYWJsZS1oZWFkZXItYm94XFxcIj5cXG4gICAgICAgICAgICAgICAgPHRhYmxlIFtjbGFzc109XFxcImR0LnRhYmxlU3R5bGVDbGFzc1xcXCIgW25nU3R5bGVdPVxcXCJkdC50YWJsZVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDx0aGVhZCBjbGFzcz1cXFwidWktZGF0YXRhYmxlLXRoZWFkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgKm5nSWY9XFxcIiFkdC5oZWFkZXJDb2x1bW5Hcm91cFxcXCIgY2xhc3M9XFxcInVpLXN0YXRlLWRlZmF1bHRcXFwiIFtwQ29sdW1uSGVhZGVyc109XFxcImNvbHVtbnNcXFwiPjwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cXFwiZHQuaGVhZGVyQ29sdW1uR3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgaGVhZGVyUm93IG9mIGR0LmhlYWRlckNvbHVtbkdyb3VwLnJvd3NcXFwiIGNsYXNzPVxcXCJ1aS1zdGF0ZS1kZWZhdWx0XFxcIiBbcENvbHVtbkhlYWRlcnNdPVxcXCJoZWFkZXJSb3cuY29sdW1uc1xcXCI+PC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiAjc2Nyb2xsQm9keSBjbGFzcz1cXFwidWktZGF0YXRhYmxlLXNjcm9sbGFibGUtYm9keVxcXCIgW25nU3R5bGVdPVxcXCJ7J3dpZHRoJzogd2lkdGgsJ21heC1oZWlnaHQnOmR0LnNjcm9sbEhlaWdodH1cXFwiPlxcbiAgICAgICAgICAgIDxkaXYgI3Njcm9sbFRhYmxlV3JhcHBlciBjbGFzcz1cXFwidWktZGF0YXRhYmxlLXNjcm9sbGFibGUtdGFibGUtd3JhcHBlclxcXCIgc3R5bGU9XFxcInBvc2l0aW9uOnJlbGF0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgPHRhYmxlICNzY3JvbGxUYWJsZSBbY2xhc3NdPVxcXCJkdC50YWJsZVN0eWxlQ2xhc3NcXFwiIFtuZ1N0eWxlXT1cXFwiZHQudGFibGVTdHlsZVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLWRhdGF0YWJsZS12aXJ0dWFsLXRhYmxlJzp2aXJ0dWFsU2Nyb2xsfVxcXCIgc3R5bGU9XFxcInRvcDowcHhcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGNvbGdyb3VwIGNsYXNzPVxcXCJ1aS1kYXRhdGFibGUtc2Nyb2xsYWJsZS1jb2xncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvbCAqbmdGb3I9XFxcImxldCBjb2wgb2YgY29sdW1uc1xcXCIgW25nU3R5bGVdPVxcXCJjb2wuc3R5bGVcXFwiLz5cXG4gICAgICAgICAgICAgICAgICAgIDwvY29sZ3JvdXA+XFxuICAgICAgICAgICAgICAgICAgICA8dGJvZHkgW25nQ2xhc3NdPVxcXCJ7J3VpLWRhdGF0YWJsZS1kYXRhIHVpLXdpZGdldC1jb250ZW50JzogdHJ1ZSwgJ3VpLWRhdGF0YWJsZS1ob3ZlcmFibGUtcm93cyc6IChkdC5yb3dIb3Zlcnx8ZHQuc2VsZWN0aW9uTW9kZSl9XFxcIiBbcFRhYmxlQm9keV09XFxcImNvbHVtbnNcXFwiPjwvdGJvZHk+XFxuICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgI3Njcm9sbEZvb3RlciBjbGFzcz1cXFwidWktd2lkZ2V0LWhlYWRlciB1aS1kYXRhdGFibGUtc2Nyb2xsYWJsZS1mb290ZXJcXFwiIFtuZ1N0eWxlXT1cXFwieyd3aWR0aCc6IHdpZHRofVxcXCIgKm5nSWY9XFxcImR0Lmhhc0Zvb3RlcigpXFxcIj5cXG4gICAgICAgICAgICA8ZGl2ICNzY3JvbGxGb290ZXJCb3ggIGNsYXNzPVxcXCJ1aS1kYXRhdGFibGUtc2Nyb2xsYWJsZS1mb290ZXItYm94XFxcIj5cXG4gICAgICAgICAgICAgICAgPHRhYmxlIFtjbGFzc109XFxcImR0LnRhYmxlU3R5bGVDbGFzc1xcXCIgW25nU3R5bGVdPVxcXCJkdC50YWJsZVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDx0Zm9vdCBjbGFzcz1cXFwidWktZGF0YXRhYmxlLXRmb290XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgKm5nSWY9XFxcIiFkdC5mb290ZXJDb2x1bW5Hcm91cFxcXCIgW3BDb2x1bW5Gb290ZXJzXT1cXFwiY29sdW1uc1xcXCIgY2xhc3M9XFxcInVpLXN0YXRlLWRlZmF1bHRcXFwiPjwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cXFwiZHQuZm9vdGVyQ29sdW1uR3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgZm9vdGVyUm93IG9mIGR0LmZvb3RlckNvbHVtbkdyb3VwLnJvd3NcXFwiIGNsYXNzPVxcXCJ1aS1zdGF0ZS1kZWZhdWx0XFxcIiBbcENvbHVtbkZvb3RlcnNdPVxcXCJmb290ZXJSb3cuY29sdW1uc1xcXCI+PC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICAgICAgPC90Zm9vdD5cXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIlxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgY29yZV8xLkluamVjdChjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRhVGFibGU7IH0pKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRhVGFibGUsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuRWxlbWVudFJlZiwgY29yZV8xLlJlbmRlcmVyMiwgY29yZV8xLk5nWm9uZV0pXG5dLCBTY3JvbGxhYmxlVmlldyk7XG5leHBvcnRzLlNjcm9sbGFibGVWaWV3ID0gU2Nyb2xsYWJsZVZpZXc7XG52YXIgRGF0YVRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhVGFibGUoZWwsIGRvbUhhbmRsZXIsIGRpZmZlcnMsIHJlbmRlcmVyLCBjaGFuZ2VEZXRlY3Rvciwgb2JqZWN0VXRpbHMsIHpvbmUpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLmRpZmZlcnMgPSBkaWZmZXJzO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5vYmplY3RVdGlscyA9IG9iamVjdFV0aWxzO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLnBhZ2VMaW5rcyA9IDU7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vblJvd0NsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vblJvd1NlbGVjdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Sb3dVbnNlbGVjdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Sb3dEYmxjbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25IZWFkZXJDaGVja2JveFRvZ2dsZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Db250ZXh0TWVudVNlbGVjdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyRGVsYXkgPSAzMDA7XG4gICAgICAgIHRoaXMub25MYXp5TG9hZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29sdW1uUmVzaXplTW9kZSA9ICdmaXQnO1xuICAgICAgICB0aGlzLm9uQ29sUmVzaXplID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkNvbFJlb3JkZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNvcnRNb2RlID0gJ3NpbmdsZSc7XG4gICAgICAgIHRoaXMuc29ydE9yZGVyID0gMTtcbiAgICAgICAgdGhpcy5jc3ZTZXBhcmF0b3IgPSAnLCc7XG4gICAgICAgIHRoaXMuZXhwb3J0RmlsZW5hbWUgPSAnZG93bmxvYWQnO1xuICAgICAgICB0aGlzLmVtcHR5TWVzc2FnZSA9ICdObyByZWNvcmRzIGZvdW5kJztcbiAgICAgICAgdGhpcy5wYWdpbmF0b3JQb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICB0aGlzLmFsd2F5c1Nob3dQYWdpbmF0b3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm1ldGFLZXlTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLnJvd1RyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH07XG4gICAgICAgIHRoaXMuaW1tdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21wYXJlU2VsZWN0aW9uQnkgPSAnZGVlcEVxdWFscyc7XG4gICAgICAgIHRoaXMub25FZGl0SW5pdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25FZGl0Q29tcGxldGUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRWRpdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25FZGl0Q2FuY2VsID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vblBhZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uU29ydCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25GaWx0ZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnJvd0V4cGFuZE1vZGUgPSAnbXVsdGlwbGUnO1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMTtcbiAgICAgICAgdGhpcy5zb3J0YWJsZVJvd0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0ge307XG4gICAgICAgIHRoaXMubG9hZGluZ0ljb24gPSAnZmEtY2lyY2xlLW8tbm90Y2gnO1xuICAgICAgICB0aGlzLmZpcnN0Q2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vblJvd0V4cGFuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Sb3dDb2xsYXBzZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Sb3dHcm91cEV4cGFuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Sb3dHcm91cENvbGxhcHNlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maXJzdCA9IDA7XG4gICAgICAgIHRoaXMuZmlsdGVyQ29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICBzdGFydHNXaXRoOiBmdW5jdGlvbiAodmFsdWUsIGZpbHRlcikge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgPT09IHVuZGVmaW5lZCB8fCBmaWx0ZXIgPT09IG51bGwgfHwgZmlsdGVyLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlclZhbHVlID0gZmlsdGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5zbGljZSgwLCBmaWx0ZXJWYWx1ZS5sZW5ndGgpID09PSBmaWx0ZXJWYWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250YWluczogZnVuY3Rpb24gKHZhbHVlLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQgfHwgZmlsdGVyID09PSBudWxsIHx8ICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyAmJiBmaWx0ZXIudHJpbSgpID09PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKGZpbHRlci50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kc1dpdGg6IGZ1bmN0aW9uICh2YWx1ZSwgZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlciA9PT0gbnVsbCB8fCBmaWx0ZXIudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyVmFsdWUgPSBmaWx0ZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihmaWx0ZXJWYWx1ZSwgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggLSBmaWx0ZXJWYWx1ZS5sZW5ndGgpICE9PSAtMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uICh2YWx1ZSwgZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlciA9PT0gbnVsbCB8fCAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgJiYgZmlsdGVyLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT0gZmlsdGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3RFcXVhbHM6IGZ1bmN0aW9uICh2YWx1ZSwgZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlciA9PT0gbnVsbCB8fCAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgJiYgZmlsdGVyLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgIT0gZmlsdGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbjogZnVuY3Rpb24gKHZhbHVlLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQgfHwgZmlsdGVyID09PSBudWxsIHx8IGZpbHRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcltpXSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRpZmZlciA9IGRpZmZlcnMuZmluZChbXSkuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICAgICAgICB0aGlzLm9uTGF6eUxvYWQuZW1pdCh0aGlzLmNyZWF0ZUxhenlMb2FkTWV0YWRhdGEoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluaXRDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY29sdW1uc1N1YnNjcmlwdGlvbiA9IHRoaXMuY29scy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgX3RoaXMuaW5pdENvbHVtbnMoKTtcbiAgICAgICAgICAgIF90aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgc3dpdGNoIChpdGVtLmdldFR5cGUoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Jvd2V4cGFuc2lvbic6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJvd0V4cGFuc2lvblRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncm93Z3JvdXBoZWFkZXInOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yb3dHcm91cEhlYWRlclRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncm93Z3JvdXBmb290ZXInOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yb3dHcm91cEZvb3RlclRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbnNDaGFuZ2VkICYmIHRoaXMuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6YWJsZUNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRSZXNpemFibGVDb2x1bW5zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yZW9yZGVyYWJsZUNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRDb2x1bW5SZW9yZGVyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG90YWxSZWNvcmRzQ2hhbmdlZCAmJiB0aGlzLnZpcnR1YWxTY3JvbGwpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxhYmxlVGFibGUgPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXYudWktZGF0YXRhYmxlLXNjcm9sbGFibGUtdGFibGUtd3JhcHBlcicpO1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHNjcm9sbGFibGVUYWJsZSwgJ3RyLnVpLXdpZGdldC1jb250ZW50Jyk7XG4gICAgICAgICAgICB2YXIgcm93SGVpZ2h0ID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHJvdyk7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxUYWJsZUhlaWdodCA9IHRoaXMuX3RvdGFsUmVjb3JkcyAqIHJvd0hlaWdodDtcbiAgICAgICAgICAgIHNjcm9sbGFibGVUYWJsZS5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpcnR1YWxUYWJsZUhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLnRvdGFsUmVjb3Jkc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsRmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbEZpbHRlckZ1bmN0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5nbG9iYWxGaWx0ZXIsICdrZXl1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maWx0ZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9maWx0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlsdGVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMuZmlsdGVyRGVsYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWwgPyB2YWwuc2xpY2UoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFUYWJsZS5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maXJzdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkUGFnaW5hdGUgPSB0aGlzLl9maXJzdCAhPT0gdmFsO1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSB2YWw7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUGFnaW5hdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2luYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGUucHJvdG90eXBlLCBcInRvdGFsUmVjb3Jkc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsUmVjb3JkcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl90b3RhbFJlY29yZHMgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLnRvdGFsUmVjb3Jkc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gdmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YUtleSAmJiAhdGhpcy5wcmV2ZW50U2VsZWN0aW9uS2V5c1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25LZXlzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fc2VsZWN0aW9uOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbktleXNbU3RyaW5nKHRoaXMub2JqZWN0VXRpbHMucmVzb2x2ZUZpZWxkRGF0YShkYXRhLCB0aGlzLmRhdGFLZXkpKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2ZW50U2VsZWN0aW9uS2V5c1Byb3BhZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmhhbmRsZURhdGFDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnBhZ2luYXRvcikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdpbmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubGF6eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmlsdGVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRTb3J0UHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZlbnRTb3J0UHJvcGFnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc29ydEZpZWxkIHx8IHRoaXMubXVsdGlTb3J0TWV0YSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zb3J0Q29sdW1uICYmIHRoaXMuY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRDb2x1bW4gPSB0aGlzLmNvbHVtbnMuZmluZChmdW5jdGlvbiAoY29sKSB7IHJldHVybiBjb2wuZmllbGQgPT09IF90aGlzLnNvcnRGaWVsZCAmJiBjb2wuc29ydGFibGUgPT09ICdjdXN0b20nOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ydE1vZGUgPT0gJ3NpbmdsZScpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFNpbmdsZSgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc29ydE1vZGUgPT0gJ211bHRpcGxlJylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0TXVsdGlwbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZURhdGFUb1JlbmRlcih0aGlzLmZpbHRlcmVkVmFsdWUgfHwgdGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmluaXRDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSB0aGlzLmNvbHMudG9BcnJheSgpO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGFibGVDb2x1bW5zID0gW107XG4gICAgICAgICAgICB0aGlzLmNvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZnJvemVuQ29sdW1ucyA9IF90aGlzLmZyb3plbkNvbHVtbnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZyb3plbkNvbHVtbnMucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsYWJsZUNvbHVtbnMucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1uc0NoYW5nZWQgPSB0cnVlO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5yZXNvbHZlRmllbGREYXRhID0gZnVuY3Rpb24gKGRhdGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGZpZWxkKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQuaW5kZXhPZignLicpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbZmllbGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IGZpZWxkLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW2ZpZWxkc1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnVwZGF0ZVJvd0dyb3VwTWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucm93R3JvdXBNZXRhZGF0YSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5kYXRhVG9SZW5kZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhVG9SZW5kZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93RGF0YSA9IHRoaXMuZGF0YVRvUmVuZGVyW2ldO1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMucmVzb2x2ZUZpZWxkRGF0YShyb3dEYXRhLCB0aGlzLnNvcnRGaWVsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0dyb3VwTWV0YWRhdGFbZ3JvdXBdID0geyBpbmRleDogMCwgc2l6ZTogMSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUm93RGF0YSA9IHRoaXMuZGF0YVRvUmVuZGVyW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUm93R3JvdXAgPSB0aGlzLnJlc29sdmVGaWVsZERhdGEocHJldmlvdXNSb3dEYXRhLCB0aGlzLnNvcnRGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cCA9PT0gcHJldmlvdXNSb3dHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dHcm91cE1ldGFkYXRhW2dyb3VwXS5zaXplKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0dyb3VwTWV0YWRhdGFbZ3JvdXBdID0geyBpbmRleDogaSwgc2l6ZTogMSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnVwZGF0ZVBhZ2luYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy90b3RhbCByZWNvcmRzXG4gICAgICAgIHRoaXMudXBkYXRlVG90YWxSZWNvcmRzKCk7XG4gICAgICAgIC8vZmlyc3RcbiAgICAgICAgaWYgKHRoaXMudG90YWxSZWNvcmRzICYmIHRoaXMuZmlyc3QgPj0gdGhpcy50b3RhbFJlY29yZHMpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJPZlBhZ2VzID0gTWF0aC5jZWlsKHRoaXMudG90YWxSZWNvcmRzIC8gdGhpcy5yb3dzKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gTWF0aC5tYXgoKG51bWJlck9mUGFnZXMgLSAxKSAqIHRoaXMucm93cywgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUudXBkYXRlVG90YWxSZWNvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvdGFsUmVjb3JkcyA9IHRoaXMubGF6eSA/IHRoaXMudG90YWxSZWNvcmRzIDogKHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmxlbmd0aCA6IDApO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5vblBhZ2VDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fZmlyc3QgPSBldmVudC5maXJzdDtcbiAgICAgICAgdGhpcy5maXJzdENoYW5nZS5lbWl0KHRoaXMuZmlyc3QpO1xuICAgICAgICB0aGlzLnJvd3MgPSBldmVudC5yb3dzO1xuICAgICAgICB0aGlzLnBhZ2luYXRlKCk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnBhZ2luYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sYXp5KVxuICAgICAgICAgICAgdGhpcy5vbkxhenlMb2FkLmVtaXQodGhpcy5jcmVhdGVMYXp5TG9hZE1ldGFkYXRhKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURhdGFUb1JlbmRlcih0aGlzLmZpbHRlcmVkVmFsdWUgfHwgdGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25QYWdlLmVtaXQoe1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICByb3dzOiB0aGlzLnJvd3NcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnVwZGF0ZURhdGFUb1JlbmRlciA9IGZ1bmN0aW9uIChkYXRhc291cmNlKSB7XG4gICAgICAgIGlmICgodGhpcy5wYWdpbmF0b3IgfHwgdGhpcy52aXJ0dWFsU2Nyb2xsKSAmJiBkYXRhc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFUb1JlbmRlciA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLmxhenkgPyAwIDogdGhpcy5maXJzdDtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMudmlydHVhbFNjcm9sbCA/IHRoaXMuZmlyc3QgKyB0aGlzLnJvd3MgKiAyIDogc3RhcnRJbmRleCArIHRoaXMucm93cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID49IGRhdGFzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFUb1JlbmRlci5wdXNoKGRhdGFzb3VyY2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhVG9SZW5kZXIgPSBkYXRhc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvd0dyb3VwTW9kZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSb3dHcm91cE1ldGFkYXRhKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUub25WaXJ0dWFsU2Nyb2xsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gKGV2ZW50LnBhZ2UgLSAxKSAqIHRoaXMucm93cztcbiAgICAgICAgaWYgKHRoaXMubGF6eSlcbiAgICAgICAgICAgIHRoaXMub25MYXp5TG9hZC5lbWl0KHRoaXMuY3JlYXRlTGF6eUxvYWRNZXRhZGF0YSgpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhVG9SZW5kZXIodGhpcy5maWx0ZXJlZFZhbHVlIHx8IHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5vbkhlYWRlcktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQsIGNvbHVtbikge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgdGhpcy5zb3J0KGV2ZW50LCBjb2x1bW4pO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5vbkhlYWRlck1vdXNlZG93biA9IGZ1bmN0aW9uIChldmVudCwgaGVhZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnJlb3JkZXJhYmxlQ29sdW1ucykge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5ub2RlTmFtZSAhPT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgICAgIGhlYWRlci5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZXZlbnQsIGNvbHVtbikge1xuICAgICAgICBpZiAoIWNvbHVtbi5zb3J0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gZXZlbnQudGFyZ2V0Lm5vZGVOYW1lO1xuICAgICAgICBpZiAoKHRhcmdldE5vZGUgPT0gJ1RIJyAmJiB0aGlzLmRvbUhhbmRsZXIuaGFzQ2xhc3MoZXZlbnQudGFyZ2V0LCAndWktc29ydGFibGUtY29sdW1uJykpIHx8ICgodGFyZ2V0Tm9kZSA9PSAnU1BBTicgfHwgdGFyZ2V0Tm9kZSA9PSAnRElWJykgJiYgIXRoaXMuZG9tSGFuZGxlci5oYXNDbGFzcyhldmVudC50YXJnZXQsICd1aS1jbGlja2FibGUnKSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZlbnRTb3J0UHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbHVtblNvcnRGaWVsZCA9IGNvbHVtbi5zb3J0RmllbGQgfHwgY29sdW1uLmZpZWxkO1xuICAgICAgICAgICAgdGhpcy5zb3J0T3JkZXIgPSAodGhpcy5zb3J0RmllbGQgPT09IGNvbHVtblNvcnRGaWVsZCkgPyB0aGlzLnNvcnRPcmRlciAqIC0xIDogMTtcbiAgICAgICAgICAgIHRoaXMuc29ydEZpZWxkID0gY29sdW1uU29ydEZpZWxkO1xuICAgICAgICAgICAgdGhpcy5zb3J0Q29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgdmFyIG1ldGFLZXkgPSBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3J0TW9kZSA9PSAnbXVsdGlwbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm11bHRpU29ydE1ldGEgfHwgIW1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdWx0aVNvcnRNZXRhID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU29ydE1ldGEoeyBmaWVsZDogdGhpcy5zb3J0RmllbGQsIG9yZGVyOiB0aGlzLnNvcnRPcmRlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxhenkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJzdCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxhenlMb2FkLmVtaXQodGhpcy5jcmVhdGVMYXp5TG9hZE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ydE1vZGUgPT0gJ211bHRpcGxlJylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0TXVsdGlwbGUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFNpbmdsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblNvcnQuZW1pdCh7XG4gICAgICAgICAgICAgICAgZmllbGQ6IHRoaXMuc29ydEZpZWxkLFxuICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLnNvcnRPcmRlcixcbiAgICAgICAgICAgICAgICBtdWx0aXNvcnRtZXRhOiB0aGlzLm11bHRpU29ydE1ldGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKHRoaXMuZmlsdGVyZWRWYWx1ZSB8fCB0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuc29ydFNpbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvcnRDb2x1bW4gJiYgdGhpcy5zb3J0Q29sdW1uLnNvcnRhYmxlID09PSAnY3VzdG9tJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmVudFNvcnRQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Q29sdW1uLnNvcnRGdW5jdGlvbi5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRoaXMuc29ydEZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5zb3J0T3JkZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuc29ydChmdW5jdGlvbiAoZGF0YTEsIGRhdGEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTEgPSBfdGhpcy5yZXNvbHZlRmllbGREYXRhKGRhdGExLCBfdGhpcy5zb3J0RmllbGQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUyID0gX3RoaXMucmVzb2x2ZUZpZWxkRGF0YShkYXRhMiwgX3RoaXMuc29ydEZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZTEgPT0gbnVsbCAmJiB2YWx1ZTIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZTEgIT0gbnVsbCAmJiB2YWx1ZTIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlMSA9PSBudWxsICYmIHZhbHVlMiA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlMSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlMiA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTEubG9jYWxlQ29tcGFyZSh2YWx1ZTIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAodmFsdWUxIDwgdmFsdWUyKSA/IC0xIDogKHZhbHVlMSA+IHZhbHVlMikgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5zb3J0T3JkZXIgKiByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maXJzdCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGaWx0ZXIoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnNvcnRNdWx0aXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuc29ydChmdW5jdGlvbiAoZGF0YTEsIGRhdGEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm11bHRpc29ydEZpZWxkKGRhdGExLCBkYXRhMiwgX3RoaXMubXVsdGlTb3J0TWV0YSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZpbHRlcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUubXVsdGlzb3J0RmllbGQgPSBmdW5jdGlvbiAoZGF0YTEsIGRhdGEyLCBtdWx0aVNvcnRNZXRhLCBpbmRleCkge1xuICAgICAgICB2YXIgdmFsdWUxID0gdGhpcy5yZXNvbHZlRmllbGREYXRhKGRhdGExLCBtdWx0aVNvcnRNZXRhW2luZGV4XS5maWVsZCk7XG4gICAgICAgIHZhciB2YWx1ZTIgPSB0aGlzLnJlc29sdmVGaWVsZERhdGEoZGF0YTIsIG11bHRpU29ydE1ldGFbaW5kZXhdLmZpZWxkKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUxID09ICdzdHJpbmcnIHx8IHZhbHVlMSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgaWYgKHZhbHVlMS5sb2NhbGVDb21wYXJlICYmICh2YWx1ZTEgIT0gdmFsdWUyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobXVsdGlTb3J0TWV0YVtpbmRleF0ub3JkZXIgKiB2YWx1ZTEubG9jYWxlQ29tcGFyZSh2YWx1ZTIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICh2YWx1ZTEgPCB2YWx1ZTIpID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZTEgPT0gdmFsdWUyKSB7XG4gICAgICAgICAgICByZXR1cm4gKG11bHRpU29ydE1ldGEubGVuZ3RoIC0gMSkgPiAoaW5kZXgpID8gKHRoaXMubXVsdGlzb3J0RmllbGQoZGF0YTEsIGRhdGEyLCBtdWx0aVNvcnRNZXRhLCBpbmRleCArIDEpKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChtdWx0aVNvcnRNZXRhW2luZGV4XS5vcmRlciAqIHJlc3VsdCk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmFkZFNvcnRNZXRhID0gZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tdWx0aVNvcnRNZXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNvcnRNZXRhW2ldLmZpZWxkID09PSBtZXRhLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgICAgdGhpcy5tdWx0aVNvcnRNZXRhW2luZGV4XSA9IG1ldGE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubXVsdGlTb3J0TWV0YS5wdXNoKG1ldGEpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5pc1NvcnRlZCA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgaWYgKCFjb2x1bW4uc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sdW1uU29ydEZpZWxkID0gY29sdW1uLnNvcnRGaWVsZCB8fCBjb2x1bW4uZmllbGQ7XG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNvcnRGaWVsZCAmJiBjb2x1bW5Tb3J0RmllbGQgPT09IHRoaXMuc29ydEZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNvcnRNb2RlID09PSAnbXVsdGlwbGUnKSB7XG4gICAgICAgICAgICB2YXIgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNvcnRNZXRhKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm11bHRpU29ydE1ldGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlTb3J0TWV0YVtpXS5maWVsZCA9PSBjb2x1bW5Tb3J0RmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuZ2V0U29ydE9yZGVyID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgb3JkZXIgPSAwO1xuICAgICAgICB2YXIgY29sdW1uU29ydEZpZWxkID0gY29sdW1uLnNvcnRGaWVsZCB8fCBjb2x1bW4uZmllbGQ7XG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ydEZpZWxkICYmIGNvbHVtblNvcnRGaWVsZCA9PT0gdGhpcy5zb3J0RmllbGQpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IHRoaXMuc29ydE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc29ydE1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpU29ydE1ldGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubXVsdGlTb3J0TWV0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNvcnRNZXRhW2ldLmZpZWxkID09IGNvbHVtblNvcnRGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSB0aGlzLm11bHRpU29ydE1ldGFbaV0ub3JkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm9uUm93R3JvdXBDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5yb3dHcm91cFRvZ2dsZUNsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0dyb3VwVG9nZ2xlQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zb3J0YWJsZVJvd0dyb3VwKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGV2ZW50LnRhcmdldC5ub2RlTmFtZTtcbiAgICAgICAgICAgIGlmICgodGFyZ2V0Tm9kZSA9PSAnVEQnIHx8ICh0YXJnZXROb2RlID09ICdTUEFOJyAmJiAhdGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKGV2ZW50LnRhcmdldCwgJ3VpLWNsaWNrYWJsZScpKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3J0RmllbGQgIT0gdGhpcy5ncm91cEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydEZpZWxkID0gdGhpcy5ncm91cEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRTaW5nbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE9yZGVyID0gLTEgKiB0aGlzLnNvcnRPcmRlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0U2luZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZVN0YXJ0LCByYW5nZUVuZDtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VSb3dJbmRleCA+IHRoaXMuYW5jaG9yUm93SW5kZXgpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSB0aGlzLmFuY2hvclJvd0luZGV4O1xuICAgICAgICAgICAgcmFuZ2VFbmQgPSB0aGlzLnJhbmdlUm93SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yYW5nZVJvd0luZGV4IDwgdGhpcy5hbmNob3JSb3dJbmRleCkge1xuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IHRoaXMucmFuZ2VSb3dJbmRleDtcbiAgICAgICAgICAgIHJhbmdlRW5kID0gdGhpcy5hbmNob3JSb3dJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSB0aGlzLnJhbmdlUm93SW5kZXg7XG4gICAgICAgICAgICByYW5nZUVuZCA9IHRoaXMucmFuZ2VSb3dJbmRleDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VSb3dEYXRhID0gdGhpc18xLmRhdGFUb1JlbmRlcltpXTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmRleCA9IHRoaXNfMS5maW5kSW5kZXhJblNlbGVjdGlvbihyYW5nZVJvd0RhdGEpO1xuICAgICAgICAgICAgdGhpc18xLl9zZWxlY3Rpb24gPSB0aGlzXzEuc2VsZWN0aW9uLmZpbHRlcihmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiBpICE9IHNlbGVjdGlvbkluZGV4OyB9KTtcbiAgICAgICAgICAgIHZhciBkYXRhS2V5VmFsdWUgPSB0aGlzXzEuZGF0YUtleSA/IFN0cmluZyh0aGlzXzEucmVzb2x2ZUZpZWxkRGF0YShyYW5nZVJvd0RhdGEsIHRoaXNfMS5kYXRhS2V5KSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGRhdGFLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzXzEuc2VsZWN0aW9uS2V5c1tkYXRhS2V5VmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc18xLm9uUm93VW5zZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBkYXRhOiByYW5nZVJvd0RhdGEsIHR5cGU6ICdyb3cnIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlU3RhcnQ7IGkgPD0gcmFuZ2VFbmQ7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5zZWxlY3RSYW5nZSA9IGZ1bmN0aW9uIChyb3dJbmRleCkge1xuICAgICAgICB2YXIgcmFuZ2VTdGFydCwgcmFuZ2VFbmQ7XG4gICAgICAgIGlmICh0aGlzLmFuY2hvclJvd0luZGV4ID4gcm93SW5kZXgpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSByb3dJbmRleDtcbiAgICAgICAgICAgIHJhbmdlRW5kID0gdGhpcy5hbmNob3JSb3dJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFuY2hvclJvd0luZGV4IDwgcm93SW5kZXgpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSB0aGlzLmFuY2hvclJvd0luZGV4O1xuICAgICAgICAgICAgcmFuZ2VFbmQgPSByb3dJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSByb3dJbmRleDtcbiAgICAgICAgICAgIHJhbmdlRW5kID0gcm93SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlU3RhcnQ7IGkgPD0gcmFuZ2VFbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJhbmdlUm93RGF0YSA9IHRoaXMuZGF0YVRvUmVuZGVyW2ldO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uY29uY2F0KFtyYW5nZVJvd0RhdGFdKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGRhdGFLZXlWYWx1ZSA9IHRoaXMuZGF0YUtleSA/IFN0cmluZyh0aGlzLnJlc29sdmVGaWVsZERhdGEocmFuZ2VSb3dEYXRhLCB0aGlzLmRhdGFLZXkpKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZGF0YUtleVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25LZXlzW2RhdGFLZXlWYWx1ZV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblJvd1NlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGRhdGE6IHJhbmdlUm93RGF0YSwgdHlwZTogJ3JvdycgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuaGFuZGxlUm93Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIHJvd0RhdGEsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZlbnRSb3dDbGlja1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRSb3dDbGlja1Byb3BhZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBldmVudC50YXJnZXQubm9kZU5hbWU7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZmluZENlbGwoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbnNbdGhpcy5kb21IYW5kbGVyLmluZGV4KGNlbGwpXTtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaENlbGxUb0VkaXRNb2RlKGNlbGwsIGNvbHVtbiwgcm93RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXROb2RlID09ICdJTlBVVCcgfHwgdGFyZ2V0Tm9kZSA9PSAnQlVUVE9OJyB8fCB0YXJnZXROb2RlID09ICdBJyB8fCAodGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKGV2ZW50LnRhcmdldCwgJ3VpLWNsaWNrYWJsZScpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Sb3dDbGljay5uZXh0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGRhdGE6IHJvd0RhdGEgfSk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGlwbGVTZWxlY3Rpb25Nb2RlKCkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgdGhpcy5hbmNob3JSb3dJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VSb3dJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlUm93SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFJhbmdlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuaXNTZWxlY3RlZChyb3dEYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgbWV0YVNlbGVjdGlvbiA9IHRoaXMucm93VG91Y2hlZCA/IGZhbHNlIDogdGhpcy5tZXRhS2V5U2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhS2V5VmFsdWUgPSB0aGlzLmRhdGFLZXkgPyBTdHJpbmcodGhpcy5yZXNvbHZlRmllbGREYXRhKHJvd0RhdGEsIHRoaXMuZGF0YUtleSkpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclJvd0luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZVJvd0luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFLZXkgPSBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiBtZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVNlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25LZXlzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmRleF8xID0gdGhpcy5maW5kSW5kZXhJblNlbGVjdGlvbihyb3dEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBzZWxlY3Rpb25JbmRleF8xOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUtleVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbktleXNbZGF0YUtleVZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUm93VW5zZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBkYXRhOiByb3dEYXRhLCB0eXBlOiAncm93JyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2luZ2xlU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gcm93RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHJvd0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhS2V5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25LZXlzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uS2V5c1tkYXRhS2V5VmFsdWVdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzTXVsdGlwbGVTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbiB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbktleXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uY29uY2F0KFtyb3dEYXRhXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbktleXNbZGF0YUtleVZhbHVlXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJvd1NlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGRhdGE6IHJvd0RhdGEsIHR5cGU6ICdyb3cnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVNlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbktleXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUm93VW5zZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBkYXRhOiByb3dEYXRhLCB0eXBlOiAncm93JyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IHJvd0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJvd1NlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGRhdGE6IHJvd0RhdGEsIHR5cGU6ICdyb3cnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhS2V5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25LZXlzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uS2V5c1tkYXRhS2V5VmFsdWVdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5kZXhfMiA9IHRoaXMuZmluZEluZGV4SW5TZWxlY3Rpb24ocm93RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIGkgIT0gc2VsZWN0aW9uSW5kZXhfMjsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJvd1Vuc2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgZGF0YTogcm93RGF0YSwgdHlwZTogJ3JvdycgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25LZXlzW2RhdGFLZXlWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gKHRoaXMuc2VsZWN0aW9uIHx8IFtdKS5jb25jYXQoW3Jvd0RhdGFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUm93U2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgZGF0YTogcm93RGF0YSwgdHlwZTogJ3JvdycgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbktleXNbZGF0YUtleVZhbHVlXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldmVudFNlbGVjdGlvbktleXNQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dUb3VjaGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmhhbmRsZVJvd1RvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucm93VG91Y2hlZCA9IHRydWU7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnNlbGVjdFJvd1dpdGhSYWRpbyA9IGZ1bmN0aW9uIChldmVudCwgcm93RGF0YSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24gIT0gcm93RGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gcm93RGF0YTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5vblJvd1NlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGRhdGE6IHJvd0RhdGEsIHR5cGU6ICdyYWRpb2J1dHRvbicgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25LZXlzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25LZXlzW1N0cmluZyh0aGlzLnJlc29sdmVGaWVsZERhdGEocm93RGF0YSwgdGhpcy5kYXRhS2V5KSldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMub25Sb3dVbnNlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGRhdGE6IHJvd0RhdGEsIHR5cGU6ICdyYWRpb2J1dHRvbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2ZW50U2VsZWN0aW9uS2V5c1Byb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmV2ZW50Um93Q2xpY2tQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnRvZ2dsZVJvd1dpdGhDaGVja2JveCA9IGZ1bmN0aW9uIChldmVudCwgcm93RGF0YSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uSW5kZXggPSB0aGlzLmZpbmRJbmRleEluU2VsZWN0aW9uKHJvd0RhdGEpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uIHx8IFtdO1xuICAgICAgICB2YXIgZGF0YUtleVZhbHVlID0gdGhpcy5kYXRhS2V5ID8gU3RyaW5nKHRoaXMucmVzb2x2ZUZpZWxkRGF0YShyb3dEYXRhLCB0aGlzLmRhdGFLZXkpKSA6IG51bGw7XG4gICAgICAgIGlmIChzZWxlY3Rpb25JbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIGkgIT0gc2VsZWN0aW9uSW5kZXg7IH0pO1xuICAgICAgICAgICAgdGhpcy5vblJvd1Vuc2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgZGF0YTogcm93RGF0YSwgdHlwZTogJ2NoZWNrYm94JyB9KTtcbiAgICAgICAgICAgIGlmIChkYXRhS2V5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25LZXlzW2RhdGFLZXlWYWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5jb25jYXQoW3Jvd0RhdGFdKTtcbiAgICAgICAgICAgIHRoaXMub25Sb3dTZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBkYXRhOiByb3dEYXRhLCB0eXBlOiAnY2hlY2tib3gnIH0pO1xuICAgICAgICAgICAgaWYgKGRhdGFLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uS2V5c1tkYXRhS2V5VmFsdWVdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5wcmV2ZW50U2VsZWN0aW9uS2V5c1Byb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmV2ZW50Um93Q2xpY2tQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLnRvZ2dsZVJvd3NXaXRoQ2hlY2tib3ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmNoZWNrZWQpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuaGVhZGVyQ2hlY2tib3hUb2dnbGVBbGxQYWdlcyA/IHRoaXMudmFsdWUuc2xpY2UoKSA6IHRoaXMuZGF0YVRvUmVuZGVyLnNsaWNlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gW107XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLm9uSGVhZGVyQ2hlY2tib3hUb2dnbGUuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBjaGVja2VkOiBldmVudC5jaGVja2VkIH0pO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5vblJvd1JpZ2h0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIHJvd0RhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmRleCA9IHRoaXMuZmluZEluZGV4SW5TZWxlY3Rpb24ocm93RGF0YSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3Rpb25JbmRleCAhPSAtMTtcbiAgICAgICAgICAgIHZhciBkYXRhS2V5VmFsdWUgPSB0aGlzLmRhdGFLZXkgPyBTdHJpbmcodGhpcy5yZXNvbHZlRmllbGREYXRhKHJvd0RhdGEsIHRoaXMuZGF0YUtleSkpIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVNlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHJvd0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQocm93RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNNdWx0aXBsZVNlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtyb3dEYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25LZXlzW1N0cmluZyh0aGlzLnJlc29sdmVGaWVsZERhdGEocm93RGF0YSwgdGhpcy5kYXRhS2V5KSldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51LnNob3coZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51U2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgZGF0YTogcm93RGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZlbnRTZWxlY3Rpb25LZXlzUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5yb3dEYmxjbGljayA9IGZ1bmN0aW9uIChldmVudCwgcm93RGF0YSkge1xuICAgICAgICB0aGlzLm9uUm93RGJsY2xpY2suZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBkYXRhOiByb3dEYXRhIH0pO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5pc1NpbmdsZVNlbGVjdGlvbk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5pc011bHRpcGxlU2VsZWN0aW9uTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpcGxlJztcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuZmluZEluZGV4SW5TZWxlY3Rpb24gPSBmdW5jdGlvbiAocm93RGF0YSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKHJvd0RhdGEsIHRoaXMuc2VsZWN0aW9uW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAocm93RGF0YSkge1xuICAgICAgICBpZiAocm93RGF0YSAmJiB0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbktleXNbdGhpcy5vYmplY3RVdGlscy5yZXNvbHZlRmllbGREYXRhKHJvd0RhdGEsIHRoaXMuZGF0YUtleSldICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEluZGV4SW5TZWxlY3Rpb24ocm93RGF0YSkgPiAtMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhyb3dEYXRhLCB0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoZGF0YTEsIGRhdGEyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVTZWxlY3Rpb25CeSA9PT0gJ2VxdWFscycgPyAoZGF0YTEgPT09IGRhdGEyKSA6IHRoaXMub2JqZWN0VXRpbHMuZXF1YWxzKGRhdGExLCBkYXRhMiwgdGhpcy5kYXRhS2V5KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGUucHJvdG90eXBlLCBcImFsbFNlbGVjdGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJDaGVja2JveFRvZ2dsZUFsbFBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uICYmIHRoaXMudmFsdWUgJiYgdGhpcy5zZWxlY3Rpb24ubGVuZ3RoID09PSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFUb1JlbmRlciAmJiB0aGlzLnNlbGVjdGlvbiAmJiAodGhpcy5kYXRhVG9SZW5kZXIubGVuZ3RoIDw9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZGF0YVRvUmVuZGVyOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5vbkZpbHRlcktleXVwID0gZnVuY3Rpb24gKHZhbHVlLCBmaWVsZCwgbWF0Y2hNb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlclRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZpbHRlclRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZmlsdGVyKHZhbHVlLCBmaWVsZCwgbWF0Y2hNb2RlKTtcbiAgICAgICAgICAgIF90aGlzLmZpbHRlclRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCB0aGlzLmZpbHRlckRlbGF5KTtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHZhbHVlLCBmaWVsZCwgbWF0Y2hNb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0ZpbHRlckJsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyc1tmaWVsZF0gPSB7IHZhbHVlOiB2YWx1ZSwgbWF0Y2hNb2RlOiBtYXRjaE1vZGUgfTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5maWx0ZXJzW2ZpZWxkXSlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNbZmllbGRdO1xuICAgICAgICB0aGlzLl9maWx0ZXIoKTtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuaXNGaWx0ZXJCbGFuayA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciAhPT0gbnVsbCAmJiBmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyAmJiBmaWx0ZXIudHJpbSgpLmxlbmd0aCA9PSAwKSB8fCAoZmlsdGVyIGluc3RhbmNlb2YgQXJyYXkgJiYgZmlsdGVyLmxlbmd0aCA9PSAwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLl9maWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgICAgICAgdGhpcy5vbkxhenlMb2FkLmVtaXQodGhpcy5jcmVhdGVMYXp5TG9hZE1ldGFkYXRhKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFZhbHVlID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGdsb2JhbE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHRoaXMuY29sdW1uc1tqXSwgZmlsdGVyTWV0YSA9IHRoaXMuZmlsdGVyc1tjb2wuZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAvL2xvY2FsXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyVmFsdWUgPSBmaWx0ZXJNZXRhLnZhbHVlLCBmaWx0ZXJGaWVsZCA9IGNvbC5maWVsZCwgZmlsdGVyTWF0Y2hNb2RlID0gZmlsdGVyTWV0YS5tYXRjaE1vZGUgfHwgJ3N0YXJ0c1dpdGgnLCBkYXRhRmllbGRWYWx1ZSA9IHRoaXMucmVzb2x2ZUZpZWxkRGF0YSh0aGlzLnZhbHVlW2ldLCBmaWx0ZXJGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyQ29uc3RyYWludCA9IHRoaXMuZmlsdGVyQ29uc3RyYWludHNbZmlsdGVyTWF0Y2hNb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyQ29uc3RyYWludChkYXRhRmllbGRWYWx1ZSwgZmlsdGVyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9nbG9iYWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsRmlsdGVyICYmICFnbG9iYWxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsTWF0Y2ggPSB0aGlzLmZpbHRlckNvbnN0cmFpbnRzWydjb250YWlucyddKHRoaXMucmVzb2x2ZUZpZWxkRGF0YSh0aGlzLnZhbHVlW2ldLCBjb2wuZmllbGQpLCB0aGlzLmdsb2JhbEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBsb2NhbE1hdGNoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdsb2JhbEZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbG9jYWxNYXRjaCAmJiBnbG9iYWxNYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFZhbHVlLnB1c2godGhpcy52YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRWYWx1ZS5sZW5ndGggPT09IHRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhZ2luYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMudG90YWxSZWNvcmRzID0gdGhpcy5maWx0ZXJlZFZhbHVlID8gdGhpcy5maWx0ZXJlZFZhbHVlLmxlbmd0aCA6IHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURhdGFUb1JlbmRlcih0aGlzLmZpbHRlcmVkVmFsdWUgfHwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkZpbHRlci5lbWl0KHtcbiAgICAgICAgICAgIGZpbHRlcnM6IHRoaXMuZmlsdGVycyxcbiAgICAgICAgICAgIGZpbHRlcmVkVmFsdWU6IHRoaXMuZmlsdGVyZWRWYWx1ZSB8fCB0aGlzLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5oYXNGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWVtcHR5IHx8ICh0aGlzLmdsb2JhbEZpbHRlciAmJiB0aGlzLmdsb2JhbEZpbHRlci52YWx1ZSAmJiB0aGlzLmdsb2JhbEZpbHRlci52YWx1ZS50cmltKCkubGVuZ3RoKTtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUub25GaWx0ZXJJbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5zd2l0Y2hDZWxsVG9FZGl0TW9kZSA9IGZ1bmN0aW9uIChjZWxsLCBjb2x1bW4sIHJvd0RhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbk1vZGUgJiYgdGhpcy5lZGl0YWJsZSAmJiBjb2x1bW4uZWRpdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnRFZGl0TGlzdGVuZXIoKTtcbiAgICAgICAgICAgIGlmIChjZWxsICE9IHRoaXMuZWRpdGluZ0NlbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGl0aW5nQ2VsbCAmJiB0aGlzLmRvbUhhbmRsZXIuZmluZCh0aGlzLmVkaXRpbmdDZWxsLCAnLm5nLWludmFsaWQubmctZGlydHknKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIucmVtb3ZlQ2xhc3ModGhpcy5lZGl0aW5nQ2VsbCwgJ3VpLWNlbGwtZWRpdGluZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRpbmdDZWxsID0gY2VsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRWRpdEluaXQuZW1pdCh7IGNvbHVtbjogY29sdW1uLCBkYXRhOiByb3dEYXRhIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hZGRDbGFzcyhjZWxsLCAndWktY2VsbC1lZGl0aW5nJyk7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzYWJsZV8xID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUoY2VsbCwgJy51aS1jZWxsLWVkaXRvciBpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGlmIChmb2N1c2FibGVfMSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRvbUhhbmRsZXIuaW52b2tlRWxlbWVudE1ldGhvZChmb2N1c2FibGVfMSwgJ2ZvY3VzJyk7IH0sIDUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuc3dpdGNoQ2VsbFRvVmlld01vZGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVkaXRpbmdDZWxsID0gbnVsbDtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmZpbmRDZWxsKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIucmVtb3ZlQ2xhc3ModGhpcy5lZGl0aW5nQ2VsbCwgJ3VpLWNlbGwtZWRpdGluZycpO1xuICAgICAgICB0aGlzLnVuYmluZERvY3VtZW50RWRpdExpc3RlbmVyKCk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmNsb3NlQ2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGluZ0NlbGwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5yZW1vdmVDbGFzcyh0aGlzLmVkaXRpbmdDZWxsLCAndWktY2VsbC1lZGl0aW5nJyk7XG4gICAgICAgICAgICB0aGlzLmVkaXRpbmdDZWxsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnRFZGl0TGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5iaW5kRG9jdW1lbnRFZGl0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5kb2N1bWVudEVkaXRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudEVkaXRMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZWRpdG9yQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2VDZWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmVkaXRvckNsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS51bmJpbmREb2N1bWVudEVkaXRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRFZGl0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRFZGl0TGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRFZGl0TGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm9uQ2VsbEVkaXRvcktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQsIGNvbHVtbiwgcm93RGF0YSwgcm93SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMub25FZGl0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgY29sdW1uOiBjb2x1bW4sIGRhdGE6IHJvd0RhdGEsIGluZGV4OiByb3dJbmRleCB9KTtcbiAgICAgICAgICAgIC8vZW50ZXJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVkaXRDb21wbGV0ZS5lbWl0KHsgY29sdW1uOiBjb2x1bW4sIGRhdGE6IHJvd0RhdGEsIGluZGV4OiByb3dJbmRleCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuaW52b2tlRWxlbWVudE1ldGhvZChldmVudC50YXJnZXQsICdibHVyJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hDZWxsVG9WaWV3TW9kZShldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVkaXRDYW5jZWwuZW1pdCh7IGNvbHVtbjogY29sdW1uLCBkYXRhOiByb3dEYXRhLCBpbmRleDogcm93SW5kZXggfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmludm9rZUVsZW1lbnRNZXRob2QoZXZlbnQudGFyZ2V0LCAnYmx1cicpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoQ2VsbFRvVmlld01vZGUoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVkaXRDb21wbGV0ZS5lbWl0KHsgY29sdW1uOiBjb2x1bW4sIGRhdGE6IHJvd0RhdGEsIGluZGV4OiByb3dJbmRleCB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvUHJldmlvdXNDZWxsKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvTmV4dENlbGwoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm1vdmVUb1ByZXZpb3VzQ2VsbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY3VycmVudENlbGwgPSB0aGlzLmZpbmRDZWxsKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHZhciByb3cgPSBjdXJyZW50Q2VsbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB2YXIgdGFyZ2V0Q2VsbCA9IHRoaXMuZmluZFByZXZpb3VzRWRpdGFibGVDb2x1bW4oY3VycmVudENlbGwpO1xuICAgICAgICBpZiAodGFyZ2V0Q2VsbCkge1xuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmludm9rZUVsZW1lbnRNZXRob2QodGFyZ2V0Q2VsbCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50Q2VsbCA9IHRoaXMuZmluZENlbGwoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdmFyIHJvdyA9IGN1cnJlbnRDZWxsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHZhciB0YXJnZXRDZWxsID0gdGhpcy5maW5kTmV4dEVkaXRhYmxlQ29sdW1uKGN1cnJlbnRDZWxsKTtcbiAgICAgICAgaWYgKHRhcmdldENlbGwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5pbnZva2VFbGVtZW50TWV0aG9kKHRhcmdldENlbGwsICdjbGljaycpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5maW5kUHJldmlvdXNFZGl0YWJsZUNvbHVtbiA9IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIHZhciBwcmV2Q2VsbCA9IGNlbGwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgaWYgKCFwcmV2Q2VsbCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUm93ID0gY2VsbC5wYXJlbnRFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNSb3cpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q2VsbCA9IHByZXZpb3VzUm93Lmxhc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZDZWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKHByZXZDZWxsLCAndWktZWRpdGFibGUtY29sdW1uJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZDZWxsO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRQcmV2aW91c0VkaXRhYmxlQ29sdW1uKHByZXZDZWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmZpbmROZXh0RWRpdGFibGVDb2x1bW4gPSBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICB2YXIgbmV4dENlbGwgPSBjZWxsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgaWYgKCFuZXh0Q2VsbCkge1xuICAgICAgICAgICAgdmFyIG5leHRSb3cgPSBjZWxsLnBhcmVudEVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG5leHRSb3cpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2VsbCA9IG5leHRSb3cuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRDZWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKG5leHRDZWxsLCAndWktZWRpdGFibGUtY29sdW1uJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDZWxsO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmROZXh0RWRpdGFibGVDb2x1bW4obmV4dENlbGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUub25DdXN0b21FZGl0b3JGb2N1c1ByZXYgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG9QcmV2aW91c0NlbGwoZXZlbnQpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5vbkN1c3RvbUVkaXRvckZvY3VzTmV4dCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLm1vdmVUb05leHRDZWxsKGV2ZW50KTtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuZmluZENlbGwgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgY2VsbCA9IGVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChjZWxsLnRhZ05hbWUgIT0gJ1REJykge1xuICAgICAgICAgICAgY2VsbCA9IGNlbGwucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUuaW5pdFJlc2l6YWJsZUNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGJvZHkgPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0Ym9keS51aS1kYXRhdGFibGUtZGF0YScpO1xuICAgICAgICB0aGlzLnJlc2l6ZXJIZWxwZXIgPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXYudWktY29sdW1uLXJlc2l6ZXItaGVscGVyJyk7XG4gICAgICAgIHRoaXMuZml4Q29sdW1uV2lkdGhzKCk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uUmVzaXppbmcpIHtcbiAgICAgICAgICAgIHRoaXMub25Db2x1bW5SZXNpemUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtblJlc2l6aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtblJlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uQ29sdW1uUmVzaXplRW5kKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5iaW5kQ29sdW1uUmVzaXplRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF90aGlzLm9uRG9jdW1lbnRNb3VzZU1vdmUuYmluZChfdGhpcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENvbHVtblJlc2l6ZUVuZExpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ21vdXNldXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb2x1bW5SZXNpemluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtblJlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Db2x1bW5SZXNpemVFbmQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUudW5iaW5kQ29sdW1uUmVzaXplRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRDb2x1bW5SZXNpemVFbmRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENvbHVtblJlc2l6ZUVuZExpc3RlbmVyKCk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q29sdW1uUmVzaXplRW5kTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmluaXRDb2x1bW5SZXNpemUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iaW5kQ29sdW1uUmVzaXplRXZlbnRzKCk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIHZhciBjb250YWluZXJMZWZ0ID0gdGhpcy5kb21IYW5kbGVyLmdldE9mZnNldChjb250YWluZXIpLmxlZnQ7XG4gICAgICAgIHRoaXMucmVzaXplQ29sdW1uID0gZXZlbnQudGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY29sdW1uUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RSZXNpemVySGVscGVyWCA9IChldmVudC5wYWdlWCAtIGNvbnRhaW5lckxlZnQgKyBjb250YWluZXIuc2Nyb2xsTGVmdCk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm9uQ29sdW1uUmVzaXplID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIHZhciBjb250YWluZXJMZWZ0ID0gdGhpcy5kb21IYW5kbGVyLmdldE9mZnNldChjb250YWluZXIpLmxlZnQ7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5hZGRDbGFzcyhjb250YWluZXIsICd1aS11bnNlbGVjdGFibGUtdGV4dCcpO1xuICAgICAgICB0aGlzLnJlc2l6ZXJIZWxwZXIuc3R5bGUuaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMucmVzaXplckhlbHBlci5zdHlsZS50b3AgPSAwICsgJ3B4JztcbiAgICAgICAgdGhpcy5yZXNpemVySGVscGVyLnN0eWxlLmxlZnQgPSAoZXZlbnQucGFnZVggLSBjb250YWluZXJMZWZ0ICsgY29udGFpbmVyLnNjcm9sbExlZnQpICsgJ3B4JztcbiAgICAgICAgdGhpcy5yZXNpemVySGVscGVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5vbkNvbHVtblJlc2l6ZUVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLnJlc2l6ZXJIZWxwZXIub2Zmc2V0TGVmdCAtIHRoaXMubGFzdFJlc2l6ZXJIZWxwZXJYO1xuICAgICAgICB2YXIgY29sdW1uV2lkdGggPSB0aGlzLnJlc2l6ZUNvbHVtbi5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIG5ld0NvbHVtbldpZHRoID0gY29sdW1uV2lkdGggKyBkZWx0YTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0gdGhpcy5yZXNpemVDb2x1bW4uc3R5bGUubWluV2lkdGggfHwgMTU7XG4gICAgICAgIGlmIChjb2x1bW5XaWR0aCArIGRlbHRhID4gcGFyc2VJbnQobWluV2lkdGgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5SZXNpemVNb2RlID09PSAnZml0Jykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q29sdW1uID0gdGhpcy5yZXNpemVDb2x1bW4ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q29sdW1uV2lkdGggPSBuZXh0Q29sdW1uLm9mZnNldFdpZHRoIC0gZGVsdGE7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NvbHVtbldpZHRoID4gMTUgJiYgbmV4dENvbHVtbldpZHRoID4gMTUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVDb2x1bW4uc3R5bGUud2lkdGggPSBuZXdDb2x1bW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29sdW1uLnN0eWxlLndpZHRoID0gbmV4dENvbHVtbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sR3JvdXAgPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjb2xncm91cC51aS1kYXRhdGFibGUtc2Nyb2xsYWJsZS1jb2xncm91cCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZUNvbHVtbkluZGV4ID0gdGhpcy5kb21IYW5kbGVyLmluZGV4KHRoaXMucmVzaXplQ29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbEdyb3VwLmNoaWxkcmVuW3Jlc2l6ZUNvbHVtbkluZGV4XS5zdHlsZS53aWR0aCA9IG5ld0NvbHVtbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sR3JvdXAuY2hpbGRyZW5bcmVzaXplQ29sdW1uSW5kZXggKyAxXS5zdHlsZS53aWR0aCA9IG5leHRDb2x1bW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbHVtblJlc2l6ZU1vZGUgPT09ICdleHBhbmQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50Ym9keS5wYXJlbnRFbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy50Ym9keS5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoICsgZGVsdGEgKyAncHgnO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplQ29sdW1uLnN0eWxlLndpZHRoID0gbmV3Q29sdW1uV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IHRoaXMudGJvZHkucGFyZW50RWxlbWVudC5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJy51aS1kYXRhdGFibGUtc2Nyb2xsYWJsZS1oZWFkZXItYm94JykuY2hpbGRyZW5bMF0uc3R5bGUud2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbEdyb3VwID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY29sZ3JvdXAudWktZGF0YXRhYmxlLXNjcm9sbGFibGUtY29sZ3JvdXAnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZUNvbHVtbkluZGV4ID0gdGhpcy5kb21IYW5kbGVyLmluZGV4KHRoaXMucmVzaXplQ29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgY29sR3JvdXAuY2hpbGRyZW5bcmVzaXplQ29sdW1uSW5kZXhdLnN0eWxlLndpZHRoID0gbmV3Q29sdW1uV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLnN0eWxlLndpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbkNvbFJlc2l6ZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLnJlc2l6ZUNvbHVtbixcbiAgICAgICAgICAgICAgICBkZWx0YTogZGVsdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplckhlbHBlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnJlc2l6ZUNvbHVtbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0sICd1aS11bnNlbGVjdGFibGUtdGV4dCcpO1xuICAgICAgICB0aGlzLnVuYmluZENvbHVtblJlc2l6ZUV2ZW50cygpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5maXhDb2x1bW5XaWR0aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5kb21IYW5kbGVyLmZpbmQodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndGgudWktcmVzaXphYmxlLWNvbHVtbicpO1xuICAgICAgICB2YXIgYm9keUNvbHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29sdW1uc1tpXS5zdHlsZS53aWR0aCA9IGNvbHVtbnNbaV0ub2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgIHZhciBjb2xHcm91cCA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2NvbGdyb3VwLnVpLWRhdGF0YWJsZS1zY3JvbGxhYmxlLWNvbGdyb3VwJyk7XG4gICAgICAgICAgICBib2R5Q29scyA9IGNvbEdyb3VwLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGJvZHlDb2xzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlDb2xzW2ldLnN0eWxlLndpZHRoID0gY29sdW1uc1tpXS5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm9uQ29sdW1uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtblJlc2l6aW5nKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ2dlZENvbHVtbiA9IHRoaXMuZmluZFBhcmVudEhlYWRlcihldmVudC50YXJnZXQpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dCcsICdiJyk7IC8vIEZpcmVmb3ggcmVxdWlyZXMgdGhpcyB0byBtYWtlIGRyYWdnaW5nIHBvc3NpYmxlXG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBfdGhpcy5vbkNvbHVtbkRyYWdvdmVyLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLm9uQ29sdW1uRHJhZ292ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRyb3BIZWFkZXIgPSB0aGlzLmZpbmRQYXJlbnRIZWFkZXIoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMucmVvcmRlcmFibGVDb2x1bW5zICYmIHRoaXMuZHJhZ2dlZENvbHVtbiAmJiBkcm9wSGVhZGVyKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJPZmZzZXQgPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T2Zmc2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgZHJvcEhlYWRlck9mZnNldCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPZmZzZXQoZHJvcEhlYWRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2VkQ29sdW1uICE9IGRyb3BIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0TGVmdCA9IGRyb3BIZWFkZXJPZmZzZXQubGVmdCAtIGNvbnRhaW5lck9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUb3AgPSBjb250YWluZXJPZmZzZXQudG9wIC0gZHJvcEhlYWRlck9mZnNldC50b3A7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkNlbnRlciA9IGRyb3BIZWFkZXJPZmZzZXQubGVmdCArIGRyb3BIZWFkZXIub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlckluZGljYXRvclVwLnN0eWxlLnRvcCA9IGRyb3BIZWFkZXJPZmZzZXQudG9wIC0gY29udGFpbmVyT2Zmc2V0LnRvcCAtICh0aGlzLmljb25IZWlnaHQgLSAxKSArICdweCc7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW9yZGVySW5kaWNhdG9yRG93bi5zdHlsZS50b3AgPSBkcm9wSGVhZGVyT2Zmc2V0LnRvcCAtIGNvbnRhaW5lck9mZnNldC50b3AgKyBkcm9wSGVhZGVyLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBhZ2VYID4gY29sdW1uQ2VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlckluZGljYXRvclVwLnN0eWxlLmxlZnQgPSAodGFyZ2V0TGVmdCArIGRyb3BIZWFkZXIub2Zmc2V0V2lkdGggLSBNYXRoLmNlaWwodGhpcy5pY29uV2lkdGggLyAyKSkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJJbmRpY2F0b3JEb3duLnN0eWxlLmxlZnQgPSAodGFyZ2V0TGVmdCArIGRyb3BIZWFkZXIub2Zmc2V0V2lkdGggLSBNYXRoLmNlaWwodGhpcy5pY29uV2lkdGggLyAyKSkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BQb3NpdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJJbmRpY2F0b3JVcC5zdHlsZS5sZWZ0ID0gKHRhcmdldExlZnQgLSBNYXRoLmNlaWwodGhpcy5pY29uV2lkdGggLyAyKSkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJJbmRpY2F0b3JEb3duLnN0eWxlLmxlZnQgPSAodGFyZ2V0TGVmdCAtIE1hdGguY2VpbCh0aGlzLmljb25XaWR0aCAvIDIpKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlckluZGljYXRvclVwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlckluZGljYXRvckRvd24uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5vbkNvbHVtbkRyYWdsZWF2ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5yZW9yZGVyYWJsZUNvbHVtbnMgJiYgdGhpcy5kcmFnZ2VkQ29sdW1uKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVySW5kaWNhdG9yVXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMucmVvcmRlckluZGljYXRvckRvd24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMub25Db2x1bW5EcmFnb3Zlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUub25Db2x1bW5Ecm9wID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRDb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBkcmFnSW5kZXggPSB0aGlzLmRvbUhhbmRsZXIuaW5kZXgodGhpcy5kcmFnZ2VkQ29sdW1uKTtcbiAgICAgICAgICAgIHZhciBkcm9wSW5kZXggPSB0aGlzLmRvbUhhbmRsZXIuaW5kZXgodGhpcy5maW5kUGFyZW50SGVhZGVyKGV2ZW50LnRhcmdldCkpO1xuICAgICAgICAgICAgdmFyIGFsbG93RHJvcCA9IChkcmFnSW5kZXggIT0gZHJvcEluZGV4KTtcbiAgICAgICAgICAgIGlmIChhbGxvd0Ryb3AgJiYgKChkcm9wSW5kZXggLSBkcmFnSW5kZXggPT0gMSAmJiB0aGlzLmRyb3BQb3NpdGlvbiA9PT0gLTEpIHx8IChkcmFnSW5kZXggLSBkcm9wSW5kZXggPT0gMSAmJiB0aGlzLmRyb3BQb3NpdGlvbiA9PT0gMSkpKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dEcm9wID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dEcm9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnNwbGljZShkcm9wSW5kZXgsIDAsIHRoaXMuY29sdW1ucy5zcGxpY2UoZHJhZ0luZGV4LCAxKVswXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbFJlb3JkZXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdJbmRleDogZHJhZ0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBkcm9wSW5kZXg6IGRyb3BJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJJbmRpY2F0b3JVcC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVySW5kaWNhdG9yRG93bi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkQ29sdW1uLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkQ29sdW1uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJvcFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5pbml0Q29sdW1uUmVvcmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW9yZGVySW5kaWNhdG9yVXAgPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0sICdzcGFuLnVpLWRhdGF0YWJsZS1yZW9yZGVyLWluZGljYXRvci11cCcpO1xuICAgICAgICB0aGlzLnJlb3JkZXJJbmRpY2F0b3JEb3duID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLCAnc3Bhbi51aS1kYXRhdGFibGUtcmVvcmRlci1pbmRpY2F0b3ItZG93bicpO1xuICAgICAgICB0aGlzLmljb25XaWR0aCA9IHRoaXMuZG9tSGFuZGxlci5nZXRIaWRkZW5FbGVtZW50T3V0ZXJXaWR0aCh0aGlzLnJlb3JkZXJJbmRpY2F0b3JVcCk7XG4gICAgICAgIHRoaXMuaWNvbkhlaWdodCA9IHRoaXMuZG9tSGFuZGxlci5nZXRIaWRkZW5FbGVtZW50T3V0ZXJIZWlnaHQodGhpcy5yZW9yZGVySW5kaWNhdG9yVXApO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5maW5kUGFyZW50SGVhZGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT0gJ1RIJykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50XzEubm9kZU5hbWUgIT0gJ1RIJykge1xuICAgICAgICAgICAgICAgIHBhcmVudF8xID0gcGFyZW50XzEucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudF8xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRfMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5oYXNGb290ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvb3RlckNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5zW2ldLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0YVRvUmVuZGVyIHx8ICh0aGlzLmRhdGFUb1JlbmRlci5sZW5ndGggPT0gMCk7XG4gICAgfTtcbiAgICBEYXRhVGFibGUucHJvdG90eXBlLmNyZWF0ZUxhenlMb2FkTWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgIHJvd3M6IHRoaXMudmlydHVhbFNjcm9sbCA/IHRoaXMucm93cyAqIDIgOiB0aGlzLnJvd3MsXG4gICAgICAgICAgICBzb3J0RmllbGQ6IHRoaXMuc29ydEZpZWxkLFxuICAgICAgICAgICAgc29ydE9yZGVyOiB0aGlzLnNvcnRPcmRlcixcbiAgICAgICAgICAgIGZpbHRlcnM6IHRoaXMuZmlsdGVycyxcbiAgICAgICAgICAgIGdsb2JhbEZpbHRlcjogdGhpcy5nbG9iYWxGaWx0ZXIgPyB0aGlzLmdsb2JhbEZpbHRlci52YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICBtdWx0aVNvcnRNZXRhOiB0aGlzLm11bHRpU29ydE1ldGFcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUudG9nZ2xlUm93ID0gZnVuY3Rpb24gKHJvdywgZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV4cGFuZGVkUm93cykge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZFJvd3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwYW5kZWRSb3dJbmRleCA9IHRoaXMuZmluZEV4cGFuZGVkUm93SW5kZXgocm93KTtcbiAgICAgICAgaWYgKGV4cGFuZGVkUm93SW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRSb3dzLnNwbGljZShleHBhbmRlZFJvd0luZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMub25Sb3dDb2xsYXBzZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBkYXRhOiByb3dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucm93RXhwYW5kTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkUm93cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leHBhbmRlZFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgdGhpcy5vblJvd0V4cGFuZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBkYXRhOiByb3dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5maW5kRXhwYW5kZWRSb3dJbmRleCA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkUm93cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV4cGFuZGVkUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZGVkUm93c1tpXSA9PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5pc1Jvd0V4cGFuZGVkID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kRXhwYW5kZWRSb3dJbmRleChyb3cpICE9IC0xO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5maW5kRXhwYW5kZWRSb3dHcm91cEluZGV4ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWRSb3dzR3JvdXBzICYmIHRoaXMuZXhwYW5kZWRSb3dzR3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV4cGFuZGVkUm93c0dyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZXhwYW5kZWRSb3dzR3JvdXBzW2ldO1xuICAgICAgICAgICAgICAgIHZhciByb3dHcm91cEZpZWxkID0gdGhpcy5yZXNvbHZlRmllbGREYXRhKHJvdywgdGhpcy5ncm91cEZpZWxkKTtcbiAgICAgICAgICAgICAgICBpZiAocm93R3JvdXBGaWVsZCA9PT0gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5pc1Jvd0dyb3VwRXhwYW5kZWQgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRFeHBhbmRlZFJvd0dyb3VwSW5kZXgocm93KSAhPSAtMTtcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUudG9nZ2xlUm93R3JvdXAgPSBmdW5jdGlvbiAoZXZlbnQsIHJvdykge1xuICAgICAgICB0aGlzLnJvd0dyb3VwVG9nZ2xlQ2xpY2sgPSB0cnVlO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRFeHBhbmRlZFJvd0dyb3VwSW5kZXgocm93KTtcbiAgICAgICAgdmFyIHJvd0dyb3VwRmllbGQgPSB0aGlzLnJlc29sdmVGaWVsZERhdGEocm93LCB0aGlzLmdyb3VwRmllbGQpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZFJvd3NHcm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMub25Sb3dHcm91cENvbGxhcHNlLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGdyb3VwOiByb3dHcm91cEZpZWxkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRSb3dzR3JvdXBzID0gdGhpcy5leHBhbmRlZFJvd3NHcm91cHMgfHwgW107XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkUm93c0dyb3Vwcy5wdXNoKHJvd0dyb3VwRmllbGQpO1xuICAgICAgICAgICAgdGhpcy5vblJvd0dyb3VwRXhwYW5kLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGdyb3VwOiByb3dHcm91cEZpZWxkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zb3J0RmllbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnNvcnRPcmRlciA9IDE7XG4gICAgICAgIHRoaXMuZmlsdGVyZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9maXJzdCA9IDA7XG4gICAgICAgIHRoaXMuZmlyc3RDaGFuZ2UuZW1pdCh0aGlzLl9maXJzdCk7XG4gICAgICAgIHRoaXMudXBkYXRlVG90YWxSZWNvcmRzKCk7XG4gICAgICAgIGlmICh0aGlzLmxhenkpXG4gICAgICAgICAgICB0aGlzLm9uTGF6eUxvYWQuZW1pdCh0aGlzLmNyZWF0ZUxhenlMb2FkTWV0YWRhdGEoKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5leHBvcnRDU1YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5maWx0ZXJlZFZhbHVlIHx8IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBjc3YgPSAnXFx1ZmVmZic7XG4gICAgICAgIC8vaGVhZGVyc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uc1tpXS5maWVsZCkge1xuICAgICAgICAgICAgICAgIGNzdiArPSAnXCInICsgKHRoaXMuY29sdW1uc1tpXS5oZWFkZXIgfHwgdGhpcy5jb2x1bW5zW2ldLmZpZWxkKSArICdcIic7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAodGhpcy5jb2x1bW5zLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdiArPSB0aGlzLmNzdlNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9ib2R5ICAgICAgICBcbiAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQsIGkpIHtcbiAgICAgICAgICAgIGNzdiArPSAnXFxuJztcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IF90aGlzLmNvbHVtbnMubGVuZ3RoOyBpXzErKykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb2x1bW5zW2lfMV0uZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N2ICs9ICdcIicgKyBfdGhpcy5yZXNvbHZlRmllbGREYXRhKHJlY29yZCwgX3RoaXMuY29sdW1uc1tpXzFdLmZpZWxkKSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpXzEgPCAoX3RoaXMuY29sdW1ucy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3N2ICs9IF90aGlzLmNzdlNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2Nzdl0sIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04OydcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcbiAgICAgICAgICAgIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2IsIHRoaXMuZXhwb3J0RmlsZW5hbWUgKyAnLmNzdicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgIGxpbmsuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgICAgICBpZiAobGluay5kb3dubG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKTtcbiAgICAgICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCB0aGlzLmV4cG9ydEZpbGVuYW1lICsgJy5jc3YnKTtcbiAgICAgICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjc3YgPSAnZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LCcgKyBjc3Y7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oZW5jb2RlVVJJKGNzdikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5nZXRCbG9ja2FibGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgIH07XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5nZXRSb3dTdHlsZUNsYXNzID0gZnVuY3Rpb24gKHJvd0RhdGEsIHJvd0luZGV4KSB7XG4gICAgICAgIHZhciBzdHlsZUNsYXNzID0gJ3VpLXdpZGdldC1jb250ZW50JztcbiAgICAgICAgaWYgKHRoaXMucm93U3R5bGVDbGFzcykge1xuICAgICAgICAgICAgdmFyIHJvd0NsYXNzID0gdGhpcy5yb3dTdHlsZUNsYXNzLmNhbGwodGhpcywgcm93RGF0YSwgcm93SW5kZXgpO1xuICAgICAgICAgICAgaWYgKHJvd0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVDbGFzcyArPSAnICcgKyByb3dDbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVDbGFzcztcbiAgICB9O1xuICAgIERhdGFUYWJsZS5wcm90b3R5cGUudmlzaWJsZUNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMgPyB0aGlzLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhYy5oaWRkZW47IH0pIDogW107XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJjb250YWluZXJXaWR0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZyb3plbldpZHRoICYmIHRoaXMudW5mcm96ZW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmZyb3plbldpZHRoKSArIHBhcnNlRmxvYXQodGhpcy51bmZyb3plbldpZHRoKSArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUgPyB0aGlzLnN0eWxlLndpZHRoIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9yZW1vdmUgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsRmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRmlsdGVyRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNpemFibGVDb2x1bW5zKSB7XG4gICAgICAgICAgICB0aGlzLnVuYmluZENvbHVtblJlc2l6ZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnRFZGl0TGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEYXRhVGFibGU7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInBhZ2luYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwicm93c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwicGFnZUxpbmtzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInJvd3NQZXJQYWdlT3B0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInJlc3BvbnNpdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJzdGFja2VkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25Nb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInNlbGVjdGlvbkNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImVkaXRhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm9uUm93Q2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwib25Sb3dTZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwib25Sb3dVbnNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJvblJvd0RibGNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm9uSGVhZGVyQ2hlY2tib3hUb2dnbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJoZWFkZXJDaGVja2JveFRvZ2dsZUFsbFBhZ2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm9uQ29udGV4dE1lbnVTZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImZpbHRlckRlbGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwibGF6eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJvbkxhenlMb2FkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwicmVzaXphYmxlQ29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiY29sdW1uUmVzaXplTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJvbkNvbFJlc2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInJlb3JkZXJhYmxlQ29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJvbkNvbFJlb3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJzY3JvbGxhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwidmlydHVhbFNjcm9sbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwic2Nyb2xsSGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJzY3JvbGxXaWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiZnJvemVuV2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInVuZnJvemVuV2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJ0YWJsZVN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJ0YWJsZVN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImdsb2JhbEZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwic29ydE1vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInNvcnRGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwic29ydE9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJncm91cEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm11bHRpU29ydE1ldGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImNvbnRleHRNZW51XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJjc3ZTZXBhcmF0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImV4cG9ydEZpbGVuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJlbXB0eU1lc3NhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInBhZ2luYXRvclBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiYWx3YXlzU2hvd1BhZ2luYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm1ldGFLZXlTZWxlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwicm93VHJhY2tCeVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImltbXV0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiY29tcGFyZVNlbGVjdGlvbkJ5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm9uRWRpdEluaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwib25FZGl0Q29tcGxldGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwib25FZGl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm9uRWRpdENhbmNlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJvblBhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwib25Tb3J0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm9uRmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkKHNoYXJlZF8yLkhlYWRlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkKHNoYXJlZF8yLkZvb3RlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiZm9vdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiZXhwYW5kYWJsZVJvd3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiZXhwYW5kZWRSb3dzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiZXhwYW5kYWJsZVJvd0dyb3Vwc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwicm93RXhwYW5kTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJleHBhbmRlZFJvd3NHcm91cHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInJvd1N0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInJvd0dyb3VwTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInNvcnRhYmxlUm93R3JvdXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInNvcnRGaWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwicm93SG92ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImZpbHRlcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImRhdGFLZXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJsb2FkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJsb2FkaW5nSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJmaXJzdENoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJvblJvd0V4cGFuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJvblJvd0NvbGxhcHNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcIm9uUm93R3JvdXBFeHBhbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwib25Sb3dHcm91cENvbGxhcHNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkcmVuKHNoYXJlZF8yLlByaW1lVGVtcGxhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuUXVlcnlMaXN0KVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oc2hhcmVkXzIuQ29sdW1uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlF1ZXJ5TGlzdClcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwiY29sc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMi5IZWFkZXJDb2x1bW5Hcm91cCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNoYXJlZF8yLkhlYWRlckNvbHVtbkdyb3VwKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJoZWFkZXJDb2x1bW5Hcm91cFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMi5Gb290ZXJDb2x1bW5Hcm91cCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHNoYXJlZF8yLkZvb3RlckNvbHVtbkdyb3VwKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJmb290ZXJDb2x1bW5Hcm91cFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIERhdGFUYWJsZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcImZpcnN0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxuXSwgRGF0YVRhYmxlLnByb3RvdHlwZSwgXCJ0b3RhbFJlY29yZHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBEYXRhVGFibGUucHJvdG90eXBlLCBcInNlbGVjdGlvblwiLCBudWxsKTtcbkRhdGFUYWJsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtZGF0YVRhYmxlJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtzdHlsZS53aWR0aF09XFxcImNvbnRhaW5lcldpZHRoXFxcIlxcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1kYXRhdGFibGUgdWktd2lkZ2V0Jzp0cnVlLCd1aS1kYXRhdGFibGUtcmVmbG93JzpyZXNwb25zaXZlLCd1aS1kYXRhdGFibGUtc3RhY2tlZCc6c3RhY2tlZCwndWktZGF0YXRhYmxlLXJlc2l6YWJsZSc6cmVzaXphYmxlQ29sdW1ucywndWktZGF0YXRhYmxlLXNjcm9sbGFibGUnOnNjcm9sbGFibGV9XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kYXRhdGFibGUtbG9hZGluZyB1aS13aWRnZXQtb3ZlcmxheVxcXCIgKm5nSWY9XFxcImxvYWRpbmdcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWRhdGF0YWJsZS1sb2FkaW5nLWNvbnRlbnRcXFwiICpuZ0lmPVxcXCJsb2FkaW5nXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgW2NsYXNzXT1cXFwiJ2ZhIGZhLXNwaW4gZmEtMnggJyArIGxvYWRpbmdJY29uXFxcIj48L2k+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZGF0YXRhYmxlLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyXFxcIiAqbmdJZj1cXFwiaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJwLWhlYWRlclxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxwLXBhZ2luYXRvciBbcm93c109XFxcInJvd3NcXFwiIFtmaXJzdF09XFxcImZpcnN0XFxcIiBbdG90YWxSZWNvcmRzXT1cXFwidG90YWxSZWNvcmRzXFxcIiBbcGFnZUxpbmtTaXplXT1cXFwicGFnZUxpbmtzXFxcIiBzdHlsZUNsYXNzPVxcXCJ1aS1wYWdpbmF0b3ItdG9wXFxcIiBbYWx3YXlzU2hvd109XFxcImFsd2F5c1Nob3dQYWdpbmF0b3JcXFwiXFxuICAgICAgICAgICAgICAgIChvblBhZ2VDaGFuZ2UpPVxcXCJvblBhZ2VDaGFuZ2UoJGV2ZW50KVxcXCIgW3Jvd3NQZXJQYWdlT3B0aW9uc109XFxcInJvd3NQZXJQYWdlT3B0aW9uc1xcXCIgKm5nSWY9XFxcInBhZ2luYXRvciAmJiBwYWdpbmF0b3JQb3NpdGlvbiA9PSd0b3AnIHx8IHBhZ2luYXRvclBvc2l0aW9uID09J2JvdGgnXFxcIj48L3AtcGFnaW5hdG9yPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWRhdGF0YWJsZS10YWJsZXdyYXBwZXJcXFwiICpuZ0lmPVxcXCIhc2Nyb2xsYWJsZVxcXCI+XFxuICAgICAgICAgICAgICAgIDx0YWJsZSBbY2xhc3NdPVxcXCJ0YWJsZVN0eWxlQ2xhc3NcXFwiIFtuZ1N0eWxlXT1cXFwidGFibGVTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQgY2xhc3M9XFxcInVpLWRhdGF0YWJsZS10aGVhZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyICpuZ0lmPVxcXCIhaGVhZGVyQ29sdW1uR3JvdXBcXFwiIGNsYXNzPVxcXCJ1aS1zdGF0ZS1kZWZhdWx0XFxcIiBbcENvbHVtbkhlYWRlcnNdPVxcXCJjb2x1bW5zXFxcIj48L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XFxcImhlYWRlckNvbHVtbkdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyICpuZ0Zvcj1cXFwibGV0IGhlYWRlclJvdyBvZiBoZWFkZXJDb2x1bW5Hcm91cC5yb3dzXFxcIiBjbGFzcz1cXFwidWktc3RhdGUtZGVmYXVsdFxcXCIgW3BDb2x1bW5IZWFkZXJzXT1cXFwiaGVhZGVyUm93LmNvbHVtbnNcXFwiPjwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGZvb3QgKm5nSWY9XFxcImhhc0Zvb3RlcigpXFxcIiBjbGFzcz1cXFwidWktZGF0YXRhYmxlLXRmb290XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgKm5nSWY9XFxcIiFmb290ZXJDb2x1bW5Hcm91cFxcXCIgY2xhc3M9XFxcInVpLXN0YXRlLWRlZmF1bHRcXFwiIFtwQ29sdW1uRm9vdGVyc109XFxcImNvbHVtbnNcXFwiPjwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cXFwiZm9vdGVyQ29sdW1uR3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgZm9vdGVyUm93IG9mIGZvb3RlckNvbHVtbkdyb3VwLnJvd3NcXFwiIGNsYXNzPVxcXCJ1aS1zdGF0ZS1kZWZhdWx0XFxcIiBbcENvbHVtbkZvb3RlcnNdPVxcXCJmb290ZXJSb3cuY29sdW1uc1xcXCI+PC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICAgICAgPC90Zm9vdD5cXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keSBbbmdDbGFzc109XFxcInsndWktZGF0YXRhYmxlLWRhdGEgdWktd2lkZ2V0LWNvbnRlbnQnOiB0cnVlLCAndWktZGF0YXRhYmxlLWhvdmVyYWJsZS1yb3dzJzogKHJvd0hvdmVyfHxzZWxlY3Rpb25Nb2RlKX1cXFwiIFtwVGFibGVCb2R5XT1cXFwiY29sdW1uc1xcXCI+PC90Ym9keT5cXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVxcXCJzY3JvbGxhYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZGF0YXRhYmxlLXNjcm9sbGFibGUtd3JhcHBlciB1aS1oZWxwZXItY2xlYXJmaXhcXFwiIFtuZ0NsYXNzXT1cXFwieydtYXgtaGVpZ2h0JzpzY3JvbGxIZWlnaHR9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcImZyb3plbkNvbHVtbnNcXFwiIFtwU2Nyb2xsYWJsZVZpZXddPVxcXCJmcm96ZW5Db2x1bW5zXFxcIiBmcm96ZW49XFxcInRydWVcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cXFwieyd3aWR0aCc6dGhpcy5mcm96ZW5XaWR0aH1cXFwiIGNsYXNzPVxcXCJ1aS1kYXRhdGFibGUtc2Nyb2xsYWJsZS12aWV3IHVpLWRhdGF0YWJsZS1mcm96ZW4tdmlld1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IFtwU2Nyb2xsYWJsZVZpZXddPVxcXCJzY3JvbGxhYmxlQ29sdW1uc1xcXCIgW25nU3R5bGVdPVxcXCJ7J3dpZHRoJzp0aGlzLnVuZnJvemVuV2lkdGgsICdsZWZ0JzogdGhpcy5mcm96ZW5XaWR0aH1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInVpLWRhdGF0YWJsZS1zY3JvbGxhYmxlLXZpZXdcXFwiIFt2aXJ0dWFsU2Nyb2xsXT1cXFwidmlydHVhbFNjcm9sbFxcXCIgKG9uVmlydHVhbFNjcm9sbCk9XFxcIm9uVmlydHVhbFNjcm9sbCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1kYXRhdGFibGUtdW5mcm96ZW4tdmlldyc6IGZyb3plbkNvbHVtbnN9XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICA8cC1wYWdpbmF0b3IgW3Jvd3NdPVxcXCJyb3dzXFxcIiBbZmlyc3RdPVxcXCJmaXJzdFxcXCIgW3RvdGFsUmVjb3Jkc109XFxcInRvdGFsUmVjb3Jkc1xcXCIgW3BhZ2VMaW5rU2l6ZV09XFxcInBhZ2VMaW5rc1xcXCIgc3R5bGVDbGFzcz1cXFwidWktcGFnaW5hdG9yLWJvdHRvbVxcXCIgW2Fsd2F5c1Nob3ddPVxcXCJhbHdheXNTaG93UGFnaW5hdG9yXFxcIlxcbiAgICAgICAgICAgICAgICAob25QYWdlQ2hhbmdlKT1cXFwib25QYWdlQ2hhbmdlKCRldmVudClcXFwiIFtyb3dzUGVyUGFnZU9wdGlvbnNdPVxcXCJyb3dzUGVyUGFnZU9wdGlvbnNcXFwiICpuZ0lmPVxcXCJwYWdpbmF0b3IgJiYgcGFnaW5hdG9yUG9zaXRpb24gPT0nYm90dG9tJyB8fCBwYWdpbmF0b3JQb3NpdGlvbiA9PSdib3RoJ1xcXCI+PC9wLXBhZ2luYXRvcj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kYXRhdGFibGUtZm9vdGVyIHVpLXdpZGdldC1oZWFkZXJcXFwiICpuZ0lmPVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcInAtZm9vdGVyXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY29sdW1uLXJlc2l6ZXItaGVscGVyIHVpLXN0YXRlLWhpZ2hsaWdodFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWFycm93LWRvd24gdWktZGF0YXRhYmxlLXJlb3JkZXItaW5kaWNhdG9yLXVwXFxcIiBzdHlsZT1cXFwicG9zaXRpb246IGFic29sdXRlOyBkaXNwbGF5OiBub25lO1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1hcnJvdy11cCB1aS1kYXRhdGFibGUtcmVvcmRlci1pbmRpY2F0b3ItZG93blxcXCIgc3R5bGU9XFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgZGlzcGxheTogbm9uZTtcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIG9iamVjdHV0aWxzXzEuT2JqZWN0VXRpbHNdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIGNvcmVfMS5JdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIGNvcmVfMS5SZW5kZXJlcjIsIGNvcmVfMS5DaGFuZ2VEZXRlY3RvclJlZiwgb2JqZWN0dXRpbHNfMS5PYmplY3RVdGlscyxcbiAgICAgICAgY29yZV8xLk5nWm9uZV0pXG5dLCBEYXRhVGFibGUpO1xuZXhwb3J0cy5EYXRhVGFibGUgPSBEYXRhVGFibGU7XG52YXIgRGF0YVRhYmxlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhVGFibGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBEYXRhVGFibGVNb2R1bGU7XG59KCkpO1xuRGF0YVRhYmxlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgc2hhcmVkXzEuU2hhcmVkTW9kdWxlLCBwYWdpbmF0b3JfMS5QYWdpbmF0b3JNb2R1bGUsIGZvcm1zXzEuRm9ybXNNb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbRGF0YVRhYmxlLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtEYXRhVGFibGUsIERUUmFkaW9CdXR0b24sIERUQ2hlY2tib3gsIENvbHVtbkhlYWRlcnMsIENvbHVtbkZvb3RlcnMsIFRhYmxlQm9keSwgU2Nyb2xsYWJsZVZpZXcsIFJvd0V4cGFuc2lvbkxvYWRlcl1cbiAgICB9KVxuXSwgRGF0YVRhYmxlTW9kdWxlKTtcbmV4cG9ydHMuRGF0YVRhYmxlTW9kdWxlID0gRGF0YVRhYmxlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YXRhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvZGF0YXRhYmxlL2RhdGF0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2RhdGF0YWJsZS9kYXRhdGFibGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgRGVmZXJyZWRMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmVycmVkTG9hZGVyKGVsLCBkb21IYW5kbGVyLCByZW5kZXJlciwgdmlld0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5vbkxvYWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBEZWZlcnJlZExvYWRlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRMb2FkKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTY3JvbGxMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCd3aW5kb3cnLCAnc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNob3VsZExvYWQoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvYWQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb2N1bWVudFNjcm9sbExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9jdW1lbnRTY3JvbGxMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGVmZXJyZWRMb2FkZXIucHJvdG90eXBlLnNob3VsZExvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9ICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgICAgIHZhciB3aW5IZWlnaHQgPSBkb2NFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgcmV0dXJuICh3aW5IZWlnaHQgPj0gcmVjdC50b3ApO1xuICAgIH07XG4gICAgRGVmZXJyZWRMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSk7XG4gICAgICAgIHRoaXMub25Mb2FkLmVtaXQoKTtcbiAgICB9O1xuICAgIERlZmVycmVkTG9hZGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRTY3JvbGxMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFNjcm9sbExpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWZlcnJlZExvYWRlcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEZWZlcnJlZExvYWRlci5wcm90b3R5cGUsIFwib25Mb2FkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkKGNvcmVfMS5UZW1wbGF0ZVJlZiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5UZW1wbGF0ZVJlZilcbl0sIERlZmVycmVkTG9hZGVyLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuRGVmZXJyZWRMb2FkZXIgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbcERlZmVyXScsXG4gICAgICAgIGhvc3Q6IHt9LFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMiwgY29yZV8xLlZpZXdDb250YWluZXJSZWZdKVxuXSwgRGVmZXJyZWRMb2FkZXIpO1xuZXhwb3J0cy5EZWZlcnJlZExvYWRlciA9IERlZmVycmVkTG9hZGVyO1xudmFyIERlZmVyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIERlZmVyTW9kdWxlO1xufSgpKTtcbkRlZmVyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtEZWZlcnJlZExvYWRlcl0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW0RlZmVycmVkTG9hZGVyXVxuICAgIH0pXG5dLCBEZWZlck1vZHVsZSk7XG5leHBvcnRzLkRlZmVyTW9kdWxlID0gRGVmZXJNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2RlZmVyL2RlZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvZGVmZXIvZGVmZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGFuaW1hdGlvbnNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9hbmltYXRpb25zXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBEaWFsb2cgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpYWxvZyhlbCwgZG9tSGFuZGxlciwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNpemFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1pbldpZHRoID0gMTUwO1xuICAgICAgICB0aGlzLm1pbkhlaWdodCA9IDE1MDtcbiAgICAgICAgdGhpcy5jbG9zZU9uRXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbG9zYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd0hlYWRlciA9IHRydWU7XG4gICAgICAgIHRoaXMuYnJlYWtwb2ludCA9IDY0MDtcbiAgICAgICAgdGhpcy5ibG9ja1Njcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uU2hvdyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25IaWRlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy52aXNpYmxlQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuY29udGFpbmVyVmlld0NoaWxkICYmIHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRWaXNpYmxlQ2hhbmdlUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZlbnRWaXNpYmxlQ2hhbmdlUHJvcGFnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEaWFsb2cucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhlY3V0ZVBvc3REaXNwbGF5QWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vblNob3cuZW1pdCh7fSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uT3ZlcmxheSgpO1xuICAgICAgICAgICAgdGhpcy5leGVjdXRlUG9zdERpc3BsYXlBY3Rpb25zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpYWxvZy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlUG9zdERpc3BsYXlBY3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS56SW5kZXggPSBTdHJpbmcoKytkb21oYW5kbGVyXzEuRG9tSGFuZGxlci56aW5kZXgpO1xuICAgICAgICB0aGlzLmJpbmRHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHRoaXMubW9kYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlTW9kYWxpdHkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS5wb3NpdGlvbk92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuZG9tSGFuZGxlci5nZXRWaWV3cG9ydCgpO1xuICAgICAgICBpZiAodGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpID4gdmlld3BvcnQuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAodmlld3BvcnQuaGVpZ2h0ICogLjc1KSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25MZWZ0ID49IDAgJiYgdGhpcy5wb3NpdGlvblRvcCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uTGVmdCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IHRoaXMucG9zaXRpb25Ub3AgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucG9zaXRpb25Ub3AgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gdGhpcy5wb3NpdGlvblRvcCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25IaWRlLmVtaXQoe30pO1xuICAgICAgICB0aGlzLnVuYmluZE1hc2tDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMudW5iaW5kR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVNb2RhbGl0eSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucHJldmVudFZpc2libGVDaGFuZ2VQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUbyA9PT0gJ2JvZHknKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQsIHRoaXMuYXBwZW5kVG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlcldpZHRoKHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB2YXIgZWxlbWVudEhlaWdodCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlckhlaWdodCh0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnRXaWR0aCA9PSAwICYmIGVsZW1lbnRIZWlnaHQgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgZWxlbWVudFdpZHRoID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVyV2lkdGgodGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50SGVpZ2h0ID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuZG9tSGFuZGxlci5nZXRWaWV3cG9ydCgpO1xuICAgICAgICB2YXIgeCA9IE1hdGgubWF4KCh2aWV3cG9ydC53aWR0aCAtIGVsZW1lbnRXaWR0aCkgLyAyLCAwKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLm1heCgodmlld3BvcnQuaGVpZ2h0IC0gZWxlbWVudEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLmVuYWJsZU1vZGFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMubWFzaykge1xuICAgICAgICAgICAgdGhpcy5tYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLm1hc2suc3R5bGUuekluZGV4ID0gU3RyaW5nKHBhcnNlSW50KHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUuekluZGV4KSAtIDEpO1xuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFkZE11bHRpcGxlQ2xhc3Nlcyh0aGlzLm1hc2ssICd1aS13aWRnZXQtb3ZlcmxheSB1aS1kaWFsb2ctbWFzaycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2FibGUgJiYgdGhpcy5kaXNtaXNzYWJsZU1hc2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hc2tDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5tYXNrLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm1hc2spO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3VpLW92ZXJmbG93LWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLmRpc2FibGVNb2RhbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm1hc2spO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3VpLW92ZXJmbG93LWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS51bmJpbmRNYXNrQ2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFza0NsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWFza0NsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMubWFza0NsaWNrTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLm1vdmVPblRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS56SW5kZXggPSBTdHJpbmcoKytkb21oYW5kbGVyXzEuRG9tSGFuZGxlci56aW5kZXgpO1xuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS5vbkNsb3NlTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuY2xvc2VJY29uTW91c2VEb3duID0gdHJ1ZTtcbiAgICB9O1xuICAgIERpYWxvZy5wcm90b3R5cGUuaW5pdERyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VJY29uTW91c2VEb3duKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlSWNvbk1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmxhc3RQYWdlWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5sYXN0UGFnZVkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS5vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBldmVudC5wYWdlWCAtIHRoaXMubGFzdFBhZ2VYO1xuICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGV2ZW50LnBhZ2VZIC0gdGhpcy5sYXN0UGFnZVk7XG4gICAgICAgICAgICB2YXIgbGVmdFBvcyA9IHBhcnNlSW50KHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCk7XG4gICAgICAgICAgICB2YXIgdG9wUG9zID0gcGFyc2VJbnQodGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS50b3ApO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdFBvcyArIGRlbHRhWCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IHRvcFBvcyArIGRlbHRhWSArICdweCc7XG4gICAgICAgICAgICB0aGlzLmxhc3RQYWdlWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5sYXN0UGFnZVkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS5lbmREcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLmluaXRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXphYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnByZVdpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sYXN0UGFnZVggPSBldmVudC5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMubGFzdFBhZ2VZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpYWxvZy5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXppbmcpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBldmVudC5wYWdlWCAtIHRoaXMubGFzdFBhZ2VYO1xuICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGV2ZW50LnBhZ2VZIC0gdGhpcy5sYXN0UGFnZVk7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aCh0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJIZWlnaHQodGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgY29udGVudEhlaWdodCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlckhlaWdodCh0aGlzLmNvbnRlbnRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBjb250YWluZXJXaWR0aCArIGRlbHRhWDtcbiAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBjb250YWluZXJIZWlnaHQgKyBkZWx0YVk7XG4gICAgICAgICAgICBpZiAobmV3V2lkdGggPiB0aGlzLm1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgPiB0aGlzLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBjb250ZW50SGVpZ2h0ICsgZGVsdGFZICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFBhZ2VYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICB0aGlzLmxhc3RQYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLmJpbmRHbG9iYWxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnREcmFnTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZERvY3VtZW50UmVzaXplTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2l2ZSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnRSZXNwb25zaXZlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZU9uRXNjYXBlICYmIHRoaXMuY2xvc2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZERvY3VtZW50RXNjYXBlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS51bmJpbmRHbG9iYWxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnREcmFnTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy51bmJpbmREb2N1bWVudFJlc2l6ZUxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnVuYmluZERvY3VtZW50UmVzcG9uc2l2ZUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnRFc2NhcGVMaXN0ZW5lcigpO1xuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS5iaW5kRG9jdW1lbnREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZG9jdW1lbnREcmFnTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5vbkRyYWcoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERpYWxvZy5wcm90b3R5cGUudW5iaW5kRG9jdW1lbnREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50RHJhZ0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50RHJhZ0xpc3RlbmVyKCk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50RHJhZ0xpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS5iaW5kRG9jdW1lbnRSZXNpemVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRSZXNpemVMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLm9uUmVzaXplKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRSZXNpemVFbmRMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdtb3VzZXVwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmVzaXppbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERpYWxvZy5wcm90b3R5cGUudW5iaW5kRG9jdW1lbnRSZXNpemVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50UmVzaXplTGlzdGVuZXIgJiYgdGhpcy5kb2N1bWVudFJlc2l6ZUVuZExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50UmVzaXplTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZXNpemVFbmRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFJlc2l6ZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZXNpemVFbmRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpYWxvZy5wcm90b3R5cGUuYmluZERvY3VtZW50UmVzcG9uc2l2ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRvY3VtZW50UmVzcG9uc2l2ZUxpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ3dpbmRvdycsICdyZXNpemUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydCA9IF90aGlzLmRvbUhhbmRsZXIuZ2V0Vmlld3BvcnQoKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IF90aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aChfdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAodmlld3BvcnQud2lkdGggPD0gX3RoaXMuYnJlYWtwb2ludCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSBfdGhpcy5wcmVXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgX3RoaXMucG9zaXRpb25PdmVybGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS51bmJpbmREb2N1bWVudFJlc3BvbnNpdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRSZXNwb25zaXZlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZXNwb25zaXZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZXNwb25zaXZlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsb2cucHJvdG90eXBlLmJpbmREb2N1bWVudEVzY2FwZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRvY3VtZW50RXNjYXBlTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09IDI3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KF90aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnN0eWxlLnpJbmRleCkgPT0gZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGlhbG9nLnByb3RvdHlwZS51bmJpbmREb2N1bWVudEVzY2FwZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudEVzY2FwZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50RXNjYXBlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRFc2NhcGVMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpYWxvZy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlTW9kYWxpdHkoKTtcbiAgICAgICAgdGhpcy51bmJpbmRHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZE1hc2tDbGlja0xpc3RlbmVyKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbG9nO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcImRyYWdnYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcInJlc2l6YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwibWluV2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcIm1pbkhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwicG9zaXRpb25MZWZ0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJwb3NpdGlvblRvcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwiY29udGVudFN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwibW9kYWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJjbG9zZU9uRXNjYXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwiZGlzbWlzc2FibGVNYXNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwicnRsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwiY2xvc2FibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJyZXNwb25zaXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJhcHBlbmRUb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJzaG93SGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJicmVha3BvaW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwiYmxvY2tTY3JvbGxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGQoc2hhcmVkXzEuSGVhZGVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJoZWFkZXJGYWNldFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMS5Gb290ZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcImZvb3RlckZhY2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdjb250YWluZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcImNvbnRhaW5lclZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgndGl0bGViYXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcImhlYWRlclZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnY29udGVudCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwiY29udGVudFZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJvblNob3dcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERpYWxvZy5wcm90b3R5cGUsIFwib25IaWRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEaWFsb2cucHJvdG90eXBlLCBcInZpc2libGVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgRGlhbG9nLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIG51bGwpO1xuRGlhbG9nID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1kaWFsb2cnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgI2NvbnRhaW5lciBbbmdDbGFzc109XFxcInsndWktZGlhbG9nIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLXNoYWRvdyc6dHJ1ZSwndWktZGlhbG9nLXJ0bCc6cnRsLCd1aS1kaWFsb2ctZHJhZ2dhYmxlJzpkcmFnZ2FibGV9XFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIlxcbiAgICAgICAgICAgIFtzdHlsZS5kaXNwbGF5XT1cXFwidmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSdcXFwiIFtzdHlsZS53aWR0aC5weF09XFxcIndpZHRoXFxcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cXFwiaGVpZ2h0XFxcIiBbc3R5bGUubWluV2lkdGgucHhdPVxcXCJtaW5XaWR0aFxcXCIgKG1vdXNlZG93bik9XFxcIm1vdmVPblRvcCgpXFxcIiBbQGRpYWxvZ1N0YXRlXT1cXFwidmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXFxcIj5cXG4gICAgICAgICAgICA8ZGl2ICN0aXRsZWJhciBjbGFzcz1cXFwidWktZGlhbG9nLXRpdGxlYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci10b3BcXFwiXFxuICAgICAgICAgICAgICAgIChtb3VzZWRvd24pPVxcXCJpbml0RHJhZygkZXZlbnQpXFxcIiAobW91c2V1cCk9XFxcImVuZERyYWcoJGV2ZW50KVxcXCIgKm5nSWY9XFxcInNob3dIZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktZGlhbG9nLXRpdGxlXFxcIiAqbmdJZj1cXFwiaGVhZGVyXFxcIj57e2hlYWRlcn19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktZGlhbG9nLXRpdGxlXFxcIiAqbmdJZj1cXFwiaGVhZGVyRmFjZXRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJwLWhlYWRlclxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCJjbG9zYWJsZVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLWRpYWxvZy10aXRsZWJhci1pY29uIHVpLWRpYWxvZy10aXRsZWJhci1jbG9zZSB1aS1jb3JuZXItYWxsJzp0cnVlfVxcXCIgaHJlZj1cXFwiI1xcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIiAoY2xpY2spPVxcXCJjbG9zZSgkZXZlbnQpXFxcIiAobW91c2Vkb3duKT1cXFwib25DbG9zZU1vdXNlRG93bigkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1jbG9zZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiAjY29udGVudCBjbGFzcz1cXFwidWktZGlhbG9nLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcXFwiIFtuZ1N0eWxlXT1cXFwiY29udGVudFN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWRpYWxvZy1mb290ZXIgdWktd2lkZ2V0LWNvbnRlbnRcXFwiICpuZ0lmPVxcXCJmb290ZXJGYWNldFxcXCI+XFxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwicC1mb290ZXJcXFwiPjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCJyZXNpemFibGVcXFwiIGNsYXNzPVxcXCJ1aS1yZXNpemFibGUtaGFuZGxlIHVpLXJlc2l6YWJsZS1zZSB1aS1pY29uIHVpLWljb24tZ3JpcHNtYWxsLWRpYWdvbmFsLXNlXFxcIiBzdHlsZT1cXFwiei1pbmRleDogOTA7XFxcIlxcbiAgICAgICAgICAgICAgICAobW91c2Vkb3duKT1cXFwiaW5pdFJlc2l6ZSgkZXZlbnQpXFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyaWdnZXIoJ2RpYWxvZ1N0YXRlJywgW1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5zdGF0ZSgnaGlkZGVuJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuc3RhdGUoJ3Zpc2libGUnLCBhbmltYXRpb25zXzEuc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS50cmFuc2l0aW9uKCd2aXNpYmxlID0+IGhpZGRlbicsIGFuaW1hdGlvbnNfMS5hbmltYXRlKCc0MDBtcyBlYXNlLWluJykpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS50cmFuc2l0aW9uKCdoaWRkZW4gPT4gdmlzaWJsZScsIGFuaW1hdGlvbnNfMS5hbmltYXRlKCc0MDBtcyBlYXNlLW91dCcpKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIGNvcmVfMS5SZW5kZXJlcjJdKVxuXSwgRGlhbG9nKTtcbmV4cG9ydHMuRGlhbG9nID0gRGlhbG9nO1xudmFyIERpYWxvZ01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlhbG9nTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gRGlhbG9nTW9kdWxlO1xufSgpKTtcbkRpYWxvZ01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbRGlhbG9nLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtEaWFsb2ddXG4gICAgfSlcbl0sIERpYWxvZ01vZHVsZSk7XG5leHBvcnRzLkRpYWxvZ01vZHVsZSA9IERpYWxvZ01vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpYWxvZy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2RpYWxvZy9kaWFsb2cuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9kaWFsb2cvZGlhbG9nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIERvbUhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvbUhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlZFNjcm9sbGJhcldpZHRoID0gbnVsbDtcbiAgICB9XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdClcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5hZGRNdWx0aXBsZUNsYXNzZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoc3R5bGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBjbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gJyAnICsgc3R5bGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KVxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxcYiknICsgY2xhc3NOYW1lLnNwbGl0KCcgJykuam9pbignfCcpICsgJyhcXFxcYnwkKScsICdnaScpLCAnICcpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdClcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKF58ICknICsgY2xhc3NOYW1lICsgJyggfCQpJywgJ2dpJykudGVzdChlbGVtZW50LmNsYXNzTmFtZSk7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5zaWJsaW5ncyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWxlbWVudC5wYXJlbnROb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCAhPT0gZWxlbWVudDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuZmluZFNpbmdsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0gPT0gZWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUucmVsYXRpdmVQb3NpdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnREaW1lbnNpb25zID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgPyB7IHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLCBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IH0gOiB0aGlzLmdldEhpZGRlbkVsZW1lbnREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgICAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgdmFyIHRhcmdldFdpZHRoID0gdGFyZ2V0Lm9mZnNldFdpZHRoO1xuICAgICAgICB2YXIgdGFyZ2V0T2Zmc2V0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgd2luZG93U2Nyb2xsVG9wID0gdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgpO1xuICAgICAgICB2YXIgdG9wLCBsZWZ0O1xuICAgICAgICBpZiAoKHRhcmdldE9mZnNldC50b3AgKyB0YXJnZXRIZWlnaHQgKyBlbGVtZW50RGltZW5zaW9ucy5oZWlnaHQpID4gdmlld3BvcnQuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0b3AgPSAtMSAqIChlbGVtZW50RGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldE9mZnNldC50b3AgKyB0b3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRhcmdldE9mZnNldC5sZWZ0ICsgZWxlbWVudERpbWVuc2lvbnMud2lkdGgpID4gdmlld3BvcnQud2lkdGgpXG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0V2lkdGggLSBlbGVtZW50RGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5hYnNvbHV0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRhcmdldCkge1xuICAgICAgICB2YXIgZWxlbWVudERpbWVuc2lvbnMgPSBlbGVtZW50Lm9mZnNldFBhcmVudCA/IHsgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgfSA6IHRoaXMuZ2V0SGlkZGVuRWxlbWVudERpbWVuc2lvbnMoZWxlbWVudCk7XG4gICAgICAgIHZhciBlbGVtZW50T3V0ZXJIZWlnaHQgPSBlbGVtZW50RGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIHZhciBlbGVtZW50T3V0ZXJXaWR0aCA9IGVsZW1lbnREaW1lbnNpb25zLndpZHRoO1xuICAgICAgICB2YXIgdGFyZ2V0T3V0ZXJIZWlnaHQgPSB0YXJnZXQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB2YXIgdGFyZ2V0T3V0ZXJXaWR0aCA9IHRhcmdldC5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIHRhcmdldE9mZnNldCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHdpbmRvd1Njcm9sbFRvcCA9IHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIHZhciB3aW5kb3dTY3JvbGxMZWZ0ID0gdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoKTtcbiAgICAgICAgdmFyIHRvcCwgbGVmdDtcbiAgICAgICAgaWYgKHRhcmdldE9mZnNldC50b3AgKyB0YXJnZXRPdXRlckhlaWdodCArIGVsZW1lbnRPdXRlckhlaWdodCA+IHZpZXdwb3J0LmhlaWdodCkge1xuICAgICAgICAgICAgdG9wID0gdGFyZ2V0T2Zmc2V0LnRvcCArIHdpbmRvd1Njcm9sbFRvcCAtIGVsZW1lbnRPdXRlckhlaWdodDtcbiAgICAgICAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gMCArIHdpbmRvd1Njcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldE91dGVySGVpZ2h0ICsgdGFyZ2V0T2Zmc2V0LnRvcCArIHdpbmRvd1Njcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0T2Zmc2V0LmxlZnQgKyB0YXJnZXRPdXRlcldpZHRoICsgZWxlbWVudE91dGVyV2lkdGggPiB2aWV3cG9ydC53aWR0aClcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRPZmZzZXQubGVmdCArIHdpbmRvd1Njcm9sbExlZnQgKyB0YXJnZXRPdXRlcldpZHRoIC0gZWxlbWVudE91dGVyV2lkdGg7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRPZmZzZXQubGVmdCArIHdpbmRvd1Njcm9sbExlZnQ7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5nZXRIaWRkZW5FbGVtZW50T3V0ZXJIZWlnaHQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdmFyIGVsZW1lbnRIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIHJldHVybiBlbGVtZW50SGVpZ2h0O1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuZ2V0SGlkZGVuRWxlbWVudE91dGVyV2lkdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICByZXR1cm4gZWxlbWVudFdpZHRoO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuZ2V0SGlkZGVuRWxlbWVudERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHt9O1xuICAgICAgICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgZGltZW5zaW9ucy53aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLnNjcm9sbEluVmlldyA9IGZ1bmN0aW9uIChjb250YWluZXIsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGJvcmRlclRvcFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlclRvcFdpZHRoJyk7XG4gICAgICAgIHZhciBib3JkZXJUb3AgPSBib3JkZXJUb3BWYWx1ZSA/IHBhcnNlRmxvYXQoYm9yZGVyVG9wVmFsdWUpIDogMDtcbiAgICAgICAgdmFyIHBhZGRpbmdUb3BWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nVG9wJyk7XG4gICAgICAgIHZhciBwYWRkaW5nVG9wID0gcGFkZGluZ1RvcFZhbHVlID8gcGFyc2VGbG9hdChwYWRkaW5nVG9wVmFsdWUpIDogMDtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBpdGVtUmVjdCA9IGl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSAoaXRlbVJlY3QudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIC0gKGNvbnRhaW5lclJlY3QudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIC0gYm9yZGVyVG9wIC0gcGFkZGluZ1RvcDtcbiAgICAgICAgdmFyIHNjcm9sbCA9IGNvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSB0aGlzLmdldE91dGVySGVpZ2h0KGl0ZW0pO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IHNjcm9sbCArIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgob2Zmc2V0ICsgaXRlbUhlaWdodCkgPiBlbGVtZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gc2Nyb2xsICsgb2Zmc2V0IC0gZWxlbWVudEhlaWdodCArIGl0ZW1IZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmZhZGVJbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBkdXJhdGlvbikge1xuICAgICAgICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB2YXIgbGFzdCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IDA7XG4gICAgICAgIHZhciB0aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3BhY2l0eSA9ICtlbGVtZW50LnN0eWxlLm9wYWNpdHkgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsYXN0KSAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgIGxhc3QgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmICgrb3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgICAgICAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljaykpIHx8IHNldFRpbWVvdXQodGljaywgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aWNrKCk7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5mYWRlT3V0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG1zKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gMSwgaW50ZXJ2YWwgPSA1MCwgZHVyYXRpb24gPSBtcywgZ2FwID0gaW50ZXJ2YWwgLyBkdXJhdGlvbjtcbiAgICAgICAgdmFyIGZhZGluZyA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5IC0gZ2FwO1xuICAgICAgICAgICAgaWYgKG9wYWNpdHkgPD0gMCkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZmFkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIH0sIGludGVydmFsKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmdldFdpbmRvd1Njcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jLnNjcm9sbFRvcCkgLSAoZG9jLmNsaWVudFRvcCB8fCAwKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmdldFdpbmRvd1Njcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiAod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvYy5zY3JvbGxMZWZ0KSAtIChkb2MuY2xpZW50TGVmdCB8fCAwKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHAgPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgICAgdmFyIGYgPSBwWydtYXRjaGVzJ10gfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgcFsnbW96TWF0Y2hlc1NlbGVjdG9yJ10gfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIFtdLmluZGV4T2YuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHMpLCB0aGlzKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuZ2V0T3V0ZXJXaWR0aCA9IGZ1bmN0aW9uIChlbCwgbWFyZ2luKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgICAgICBpZiAobWFyZ2luKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgICAgIHdpZHRoICs9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5nZXRIb3Jpem9udGFsUGFkZGluZyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuZ2V0SG9yaXpvbnRhbE1hcmdpbiA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmlubmVyV2lkdGggPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICB3aWR0aCArPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICB3aWR0aCAtPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuZ2V0SW5uZXJIZWlnaHQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGhlaWdodCArPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApICsgcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmdldE91dGVySGVpZ2h0ID0gZnVuY3Rpb24gKGVsLCBtYXJnaW4pIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKG1hcmdpbikge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGhlaWdodCAtPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApICsgcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKSArIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpICsgcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgd2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIHdpZHRoIC09IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nUmlnaHQpICsgcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgpICsgcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJSaWdodFdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aW4gPSB3aW5kb3csIGQgPSBkb2N1bWVudCwgZSA9IGQuZG9jdW1lbnRFbGVtZW50LCBnID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdLCB3ID0gd2luLmlubmVyV2lkdGggfHwgZS5jbGllbnRXaWR0aCB8fCBnLmNsaWVudFdpZHRoLCBoID0gd2luLmlubmVySGVpZ2h0IHx8IGUuY2xpZW50SGVpZ2h0IHx8IGcuY2xpZW50SGVpZ2h0O1xuICAgICAgICByZXR1cm4geyB3aWR0aDogdywgaGVpZ2h0OiBoIH07XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5nZXRPZmZzZXQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuZ2V0VXNlckFnZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmlzSUUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICB2YXIgbXNpZSA9IHVhLmluZGV4T2YoJ01TSUUgJyk7XG4gICAgICAgIGlmIChtc2llID4gMCkge1xuICAgICAgICAgICAgLy8gSUUgMTAgb3Igb2xkZXIgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJpZGVudCA9IHVhLmluZGV4T2YoJ1RyaWRlbnQvJyk7XG4gICAgICAgIGlmICh0cmlkZW50ID4gMCkge1xuICAgICAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgICAgICB2YXIgcnYgPSB1YS5pbmRleE9mKCdydjonKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlZGdlID0gdWEuaW5kZXhPZignRWRnZS8nKTtcbiAgICAgICAgaWYgKGVkZ2UgPiAwKSB7XG4gICAgICAgICAgICAvLyBFZGdlIChJRSAxMispID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXIgYnJvd3NlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChlbGVtZW50LCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbGVtZW50KHRhcmdldCkpXG4gICAgICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldC5lbCAmJiB0YXJnZXQuZWwubmF0aXZlRWxlbWVudClcbiAgICAgICAgICAgIHRhcmdldC5lbC5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGFwcGVuZCAnICsgdGFyZ2V0ICsgJyB0byAnICsgZWxlbWVudDtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5pc0VsZW1lbnQodGFyZ2V0KSlcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0LmVsICYmIHRhcmdldC5lbC5uYXRpdmVFbGVtZW50KVxuICAgICAgICAgICAgdGFyZ2V0LmVsLm5hdGl2ZUVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93ICdDYW5ub3QgcmVtb3ZlICcgKyBlbGVtZW50ICsgJyBmcm9tICcgKyB0YXJnZXQ7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5pc0VsZW1lbnQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOlxuICAgICAgICAgICAgb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsICYmIG9iai5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygb2JqLm5vZGVOYW1lID09PSBcInN0cmluZ1wiKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmNhbGN1bGF0ZVNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jYWxjdWxhdGVkU2Nyb2xsYmFyV2lkdGggIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVkU2Nyb2xsYmFyV2lkdGg7XG4gICAgICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gXCJ1aS1zY3JvbGxiYXItbWVhc3VyZVwiO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZWRTY3JvbGxiYXJXaWR0aCA9IHNjcm9sbGJhcldpZHRoO1xuICAgICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5pbnZva2VFbGVtZW50TWV0aG9kID0gZnVuY3Rpb24gKGVsZW1lbnQsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgZWxlbWVudFttZXRob2ROYW1lXS5hcHBseShlbGVtZW50LCBhcmdzKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5lbXB0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcyAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmFuZ2VDb3VudCA+IDAgJiYgd2luZG93LmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50WydzZWxlY3Rpb24nXSAmJiBkb2N1bWVudFsnc2VsZWN0aW9uJ10uZW1wdHkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRbJ3NlbGVjdGlvbiddLmVtcHR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvL2lnbm9yZSBJRSBidWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERvbUhhbmRsZXI7XG59KCkpO1xuRG9tSGFuZGxlci56aW5kZXggPSAxMDAwO1xuRG9tSGFuZGxlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbmplY3RhYmxlKClcbl0sIERvbUhhbmRsZXIpO1xuZXhwb3J0cy5Eb21IYW5kbGVyID0gRG9tSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbWhhbmRsZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9kb20vZG9taGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2RvbS9kb21oYW5kbGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIERyYWdnYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJhZ2dhYmxlKGVsLCBkb21IYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5vbkRyYWdTdGFydCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25EcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkRyYWcgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBEcmFnZ2FibGUucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5hbGxvd0RyYWcoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ0VmZmVjdCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gdGhpcy5kcmFnRWZmZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCB0aGlzLnNjb3BlKTtcbiAgICAgICAgICAgIHRoaXMub25EcmFnU3RhcnQuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcmFnZ2FibGUucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vbkRyYWcuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICBEcmFnZ2FibGUucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vbkRyYWdFbmQuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICBEcmFnZ2FibGUucHJvdG90eXBlLm1vdXNlb3ZlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmhhbmRsZSA9IGV2ZW50LnRhcmdldDtcbiAgICB9O1xuICAgIERyYWdnYWJsZS5wcm90b3R5cGUubW91c2VsZWF2ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmhhbmRsZSA9IG51bGw7XG4gICAgfTtcbiAgICBEcmFnZ2FibGUucHJvdG90eXBlLmFsbG93RHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0hhbmRsZSAmJiB0aGlzLmhhbmRsZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbUhhbmRsZXIubWF0Y2hlcyh0aGlzLmhhbmRsZSwgdGhpcy5kcmFnSGFuZGxlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gRHJhZ2dhYmxlO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgncERyYWdnYWJsZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcmFnZ2FibGUucHJvdG90eXBlLCBcInNjb3BlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRHJhZ2dhYmxlLnByb3RvdHlwZSwgXCJkcmFnRWZmZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRHJhZ2dhYmxlLnByb3RvdHlwZSwgXCJkcmFnSGFuZGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEcmFnZ2FibGUucHJvdG90eXBlLCBcIm9uRHJhZ1N0YXJ0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEcmFnZ2FibGUucHJvdG90eXBlLCBcIm9uRHJhZ0VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRHJhZ2dhYmxlLnByb3RvdHlwZSwgXCJvbkRyYWdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Ib3N0TGlzdGVuZXIoJ2RyYWdzdGFydCcsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgRHJhZ2dhYmxlLnByb3RvdHlwZSwgXCJkcmFnU3RhcnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdkcmFnJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBEcmFnZ2FibGUucHJvdG90eXBlLCBcImRyYWdcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdkcmFnZW5kJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBEcmFnZ2FibGUucHJvdG90eXBlLCBcImRyYWdFbmRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdtb3VzZW92ZXInLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIERyYWdnYWJsZS5wcm90b3R5cGUsIFwibW91c2VvdmVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgRHJhZ2dhYmxlLnByb3RvdHlwZSwgXCJtb3VzZWxlYXZlXCIsIG51bGwpO1xuRHJhZ2dhYmxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkRpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW3BEcmFnZ2FibGVdJyxcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ1tkcmFnZ2FibGVdJzogJ3RydWUnXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIERyYWdnYWJsZSk7XG5leHBvcnRzLkRyYWdnYWJsZSA9IERyYWdnYWJsZTtcbnZhciBEcm9wcGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERyb3BwYWJsZShlbCwgZG9tSGFuZGxlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMub25EcmFnRW50ZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRHJhZ0xlYXZlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkRyb3AgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRHJhZ092ZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBEcm9wcGFibGUucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dEcm9wKGV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMub25Ecm9wLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wcGFibGUucHJvdG90eXBlLmRyYWdFbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5kcm9wRWZmZWN0KSB7XG4gICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IHRoaXMuZHJvcEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRHJhZ0VudGVyLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgRHJvcHBhYmxlLnByb3RvdHlwZS5kcmFnTGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5vbkRyYWdMZWF2ZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIERyb3BwYWJsZS5wcm90b3R5cGUuZHJhZ092ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5vbkRyYWdPdmVyLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgRHJvcHBhYmxlLnByb3RvdHlwZS5hbGxvd0Ryb3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRyYWdTY29wZSA9IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHRoaXMuc2NvcGUpID09IFwic3RyaW5nXCIgJiYgZHJhZ1Njb3BlID09IHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NvcGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNjb3BlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdTY29wZSA9PSB0aGlzLnNjb3BlW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gRHJvcHBhYmxlO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgncERyb3BwYWJsZScpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEcm9wcGFibGUucHJvdG90eXBlLCBcInNjb3BlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRHJvcHBhYmxlLnByb3RvdHlwZSwgXCJkcm9wRWZmZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEcm9wcGFibGUucHJvdG90eXBlLCBcIm9uRHJhZ0VudGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEcm9wcGFibGUucHJvdG90eXBlLCBcIm9uRHJhZ0xlYXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEcm9wcGFibGUucHJvdG90eXBlLCBcIm9uRHJvcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRHJvcHBhYmxlLnByb3RvdHlwZSwgXCJvbkRyYWdPdmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdkcm9wJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBEcm9wcGFibGUucHJvdG90eXBlLCBcImRyb3BcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdkcmFnZW50ZXInLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIERyb3BwYWJsZS5wcm90b3R5cGUsIFwiZHJhZ0VudGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkhvc3RMaXN0ZW5lcignZHJhZ2xlYXZlJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBEcm9wcGFibGUucHJvdG90eXBlLCBcImRyYWdMZWF2ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Ib3N0TGlzdGVuZXIoJ2RyYWdvdmVyJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBEcm9wcGFibGUucHJvdG90eXBlLCBcImRyYWdPdmVyXCIsIG51bGwpO1xuRHJvcHBhYmxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkRpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW3BEcm9wcGFibGVdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdKVxuXSwgRHJvcHBhYmxlKTtcbmV4cG9ydHMuRHJvcHBhYmxlID0gRHJvcHBhYmxlO1xudmFyIERyYWdEcm9wTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcmFnRHJvcE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIERyYWdEcm9wTW9kdWxlO1xufSgpKTtcbkRyYWdEcm9wTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtEcmFnZ2FibGUsIERyb3BwYWJsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW0RyYWdnYWJsZSwgRHJvcHBhYmxlXVxuICAgIH0pXG5dLCBEcmFnRHJvcE1vZHVsZSk7XG5leHBvcnRzLkRyYWdEcm9wTW9kdWxlID0gRHJhZ0Ryb3BNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmFnZHJvcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2RyYWdkcm9wL2RyYWdkcm9wLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvZHJhZ2Ryb3AvZHJhZ2Ryb3AuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGFuaW1hdGlvbnNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9hbmltYXRpb25zXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc2hhcmVkXCIpO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbnZhciBvYmplY3R1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL29iamVjdHV0aWxzXCIpO1xudmFyIGZvcm1zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIik7XG5leHBvcnRzLkRST1BET1dOX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IGZvcm1zXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERyb3Bkb3duOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBEcm9wZG93biA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcGRvd24oZWwsIGRvbUhhbmRsZXIsIHJlbmRlcmVyLCBjZCwgb2JqZWN0VXRpbHMpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5vYmplY3RVdGlscyA9IG9iamVjdFV0aWxzO1xuICAgICAgICB0aGlzLnNjcm9sbEhlaWdodCA9ICcyMDBweCc7XG4gICAgICAgIHRoaXMuYXV0b1dpZHRoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWx0ZXJCeSA9ICdsYWJlbCc7XG4gICAgICAgIHRoaXMubGF6eSA9IHRydWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5wYW5lbFZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgc3dpdGNoIChpdGVtLmdldFR5cGUoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pdGVtVGVtcGxhdGUgPSBpdGVtLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pdGVtVGVtcGxhdGUgPSBpdGVtLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1RvRGlzcGxheSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZE9wdGlvbihudWxsKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEcm9wZG93bi5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRzO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zVG9EaXNwbGF5ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24odGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlclZhbHVlICYmIHRoaXMuZmlsdGVyVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUZpbHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucGFuZWwgPSB0aGlzLnBhbmVsVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuaXRlbXNXcmFwcGVyID0gdGhpcy5pdGVtc1dyYXBwZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWRpdGFibGVMYWJlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvID09PSAnYm9keScpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYXBwZW5kQ2hpbGQodGhpcy5wYW5lbCwgdGhpcy5hcHBlbmRUbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEcm9wZG93bi5wcm90b3R5cGUsIFwibGFiZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zZWxlY3RlZE9wdGlvbiA/IHRoaXMuc2VsZWN0ZWRPcHRpb24ubGFiZWwgOiB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLnVwZGF0ZUVkaXRhYmxlTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlSW5wdXRWaWV3Q2hpbGQgJiYgdGhpcy5lZGl0YWJsZUlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdGFibGVJbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnZhbHVlID0gKHRoaXMuc2VsZWN0ZWRPcHRpb24gPyB0aGlzLnNlbGVjdGVkT3B0aW9uLmxhYmVsIDogdGhpcy52YWx1ZSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5vbkl0ZW1DbGljayA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9uKSB7XG4gICAgICAgIHRoaXMuaXRlbUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3RJdGVtKGV2ZW50LCBvcHRpb24pO1xuICAgICAgICB0aGlzLmZvY3VzVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuc2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkT3B0aW9uICE9IG9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IG9wdGlvbjtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvcHRpb24udmFsdWU7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVkaXRhYmxlTGFiZWwoKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zaG93bikge1xuICAgICAgICAgICAgdGhpcy5vblNob3coKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zQ2hhbmdlZCAmJiB0aGlzLnBhbmVsVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hbGlnblBhbmVsKCk7IH0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkT3B0aW9uVXBkYXRlZCAmJiB0aGlzLml0ZW1zV3JhcHBlcikge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMucGFuZWwsICdsaS51aS1zdGF0ZS1oaWdobGlnaHQnKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuc2Nyb2xsSW5WaWV3KHRoaXMuaXRlbXNXcmFwcGVyLCB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLnBhbmVsLCAnbGkudWktc3RhdGUtaGlnaGxpZ2h0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvblVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0RmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkT3B0aW9uKHZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0YWJsZUxhYmVsKCk7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUucmVzZXRGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlclZpZXdDaGlsZCAmJiB0aGlzLmZpbHRlclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zVG9EaXNwbGF5ID0gdGhpcy5vcHRpb25zO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLnVwZGF0ZVNlbGVjdGVkT3B0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkT3B0aW9uID0gdGhpcy5maW5kT3B0aW9uKHZhbCwgdGhpcy5vcHRpb25zVG9EaXNwbGF5KTtcbiAgICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyICYmICF0aGlzLnNlbGVjdGVkT3B0aW9uICYmIHRoaXMub3B0aW9uc1RvRGlzcGxheSAmJiB0aGlzLm9wdGlvbnNUb0Rpc3BsYXkubGVuZ3RoICYmICF0aGlzLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkT3B0aW9uID0gdGhpcy5vcHRpb25zVG9EaXNwbGF5WzBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25VcGRhdGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdmFsO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLnVwZGF0ZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9XaWR0aCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdCA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3NlbGVjdCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0eWxlIHx8ICghdGhpcy5zdHlsZVsnd2lkdGgnXSAmJiAhdGhpcy5zdHlsZVsnbWluLXdpZHRoJ10pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLnN0eWxlLndpZHRoID0gc2VsZWN0Lm9mZnNldFdpZHRoICsgMzAgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUub25Nb3VzZWNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGZDbGljayA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pdGVtQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFuZWxWaXNpYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyVmlld0NoaWxkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbHRlclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUub25FZGl0YWJsZUlucHV0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pdGVtQ2xpY2sgPSB0cnVlO1xuICAgICAgICB0aGlzLmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5vbkVkaXRhYmxlSW5wdXRGb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUub25FZGl0YWJsZUlucHV0Q2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24odGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUub25TaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWxpZ25QYW5lbCgpO1xuICAgICAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRMaXN0SXRlbSA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuaXRlbXNXcmFwcGVyLCAnLnVpLWRyb3Bkb3duLWl0ZW0udWktc3RhdGUtaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRMaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5zY3JvbGxJblZpZXcodGhpcy5pdGVtc1dyYXBwZXIsIHNlbGVjdGVkTGlzdEl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIHRoaXMucGFuZWwuc3R5bGUubWluV2lkdGggPSB0aGlzLmRvbUhhbmRsZXIuZ2V0V2lkdGgodGhpcy5jb250YWluZXIpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhbmVsLnN0eWxlLnpJbmRleCA9IFN0cmluZygrK2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLnppbmRleCk7XG4gICAgICAgIHRoaXMucGFuZWxWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaG93biA9IHRydWU7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYW5lbFZpc2libGUgPSBmYWxzZTtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5hbGlnblBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRUbylcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hYnNvbHV0ZVBvc2l0aW9uKHRoaXMucGFuZWwsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLnJlbGF0aXZlUG9zaXRpb24odGhpcy5wYW5lbCwgdGhpcy5jb250YWluZXIpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLm9uSW5wdXRGb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLm9uSW5wdXRCbHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCgpO1xuICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5vbktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtSW5kZXggPSB0aGlzLnNlbGVjdGVkT3B0aW9uID8gdGhpcy5maW5kT3B0aW9uSW5kZXgodGhpcy5zZWxlY3RlZE9wdGlvbi52YWx1ZSwgdGhpcy5vcHRpb25zVG9EaXNwbGF5KSA6IC0xO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgICAvL2Rvd25cbiAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhbmVsVmlzaWJsZSAmJiBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtSW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SXRlbUluZGV4ID0gc2VsZWN0ZWRJdGVtSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJdGVtSW5kZXggIT0gKHRoaXMub3B0aW9uc1RvRGlzcGxheS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IHRoaXMub3B0aW9uc1RvRGlzcGxheVtuZXh0SXRlbUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkT3B0aW9uVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RJdGVtKGV2ZW50LCB0aGlzLnNlbGVjdGVkT3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnNUb0Rpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRPcHRpb24gPSB0aGlzLm9wdGlvbnNUb0Rpc3BsYXlbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vdXBcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSXRlbUluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkl0ZW1JbmRleCA9IHNlbGVjdGVkSXRlbUluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IHRoaXMub3B0aW9uc1RvRGlzcGxheVtwcmV2SXRlbUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvblVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oZXZlbnQsIHRoaXMuc2VsZWN0ZWRPcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy9zcGFjZVxuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy9lbnRlclxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy9lc2NhcGUgYW5kIHRhYlxuICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLmZpbmRPcHRpb25JbmRleCA9IGZ1bmN0aW9uICh2YWwsIG9wdHMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHZhbCA9PSBudWxsICYmIG9wdHNbaV0udmFsdWUgPT0gbnVsbCkgfHwgdGhpcy5vYmplY3RVdGlscy5lcXVhbHModmFsLCBvcHRzW2ldLnZhbHVlLCB0aGlzLmRhdGFLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5maW5kT3B0aW9uID0gZnVuY3Rpb24gKHZhbCwgb3B0cykge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRPcHRpb25JbmRleCh2YWwsIG9wdHMpO1xuICAgICAgICByZXR1cm4gKGluZGV4ICE9IC0xKSA/IG9wdHNbaW5kZXhdIDogbnVsbDtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5vbkZpbHRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaW5wdXRWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJWYWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlRmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1RvRGlzcGxheSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5hY3RpdmF0ZUZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlYXJjaEZpZWxkcyA9IHRoaXMuZmlsdGVyQnkuc3BsaXQoJywnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNUb0Rpc3BsYXkgPSB0aGlzLm9iamVjdFV0aWxzLmZpbHRlcih0aGlzLm9wdGlvbnMsIHNlYXJjaEZpZWxkcywgdGhpcy5maWx0ZXJWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLmFwcGx5Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnLnVpLWRyb3Bkb3duLWxhYmVsLnVpLWlucHV0dGV4dCcpLmZvY3VzKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2lucHV0W3JlYWRvbmx5XScpLmZvY3VzKCk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zZWxmQ2xpY2sgJiYgIV90aGlzLml0ZW1DbGljaykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYW5lbFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnNlbGZDbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLml0ZW1DbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS51bmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5wYW5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEcm9wZG93bjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRHJvcGRvd24ucHJvdG90eXBlLCBcInNjcm9sbEhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRHJvcGRvd24ucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgRHJvcGRvd24ucHJvdG90eXBlLCBcInBhbmVsU3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERyb3Bkb3duLnByb3RvdHlwZSwgXCJwYW5lbFN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRHJvcGRvd24ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyb3Bkb3duLnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiYXV0b1dpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyb3Bkb3duLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiZWRpdGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiYXBwZW5kVG9cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiZmlsdGVyUGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIERyb3Bkb3duLnByb3RvdHlwZSwgXCJkYXRhS2V5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRHJvcGRvd24ucHJvdG90eXBlLCBcImZpbHRlckJ5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyb3Bkb3duLnByb3RvdHlwZSwgXCJsYXp5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIERyb3Bkb3duLnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdjb250YWluZXInKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiY29udGFpbmVyVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdwYW5lbCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIERyb3Bkb3duLnByb3RvdHlwZSwgXCJwYW5lbFZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnaXRlbXN3cmFwcGVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgRHJvcGRvd24ucHJvdG90eXBlLCBcIml0ZW1zV3JhcHBlclZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnZmlsdGVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgRHJvcGRvd24ucHJvdG90eXBlLCBcImZpbHRlclZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnaW4nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiZm9jdXNWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2VkaXRhYmxlSW5wdXQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwiZWRpdGFibGVJbnB1dFZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZHJlbihzaGFyZWRfMS5QcmltZVRlbXBsYXRlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlF1ZXJ5TGlzdClcbl0sIERyb3Bkb3duLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBEcm9wZG93bi5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCBudWxsKTtcbkRyb3Bkb3duID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1kcm9wZG93bicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgIDxkaXYgI2NvbnRhaW5lciBbbmdDbGFzc109XFxcInsndWktZHJvcGRvd24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXgnOnRydWUsXFxuICAgICAgICAgICAgJ3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZCwndWktZHJvcGRvd24tb3Blbic6cGFuZWxWaXNpYmxlLCd1aS1zdGF0ZS1mb2N1cyc6Zm9jdXN9XFxcIlxcbiAgICAgICAgICAgIChjbGljayk9XFxcIm9uTW91c2VjbGljaygkZXZlbnQpXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcXFwiICpuZ0lmPVxcXCJhdXRvV2lkdGhcXFwiPlxcbiAgICAgICAgICAgICAgICA8c2VsZWN0IFtyZXF1aXJlZF09XFxcInJlcXVpcmVkXFxcIiBuYW1lPVxcXCJvcHRpb25zXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwic2VsZWN0ZWRPcHRpb24gPyBzZWxlY3RlZE9wdGlvbi5sYWJlbCA6ICcgJ1xcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uICpuZ0Zvcj1cXFwibGV0IG9wdGlvbiBvZiBvcHRpb25zXFxcIiBbdmFsdWVdPVxcXCJvcHRpb24udmFsdWVcXFwiIFtzZWxlY3RlZF09XFxcInNlbGVjdGVkT3B0aW9uID09IG9wdGlvblxcXCI+e3tvcHRpb24ubGFiZWx9fTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgI2luIFthdHRyLmlkXT1cXFwiaW5wdXRJZFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcInNlbGVjdGVkT3B0aW9uID8gc2VsZWN0ZWRPcHRpb24ubGFiZWwgOiAnICdcXFwiIHJlYWRvbmx5IChmb2N1cyk9XFxcIm9uSW5wdXRGb2N1cygkZXZlbnQpXFxcIiAoYmx1cik9XFxcIm9uSW5wdXRCbHVyKCRldmVudClcXFwiIChrZXlkb3duKT1cXFwib25LZXlkb3duKCRldmVudClcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbYXR0ci50YWJpbmRleF09XFxcInRhYmluZGV4XFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8bGFiZWwgW25nQ2xhc3NdPVxcXCJ7J3VpLWRyb3Bkb3duLWxhYmVsIHVpLWlucHV0dGV4dCB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1kcm9wZG93bi1sYWJlbC1lbXB0eSc6IWxhYmVsfVxcXCIgKm5nSWY9XFxcIiFlZGl0YWJsZVxcXCI+e3tsYWJlbHx8J2VtcHR5J319PC9sYWJlbD5cXG4gICAgICAgICAgICA8aW5wdXQgI2VkaXRhYmxlSW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcInNlbGVjdGVkT3B0aW9uID8gc2VsZWN0ZWRPcHRpb24ubGFiZWwgOiAnICdcXFwiIGNsYXNzPVxcXCJ1aS1kcm9wZG93bi1sYWJlbCB1aS1pbnB1dHRleHQgdWktY29ybmVyLWFsbFxcXCIgKm5nSWY9XFxcImVkaXRhYmxlXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW2F0dHIucGxhY2Vob2xkZXJdPVxcXCJwbGFjZWhvbGRlclxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJvbkVkaXRhYmxlSW5wdXRDbGljaygkZXZlbnQpXFxcIiAoaW5wdXQpPVxcXCJvbkVkaXRhYmxlSW5wdXRDaGFuZ2UoJGV2ZW50KVxcXCIgKGZvY3VzKT1cXFwib25FZGl0YWJsZUlucHV0Rm9jdXMoJGV2ZW50KVxcXCIgKGJsdXIpPVxcXCJvbklucHV0Qmx1cigkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1kcm9wZG93bi10cmlnZ2VyIHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLXJpZ2h0XFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWZ3IGZhLWNhcmV0LWRvd24gdWktY2xpY2thYmxlXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiAjcGFuZWwgW25nQ2xhc3NdPVxcXCIndWktZHJvcGRvd24tcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItaGlkZGVuIHVpLXNoYWRvdydcXFwiIFtAcGFuZWxTdGF0ZV09XFxcInBhbmVsVmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXFxcIlxcbiAgICAgICAgICAgICAgICBbc3R5bGUuZGlzcGxheV09XFxcInBhbmVsVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSdcXFwiIFtuZ1N0eWxlXT1cXFwicGFuZWxTdHlsZVxcXCIgW2NsYXNzXT1cXFwicGFuZWxTdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cXFwiZmlsdGVyXFxcIiBjbGFzcz1cXFwidWktZHJvcGRvd24tZmlsdGVyLWNvbnRhaW5lclxcXCIgKGlucHV0KT1cXFwib25GaWx0ZXIoJGV2ZW50KVxcXCIgKGNsaWNrKT1cXFwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCAjZmlsdGVyIHR5cGU9XFxcInRleHRcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBjbGFzcz1cXFwidWktZHJvcGRvd24tZmlsdGVyIHVpLWlucHV0dGV4dCB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXFxcIiBbYXR0ci5wbGFjZWhvbGRlcl09XFxcImZpbHRlclBsYWNlaG9sZGVyXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVxcXCIkZXZlbnQucHJldmVudERlZmF1bHQoKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtc2VhcmNoXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2ICNpdGVtc3dyYXBwZXIgY2xhc3M9XFxcInVpLWRyb3Bkb3duLWl0ZW1zLXdyYXBwZXJcXFwiIFtzdHlsZS5tYXgtaGVpZ2h0XT1cXFwic2Nyb2xsSGVpZ2h0fHwnYXV0bydcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS1kcm9wZG93bi1pdGVtcyB1aS1kcm9wZG93bi1saXN0IHVpLXdpZGdldC1jb250ZW50IHVpLXdpZGdldCB1aS1jb3JuZXItYWxsIHVpLWhlbHBlci1yZXNldFxcXCIgKm5nSWY9XFxcImxhenkgPyBwYW5lbFZpc2libGUgOiB0cnVlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgKm5nRm9yPVxcXCJsZXQgb3B0aW9uIG9mIG9wdGlvbnNUb0Rpc3BsYXk7bGV0IGk9aW5kZXhcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktZHJvcGRvd24taXRlbSB1aS1jb3JuZXItYWxsJzp0cnVlLCAndWktc3RhdGUtaGlnaGxpZ2h0Jzooc2VsZWN0ZWRPcHRpb24gPT0gb3B0aW9uKSwgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1aS1kcm9wZG93bi1pdGVtLWVtcHR5Jzohb3B0aW9uLmxhYmVsfHxvcHRpb24ubGFiZWwubGVuZ3RoID09PSAwfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwib25JdGVtQ2xpY2soJGV2ZW50LCBvcHRpb24pXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiFpdGVtVGVtcGxhdGVcXFwiPnt7b3B0aW9uLmxhYmVsfHwnZW1wdHknfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbcFRlbXBsYXRlV3JhcHBlcl09XFxcIml0ZW1UZW1wbGF0ZVxcXCIgW2l0ZW1dPVxcXCJvcHRpb25cXFwiICpuZ0lmPVxcXCJpdGVtVGVtcGxhdGVcXFwiPjwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICBhbmltYXRpb25zXzEudHJpZ2dlcigncGFuZWxTdGF0ZScsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuc3RhdGUoJ2hpZGRlbicsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCd2aXNpYmxlJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEudHJhbnNpdGlvbigndmlzaWJsZSA9PiBoaWRkZW4nLCBhbmltYXRpb25zXzEuYW5pbWF0ZSgnNDAwbXMgZWFzZS1pbicpKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEudHJhbnNpdGlvbignaGlkZGVuID0+IHZpc2libGUnLCBhbmltYXRpb25zXzEuYW5pbWF0ZSgnNDAwbXMgZWFzZS1vdXQnKSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0sXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBvYmplY3R1dGlsc18xLk9iamVjdFV0aWxzLCBleHBvcnRzLkRST1BET1dOX1ZBTFVFX0FDQ0VTU09SXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuUmVuZGVyZXIyLCBjb3JlXzEuQ2hhbmdlRGV0ZWN0b3JSZWYsIG9iamVjdHV0aWxzXzEuT2JqZWN0VXRpbHNdKVxuXSwgRHJvcGRvd24pO1xuZXhwb3J0cy5Ecm9wZG93biA9IERyb3Bkb3duO1xudmFyIERyb3Bkb3duTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcm9wZG93bk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIERyb3Bkb3duTW9kdWxlO1xufSgpKTtcbkRyb3Bkb3duTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgc2hhcmVkXzEuU2hhcmVkTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0Ryb3Bkb3duLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtEcm9wZG93bl1cbiAgICB9KVxuXSwgRHJvcGRvd25Nb2R1bGUpO1xuZXhwb3J0cy5Ecm9wZG93bk1vZHVsZSA9IERyb3Bkb3duTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJvcGRvd24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9kcm9wZG93bi9kcm9wZG93bi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2Ryb3Bkb3duL2Ryb3Bkb3duLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgZm9ybXNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKTtcbmV4cG9ydHMuRURJVE9SX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IGZvcm1zXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVkaXRvcjsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgRWRpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGl0b3IoZWwsIGRvbUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLm9uVGV4dENoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uSW5pdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgRWRpdG9yLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlZGl0b3JFbGVtZW50ID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnZGl2LnVpLWVkaXRvci1jb250ZW50Jyk7XG4gICAgICAgIHZhciB0b29sYmFyRWxlbWVudCA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2Rpdi51aS1lZGl0b3ItdG9vbGJhcicpO1xuICAgICAgICB0aGlzLnF1aWxsID0gbmV3IFF1aWxsKGVkaXRvckVsZW1lbnQsIHtcbiAgICAgICAgICAgIG1vZHVsZXM6IHtcbiAgICAgICAgICAgICAgICB0b29sYmFyOiB0b29sYmFyRWxlbWVudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRoaXMucmVhZG9ubHksXG4gICAgICAgICAgICB0aGVtZTogJ3Nub3cnLFxuICAgICAgICAgICAgZm9ybWF0czogdGhpcy5mb3JtYXRzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5xdWlsbC5wYXN0ZUhUTUwodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWlsbC5vbigndGV4dC1jaGFuZ2UnLCBmdW5jdGlvbiAoZGVsdGEsIG9sZENvbnRlbnRzLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gZWRpdG9yRWxlbWVudC5jaGlsZHJlblswXS5pbm5lckhUTUw7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IF90aGlzLnF1aWxsLmdldFRleHQoKTtcbiAgICAgICAgICAgIGlmIChodG1sID09ICc8cD48YnI+PC9wPicpIHtcbiAgICAgICAgICAgICAgICBodG1sID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm9uVGV4dENoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBodG1sVmFsdWU6IGh0bWwsXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5vbk1vZGVsQ2hhbmdlKGh0bWwpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Nb2RlbFRvdWNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVpbGwub24oJ3NlbGVjdGlvbi1jaGFuZ2UnLCBmdW5jdGlvbiAocmFuZ2UsIG9sZFJhbmdlLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIF90aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICBvbGRSYW5nZTogb2xkUmFuZ2UsXG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkluaXQuZW1pdCh7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMucXVpbGxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5xdWlsbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHRoaXMucXVpbGwucGFzdGVIVE1MKHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnF1aWxsLnNldFRleHQoJycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0UXVpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1aWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEVkaXRvcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBFZGl0b3IucHJvdG90eXBlLCBcIm9uVGV4dENoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRWRpdG9yLnByb3RvdHlwZSwgXCJvblNlbGVjdGlvbkNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMS5IZWFkZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFZGl0b3IucHJvdG90eXBlLCBcInRvb2xiYXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBFZGl0b3IucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRWRpdG9yLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRWRpdG9yLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBFZGl0b3IucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBFZGl0b3IucHJvdG90eXBlLCBcImZvcm1hdHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEVkaXRvci5wcm90b3R5cGUsIFwib25Jbml0XCIsIHZvaWQgMCk7XG5FZGl0b3IgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWVkaXRvcicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcIid1aS13aWRnZXQgdWktZWRpdG9yLWNvbnRhaW5lciB1aS1jb3JuZXItYWxsJ1xcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZWRpdG9yLXRvb2xiYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItdG9wXFxcIiAqbmdJZj1cXFwidG9vbGJhclxcXCI+XFxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwicC1oZWFkZXJcXFwiPjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1lZGl0b3ItdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci10b3BcXFwiICpuZ0lmPVxcXCIhdG9vbGJhclxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJxbC1mb3JtYXRzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XFxcInFsLWhlYWRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjFcXFwiPkhlYWRpbmc8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiMlxcXCI+U3ViaGVhZGluZzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHNlbGVjdGVkPk5vcm1hbDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVxcXCJxbC1mb250XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBzZWxlY3RlZD5TYW5zIFNlcmlmPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInNlcmlmXFxcIj5TZXJpZjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJtb25vc3BhY2VcXFwiPk1vbm9zcGFjZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInFsLWZvcm1hdHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwicWwtYm9sZFxcXCIgYXJpYS1sYWJlbD1cXFwiQm9sZFxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJxbC1pdGFsaWNcXFwiIGFyaWEtbGFiZWw9XFxcIkl0YWxpY1xcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJxbC11bmRlcmxpbmVcXFwiIGFyaWEtbGFiZWw9XFxcIlVuZGVybGluZVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInFsLWZvcm1hdHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwicWwtY29sb3JcXFwiPjwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwicWwtYmFja2dyb3VuZFxcXCI+PC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInFsLWZvcm1hdHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwicWwtbGlzdFxcXCIgdmFsdWU9XFxcIm9yZGVyZWRcXFwiIGFyaWEtbGFiZWw9XFxcIk9yZGVyZWQgTGlzdFxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJxbC1saXN0XFxcIiB2YWx1ZT1cXFwiYnVsbGV0XFxcIiBhcmlhLWxhYmVsPVxcXCJVbm9yZGVyZWQgTGlzdFxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVxcXCJxbC1hbGlnblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBzZWxlY3RlZD48L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJjZW50ZXJcXFwiPjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInJpZ2h0XFxcIj48L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJqdXN0aWZ5XFxcIj48L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJxbC1mb3JtYXRzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcInFsLWxpbmtcXFwiIGFyaWEtbGFiZWw9XFxcIkluc2VydCBMaW5rXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcInFsLWltYWdlXFxcIiBhcmlhLWxhYmVsPVxcXCJJbnNlcnQgSW1hZ2VcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwicWwtY29kZS1ibG9ja1xcXCIgYXJpYS1sYWJlbD1cXFwiSW5zZXJ0IENvZGUgQmxvY2tcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJxbC1mb3JtYXRzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcInFsLWNsZWFuXFxcIiBhcmlhLWxhYmVsPVxcXCJSZW1vdmUgU3R5bGVzXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWVkaXRvci1jb250ZW50XFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIGV4cG9ydHMuRURJVE9SX1ZBTFVFX0FDQ0VTU09SXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIEVkaXRvcik7XG5leHBvcnRzLkVkaXRvciA9IEVkaXRvcjtcbnZhciBFZGl0b3JNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVkaXRvck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvck1vZHVsZTtcbn0oKSk7XG5FZGl0b3JNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0VkaXRvciwgc2hhcmVkXzEuU2hhcmVkTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbRWRpdG9yXVxuICAgIH0pXG5dLCBFZGl0b3JNb2R1bGUpO1xuZXhwb3J0cy5FZGl0b3JNb2R1bGUgPSBFZGl0b3JNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZGl0b3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9lZGl0b3IvZWRpdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvZWRpdG9yL2VkaXRvci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYW5pbWF0aW9uc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2FuaW1hdGlvbnNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zaGFyZWRcIik7XG52YXIgRmllbGRzZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpZWxkc2V0KGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkJlZm9yZVRvZ2dsZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25BZnRlclRvZ2dsZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIEZpZWxkc2V0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudG9nZ2xlYWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZVRvZ2dsZS5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGNvbGxhcHNlZDogdGhpcy5jb2xsYXBzZWQgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmQoZXZlbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5vbkFmdGVyVG9nZ2xlLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgY29sbGFwc2VkOiB0aGlzLmNvbGxhcHNlZCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmllbGRzZXQucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgRmllbGRzZXQucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEZpZWxkc2V0LnByb3RvdHlwZS5nZXRCbG9ja2FibGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgIH07XG4gICAgRmllbGRzZXQucHJvdG90eXBlLm9uVG9nZ2xlRG9uZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIEZpZWxkc2V0O1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGaWVsZHNldC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZpZWxkc2V0LnByb3RvdHlwZSwgXCJ0b2dnbGVhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZpZWxkc2V0LnByb3RvdHlwZSwgXCJjb2xsYXBzZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEZpZWxkc2V0LnByb3RvdHlwZSwgXCJvbkJlZm9yZVRvZ2dsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRmllbGRzZXQucHJvdG90eXBlLCBcIm9uQWZ0ZXJUb2dnbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBGaWVsZHNldC5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGaWVsZHNldC5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuRmllbGRzZXQgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWZpZWxkc2V0JyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZmllbGRzZXQgW25nQ2xhc3NdPVxcXCJ7J3VpLWZpZWxkc2V0IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsJzogdHJ1ZSwgJ3VpLWZpZWxkc2V0LXRvZ2dsZWFibGUnOiB0b2dnbGVhYmxlfVxcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGxlZ2VuZCBjbGFzcz1cXFwidWktZmllbGRzZXQtbGVnZW5kIHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGVmYXVsdCB1aS11bnNlbGVjdGFibGUtdGV4dFxcXCIgKGNsaWNrKT1cXFwidG9nZ2xlKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwidG9nZ2xlYWJsZVxcXCIgY2xhc3M9XFxcInVpLWZpZWxkc2V0LXRvZ2dsZXIgZmEgZmEtd1xcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhLW1pbnVzJzogIWNvbGxhcHNlZCwnZmEtcGx1cyc6Y29sbGFwc2VkfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICB7e2xlZ2VuZH19XFxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwicC1oZWFkZXJcXFwiPjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8L2xlZ2VuZD5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1maWVsZHNldC1jb250ZW50LXdyYXBwZXJcXFwiIFtAZmllbGRzZXRDb250ZW50XT1cXFwiY29sbGFwc2VkID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1maWVsZHNldC1jb250ZW50LXdyYXBwZXItb3ZlcmZsb3duJzogY29sbGFwc2VkfHxhbmltYXRpbmd9XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAoQGZpZWxkc2V0Q29udGVudC5kb25lKT1cXFwib25Ub2dnbGVEb25lKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1maWVsZHNldC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2ZpZWxkc2V0PlxcbiAgICBcIixcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyaWdnZXIoJ2ZpZWxkc2V0Q29udGVudCcsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuc3RhdGUoJ2hpZGRlbicsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzBweCdcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCd2aXNpYmxlJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnKidcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyYW5zaXRpb24oJ3Zpc2libGUgPT4gaGlkZGVuJywgYW5pbWF0aW9uc18xLmFuaW1hdGUoJzQwMG1zIGN1YmljLWJlemllcigwLjg2LCAwLCAwLjA3LCAxKScpKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEudHJhbnNpdGlvbignaGlkZGVuID0+IHZpc2libGUnLCBhbmltYXRpb25zXzEuYW5pbWF0ZSgnNDAwbXMgY3ViaWMtYmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpJykpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZl0pXG5dLCBGaWVsZHNldCk7XG5leHBvcnRzLkZpZWxkc2V0ID0gRmllbGRzZXQ7XG52YXIgRmllbGRzZXRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpZWxkc2V0TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gRmllbGRzZXRNb2R1bGU7XG59KCkpO1xuRmllbGRzZXRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0ZpZWxkc2V0LCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtGaWVsZHNldF1cbiAgICB9KVxuXSwgRmllbGRzZXRNb2R1bGUpO1xuZXhwb3J0cy5GaWVsZHNldE1vZHVsZSA9IEZpZWxkc2V0TW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmllbGRzZXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9maWVsZHNldC9maWVsZHNldC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2ZpZWxkc2V0L2ZpZWxkc2V0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgcGxhdGZvcm1fYnJvd3Nlcl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIik7XG52YXIgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vYnV0dG9uL2J1dHRvblwiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL21lc3NhZ2VzXCIpO1xudmFyIHByb2dyZXNzYmFyXzEgPSByZXF1aXJlKFwiLi4vcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXJcIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBGaWxlVXBsb2FkID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWxlVXBsb2FkKHNhbml0aXplcikge1xuICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgdGhpcy5tZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIHRoaXMuaW52YWxpZEZpbGVTaXplTWVzc2FnZVN1bW1hcnkgPSAnezB9OiBJbnZhbGlkIGZpbGUgc2l6ZSwgJztcbiAgICAgICAgdGhpcy5pbnZhbGlkRmlsZVNpemVNZXNzYWdlRGV0YWlsID0gJ21heGltdW0gdXBsb2FkIHNpemUgaXMgezB9Lic7XG4gICAgICAgIHRoaXMuaW52YWxpZEZpbGVUeXBlTWVzc2FnZVN1bW1hcnkgPSAnezB9OiBJbnZhbGlkIGZpbGUgdHlwZSwgJztcbiAgICAgICAgdGhpcy5pbnZhbGlkRmlsZVR5cGVNZXNzYWdlRGV0YWlsID0gJ2FsbG93ZWQgZmlsZSB0eXBlczogezB9Lic7XG4gICAgICAgIHRoaXMucHJldmlld1dpZHRoID0gNTA7XG4gICAgICAgIHRoaXMuY2hvb3NlTGFiZWwgPSAnQ2hvb3NlJztcbiAgICAgICAgdGhpcy51cGxvYWRMYWJlbCA9ICdVcGxvYWQnO1xuICAgICAgICB0aGlzLmNhbmNlbExhYmVsID0gJ0NhbmNlbCc7XG4gICAgICAgIHRoaXMuc2hvd1VwbG9hZEJ1dHRvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd0NhbmNlbEJ1dHRvbiA9IHRydWU7XG4gICAgICAgIHRoaXMubW9kZSA9ICdhZHZhbmNlZCc7XG4gICAgICAgIHRoaXMub25CZWZvcmVVcGxvYWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQmVmb3JlU2VuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25VcGxvYWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQ2xlYXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uUmVtb3ZlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vblNlbGVjdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudXBsb2FkSGFuZGxlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICAgIH1cbiAgICBGaWxlVXBsb2FkLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWxlcyA9IFtdO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0uZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbGVUZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnQnOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250ZW50VGVtcGxhdGUgPSBpdGVtLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0b29sYmFyJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9vbGJhclRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlsZVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUub25GaWxlU2VsZWN0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubXNncyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIgPyBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMgOiBldmVudC50YXJnZXQuZmlsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0gZmlsZXNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZGF0ZShmaWxlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW1hZ2UoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5vYmplY3RVUkwgPSB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0VXJsKCh3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlc1tpXSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgZmlsZXM6IGZpbGVzIH0pO1xuICAgICAgICBpZiAodGhpcy5oYXNGaWxlcygpICYmIHRoaXMuYXV0bykge1xuICAgICAgICAgICAgdGhpcy51cGxvYWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICBpZiAodGhpcy5hY2NlcHQgJiYgIXRoaXMuaXNGaWxlVHlwZVZhbGlkKGZpbGUpKSB7XG4gICAgICAgICAgICB0aGlzLm1zZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogdGhpcy5pbnZhbGlkRmlsZVR5cGVNZXNzYWdlU3VtbWFyeS5yZXBsYWNlKCd7MH0nLCBmaWxlLm5hbWUpLFxuICAgICAgICAgICAgICAgIGRldGFpbDogdGhpcy5pbnZhbGlkRmlsZVR5cGVNZXNzYWdlRGV0YWlsLnJlcGxhY2UoJ3swfScsIHRoaXMuYWNjZXB0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4RmlsZVNpemUgJiYgZmlsZS5zaXplID4gdGhpcy5tYXhGaWxlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tc2dzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNldmVyaXR5OiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIHN1bW1hcnk6IHRoaXMuaW52YWxpZEZpbGVTaXplTWVzc2FnZVN1bW1hcnkucmVwbGFjZSgnezB9JywgZmlsZS5uYW1lKSxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHRoaXMuaW52YWxpZEZpbGVTaXplTWVzc2FnZURldGFpbC5yZXBsYWNlKCd7MH0nLCB0aGlzLmZvcm1hdFNpemUodGhpcy5tYXhGaWxlU2l6ZSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZpbGVVcGxvYWQucHJvdG90eXBlLmlzRmlsZVR5cGVWYWxpZCA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHZhciBhY2NlcHRhYmxlVHlwZXMgPSB0aGlzLmFjY2VwdC5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFjY2VwdGFibGVUeXBlc18xID0gYWNjZXB0YWJsZVR5cGVzOyBfaSA8IGFjY2VwdGFibGVUeXBlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBhY2NlcHRhYmxlVHlwZXNfMVtfaV07XG4gICAgICAgICAgICB2YXIgYWNjZXB0YWJsZSA9IHRoaXMuaXNXaWxkY2FyZCh0eXBlKSA/IHRoaXMuZ2V0VHlwZUNsYXNzKGZpbGUudHlwZSkgPT09IHRoaXMuZ2V0VHlwZUNsYXNzKHR5cGUpXG4gICAgICAgICAgICAgICAgOiBmaWxlLnR5cGUgPT0gdHlwZSB8fCB0aGlzLmdldEZpbGVFeHRlbnNpb24oZmlsZSkgPT09IHR5cGU7XG4gICAgICAgICAgICBpZiAoYWNjZXB0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEZpbGVVcGxvYWQucHJvdG90eXBlLmdldFR5cGVDbGFzcyA9IGZ1bmN0aW9uIChmaWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gZmlsZVR5cGUuc3Vic3RyaW5nKDAsIGZpbGVUeXBlLmluZGV4T2YoJy8nKSk7XG4gICAgfTtcbiAgICBGaWxlVXBsb2FkLnByb3RvdHlwZS5pc1dpbGRjYXJkID0gZnVuY3Rpb24gKGZpbGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBmaWxlVHlwZS5pbmRleE9mKCcqJykgIT09IC0xO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUuZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHJldHVybiAnLicgKyBmaWxlLm5hbWUuc3BsaXQoJy4nKS5wb3AoKTtcbiAgICB9O1xuICAgIEZpbGVVcGxvYWQucHJvdG90eXBlLmlzSW1hZ2UgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4gL15pbWFnZVxcLy8udGVzdChmaWxlLnR5cGUpO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUub25JbWFnZUxvYWQgPSBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKGltZy5zcmMpO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jdXN0b21VcGxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkSGFuZGxlci5lbWl0KHtcbiAgICAgICAgICAgICAgICBmaWxlczogdGhpcy5maWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1zZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciB4aHJfMSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZVVwbG9hZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAneGhyJzogeGhyXzEsXG4gICAgICAgICAgICAgICAgJ2Zvcm1EYXRhJzogZm9ybURhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKHRoaXMubmFtZSwgdGhpcy5maWxlc1tpXSwgdGhpcy5maWxlc1tpXS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhocl8xLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9ncmVzcyA9IE1hdGgucm91bmQoKGUubG9hZGVkICogMTAwKSAvIGUudG90YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vblByb2dyZXNzLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBlLCBwcm9ncmVzczogX3RoaXMucHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB4aHJfMS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhocl8xLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHJfMS5zdGF0dXMgPj0gMjAwICYmIHhocl8xLnN0YXR1cyA8IDMwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uVXBsb2FkLmVtaXQoeyB4aHI6IHhocl8xLCBmaWxlczogX3RoaXMuZmlsZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRXJyb3IuZW1pdCh7IHhocjogeGhyXzEsIGZpbGVzOiBfdGhpcy5maWxlcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyXzEub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZVNlbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgJ3hocic6IHhocl8xLFxuICAgICAgICAgICAgICAgICdmb3JtRGF0YSc6IGZvcm1EYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHhocl8xLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICAgICAgeGhyXzEuc2VuZChmb3JtRGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpbGVVcGxvYWQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZpbGVzID0gW107XG4gICAgICAgIHRoaXMub25DbGVhci5lbWl0KCk7XG4gICAgfTtcbiAgICBGaWxlVXBsb2FkLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMub25SZW1vdmUuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBmaWxlOiB0aGlzLmZpbGVzW2luZGV4XSB9KTtcbiAgICAgICAgdGhpcy5maWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUuaGFzRmlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzICYmIHRoaXMuZmlsZXMubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIEZpbGVVcGxvYWQucHJvdG90eXBlLm9uRHJhZ0VudGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaWxlVXBsb2FkLnByb3RvdHlwZS5vbkRyYWdPdmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUub25EcmFnTGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdIaWdobGlnaHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUub25Ecm9wID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnSGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIgPyBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMgOiBldmVudC50YXJnZXQuZmlsZXM7XG4gICAgICAgICAgICB2YXIgYWxsb3dEcm9wID0gdGhpcy5tdWx0aXBsZSB8fCAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoID09PSAxKTtcbiAgICAgICAgICAgIGlmIChhbGxvd0Ryb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRmlsZVNlbGVjdChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpbGVVcGxvYWQucHJvdG90eXBlLm9uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm9jdXMgPSB0cnVlO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUub25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBGaWxlVXBsb2FkLnByb3RvdHlwZS5mb3JtYXRTaXplID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgIGlmIChieXRlcyA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJzAgQic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGsgPSAxMDAwLCBkbSA9IDMsIHNpemVzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ10sIGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGspKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoKGJ5dGVzIC8gTWF0aC5wb3coaywgaSkpLnRvRml4ZWQoZG0pKSArICcgJyArIHNpemVzW2ldO1xuICAgIH07XG4gICAgRmlsZVVwbG9hZC5wcm90b3R5cGUub25TaW1wbGVVcGxvYWRlckNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZpbGVzKCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaWxlVXBsb2FkO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwidXJsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwibWV0aG9kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcIm11bHRpcGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwiYWNjZXB0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcImF1dG9cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwid2l0aENyZWRlbnRpYWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwibWF4RmlsZVNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJpbnZhbGlkRmlsZVNpemVNZXNzYWdlU3VtbWFyeVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcImludmFsaWRGaWxlU2l6ZU1lc3NhZ2VEZXRhaWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJpbnZhbGlkRmlsZVR5cGVNZXNzYWdlU3VtbWFyeVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcImludmFsaWRGaWxlVHlwZU1lc3NhZ2VEZXRhaWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJwcmV2aWV3V2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJjaG9vc2VMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcInVwbG9hZExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwiY2FuY2VsTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwic2hvd1VwbG9hZEJ1dHRvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJzaG93Q2FuY2VsQnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwibW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJjdXN0b21VcGxvYWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcIm9uQmVmb3JlVXBsb2FkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJvbkJlZm9yZVNlbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcIm9uVXBsb2FkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJvbkVycm9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJvbkNsZWFyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJvblJlbW92ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgRmlsZVVwbG9hZC5wcm90b3R5cGUsIFwib25TZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcIm9uUHJvZ3Jlc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEZpbGVVcGxvYWQucHJvdG90eXBlLCBcInVwbG9hZEhhbmRsZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oc2hhcmVkXzEuUHJpbWVUZW1wbGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5RdWVyeUxpc3QpXG5dLCBGaWxlVXBsb2FkLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZXNcIiwgdm9pZCAwKTtcbkZpbGVVcGxvYWQgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWZpbGVVcGxvYWQnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCIndWktZmlsZXVwbG9hZCB1aS13aWRnZXQnXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIiAqbmdJZj1cXFwibW9kZSA9PT0gJ2FkdmFuY2VkJ1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZmlsZXVwbG9hZC1idXR0b25iYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItdG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWZpbGV1cGxvYWQtY2hvb3NlXFxcIiBbbGFiZWxdPVxcXCJjaG9vc2VMYWJlbFxcXCIgaWNvbj1cXFwiZmEtcGx1c1xcXCIgcEJ1dHRvbiAgW25nQ2xhc3NdPVxcXCJ7J3VpLWZpbGV1cGxvYWQtY2hvb3NlLXNlbGVjdGVkJzogaGFzRmlsZXMoKSwndWktc3RhdGUtZm9jdXMnOiBmb2N1c31cXFwiIFthdHRyLmRpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiID4gXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgI2ZpbGVpbnB1dCB0eXBlPVxcXCJmaWxlXFxcIiAoY2hhbmdlKT1cXFwib25GaWxlU2VsZWN0KCRldmVudClcXFwiIFttdWx0aXBsZV09XFxcIm11bHRpcGxlXFxcIiBbYWNjZXB0XT1cXFwiYWNjZXB0XFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgKGZvY3VzKT1cXFwib25Gb2N1cygpXFxcIiAoYmx1cik9XFxcIm9uQmx1cigpXFxcIj5cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcblxcbiAgICAgICAgICAgICAgICA8YnV0dG9uICpuZ0lmPVxcXCIhYXV0byYmc2hvd1VwbG9hZEJ1dHRvblxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBbbGFiZWxdPVxcXCJ1cGxvYWRMYWJlbFxcXCIgaWNvbj1cXFwiZmEtdXBsb2FkXFxcIiBwQnV0dG9uIChjbGljayk9XFxcInVwbG9hZCgpXFxcIiBbZGlzYWJsZWRdPVxcXCIhaGFzRmlsZXMoKVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDxidXR0b24gKm5nSWY9XFxcIiFhdXRvJiZzaG93Q2FuY2VsQnV0dG9uXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIFtsYWJlbF09XFxcImNhbmNlbExhYmVsXFxcIiBpY29uPVxcXCJmYS1jbG9zZVxcXCIgcEJ1dHRvbiAoY2xpY2spPVxcXCJjbGVhcigpXFxcIiBbZGlzYWJsZWRdPVxcXCIhaGFzRmlsZXMoKVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIDxwLXRlbXBsYXRlTG9hZGVyIFt0ZW1wbGF0ZV09XFxcInRvb2xiYXJUZW1wbGF0ZVxcXCI+PC9wLXRlbXBsYXRlTG9hZGVyPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJ7J3VpLWZpbGV1cGxvYWQtY29udGVudCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tJzp0cnVlLCd1aS1maWxldXBsb2FkLWhpZ2hsaWdodCc6ZHJhZ0hpZ2hsaWdodH1cXFwiIFxcbiAgICAgICAgICAgICAgICAoZHJhZ2VudGVyKT1cXFwib25EcmFnRW50ZXIoJGV2ZW50KVxcXCIgKGRyYWdvdmVyKT1cXFwib25EcmFnT3ZlcigkZXZlbnQpXFxcIiAoZHJhZ2xlYXZlKT1cXFwib25EcmFnTGVhdmUoJGV2ZW50KVxcXCIgKGRyb3ApPVxcXCJvbkRyb3AoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgIDxwLXByb2dyZXNzQmFyIFt2YWx1ZV09XFxcInByb2dyZXNzXFxcIiBbc2hvd1ZhbHVlXT1cXFwiZmFsc2VcXFwiICpuZ0lmPVxcXCJoYXNGaWxlcygpXFxcIj48L3AtcHJvZ3Jlc3NCYXI+XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICA8cC1tZXNzYWdlcyBbdmFsdWVdPVxcXCJtc2dzXFxcIj48L3AtbWVzc2FnZXM+XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1maWxldXBsb2FkLWZpbGVzXFxcIiAqbmdJZj1cXFwiaGFzRmlsZXMoKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCIhZmlsZVRlbXBsYXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1maWxldXBsb2FkLXJvd1xcXCIgKm5nRm9yPVxcXCJsZXQgZmlsZSBvZiBmaWxlczsgbGV0IGkgPSBpbmRleDtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxpbWcgW3NyY109XFxcImZpbGUub2JqZWN0VVJMXFxcIiAqbmdJZj1cXFwiaXNJbWFnZShmaWxlKVxcXCIgW3dpZHRoXT1cXFwicHJldmlld1dpZHRoXFxcIiAvPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pnt7ZmlsZS5uYW1lfX08L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj57e2Zvcm1hdFNpemUoZmlsZS5zaXplKX19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGljb249XFxcImZhLWNsb3NlXFxcIiBwQnV0dG9uIChjbGljayk9XFxcInJlbW92ZSgkZXZlbnQsaSlcXFwiPjwvYnV0dG9uPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCJmaWxlVGVtcGxhdGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBbbmdGb3JPZl09XFxcImZpbGVzXFxcIiBbbmdGb3JUZW1wbGF0ZV09XFxcImZpbGVUZW1wbGF0ZVxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPHAtdGVtcGxhdGVMb2FkZXIgW3RlbXBsYXRlXT1cXFwiY29udGVudFRlbXBsYXRlXFxcIj48L3AtdGVtcGxhdGVMb2FkZXI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1idXR0b24gdWktZmlsZXVwbG9hZC1jaG9vc2UgdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCB1aS1idXR0b24tdGV4dC1pY29uLWxlZnRcXFwiICpuZ0lmPVxcXCJtb2RlID09PSAnYmFzaWMnXFxcIiBcXG4gICAgICAgIChtb3VzZXVwKT1cXFwib25TaW1wbGVVcGxvYWRlckNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICBbbmdDbGFzc109XFxcInsndWktZmlsZXVwbG9hZC1jaG9vc2Utc2VsZWN0ZWQnOiBoYXNGaWxlcygpLCd1aS1zdGF0ZS1mb2N1cyc6IGZvY3VzfVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWJ1dHRvbi1pY29uLWxlZnQgZmFcXFwiIFtuZ0NsYXNzXT1cXFwieydmYS1wbHVzJzogIWhhc0ZpbGVzKCl8fGF1dG8sICdmYS11cGxvYWQnOiBoYXNGaWxlcygpJiYhYXV0b31cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktYnV0dG9uLXRleHQgdWktY2xpY2thYmxlXFxcIj57e2F1dG8gPyBjaG9vc2VMYWJlbCA6IGhhc0ZpbGVzKCkgPyBmaWxlc1swXS5uYW1lIDogY2hvb3NlTGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZmlsZVxcXCIgW2FjY2VwdF09XFxcImFjY2VwdFxcXCIgW211bHRpcGxlXT1cXFwibXVsdGlwbGVcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgICAoY2hhbmdlKT1cXFwib25GaWxlU2VsZWN0KCRldmVudClcXFwiICpuZ0lmPVxcXCIhaGFzRmlsZXMoKVxcXCIgKGZvY3VzKT1cXFwib25Gb2N1cygpXFxcIiAoYmx1cik9XFxcIm9uQmx1cigpXFxcIj5cXG4gICAgICAgIDwvc3Bhbj5cXG4gICAgXCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3BsYXRmb3JtX2Jyb3dzZXJfMS5Eb21TYW5pdGl6ZXJdKVxuXSwgRmlsZVVwbG9hZCk7XG5leHBvcnRzLkZpbGVVcGxvYWQgPSBGaWxlVXBsb2FkO1xudmFyIEZpbGVVcGxvYWRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbGVVcGxvYWRNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBGaWxlVXBsb2FkTW9kdWxlO1xufSgpKTtcbkZpbGVVcGxvYWRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGUsIGJ1dHRvbl8xLkJ1dHRvbk1vZHVsZSwgcHJvZ3Jlc3NiYXJfMS5Qcm9ncmVzc0Jhck1vZHVsZSwgbWVzc2FnZXNfMS5NZXNzYWdlc01vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtGaWxlVXBsb2FkLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGUsIGJ1dHRvbl8xLkJ1dHRvbk1vZHVsZSwgcHJvZ3Jlc3NiYXJfMS5Qcm9ncmVzc0Jhck1vZHVsZSwgbWVzc2FnZXNfMS5NZXNzYWdlc01vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW0ZpbGVVcGxvYWRdXG4gICAgfSlcbl0sIEZpbGVVcGxvYWRNb2R1bGUpO1xuZXhwb3J0cy5GaWxlVXBsb2FkTW9kdWxlID0gRmlsZVVwbG9hZE1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGV1cGxvYWQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9maWxldXBsb2FkL2ZpbGV1cGxvYWQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9maWxldXBsb2FkL2ZpbGV1cGxvYWQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgR2FsbGVyaWEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhbGxlcmlhKGVsLCBkb21IYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5wYW5lbFdpZHRoID0gNjAwO1xuICAgICAgICB0aGlzLnBhbmVsSGVpZ2h0ID0gNDAwO1xuICAgICAgICB0aGlzLmZyYW1lV2lkdGggPSA2MDtcbiAgICAgICAgdGhpcy5mcmFtZUhlaWdodCA9IDQwO1xuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zaG93RmlsbXN0cmlwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRvUGxheSA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkludGVydmFsID0gNDAwMDtcbiAgICAgICAgdGhpcy5zaG93Q2FwdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMub25JbWFnZUNsaWNrZWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN0cmlwTGVmdCA9IDA7XG4gICAgfVxuICAgIEdhbGxlcmlhLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFNsaWRlc2hvdygpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR2FsbGVyaWEucHJvdG90eXBlLCBcImltYWdlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlcyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLmltYWdlc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBHYWxsZXJpYS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgdGhpcy5wYW5lbFdyYXBwZXIgPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd1bC51aS1nYWxsZXJpYS1wYW5lbC13cmFwcGVyJyk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zaG93RmlsbXN0cmlwKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmlwV3JhcHBlciA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMuY29udGFpbmVyLCAnZGl2LnVpLWdhbGxlcmlhLWZpbG1zdHJpcC13cmFwcGVyJyk7XG4gICAgICAgICAgICB0aGlzLnN0cmlwID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5zdHJpcFdyYXBwZXIsICd1bC51aS1nYWxsZXJpYS1maWxtc3RyaXAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbWFnZXMgJiYgdGhpcy5pbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHYWxsZXJpYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuZG9tSGFuZGxlci5maW5kKHRoaXMucGFuZWxXcmFwcGVyLCAnbGkudWktZ2FsbGVyaWEtcGFuZWwnKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvd0ZpbG1zdHJpcCkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZXMgPSB0aGlzLmRvbUhhbmRsZXIuZmluZCh0aGlzLnN0cmlwLCAnbGkudWktZ2FsbGVyaWEtZnJhbWUnKTtcbiAgICAgICAgICAgIHRoaXMuc3RyaXBXcmFwcGVyLnN0eWxlLndpZHRoID0gdGhpcy5kb21IYW5kbGVyLndpZHRoKHRoaXMucGFuZWxXcmFwcGVyKSAtIDUwICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuc3RyaXBXcmFwcGVyLnN0eWxlLmhlaWdodCA9IHRoaXMuZnJhbWVIZWlnaHQgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3dDYXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNhcHRpb24gPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmNvbnRhaW5lciwgJ2Rpdi51aS1nYWxsZXJpYS1jYXB0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLmNhcHRpb24uc3R5bGUuYm90dG9tID0gdGhpcy5zaG93RmlsbXN0cmlwID8gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHRoaXMuc3RyaXBXcmFwcGVyLCB0cnVlKSArICdweCcgOiAwICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuY2FwdGlvbi5zdHlsZS53aWR0aCA9IHRoaXMuZG9tSGFuZGxlci53aWR0aCh0aGlzLnBhbmVsV3JhcHBlcikgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9QbGF5KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2xpZGVzaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9O1xuICAgIEdhbGxlcmlhLnByb3RvdHlwZS5zdGFydFNsaWRlc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm5leHQoKTtcbiAgICAgICAgfSwgdGhpcy50cmFuc2l0aW9uSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLnNsaWRlc2hvd0FjdGl2ZSA9IHRydWU7XG4gICAgfTtcbiAgICBHYWxsZXJpYS5wcm90b3R5cGUuc3RvcFNsaWRlc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zbGlkZXNob3dBY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIEdhbGxlcmlhLnByb3RvdHlwZS5jbGlja05hdlJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zbGlkZXNob3dBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFNsaWRlc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH07XG4gICAgR2FsbGVyaWEucHJvdG90eXBlLmNsaWNrTmF2TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2xpZGVzaG93QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BTbGlkZXNob3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXYoKTtcbiAgICB9O1xuICAgIEdhbGxlcmlhLnByb3RvdHlwZS5mcmFtZUNsaWNrID0gZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnNsaWRlc2hvd0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wU2xpZGVzaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5kb21IYW5kbGVyLmluZGV4KGZyYW1lKSwgZmFsc2UpO1xuICAgIH07XG4gICAgR2FsbGVyaWEucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmFjdGl2ZUluZGV4IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdhbGxlcmlhLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVJbmRleCAhPT0gKHRoaXMucGFuZWxzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmFjdGl2ZUluZGV4ICsgMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCgwLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnN0cmlwTGVmdCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdhbGxlcmlhLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoaW5kZXgsIHJlcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLmFjdGl2ZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb2xkUGFuZWwgPSB0aGlzLnBhbmVsc1t0aGlzLmFjdGl2ZUluZGV4XSwgbmV3UGFuZWwgPSB0aGlzLnBhbmVsc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuZmFkZUluKG5ld1BhbmVsLCA1MDApO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0ZpbG1zdHJpcCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRGcmFtZSA9IHRoaXMuZnJhbWVzW3RoaXMuYWN0aXZlSW5kZXhdLCBuZXdGcmFtZSA9IHRoaXMuZnJhbWVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHJlcG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lTGVmdCA9IG5ld0ZyYW1lLm9mZnNldExlZnQsIHN0ZXBGYWN0b3IgPSB0aGlzLmZyYW1lV2lkdGggKyBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKG5ld0ZyYW1lKVsnbWFyZ2luLXJpZ2h0J10sIDEwKSwgc3RyaXBMZWZ0ID0gdGhpcy5zdHJpcC5vZmZzZXRMZWZ0LCBmcmFtZVZpZXdwb3J0TGVmdCA9IGZyYW1lTGVmdCArIHN0cmlwTGVmdCwgZnJhbWVWaWV3cG9ydFJpZ2h0ID0gZnJhbWVWaWV3cG9ydExlZnQgKyB0aGlzLmZyYW1lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZVZpZXdwb3J0UmlnaHQgPiB0aGlzLmRvbUhhbmRsZXIud2lkdGgodGhpcy5zdHJpcFdyYXBwZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpcExlZnQgLT0gc3RlcEZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnJhbWVWaWV3cG9ydExlZnQgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpcExlZnQgKz0gc3RlcEZhY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdhbGxlcmlhLnByb3RvdHlwZS5jbGlja0ltYWdlID0gZnVuY3Rpb24gKGV2ZW50LCBpbWFnZSwgaSkge1xuICAgICAgICB0aGlzLm9uSW1hZ2VDbGlja2VkLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgaW1hZ2U6IGltYWdlLCBpbmRleDogaSB9KTtcbiAgICB9O1xuICAgIEdhbGxlcmlhLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wU2xpZGVzaG93KCk7XG4gICAgfTtcbiAgICByZXR1cm4gR2FsbGVyaWE7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEdhbGxlcmlhLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEdhbGxlcmlhLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgR2FsbGVyaWEucHJvdG90eXBlLCBcInBhbmVsV2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBHYWxsZXJpYS5wcm90b3R5cGUsIFwicGFuZWxIZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBHYWxsZXJpYS5wcm90b3R5cGUsIFwiZnJhbWVXaWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEdhbGxlcmlhLnByb3RvdHlwZSwgXCJmcmFtZUhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEdhbGxlcmlhLnByb3RvdHlwZSwgXCJhY3RpdmVJbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBHYWxsZXJpYS5wcm90b3R5cGUsIFwic2hvd0ZpbG1zdHJpcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBHYWxsZXJpYS5wcm90b3R5cGUsIFwiYXV0b1BsYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBHYWxsZXJpYS5wcm90b3R5cGUsIFwidHJhbnNpdGlvbkludGVydmFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdhbGxlcmlhLnByb3RvdHlwZSwgXCJzaG93Q2FwdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHYWxsZXJpYS5wcm90b3R5cGUsIFwib25JbWFnZUNsaWNrZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBHYWxsZXJpYS5wcm90b3R5cGUsIFwiaW1hZ2VzXCIsIG51bGwpO1xuR2FsbGVyaWEgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWdhbGxlcmlhJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwieyd1aS1nYWxsZXJpYSB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCc6dHJ1ZX1cXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtzdHlsZS53aWR0aC5weF09XFxcInBhbmVsV2lkdGhcXFwiPlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwidWktZ2FsbGVyaWEtcGFuZWwtd3JhcHBlclxcXCIgW3N0eWxlLndpZHRoLnB4XT1cXFwicGFuZWxXaWR0aFxcXCIgW3N0eWxlLmhlaWdodC5weF09XFxcInBhbmVsSGVpZ2h0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpICpuZ0Zvcj1cXFwibGV0IGltYWdlIG9mIGltYWdlcztsZXQgaT1pbmRleFxcXCIgY2xhc3M9XFxcInVpLWdhbGxlcmlhLXBhbmVsXFxcIiBbbmdDbGFzc109XFxcInsndWktaGVscGVyLWhpZGRlbic6aSE9YWN0aXZlSW5kZXh9XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cXFwicGFuZWxXaWR0aFxcXCIgW3N0eWxlLmhlaWdodC5weF09XFxcInBhbmVsSGVpZ2h0XFxcIiAoY2xpY2spPVxcXCJjbGlja0ltYWdlKCRldmVudCxpbWFnZSxpKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVxcXCJ1aS1wYW5lbC1pbWFnZXNcXFwiIFtzcmNdPVxcXCJpbWFnZS5zb3VyY2VcXFwiIFthbHRdPVxcXCJpbWFnZS5hbHRcXFwiIFt0aXRsZV09XFxcImltYWdlLnRpdGxlXFxcIi8+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwieyd1aS1nYWxsZXJpYS1maWxtc3RyaXAtd3JhcHBlcic6dHJ1ZX1cXFwiICpuZ0lmPVxcXCJzaG93RmlsbXN0cmlwXFxcIj5cXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS1nYWxsZXJpYS1maWxtc3RyaXBcXFwiIHN0eWxlPVxcXCJ0cmFuc2l0aW9uOmxlZnQgMXNcXFwiIFtzdHlsZS5sZWZ0LnB4XT1cXFwic3RyaXBMZWZ0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxsaSAjZnJhbWUgKm5nRm9yPVxcXCJsZXQgaW1hZ2Ugb2YgaW1hZ2VzO2xldCBpPWluZGV4XFxcIiBbbmdDbGFzc109XFxcInsndWktZ2FsbGVyaWEtZnJhbWUtYWN0aXZlJzppPT1hY3RpdmVJbmRleH1cXFwiIGNsYXNzPVxcXCJ1aS1nYWxsZXJpYS1mcmFtZVxcXCIgKGNsaWNrKT1cXFwiZnJhbWVDbGljayhmcmFtZSlcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cXFwiZnJhbWVXaWR0aFxcXCIgW3N0eWxlLmhlaWdodC5weF09XFxcImZyYW1lSGVpZ2h0XFxcIiBbc3R5bGUudHJhbnNpdGlvbl09XFxcIidvcGFjaXR5IDAuNzVzIGVhc2UnXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1nYWxsZXJpYS1mcmFtZS1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBbc3JjXT1cXFwiaW1hZ2Uuc291cmNlXFxcIiBbYWx0XT1cXFwiaW1hZ2UuYWx0XFxcIiBbdGl0bGVdPVxcXCJpbWFnZS50aXRsZVxcXCIgY2xhc3M9XFxcInVpLWdhbGxlcmlhLWZyYW1lLWltYWdlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cXFwiZnJhbWVXaWR0aFxcXCIgW3N0eWxlLmhlaWdodC5weF09XFxcImZyYW1lSGVpZ2h0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktZ2FsbGVyaWEtbmF2LXByZXYgZmEgZmEtZncgZmEtY2hldnJvbi1jaXJjbGUtbGVmdFxcXCIgKGNsaWNrKT1cXFwiY2xpY2tOYXZMZWZ0KClcXFwiIFtzdHlsZS5ib3R0b20ucHhdPVxcXCJmcmFtZUhlaWdodC8yXFxcIiAqbmdJZj1cXFwiYWN0aXZlSW5kZXggIT09IDBcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWdhbGxlcmlhLW5hdi1uZXh0IGZhIGZhLWZ3IGZhLWNoZXZyb24tY2lyY2xlLXJpZ2h0XFxcIiAoY2xpY2spPVxcXCJjbGlja05hdlJpZ2h0KClcXFwiIFtzdHlsZS5ib3R0b20ucHhdPVxcXCJmcmFtZUhlaWdodC8yXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1nYWxsZXJpYS1jYXB0aW9uXFxcIiAqbmdJZj1cXFwic2hvd0NhcHRpb24mJmltYWdlc1xcXCIgc3R5bGU9XFxcImRpc3BsYXk6YmxvY2tcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDQ+e3tpbWFnZXNbYWN0aXZlSW5kZXhdPy50aXRsZX19PC9oND48cD57e2ltYWdlc1thY3RpdmVJbmRleF0/LmFsdH19PC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl0pXG5dLCBHYWxsZXJpYSk7XG5leHBvcnRzLkdhbGxlcmlhID0gR2FsbGVyaWE7XG52YXIgR2FsbGVyaWFNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhbGxlcmlhTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gR2FsbGVyaWFNb2R1bGU7XG59KCkpO1xuR2FsbGVyaWFNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0dhbGxlcmlhXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbR2FsbGVyaWFdXG4gICAgfSlcbl0sIEdhbGxlcmlhTW9kdWxlKTtcbmV4cG9ydHMuR2FsbGVyaWFNb2R1bGUgPSBHYWxsZXJpYU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhbGxlcmlhLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvZ2FsbGVyaWEvZ2FsbGVyaWEuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9nYWxsZXJpYS9nYWxsZXJpYS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIEdNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdNYXAoZWwsIGRpZmZlcnMsIGNkLCB6b25lKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLm9uTWFwQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uT3ZlcmxheUNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk92ZXJsYXlEcmFnU3RhcnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uT3ZlcmxheURyYWcgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uT3ZlcmxheURyYWdFbmQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTWFwUmVhZHkgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTWFwRHJhZ0VuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25ab29tQ2hhbmdlZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGlmZmVyID0gZGlmZmVycy5maW5kKFtdKS5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIEdNYXAucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcCAmJiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR01hcC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5vbk1hcFJlYWR5LmVtaXQoe1xuICAgICAgICAgICAgbWFwOiB0aGlzLm1hcFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLm92ZXJsYXlzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGF5ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG92ZXJsYXkuc2V0TWFwKHRoaXMubWFwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRPdmVybGF5RXZlbnRzKG92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwLmFkZExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uTWFwQ2xpY2suZW1pdChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFwLmFkZExpc3RlbmVyKCdkcmFnZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25NYXBEcmFnRW5kLmVtaXQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcC5hZGRMaXN0ZW5lcignem9vbV9jaGFuZ2VkJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25ab29tQ2hhbmdlZC5lbWl0KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdNYXAucHJvdG90eXBlLmJpbmRPdmVybGF5RXZlbnRzID0gZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3ZlcmxheS5hZGRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbk92ZXJsYXlDbGljay5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICdvdmVybGF5Jzogb3ZlcmxheSxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBfdGhpcy5tYXBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG92ZXJsYXkuZ2V0RHJhZ2dhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZERyYWdFdmVudHMob3ZlcmxheSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdNYXAucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLmRpZmZlci5kaWZmKHRoaXMub3ZlcmxheXMpO1xuICAgICAgICBpZiAoY2hhbmdlcyAmJiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZWNvcmQuaXRlbS5zZXRNYXAobnVsbCk7IH0pO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQuaXRlbS5zZXRNYXAoX3RoaXMubWFwKTtcbiAgICAgICAgICAgICAgICByZWNvcmQuaXRlbS5hZGRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25PdmVybGF5Q2xpY2suZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheTogcmVjb3JkLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBfdGhpcy5tYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLml0ZW0uZ2V0RHJhZ2dhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmluZERyYWdFdmVudHMocmVjb3JkLml0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHTWFwLnByb3RvdHlwZS5iaW5kRHJhZ0V2ZW50cyA9IGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG92ZXJsYXkuYWRkTGlzdGVuZXIoJ2RyYWdzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uT3ZlcmxheURyYWdTdGFydC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogX3RoaXMubWFwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG92ZXJsYXkuYWRkTGlzdGVuZXIoJ2RyYWcnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbk92ZXJsYXlEcmFnLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheTogb3ZlcmxheSxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBfdGhpcy5tYXBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgb3ZlcmxheS5hZGRMaXN0ZW5lcignZHJhZ2VuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uT3ZlcmxheURyYWdFbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5LFxuICAgICAgICAgICAgICAgICAgICBtYXA6IF90aGlzLm1hcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR01hcC5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXA7XG4gICAgfTtcbiAgICByZXR1cm4gR01hcDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgR01hcC5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBHTWFwLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgR01hcC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgR01hcC5wcm90b3R5cGUsIFwib3ZlcmxheXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEdNYXAucHJvdG90eXBlLCBcIm9uTWFwQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEdNYXAucHJvdG90eXBlLCBcIm9uT3ZlcmxheUNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBHTWFwLnByb3RvdHlwZSwgXCJvbk92ZXJsYXlEcmFnU3RhcnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEdNYXAucHJvdG90eXBlLCBcIm9uT3ZlcmxheURyYWdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEdNYXAucHJvdG90eXBlLCBcIm9uT3ZlcmxheURyYWdFbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEdNYXAucHJvdG90eXBlLCBcIm9uTWFwUmVhZHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEdNYXAucHJvdG90eXBlLCBcIm9uTWFwRHJhZ0VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgR01hcC5wcm90b3R5cGUsIFwib25ab29tQ2hhbmdlZFwiLCB2b2lkIDApO1xuR01hcCA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtZ21hcCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+PC9kaXY+XCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBjb3JlXzEuSXRlcmFibGVEaWZmZXJzLCBjb3JlXzEuQ2hhbmdlRGV0ZWN0b3JSZWYsIGNvcmVfMS5OZ1pvbmVdKVxuXSwgR01hcCk7XG5leHBvcnRzLkdNYXAgPSBHTWFwO1xudmFyIEdNYXBNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdNYXBNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBHTWFwTW9kdWxlO1xufSgpKTtcbkdNYXBNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0dNYXBdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtHTWFwXVxuICAgIH0pXG5dLCBHTWFwTW9kdWxlKTtcbmV4cG9ydHMuR01hcE1vZHVsZSA9IEdNYXBNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvZ21hcC9nbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvZ21hcC9nbWFwLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIEdyb3dsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcm93bChlbCwgZG9tSGFuZGxlciwgZGlmZmVycykge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMuZGlmZmVycyA9IGRpZmZlcnM7XG4gICAgICAgIHRoaXMubGlmZSA9IDMwMDA7XG4gICAgICAgIHRoaXMuaW1tdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuekluZGV4ID0gZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4O1xuICAgICAgICB0aGlzLmRpZmZlciA9IGRpZmZlcnMuZmluZChbXSkuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBHcm93bC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3Jvd2wucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIgJiYgdGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEdyb3dsLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbW11dGFibGUgJiYgdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5kaWZmZXIuZGlmZih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm93bC5wcm90b3R5cGUuaGFuZGxlVmFsdWVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZlbnRSZXJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50UmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnpJbmRleCA9ICsrZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4O1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIuZmFkZUluKHRoaXMuY29udGFpbmVyLCAyNTApO1xuICAgICAgICB0aGlzLmNsZWFyVHJpZ2dlcigpO1xuICAgIH07XG4gICAgR3Jvd2wucHJvdG90eXBlLmNsZWFyVHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVBbGwoKTtcbiAgICAgICAgfSwgdGhpcy5saWZlKTtcbiAgICB9O1xuICAgIEdyb3dsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgsIG1zZ2VsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5mYWRlT3V0KG1zZ2VsLCAyNTApO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByZXZlbnRSZXJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5vbkNsb3NlLmVtaXQoeyBtZXNzYWdlOiBfdGhpcy52YWx1ZVtpbmRleF0gfSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3ZhbHVlID0gX3RoaXMudmFsdWUuZmlsdGVyKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIGkgIT0gaW5kZXg7IH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlQ2hhbmdlLmVtaXQoX3RoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl92YWx1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyNTApO1xuICAgIH07XG4gICAgR3Jvd2wucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5mYWRlT3V0KHRoaXMuY29udGFpbmVyLCAyNTApO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobXNnLCBpbmRleCkgeyByZXR1cm4gX3RoaXMub25DbG9zZS5lbWl0KHsgbWVzc2FnZTogX3RoaXMudmFsdWVbaW5kZXhdIH0pOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlQ2hhbmdlLmVtaXQoX3RoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUuc3BsaWNlKDAsIF90aGlzLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3Jvd2wucHJvdG90eXBlLm9uTWVzc2FnZUNsaWNrID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdGhpcy5vbkNsaWNrLmVtaXQoeyBtZXNzYWdlOiB0aGlzLnZhbHVlW2ldIH0pO1xuICAgIH07XG4gICAgR3Jvd2wucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RpY2t5KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyb3dsO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgR3Jvd2wucHJvdG90eXBlLCBcInN0aWNreVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEdyb3dsLnByb3RvdHlwZSwgXCJsaWZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgR3Jvd2wucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgR3Jvd2wucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgR3Jvd2wucHJvdG90eXBlLCBcImltbXV0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgR3Jvd2wucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIEdyb3dsLnByb3RvdHlwZSwgXCJvbkNsb3NlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBHcm93bC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2NvbnRhaW5lcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIEdyb3dsLnByb3RvdHlwZSwgXCJjb250YWluZXJWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBHcm93bC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5Hcm93bCA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtZ3Jvd2wnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgI2NvbnRhaW5lciBbbmdDbGFzc109XFxcIid1aS1ncm93bCB1aS13aWRnZXQnXFxcIiBbc3R5bGUuekluZGV4XT1cXFwiekluZGV4XFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2ICNtc2dlbCAqbmdGb3I9XFxcImxldCBtc2cgb2YgdmFsdWU7bGV0IGkgPSBpbmRleFxcXCIgY2xhc3M9XFxcInVpLWdyb3dsLWl0ZW0tY29udGFpbmVyIHVpLXN0YXRlLWhpZ2hsaWdodCB1aS1jb3JuZXItYWxsIHVpLXNoYWRvd1xcXCIgYXJpYS1saXZlPVxcXCJwb2xpdGVcXFwiXFxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1ncm93bC1tZXNzYWdlLWluZm8nOm1zZy5zZXZlcml0eSA9PSAnaW5mbycsJ3VpLWdyb3dsLW1lc3NhZ2Utd2Fybic6bXNnLnNldmVyaXR5ID09ICd3YXJuJyxcXG4gICAgICAgICAgICAgICAgICAgICd1aS1ncm93bC1tZXNzYWdlLWVycm9yJzptc2cuc2V2ZXJpdHkgPT0gJ2Vycm9yJywndWktZ3Jvd2wtbWVzc2FnZS1zdWNjZXNzJzptc2cuc2V2ZXJpdHkgPT0gJ3N1Y2Nlc3MnfVxcXCIgKGNsaWNrKT1cXFwib25NZXNzYWdlQ2xpY2soaSlcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1ncm93bC1pdGVtXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1ncm93bC1pY29uLWNsb3NlIGZhIGZhLWNsb3NlXFxcIiAoY2xpY2spPVxcXCJyZW1vdmUoaSxtc2dlbClcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1ncm93bC1pbWFnZSBmYSBmYS0yeFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsnZmEtaW5mby1jaXJjbGUnOm1zZy5zZXZlcml0eSA9PSAnaW5mbycsJ2ZhLWV4Y2xhbWF0aW9uLWNpcmNsZSc6bXNnLnNldmVyaXR5ID09ICd3YXJuJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYS1jbG9zZSc6bXNnLnNldmVyaXR5ID09ICdlcnJvcicsJ2ZhLWNoZWNrJzptc2cuc2V2ZXJpdHkgPT0gJ3N1Y2Nlc3MnfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWdyb3dsLW1lc3NhZ2VcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1ncm93bC10aXRsZVxcXCI+e3ttc2cuc3VtbWFyeX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIFtpbm5lckhUTUxdPVxcXCJtc2cuZGV0YWlsXFxcIj48L3A+XFxuICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cXFwiY2xlYXI6IGJvdGg7XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuSXRlcmFibGVEaWZmZXJzXSlcbl0sIEdyb3dsKTtcbmV4cG9ydHMuR3Jvd2wgPSBHcm93bDtcbnZhciBHcm93bE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3Jvd2xNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBHcm93bE1vZHVsZTtcbn0oKSk7XG5Hcm93bE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbR3Jvd2xdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtHcm93bF1cbiAgICB9KVxuXSwgR3Jvd2xNb2R1bGUpO1xuZXhwb3J0cy5Hcm93bE1vZHVsZSA9IEdyb3dsTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3Jvd2wuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9ncm93bC9ncm93bC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL2dyb3dsL2dyb3dsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgYnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vYnV0dG9uL2J1dHRvblwiKTtcbnZhciBJbnBsYWNlRGlzcGxheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wbGFjZURpc3BsYXkoKSB7XG4gICAgfVxuICAgIHJldHVybiBJbnBsYWNlRGlzcGxheTtcbn0oKSk7XG5JbnBsYWNlRGlzcGxheSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtaW5wbGFjZURpc3BsYXknLFxuICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG4gICAgfSlcbl0sIElucGxhY2VEaXNwbGF5KTtcbmV4cG9ydHMuSW5wbGFjZURpc3BsYXkgPSBJbnBsYWNlRGlzcGxheTtcbnZhciBJbnBsYWNlQ29udGVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wbGFjZUNvbnRlbnQoKSB7XG4gICAgfVxuICAgIHJldHVybiBJbnBsYWNlQ29udGVudDtcbn0oKSk7XG5JbnBsYWNlQ29udGVudCA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtaW5wbGFjZUNvbnRlbnQnLFxuICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG4gICAgfSlcbl0sIElucGxhY2VDb250ZW50KTtcbmV4cG9ydHMuSW5wbGFjZUNvbnRlbnQgPSBJbnBsYWNlQ29udGVudDtcbnZhciBJbnBsYWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnBsYWNlKCkge1xuICAgICAgICB0aGlzLm9uQWN0aXZhdGUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRGVhY3RpdmF0ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIElucGxhY2UucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vbkFjdGl2YXRlLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnBsYWNlLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25EZWFjdGl2YXRlLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW5wbGFjZTtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIElucGxhY2UucHJvdG90eXBlLCBcImFjdGl2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBJbnBsYWNlLnByb3RvdHlwZSwgXCJjbG9zYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBJbnBsYWNlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIElucGxhY2UucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgSW5wbGFjZS5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgSW5wbGFjZS5wcm90b3R5cGUsIFwib25BY3RpdmF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgSW5wbGFjZS5wcm90b3R5cGUsIFwib25EZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG5JbnBsYWNlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1pbnBsYWNlJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwiJ3VpLWlucGxhY2UgdWktd2lkZ2V0J1xcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaW5wbGFjZS1kaXNwbGF5XFxcIiAoY2xpY2spPVxcXCJhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtZGlzYWJsZWQnOmRpc2FibGVkfVxcXCIgKm5nSWY9XFxcIiFhY3RpdmVcXFwiPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcIltwSW5wbGFjZURpc3BsYXldXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaW5wbGFjZS1jb250ZW50XFxcIiAqbmdJZj1cXFwiYWN0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbcElucGxhY2VDb250ZW50XVxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWNvbj1cXFwiZmEtY2xvc2VcXFwiIHBCdXR0b24gKGNsaWNrKT1cXFwiZGVhY3RpdmF0ZSgkZXZlbnQpXFxcIiAqbmdJZj1cXFwiY2xvc2FibGVcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiXG4gICAgfSlcbl0sIElucGxhY2UpO1xuZXhwb3J0cy5JbnBsYWNlID0gSW5wbGFjZTtcbnZhciBJbnBsYWNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnBsYWNlTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gSW5wbGFjZU1vZHVsZTtcbn0oKSk7XG5JbnBsYWNlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgYnV0dG9uXzEuQnV0dG9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0lucGxhY2UsIElucGxhY2VEaXNwbGF5LCBJbnBsYWNlQ29udGVudCwgYnV0dG9uXzEuQnV0dG9uTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbSW5wbGFjZSwgSW5wbGFjZURpc3BsYXksIElucGxhY2VDb250ZW50XVxuICAgIH0pXG5dLCBJbnBsYWNlTW9kdWxlKTtcbmV4cG9ydHMuSW5wbGFjZU1vZHVsZSA9IElucGxhY2VNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnBsYWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvaW5wbGFjZS9pbnBsYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvaW5wbGFjZS9pbnBsYWNlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gICAgUG9ydCBvZiBqUXVlcnkgTWFza2VkSW5wdXQgYnkgRGlnaXRhbEJ1c2ggYXMgYSBOYXRpdmUgQW5ndWxhcjIgQ29tcG9uZW50IGluIFR5cGVzY3JpcHQgd2l0aG91dCBqUXVlcnlcbiAgICBodHRwczovL2dpdGh1Yi5jb20vZGlnaXRhbEJ1c2gvanF1ZXJ5Lm1hc2tlZGlucHV0L1xuICAgIFxuICAgIENvcHlyaWdodCAoYykgMjAwNy0yMDE0IEpvc2ggQnVzaCAoZGlnaXRhbGJ1c2guY29tKVxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgaW5wdXR0ZXh0XzEgPSByZXF1aXJlKFwiLi4vaW5wdXR0ZXh0L2lucHV0dGV4dFwiKTtcbnZhciBmb3Jtc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpO1xuZXhwb3J0cy5JTlBVVE1BU0tfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogZm9ybXNfMS5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5wdXRNYXNrOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBJbnB1dE1hc2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElucHV0TWFzayhlbCwgZG9tSGFuZGxlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy5zbG90Q2hhciA9ICdfJztcbiAgICAgICAgdGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLnBhcnRpYWxQb3NpdGlvbiA9IHRoaXMubWFzay5sZW5ndGg7XG4gICAgICAgIHRoaXMubGVuID0gdGhpcy5tYXNrLmxlbmd0aDtcbiAgICAgICAgdGhpcy5maXJzdE5vbk1hc2tQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmRlZnMgPSB7XG4gICAgICAgICAgICAnOSc6ICdbMC05XScsXG4gICAgICAgICAgICAnYSc6ICdbQS1aYS16XScsXG4gICAgICAgICAgICAnKic6ICdbQS1aYS16MC05XSdcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVhID0gdGhpcy5kb21IYW5kbGVyLmdldFVzZXJBZ2VudCgpO1xuICAgICAgICB0aGlzLmFuZHJvaWRDaHJvbWUgPSAvY2hyb21lL2kudGVzdCh1YSkgJiYgL2FuZHJvaWQvaS50ZXN0KHVhKTtcbiAgICAgICAgdmFyIG1hc2tUb2tlbnMgPSB0aGlzLm1hc2suc3BsaXQoJycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hc2tUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gbWFza1Rva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChjID09ICc/Jykge1xuICAgICAgICAgICAgICAgIHRoaXMubGVuLS07XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsUG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5kZWZzW2NdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0cy5wdXNoKG5ldyBSZWdFeHAodGhpcy5kZWZzW2NdKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3ROb25NYXNrUG9zID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3ROb25NYXNrUG9zID0gdGhpcy50ZXN0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMucGFydGlhbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlcXVpcmVkTm9uTWFza1BvcyA9IHRoaXMudGVzdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlc3RzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG1hc2tUb2tlbnNbaV07XG4gICAgICAgICAgICBpZiAoYyAhPSAnPycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZzW2NdKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuZ2V0UGxhY2Vob2xkZXIoaSkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRCdWZmZXIgPSB0aGlzLmJ1ZmZlci5qb2luKCcnKTtcbiAgICB9O1xuICAgIElucHV0TWFzay5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWYWwoKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUZXh0ID0gdGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaWxsZWRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dE1hc2sucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICBJbnB1dE1hc2sucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIElucHV0TWFzay5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHZhbDtcbiAgICB9O1xuICAgIElucHV0TWFzay5wcm90b3R5cGUuY2FyZXQgPSBmdW5jdGlvbiAoZmlyc3QsIGxhc3QpIHtcbiAgICAgICAgdmFyIHJhbmdlLCBiZWdpbiwgZW5kO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgdGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYmVnaW4gPSBmaXJzdDtcbiAgICAgICAgICAgIGVuZCA9ICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpID8gbGFzdCA6IGJlZ2luO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShiZWdpbiwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudFsnY3JlYXRlVGV4dFJhbmdlJ10pIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudFsnY3JlYXRlVGV4dFJhbmdlJ10oKTtcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgYmVnaW4pO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIGJlZ2luID0gdGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb2N1bWVudFsnc2VsZWN0aW9uJ10gJiYgZG9jdW1lbnRbJ3NlbGVjdGlvbiddLmNyZWF0ZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudFsnc2VsZWN0aW9uJ10uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBiZWdpbiA9IDAgLSByYW5nZS5kdXBsaWNhdGUoKS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC0xMDAwMDApO1xuICAgICAgICAgICAgICAgIGVuZCA9IGJlZ2luICsgcmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBiZWdpbjogYmVnaW4sIGVuZDogZW5kIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0TWFzay5wcm90b3R5cGUuaXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZWQ7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmZpcnN0Tm9uTWFza1BvczsgaSA8PSB0aGlzLmxhc3RSZXF1aXJlZE5vbk1hc2tQb3M7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudGVzdHNbaV0gJiYgdGhpcy5idWZmZXJbaV0gPT09IHRoaXMuZ2V0UGxhY2Vob2xkZXIoaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbnB1dE1hc2sucHJvdG90eXBlLmdldFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgaWYgKGkgPCB0aGlzLnNsb3RDaGFyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xvdENoYXIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNsb3RDaGFyLmNoYXJBdCgwKTtcbiAgICB9O1xuICAgIElucHV0TWFzay5wcm90b3R5cGUuc2Vla05leHQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHdoaWxlICgrK3BvcyA8IHRoaXMubGVuICYmICF0aGlzLnRlc3RzW3Bvc10pXG4gICAgICAgICAgICA7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBJbnB1dE1hc2sucHJvdG90eXBlLnNlZWtQcmV2ID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB3aGlsZSAoLS1wb3MgPj0gMCAmJiAhdGhpcy50ZXN0c1twb3NdKVxuICAgICAgICAgICAgO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5zaGlmdEwgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCkge1xuICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgaWYgKGJlZ2luIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGJlZ2luLCBqID0gdGhpcy5zZWVrTmV4dChlbmQpOyBpIDwgdGhpcy5sZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudGVzdHNbaV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA8IHRoaXMubGVuICYmIHRoaXMudGVzdHNbaV0udGVzdCh0aGlzLmJ1ZmZlcltqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaV0gPSB0aGlzLmJ1ZmZlcltqXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbal0gPSB0aGlzLmdldFBsYWNlaG9sZGVyKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGogPSB0aGlzLnNlZWtOZXh0KGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5jYXJldChNYXRoLm1heCh0aGlzLmZpcnN0Tm9uTWFza1BvcywgYmVnaW4pKTtcbiAgICB9O1xuICAgIElucHV0TWFzay5wcm90b3R5cGUuc2hpZnRSID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgaSwgYywgaiwgdDtcbiAgICAgICAgZm9yIChpID0gcG9zLCBjID0gdGhpcy5nZXRQbGFjZWhvbGRlcihwb3MpOyBpIDwgdGhpcy5sZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudGVzdHNbaV0pIHtcbiAgICAgICAgICAgICAgICBqID0gdGhpcy5zZWVrTmV4dChpKTtcbiAgICAgICAgICAgICAgICB0ID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaV0gPSBjO1xuICAgICAgICAgICAgICAgIGlmIChqIDwgdGhpcy5sZW4gJiYgdGhpcy50ZXN0c1tqXS50ZXN0KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dE1hc2sucHJvdG90eXBlLmhhbmRsZUFuZHJvaWRJbnB1dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjdXJWYWwgPSB0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmNhcmV0KCk7XG4gICAgICAgIGlmICh0aGlzLm9sZFZhbCAmJiB0aGlzLm9sZFZhbC5sZW5ndGggJiYgdGhpcy5vbGRWYWwubGVuZ3RoID4gY3VyVmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gYSBkZWxldGlvbiBvciBiYWNrc3BhY2UgaGFwcGVuZWRcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWYWwodHJ1ZSk7XG4gICAgICAgICAgICB3aGlsZSAocG9zLmJlZ2luID4gMCAmJiAhdGhpcy50ZXN0c1twb3MuYmVnaW4gLSAxXSlcbiAgICAgICAgICAgICAgICBwb3MuYmVnaW4tLTtcbiAgICAgICAgICAgIGlmIChwb3MuYmVnaW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zLmJlZ2luIDwgdGhpcy5maXJzdE5vbk1hc2tQb3MgJiYgIXRoaXMudGVzdHNbcG9zLmJlZ2luXSlcbiAgICAgICAgICAgICAgICAgICAgcG9zLmJlZ2luKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhcmV0KHBvcy5iZWdpbiwgcG9zLmJlZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWYWwodHJ1ZSk7XG4gICAgICAgICAgICB3aGlsZSAocG9zLmJlZ2luIDwgdGhpcy5sZW4gJiYgIXRoaXMudGVzdHNbcG9zLmJlZ2luIC0gMV0pXG4gICAgICAgICAgICAgICAgcG9zLmJlZ2luKys7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNhcmV0KHBvcy5iZWdpbiwgcG9zLmJlZ2luKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5vbklucHV0Qmx1ciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCgpO1xuICAgICAgICB0aGlzLmNoZWNrVmFsKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWwoZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRmlsbGVkU3RhdGUoKTtcbiAgICAgICAgdGhpcy5vbkJsdXIuZW1pdChlKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC52YWx1ZSAhPSB0aGlzLmZvY3VzVGV4dCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgICAgICAgICAgZXZlbnRfMS5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dE1hc2sucHJvdG90eXBlLm9uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGsgPSBlLndoaWNoIHx8IGUua2V5Q29kZSwgcG9zLCBiZWdpbiwgZW5kO1xuICAgICAgICB2YXIgaVBob25lID0gL2lwaG9uZS9pLnRlc3QodGhpcy5kb21IYW5kbGVyLmdldFVzZXJBZ2VudCgpKTtcbiAgICAgICAgdGhpcy5vbGRWYWwgPSB0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICAgIC8vYmFja3NwYWNlLCBkZWxldGUsIGFuZCBlc2NhcGUgZ2V0IHNwZWNpYWwgdHJlYXRtZW50XG4gICAgICAgIGlmIChrID09PSA4IHx8IGsgPT09IDQ2IHx8IChpUGhvbmUgJiYgayA9PT0gMTI3KSkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5jYXJldCgpO1xuICAgICAgICAgICAgYmVnaW4gPSBwb3MuYmVnaW47XG4gICAgICAgICAgICBlbmQgPSBwb3MuZW5kO1xuICAgICAgICAgICAgaWYgKGVuZCAtIGJlZ2luID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYmVnaW4gPSBrICE9PSA0NiA/IHRoaXMuc2Vla1ByZXYoYmVnaW4pIDogKGVuZCA9IHRoaXMuc2Vla05leHQoYmVnaW4gLSAxKSk7XG4gICAgICAgICAgICAgICAgZW5kID0gayA9PT0gNDYgPyB0aGlzLnNlZWtOZXh0KGVuZCkgOiBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyQnVmZmVyKGJlZ2luLCBlbmQpO1xuICAgICAgICAgICAgdGhpcy5zaGlmdEwoYmVnaW4sIGVuZCAtIDEpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RlbChlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrID09PSAxMykge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0Qmx1cihlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kZWwoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoayA9PT0gMjcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC52YWx1ZSA9IHRoaXMuZm9jdXNUZXh0O1xuICAgICAgICAgICAgdGhpcy5jYXJldCgwLCB0aGlzLmNoZWNrVmFsKCkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RlbChlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgayA9IGUud2hpY2ggfHwgZS5rZXlDb2RlLCBwb3MgPSB0aGlzLmNhcmV0KCksIHAsIGMsIG5leHQsIGNvbXBsZXRlZDtcbiAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLmFsdEtleSB8fCBlLm1ldGFLZXkgfHwgayA8IDMyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoayAmJiBrICE9PSAxMykge1xuICAgICAgICAgICAgaWYgKHBvcy5lbmQgLSBwb3MuYmVnaW4gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQnVmZmVyKHBvcy5iZWdpbiwgcG9zLmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGlmdEwocG9zLmJlZ2luLCBwb3MuZW5kIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gdGhpcy5zZWVrTmV4dChwb3MuYmVnaW4gLSAxKTtcbiAgICAgICAgICAgIGlmIChwIDwgdGhpcy5sZW4pIHtcbiAgICAgICAgICAgICAgICBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShrKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXN0c1twXS50ZXN0KGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hpZnRSKHApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltwXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuc2Vla05leHQocCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvYW5kcm9pZC9pLnRlc3QodGhpcy5kb21IYW5kbGVyLmdldFVzZXJBZ2VudCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9QYXRoIGZvciBDU1AgVmlvbGF0aW9uIG9uIEZpcmVGb3ggT1MgMS4xXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FyZXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChwcm94eSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmV0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MuYmVnaW4gPD0gdGhpcy5sYXN0UmVxdWlyZWROb25NYXNrUG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0aGlzLmlzQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbChlKTtcbiAgICAgICAgdGhpcy51cGRhdGVGaWxsZWRTdGF0ZSgpO1xuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dE1hc2sucHJvdG90eXBlLmNsZWFyQnVmZmVyID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kICYmIGkgPCB0aGlzLmxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXN0c1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2ldID0gdGhpcy5nZXRQbGFjZWhvbGRlcihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5idWZmZXIuam9pbignJyk7XG4gICAgfTtcbiAgICBJbnB1dE1hc2sucHJvdG90eXBlLmNoZWNrVmFsID0gZnVuY3Rpb24gKGFsbG93KSB7XG4gICAgICAgIC8vdHJ5IHRvIHBsYWNlIGNoYXJhY3RlcnMgd2hlcmUgdGhleSBiZWxvbmdcbiAgICAgICAgdmFyIHRlc3QgPSB0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQudmFsdWUsIGxhc3RNYXRjaCA9IC0xLCBpLCBjLCBwb3M7XG4gICAgICAgIGZvciAoaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLmxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXN0c1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2ldID0gdGhpcy5nZXRQbGFjZWhvbGRlcihpKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zKysgPCB0ZXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjID0gdGVzdC5jaGFyQXQocG9zIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlc3RzW2ldLnRlc3QoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2ldID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNYXRjaCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gdGVzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckJ1ZmZlcihpICsgMSwgdGhpcy5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWZmZXJbaV0gPT09IHRlc3QuY2hhckF0KHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5wYXJ0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1hdGNoID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93KSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFzdE1hdGNoICsgMSA8IHRoaXMucGFydGlhbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xlYXIgfHwgdGhpcy5idWZmZXIuam9pbignJykgPT09IHRoaXMuZGVmYXVsdEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWQgdmFsdWUuIFJlbW92ZSBpdCBhbmQgcmVwbGFjZSBpdCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIG1hc2ssIHdoaWNoIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJCdWZmZXIoMCwgdGhpcy5sZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW52YWxpZCB2YWx1ZSwgYnV0IHdlIG9wdCB0byBzaG93IHRoZSB2YWx1ZSB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB1c2VyIGFuZCBhbGxvdyB0aGVtIHRvIGNvcnJlY3QgdGhlaXIgbWlzdGFrZS5cbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQudmFsdWUuc3Vic3RyaW5nKDAsIGxhc3RNYXRjaCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5wYXJ0aWFsUG9zaXRpb24gPyBpIDogdGhpcy5maXJzdE5vbk1hc2tQb3MpO1xuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2FyZXRUaW1lb3V0SWQpO1xuICAgICAgICB2YXIgcG9zO1xuICAgICAgICB0aGlzLmZvY3VzVGV4dCA9IHRoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgICAgcG9zID0gdGhpcy5jaGVja1ZhbCgpO1xuICAgICAgICB0aGlzLmNhcmV0VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaW5wdXRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLndyaXRlQnVmZmVyKCk7XG4gICAgICAgICAgICBpZiAocG9zID09IF90aGlzLm1hc2sucmVwbGFjZShcIj9cIiwgXCJcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2FyZXQoMCwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNhcmV0KHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwKTtcbiAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5vbklucHV0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmFuZHJvaWRDaHJvbWUpXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUFuZHJvaWRJbnB1dChldmVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5wdXRDaGFuZ2UoZXZlbnQpO1xuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5oYW5kbGVJbnB1dENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF90aGlzLmNoZWNrVmFsKHRydWUpO1xuICAgICAgICAgICAgX3RoaXMuY2FyZXQocG9zKTtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZU1vZGVsKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Db21wbGV0ZS5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5nZXRVbm1hc2tlZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdW5tYXNrZWRCdWZmZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRlc3RzW2ldICYmIGMgIT0gdGhpcy5nZXRQbGFjZWhvbGRlcihpKSkge1xuICAgICAgICAgICAgICAgIHVubWFza2VkQnVmZmVyLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVubWFza2VkQnVmZmVyLmpvaW4oJycpO1xuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLnVubWFzayA/IHRoaXMuZ2V0VW5tYXNrZWRWYWx1ZSgpIDogZS50YXJnZXQudmFsdWUpO1xuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS51cGRhdGVGaWxsZWRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWxsZWQgPSB0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQgJiYgdGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnZhbHVlICE9ICcnO1xuICAgIH07XG4gICAgSW5wdXRNYXNrLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIHJldHVybiBJbnB1dE1hc2s7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIElucHV0TWFzay5wcm90b3R5cGUsIFwibWFza1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIElucHV0TWFzay5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIElucHV0TWFzay5wcm90b3R5cGUsIFwic2xvdENoYXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSW5wdXRNYXNrLnByb3RvdHlwZSwgXCJhdXRvQ2xlYXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBJbnB1dE1hc2sucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgSW5wdXRNYXNrLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgSW5wdXRNYXNrLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgSW5wdXRNYXNrLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIElucHV0TWFzay5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIElucHV0TWFzay5wcm90b3R5cGUsIFwibWF4bGVuZ3RoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgSW5wdXRNYXNrLnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBJbnB1dE1hc2sucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIElucHV0TWFzay5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgSW5wdXRNYXNrLnByb3RvdHlwZSwgXCJ1bm1hc2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBJbnB1dE1hc2sucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2lucHV0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgSW5wdXRNYXNrLnByb3RvdHlwZSwgXCJpbnB1dFZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgSW5wdXRNYXNrLnByb3RvdHlwZSwgXCJvbkNvbXBsZXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBJbnB1dE1hc2sucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIElucHV0TWFzay5wcm90b3R5cGUsIFwib25CbHVyXCIsIHZvaWQgMCk7XG5JbnB1dE1hc2sgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWlucHV0TWFzaycsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpbnB1dCAjaW5wdXQgcElucHV0VGV4dCBbYXR0ci5pZF09XFxcImlucHV0SWRcXFwiIFthdHRyLnR5cGVdPVxcXCJ0eXBlXFxcIiBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW25nQ2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIiBbYXR0ci5wbGFjZWhvbGRlcl09XFxcInBsYWNlaG9sZGVyXFxcIlxcbiAgICAgICAgW2F0dHIuc2l6ZV09XFxcInNpemVcXFwiIFthdHRyLm1heGxlbmd0aF09XFxcIm1heGxlbmd0aFxcXCIgW2F0dHIudGFiaW5kZXhdPVxcXCJ0YWJpbmRleFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFtyZWFkb25seV09XFxcInJlYWRvbmx5XFxcIlxcbiAgICAgICAgKGZvY3VzKT1cXFwib25JbnB1dEZvY3VzKCRldmVudClcXFwiIChibHVyKT1cXFwib25JbnB1dEJsdXIoJGV2ZW50KVxcXCIgKGtleWRvd24pPVxcXCJvbktleURvd24oJGV2ZW50KVxcXCIgKGtleXByZXNzKT1cXFwib25LZXlQcmVzcygkZXZlbnQpXFxcIlxcbiAgICAgICAgKGlucHV0KT1cXFwib25JbnB1dCgkZXZlbnQpXFxcIiAocGFzdGUpPVxcXCJoYW5kbGVJbnB1dENoYW5nZSgkZXZlbnQpXFxcIj5cIixcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ1tjbGFzcy51aS1pbnB1dHdyYXBwZXItZmlsbGVkXSc6ICdmaWxsZWQnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS1pbnB1dHdyYXBwZXItZm9jdXNdJzogJ2ZvY3VzJ1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLklOUFVUTUFTS19WQUxVRV9BQ0NFU1NPUiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZiwgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdKVxuXSwgSW5wdXRNYXNrKTtcbmV4cG9ydHMuSW5wdXRNYXNrID0gSW5wdXRNYXNrO1xudmFyIElucHV0TWFza01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wdXRNYXNrTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gSW5wdXRNYXNrTW9kdWxlO1xufSgpKTtcbklucHV0TWFza01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIGlucHV0dGV4dF8xLklucHV0VGV4dE1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtJbnB1dE1hc2tdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtJbnB1dE1hc2tdXG4gICAgfSlcbl0sIElucHV0TWFza01vZHVsZSk7XG5leHBvcnRzLklucHV0TWFza01vZHVsZSA9IElucHV0TWFza01vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0bWFzay5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2lucHV0bWFzay9pbnB1dG1hc2suanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9pbnB1dG1hc2svaW5wdXRtYXNrLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZm9ybXNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG5leHBvcnRzLklOUFVUU1dJVENIX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IGZvcm1zXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIElucHV0U3dpdGNoOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBJbnB1dFN3aXRjaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wdXRTd2l0Y2goZWwsIGRvbUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLm9uTGFiZWwgPSAnT24nO1xuICAgICAgICB0aGlzLm9mZkxhYmVsID0gJ09mZic7XG4gICAgICAgIHRoaXMuYXJpYUxhYmVsVGVtcGxhdGUgPSBcIklucHV0U3dpdGNoIHswfVwiO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgSW5wdXRTd2l0Y2gucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIHRoaXMuaGFuZGxlID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnZGl2LnVpLWlucHV0c3dpdGNoLWhhbmRsZScpO1xuICAgICAgICB0aGlzLm9uQ29udGFpbmVyID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5jb250YWluZXIsICdkaXYudWktaW5wdXRzd2l0Y2gtb24nKTtcbiAgICAgICAgdGhpcy5vZmZDb250YWluZXIgPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLmNvbnRhaW5lciwgJ2Rpdi51aS1pbnB1dHN3aXRjaC1vZmYnKTtcbiAgICAgICAgdGhpcy5vbkxhYmVsQ2hpbGQgPSB0aGlzLmRvbUhhbmRsZXIuZmluZFNpbmdsZSh0aGlzLm9uQ29udGFpbmVyLCAnc3Bhbi51aS1pbnB1dHN3aXRjaC1vbmxhYmVsJyk7XG4gICAgICAgIHRoaXMub2ZmTGFiZWxDaGlsZCA9IHRoaXMuZG9tSGFuZGxlci5maW5kU2luZ2xlKHRoaXMub2ZmQ29udGFpbmVyLCAnc3Bhbi51aS1pbnB1dHN3aXRjaC1vZmZsYWJlbCcpO1xuICAgIH07XG4gICAgSW5wdXRTd2l0Y2gucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLm9mZnNldFBhcmVudCAmJiAhdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRTd2l0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9uQ29udGFpbmVyV2lkdGggPSB0aGlzLmRvbUhhbmRsZXIud2lkdGgodGhpcy5vbkNvbnRhaW5lciksIG9mZkNvbnRhaW5lcldpZHRoID0gdGhpcy5kb21IYW5kbGVyLndpZHRoKHRoaXMub2ZmQ29udGFpbmVyKSwgc3BhblBhZGRpbmcgPSB0aGlzLmRvbUhhbmRsZXIuaW5uZXJXaWR0aCh0aGlzLm9mZkxhYmVsQ2hpbGQpIC0gdGhpcy5kb21IYW5kbGVyLndpZHRoKHRoaXMub2ZmTGFiZWxDaGlsZCksIGhhbmRsZU1hcmdpbnMgPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aCh0aGlzLmhhbmRsZSkgLSB0aGlzLmRvbUhhbmRsZXIuaW5uZXJXaWR0aCh0aGlzLmhhbmRsZSk7XG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IChvbkNvbnRhaW5lcldpZHRoID4gb2ZmQ29udGFpbmVyV2lkdGgpID8gb25Db250YWluZXJXaWR0aCA6IG9mZkNvbnRhaW5lcldpZHRoLCBoYW5kbGVXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgICB0aGlzLmhhbmRsZS5zdHlsZS53aWR0aCA9IGhhbmRsZVdpZHRoICsgJ3B4JztcbiAgICAgICAgaGFuZGxlV2lkdGggPSB0aGlzLmRvbUhhbmRsZXIud2lkdGgodGhpcy5oYW5kbGUpO1xuICAgICAgICBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lcldpZHRoICsgaGFuZGxlV2lkdGggKyA2O1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gaGFuZGxlV2lkdGggLSBzcGFuUGFkZGluZyAtIGhhbmRsZU1hcmdpbnM7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoID0gY29udGFpbmVyV2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLm9uTGFiZWxDaGlsZC5zdHlsZS53aWR0aCA9IGxhYmVsV2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLm9mZkxhYmVsQ2hpbGQuc3R5bGUud2lkdGggPSBsYWJlbFdpZHRoICsgJ3B4JztcbiAgICAgICAgLy9wb3NpdGlvblxuICAgICAgICB0aGlzLm9mZkNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICh0aGlzLmRvbUhhbmRsZXIud2lkdGgodGhpcy5jb250YWluZXIpIC0gNSkgKyAncHgnO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuZG9tSGFuZGxlci53aWR0aCh0aGlzLmNvbnRhaW5lcikgLSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aCh0aGlzLmhhbmRsZSk7XG4gICAgICAgIC8vZGVmYXVsdCB2YWx1ZVxuICAgICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZS5zdHlsZS5sZWZ0ID0gdGhpcy5vZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMub2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMub2ZmTGFiZWxDaGlsZC5zdHlsZS5tYXJnaW5SaWdodCA9IC10aGlzLm9mZnNldCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29udGFpbmVyLnN0eWxlLndpZHRoID0gMCArICdweCc7XG4gICAgICAgICAgICB0aGlzLm9uTGFiZWxDaGlsZC5zdHlsZS5tYXJnaW5MZWZ0ID0gLXRoaXMub2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIElucHV0U3dpdGNoLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZXZlbnQsIGNoZWNrYm94KSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5jaGVja1VJKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tVSSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlKHRoaXMuY2hlY2tlZCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGVja2JveC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnB1dFN3aXRjaC5wcm90b3R5cGUuY2hlY2tVSSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbkNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMub2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5vbkxhYmVsQ2hpbGQuc3R5bGUubWFyZ2luTGVmdCA9IDAgKyAncHgnO1xuICAgICAgICB0aGlzLm9mZkxhYmVsQ2hpbGQuc3R5bGUubWFyZ2luUmlnaHQgPSAtdGhpcy5vZmZzZXQgKyAncHgnO1xuICAgICAgICB0aGlzLmhhbmRsZS5zdHlsZS5sZWZ0ID0gdGhpcy5vZmZzZXQgKyAncHgnO1xuICAgICAgICB0aGlzLnVwZGF0ZUFyaWFMYWJlbCgpO1xuICAgIH07XG4gICAgSW5wdXRTd2l0Y2gucHJvdG90eXBlLnVuY2hlY2tVSSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbkNvbnRhaW5lci5zdHlsZS53aWR0aCA9IDAgKyAncHgnO1xuICAgICAgICB0aGlzLm9uTGFiZWxDaGlsZC5zdHlsZS5tYXJnaW5MZWZ0ID0gLXRoaXMub2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5vZmZMYWJlbENoaWxkLnN0eWxlLm1hcmdpblJpZ2h0ID0gMCArICdweCc7XG4gICAgICAgIHRoaXMuaGFuZGxlLnN0eWxlLmxlZnQgPSAwICsgJ3B4JztcbiAgICAgICAgdGhpcy51cGRhdGVBcmlhTGFiZWwoKTtcbiAgICB9O1xuICAgIElucHV0U3dpdGNoLnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG4gICAgfTtcbiAgICBJbnB1dFN3aXRjaC5wcm90b3R5cGUub25CbHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkKCk7XG4gICAgfTtcbiAgICBJbnB1dFN3aXRjaC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uIChjaGVja2VkKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja2VkID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tVSSgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMudW5jaGVja1VJKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0U3dpdGNoLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgSW5wdXRTd2l0Y2gucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIElucHV0U3dpdGNoLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdmFsO1xuICAgIH07XG4gICAgSW5wdXRTd2l0Y2gucHJvdG90eXBlLnVwZGF0ZUFyaWFMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSAveyguKj8pfS8sIHZhbHVlID0gdGhpcy5jaGVja2VkID8gdGhpcy5vbkxhYmVsIDogdGhpcy5vZmZMYWJlbDtcbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSB0aGlzLmFyaWFMYWJlbFRlbXBsYXRlLnJlcGxhY2UodGhpcy5hcmlhTGFiZWxUZW1wbGF0ZS5tYXRjaChwYXR0ZXJuKVswXSwgdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIElucHV0U3dpdGNoO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBJbnB1dFN3aXRjaC5wcm90b3R5cGUsIFwib25MYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIElucHV0U3dpdGNoLnByb3RvdHlwZSwgXCJvZmZMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBJbnB1dFN3aXRjaC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBJbnB1dFN3aXRjaC5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBJbnB1dFN3aXRjaC5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIElucHV0U3dpdGNoLnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIElucHV0U3dpdGNoLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgSW5wdXRTd2l0Y2gucHJvdG90eXBlLCBcImFyaWFMYWJlbFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBJbnB1dFN3aXRjaC5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbklucHV0U3dpdGNoID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1pbnB1dFN3aXRjaCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcInsndWktaW5wdXRzd2l0Y2ggdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnOiB0cnVlLFxcbiAgICAgICAgICAgICd1aS1zdGF0ZS1kaXNhYmxlZCc6IGRpc2FibGVkLCd1aS1pbnB1dHN3aXRjaC1jaGVja2VkJzpjaGVja2VkLCAndWktc3RhdGUtZm9jdXMnOmZvY3VzZWR9XFxcIiAoY2xpY2spPVxcXCJ0b2dnbGUoJGV2ZW50LCBpbilcXFwiXFxuICAgICAgICAgICAgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaW5wdXRzd2l0Y2gtb2ZmXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWlucHV0c3dpdGNoLW9mZmxhYmVsXFxcIj57e29mZkxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaW5wdXRzd2l0Y2gtb25cXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktaW5wdXRzd2l0Y2gtb25sYWJlbFxcXCI+e3tvbkxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcInsndWktaW5wdXRzd2l0Y2gtaGFuZGxlIHVpLXN0YXRlLWRlZmF1bHQnOnRydWUsICd1aS1zdGF0ZS1mb2N1cyc6Zm9jdXNlZH1cXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCAjaW4gdHlwZT1cXFwiY2hlY2tib3hcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJhcmlhTGFiZWxcXFwiIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XFxcImFyaWFMYWJlbGxlZEJ5XFxcIiBhcmlhLWxpdmU9XFxcInBvbGl0ZVxcXCIgW2F0dHIuaWRdPVxcXCJpbnB1dElkXFxcIiAoZm9jdXMpPVxcXCJvbkZvY3VzKCRldmVudClcXFwiIChibHVyKT1cXFwib25CbHVyKCRldmVudClcXFwiIHJlYWRvbmx5PVxcXCJyZWFkb25seVxcXCIgW2F0dHIudGFiaW5kZXhdPVxcXCJ0YWJpbmRleFxcXCIvPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLklOUFVUU1dJVENIX1ZBTFVFX0FDQ0VTU09SLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl0pXG5dLCBJbnB1dFN3aXRjaCk7XG5leHBvcnRzLklucHV0U3dpdGNoID0gSW5wdXRTd2l0Y2g7XG52YXIgSW5wdXRTd2l0Y2hNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElucHV0U3dpdGNoTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gSW5wdXRTd2l0Y2hNb2R1bGU7XG59KCkpO1xuSW5wdXRTd2l0Y2hNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0lucHV0U3dpdGNoXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbSW5wdXRTd2l0Y2hdXG4gICAgfSlcbl0sIElucHV0U3dpdGNoTW9kdWxlKTtcbmV4cG9ydHMuSW5wdXRTd2l0Y2hNb2R1bGUgPSBJbnB1dFN3aXRjaE1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0c3dpdGNoLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvaW5wdXRzd2l0Y2gvaW5wdXRzd2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9pbnB1dHN3aXRjaC9pbnB1dHN3aXRjaC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIElucHV0VGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wdXRUZXh0KGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICB9XG4gICAgSW5wdXRUZXh0LnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRmlsbGVkU3RhdGUoKTtcbiAgICB9O1xuICAgIC8vVG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIHRvIG1hbmFnZSB1aS1zdGF0ZS1maWxsZWQgZm9yIG1hdGVyaWFsIGxhYmVscyB3aGVuIHRoZXJlIGlzIG5vIHZhbHVlIGJpbmRpbmdcbiAgICBJbnB1dFRleHQucHJvdG90eXBlLm9uSW5wdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgfTtcbiAgICBJbnB1dFRleHQucHJvdG90eXBlLnVwZGF0ZUZpbGxlZFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZpbGxlZCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC52YWx1ZSAmJiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIElucHV0VGV4dDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdpbnB1dCcsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgSW5wdXRUZXh0LnByb3RvdHlwZSwgXCJvbklucHV0XCIsIG51bGwpO1xuSW5wdXRUZXh0ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkRpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW3BJbnB1dFRleHRdJyxcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ1tjbGFzcy51aS1pbnB1dHRleHRdJzogJ3RydWUnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS1jb3JuZXItYWxsXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICdbY2xhc3MudWktc3RhdGUtZGVmYXVsdF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAnW2NsYXNzLnVpLXdpZGdldF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAnW2NsYXNzLnVpLXN0YXRlLWZpbGxlZF0nOiAnZmlsbGVkJ1xuICAgICAgICB9XG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZl0pXG5dLCBJbnB1dFRleHQpO1xuZXhwb3J0cy5JbnB1dFRleHQgPSBJbnB1dFRleHQ7XG52YXIgSW5wdXRUZXh0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnB1dFRleHRNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBJbnB1dFRleHRNb2R1bGU7XG59KCkpO1xuSW5wdXRUZXh0TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtJbnB1dFRleHRdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtJbnB1dFRleHRdXG4gICAgfSlcbl0sIElucHV0VGV4dE1vZHVsZSk7XG5leHBvcnRzLklucHV0VGV4dE1vZHVsZSA9IElucHV0VGV4dE1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0dGV4dC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL2lucHV0dGV4dC9pbnB1dHRleHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9pbnB1dHRleHQvaW5wdXR0ZXh0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgSW5wdXRUZXh0YXJlYSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wdXRUZXh0YXJlYShlbCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMub25SZXNpemUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBJbnB1dFRleHRhcmVhLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yb3dzRGVmYXVsdCA9IHRoaXMucm93cztcbiAgICAgICAgdGhpcy5jb2xzRGVmYXVsdCA9IHRoaXMuY29scztcbiAgICB9O1xuICAgIElucHV0VGV4dGFyZWEucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGaWxsZWRTdGF0ZSgpO1xuICAgIH07XG4gICAgLy9UbyB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gdG8gbWFuYWdlIHVpLXN0YXRlLWZpbGxlZCBmb3IgbWF0ZXJpYWwgbGFiZWxzIHdoZW4gdGhlcmUgaXMgbm8gdmFsdWUgYmluZGluZ1xuICAgIElucHV0VGV4dGFyZWEucHJvdG90eXBlLm9uSW5wdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgfTtcbiAgICBJbnB1dFRleHRhcmVhLnByb3RvdHlwZS51cGRhdGVGaWxsZWRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWxsZWQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUgJiYgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnZhbHVlLmxlbmd0aDtcbiAgICB9O1xuICAgIElucHV0VGV4dGFyZWEucHJvdG90eXBlLm9uRm9jdXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZShlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRUZXh0YXJlYS5wcm90b3R5cGUub25CbHVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0VGV4dGFyZWEucHJvdG90eXBlLm9uS2V5dXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZShlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRUZXh0YXJlYS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBsaW5lc0NvdW50ID0gMCwgbGluZXMgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUuc3BsaXQoJ1xcbicpO1xuICAgICAgICBmb3IgKHZhciBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxpbmVzQ291bnQgKz0gTWF0aC5mbG9vcigobGluZXNbaV0ubGVuZ3RoIC8gdGhpcy5jb2xzRGVmYXVsdCkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd3MgPSAobGluZXNDb3VudCA+PSB0aGlzLnJvd3NEZWZhdWx0KSA/IChsaW5lc0NvdW50ICsgMSkgOiB0aGlzLnJvd3NEZWZhdWx0O1xuICAgICAgICB0aGlzLm9uUmVzaXplLmVtaXQoZXZlbnQgfHwge30pO1xuICAgIH07XG4gICAgcmV0dXJuIElucHV0VGV4dGFyZWE7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBJbnB1dFRleHRhcmVhLnByb3RvdHlwZSwgXCJhdXRvUmVzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgSW5wdXRUZXh0YXJlYS5wcm90b3R5cGUsIFwicm93c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIElucHV0VGV4dGFyZWEucHJvdG90eXBlLCBcImNvbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIElucHV0VGV4dGFyZWEucHJvdG90eXBlLCBcIm9uUmVzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdpbnB1dCcsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgSW5wdXRUZXh0YXJlYS5wcm90b3R5cGUsIFwib25JbnB1dFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Ib3N0TGlzdGVuZXIoJ2ZvY3VzJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBJbnB1dFRleHRhcmVhLnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkhvc3RMaXN0ZW5lcignYmx1cicsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgSW5wdXRUZXh0YXJlYS5wcm90b3R5cGUsIFwib25CbHVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkhvc3RMaXN0ZW5lcigna2V5dXAnLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIElucHV0VGV4dGFyZWEucHJvdG90eXBlLCBcIm9uS2V5dXBcIiwgbnVsbCk7XG5JbnB1dFRleHRhcmVhID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkRpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW3BJbnB1dFRleHRhcmVhXScsXG4gICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICdbY2xhc3MudWktaW5wdXR0ZXh0XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICdbY2xhc3MudWktY29ybmVyLWFsbF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAnW2NsYXNzLnVpLXN0YXRlLWRlZmF1bHRdJzogJ3RydWUnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS13aWRnZXRdJzogJ3RydWUnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS1zdGF0ZS1maWxsZWRdJzogJ2ZpbGxlZCcsXG4gICAgICAgICAgICAnW2F0dHIucm93c10nOiAncm93cycsXG4gICAgICAgICAgICAnW2F0dHIuY29sc10nOiAnY29scydcbiAgICAgICAgfVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWZdKVxuXSwgSW5wdXRUZXh0YXJlYSk7XG5leHBvcnRzLklucHV0VGV4dGFyZWEgPSBJbnB1dFRleHRhcmVhO1xudmFyIElucHV0VGV4dGFyZWFNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElucHV0VGV4dGFyZWFNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBJbnB1dFRleHRhcmVhTW9kdWxlO1xufSgpKTtcbklucHV0VGV4dGFyZWFNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0lucHV0VGV4dGFyZWFdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtJbnB1dFRleHRhcmVhXVxuICAgIH0pXG5dLCBJbnB1dFRleHRhcmVhTW9kdWxlKTtcbmV4cG9ydHMuSW5wdXRUZXh0YXJlYU1vZHVsZSA9IElucHV0VGV4dGFyZWFNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dHRleHRhcmVhLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvaW5wdXR0ZXh0YXJlYS9pbnB1dHRleHRhcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvaW5wdXR0ZXh0YXJlYS9pbnB1dHRleHRhcmVhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIExpZ2h0Ym94ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaWdodGJveChlbCwgZG9tSGFuZGxlciwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMudHlwZSA9ICdpbWFnZSc7XG4gICAgICAgIHRoaXMuZWZmZWN0RHVyYXRpb24gPSAnNTAwbXMnO1xuICAgIH1cbiAgICBMaWdodGJveC5wcm90b3R5cGUub25JbWFnZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBpbWFnZSwgaSwgY29udGVudCkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgY29udGVudC5zdHlsZS53aWR0aCA9IDMyICsgJ3B4JztcbiAgICAgICAgY29udGVudC5zdHlsZS5oZWlnaHQgPSAzMiArICdweCc7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB0aGlzLmRpc3BsYXlJbWFnZShpbWFnZSk7XG4gICAgICAgIHRoaXMucHJldmVudERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRydWU7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBMaWdodGJveC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBhbmVsID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnLnVpLWxpZ2h0Ym94ICcpO1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRUbykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8gPT09ICdib2R5JylcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucGFuZWwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hcHBlbmRDaGlsZCh0aGlzLnBhbmVsLCB0aGlzLmFwcGVuZFRvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcmV2ZW50RG9jdW1lbnRDbGlja0xpc3RlbmVyICYmIF90aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnByZXZlbnREb2N1bWVudENsaWNrTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMaWdodGJveC5wcm90b3R5cGUub25MaW5rQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIHRoaXMucHJldmVudERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRydWU7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBMaWdodGJveC5wcm90b3R5cGUuZGlzcGxheUltYWdlID0gZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY3VycmVudEltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICBfdGhpcy5jYXB0aW9uVGV4dCA9IGltYWdlLnRpdGxlO1xuICAgICAgICAgICAgX3RoaXMuY2VudGVyKCk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH07XG4gICAgTGlnaHRib3gucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm1hc2suc3R5bGUuekluZGV4ID0gKytkb21oYW5kbGVyXzEuRG9tSGFuZGxlci56aW5kZXg7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5hZGRNdWx0aXBsZUNsYXNzZXModGhpcy5tYXNrLCAndWktd2lkZ2V0LW92ZXJsYXkgdWktZGlhbG9nLW1hc2snKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm1hc2spO1xuICAgICAgICB0aGlzLnppbmRleCA9ICsrZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4O1xuICAgICAgICB0aGlzLmNlbnRlcigpO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIH07XG4gICAgTGlnaHRib3gucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jYXB0aW9uVGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRJbWFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhbmVsLnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgICAgIHRoaXMucGFuZWwuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICBpZiAodGhpcy5tYXNrKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubWFzayk7XG4gICAgICAgICAgICB0aGlzLm1hc2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBMaWdodGJveC5wcm90b3R5cGUuY2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxlbWVudFdpZHRoID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVyV2lkdGgodGhpcy5wYW5lbCk7XG4gICAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHRoaXMucGFuZWwpO1xuICAgICAgICBpZiAoZWxlbWVudFdpZHRoID09IDAgJiYgZWxlbWVudEhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIHRoaXMucGFuZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICBlbGVtZW50V2lkdGggPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aCh0aGlzLnBhbmVsKTtcbiAgICAgICAgICAgIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJIZWlnaHQodGhpcy5wYW5lbCk7XG4gICAgICAgICAgICB0aGlzLnBhbmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLnBhbmVsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5kb21IYW5kbGVyLmdldFZpZXdwb3J0KCk7XG4gICAgICAgIHZhciB4ID0gKHZpZXdwb3J0LndpZHRoIC0gZWxlbWVudFdpZHRoKSAvIDI7XG4gICAgICAgIHZhciB5ID0gKHZpZXdwb3J0LmhlaWdodCAtIGVsZW1lbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgdGhpcy5wYW5lbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIHRoaXMucGFuZWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgfTtcbiAgICBMaWdodGJveC5wcm90b3R5cGUub25JbWFnZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGltYWdlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpbWFnZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGltYWdlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB2YXIgaW1hZ2VXaWR0aCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlcldpZHRoKGltYWdlKTtcbiAgICAgICAgdmFyIGltYWdlSGVpZ2h0ID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KGltYWdlKTtcbiAgICAgICAgaW1hZ2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgaW1hZ2Uuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgY29udGVudC5zdHlsZS53aWR0aCA9IGltYWdlV2lkdGggKyAncHgnO1xuICAgICAgICBjb250ZW50LnN0eWxlLmhlaWdodCA9IGltYWdlSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5wYW5lbC5zdHlsZS5sZWZ0ID0gcGFyc2VJbnQodGhpcy5wYW5lbC5zdHlsZS5sZWZ0KSArICh0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aCh0aGlzLnBhbmVsKSAtIGltYWdlV2lkdGgpIC8gMiArICdweCc7XG4gICAgICAgIHRoaXMucGFuZWwuc3R5bGUudG9wID0gcGFyc2VJbnQodGhpcy5wYW5lbC5zdHlsZS50b3ApICsgKHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlckhlaWdodCh0aGlzLnBhbmVsKSAtIGltYWdlSGVpZ2h0KSAvIDIgKyAncHgnO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmRvbUhhbmRsZXIuZmFkZUluKGltYWdlLCA1MDApO1xuICAgICAgICAgICAgaW1hZ2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAvL3RoaXMuY2FwdGlvblRleHQgPSB0aGlzLmN1cnJlbnRJbWFnZS50aXRsZTtcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgcGFyc2VJbnQodGhpcy5lZmZlY3REdXJhdGlvbikpO1xuICAgIH07XG4gICAgTGlnaHRib3gucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5jYXB0aW9uVGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5SW1hZ2UodGhpcy5pbWFnZXNbLS10aGlzLmluZGV4XSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpZ2h0Ym94LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMuY2FwdGlvblRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICBwbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8PSAodGhpcy5pbWFnZXMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheUltYWdlKHRoaXMuaW1hZ2VzWysrdGhpcy5pbmRleF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlnaHRib3gucHJvdG90eXBlLCBcImxlZnRWaXNpYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXMgJiYgdGhpcy5pbWFnZXMubGVuZ3RoICYmIHRoaXMuaW5kZXggIT0gMCAmJiAhdGhpcy5sb2FkaW5nO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlnaHRib3gucHJvdG90eXBlLCBcInJpZ2h0VmlzaWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VzICYmIHRoaXMuaW1hZ2VzLmxlbmd0aCAmJiB0aGlzLmluZGV4IDwgKHRoaXMuaW1hZ2VzLmxlbmd0aCAtIDEpICYmICF0aGlzLmxvYWRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExpZ2h0Ym94LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5wYW5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMaWdodGJveDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBMaWdodGJveC5wcm90b3R5cGUsIFwiaW1hZ2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTGlnaHRib3gucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMaWdodGJveC5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMaWdodGJveC5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExpZ2h0Ym94LnByb3RvdHlwZSwgXCJhcHBlbmRUb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExpZ2h0Ym94LnByb3RvdHlwZSwgXCJlYXNpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMaWdodGJveC5wcm90b3R5cGUsIFwiZWZmZWN0RHVyYXRpb25cIiwgdm9pZCAwKTtcbkxpZ2h0Ym94ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1saWdodGJveCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIiAqbmdJZj1cXFwiKHR5cGUgPT0gJ2ltYWdlJylcXFwiPlxcbiAgICAgICAgICAgIDxhICpuZ0Zvcj1cXFwibGV0IGltYWdlIG9mIGltYWdlczsgbGV0IGkgPSBpbmRleDtcXFwiIFtocmVmXT1cXFwiaW1hZ2Uuc291cmNlXFxcIiAoY2xpY2spPVxcXCJvbkltYWdlQ2xpY2soJGV2ZW50LGltYWdlLGksY29udGVudClcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW1nIFtzcmNdPVxcXCJpbWFnZS50aHVtYm5haWxcXFwiIFt0aXRsZV09XFxcImltYWdlLnRpdGxlXFxcIiBbYWx0XT1cXFwiaW1hZ2UuYWx0XFxcIj5cXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxzcGFuIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiICpuZ0lmPVxcXCIodHlwZSA9PSAnY29udGVudCcpXFxcIiAoY2xpY2spPVxcXCJvbkxpbmtDbGljaygkZXZlbnQsY29udGVudClcXFwiPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwiYVxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktbGlnaHRib3ggdWktd2lkZ2V0IHVpLWhlbHBlci1oaWRkZW4gdWktY29ybmVyLWFsbCB1aS1zaGFkb3dcXFwiIFtzdHlsZS5kaXNwbGF5XT1cXFwidmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSdcXFwiIFtzdHlsZS56SW5kZXhdPVxcXCJ6aW5kZXhcXFwiXFxuICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLWxpZ2h0Ym94LWxvYWRpbmcnOiBsb2FkaW5nfVxcXCJcXG4gICAgICAgICAgICBbc3R5bGUudHJhbnNpdGlvblByb3BlcnR5XT1cXFwiJ2FsbCdcXFwiIFtzdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dPVxcXCJlZmZlY3REdXJhdGlvblxcXCIgW3N0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbl09XFxcImVhc2luZ1xcXCIgKGNsaWNrKT1cXFwicHJldmVudERvY3VtZW50Q2xpY2tMaXN0ZW5lcj10cnVlXFxcIj5cXG4gICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWxpZ2h0Ym94LWNvbnRlbnQtd3JhcHBlclxcXCI+XFxuICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwidWktc3RhdGUtZGVmYXVsdCB1aS1saWdodGJveC1uYXYtbGVmdCB1aS1jb3JuZXItcmlnaHRcXFwiIFtzdHlsZS56SW5kZXhdPVxcXCJ6aW5kZXggKyAxXFxcIiAoY2xpY2spPVxcXCJwcmV2KGltZylcXFwiXFxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1oZWxwZXItaGlkZGVuJzohbGVmdFZpc2libGV9XFxcIj48c3BhbiBjbGFzcz1cXFwiZmEgZmEtZncgZmEtY2FyZXQtbGVmdFxcXCI+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICAgIDxkaXYgI2NvbnRlbnQgY2xhc3M9XFxcInVpLWxpZ2h0Ym94LWNvbnRlbnQgdWktY29ybmVyLWFsbFxcXCIgI2NvbnRlbnQgXFxuICAgICAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uUHJvcGVydHldPVxcXCInd2lkdGgsaGVpZ2h0J1xcXCIgW3N0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl09XFxcImVmZmVjdER1cmF0aW9uXFxcIiBbc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXT1cXFwiZWFzaW5nXFxcIj5cXG4gICAgICAgICAgICAgICAgPGltZyAjaW1nIFtzcmNdPVxcXCJjdXJyZW50SW1hZ2UgPyBjdXJyZW50SW1hZ2Uuc291cmNlfHwnJyA6ICcnXFxcIiAobG9hZCk9XFxcIm9uSW1hZ2VMb2FkKCRldmVudCxjb250ZW50KVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcInVpLXN0YXRlLWRlZmF1bHQgdWktbGlnaHRib3gtbmF2LXJpZ2h0IHVpLWNvcm5lci1sZWZ0IHVpLWhlbHBlci1oaWRkZW5cXFwiIFtzdHlsZS56SW5kZXhdPVxcXCJ6aW5kZXggKyAxXFxcIiAoY2xpY2spPVxcXCJuZXh0KGltZylcXFwiXFxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1oZWxwZXItaGlkZGVuJzohcmlnaHRWaXNpYmxlfVxcXCI+PHNwYW4gY2xhc3M9XFxcImZhIGZhLWZ3IGZhLWNhcmV0LXJpZ2h0XFxcIj48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1saWdodGJveC1jYXB0aW9uIHVpLXdpZGdldC1oZWFkZXJcXFwiIFtzdHlsZS5kaXNwbGF5XT1cXFwiY2FwdGlvblRleHQgPyAnYmxvY2snIDogJ25vbmUnXFxcIj5cXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1saWdodGJveC1jYXB0aW9uLXRleHRcXFwiPnt7Y2FwdGlvblRleHR9fTwvc3Bhbj48YSBjbGFzcz1cXFwidWktbGlnaHRib3gtY2xvc2UgdWktY29ybmVyLWFsbFxcXCIgaHJlZj1cXFwiI1xcXCIgKGNsaWNrKT1cXFwiaGlkZSgkZXZlbnQpXFxcIj48c3BhbiBjbGFzcz1cXFwiZmEgZmEtZncgZmEtY2xvc2VcXFwiPjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVxcXCJjbGVhcjpib3RoXFxcIj48L2Rpdj5cXG4gICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMl0pXG5dLCBMaWdodGJveCk7XG5leHBvcnRzLkxpZ2h0Ym94ID0gTGlnaHRib3g7XG52YXIgTGlnaHRib3hNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpZ2h0Ym94TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTGlnaHRib3hNb2R1bGU7XG59KCkpO1xuTGlnaHRib3hNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW0xpZ2h0Ym94XSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbTGlnaHRib3hdXG4gICAgfSlcbl0sIExpZ2h0Ym94TW9kdWxlKTtcbmV4cG9ydHMuTGlnaHRib3hNb2R1bGUgPSBMaWdodGJveE1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZ2h0Ym94LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvbGlnaHRib3gvbGlnaHRib3guanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9saWdodGJveC9saWdodGJveC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zaGFyZWRcIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIG9iamVjdHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvb2JqZWN0dXRpbHNcIik7XG52YXIgZm9ybXNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKTtcbmV4cG9ydHMuTElTVEJPWF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBmb3Jtc18xLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBMaXN0Ym94OyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBMaXN0Ym94ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaXN0Ym94KGVsLCBkb21IYW5kbGVyLCBvYmplY3RVdGlscykge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMub2JqZWN0VXRpbHMgPSBvYmplY3RVdGlscztcbiAgICAgICAgdGhpcy5jaGVja2JveCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGFLZXlTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkRibENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIH1cbiAgICBMaXN0Ym94LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5nZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICBMaXN0Ym94LnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHZhbDtcbiAgICB9O1xuICAgIExpc3Rib3gucHJvdG90eXBlLm9uT3B0aW9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIG9wdGlvbikge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jaGVja2JveENsaWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSlcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3B0aW9uQ2xpY2tNdWx0aXBsZShldmVudCwgb3B0aW9uKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3B0aW9uQ2xpY2tTaW5nbGUoZXZlbnQsIG9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94Q2xpY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvblRvdWNoZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIExpc3Rib3gucHJvdG90eXBlLm9uT3B0aW9uVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQsIG9wdGlvbikge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uVG91Y2hlZCA9IHRydWU7XG4gICAgfTtcbiAgICBMaXN0Ym94LnByb3RvdHlwZS5vbk9wdGlvbkNsaWNrU2luZ2xlID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb24pIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5pc1NlbGVjdGVkKG9wdGlvbik7XG4gICAgICAgIHZhciB2YWx1ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG1ldGFTZWxlY3Rpb24gPSB0aGlzLm9wdGlvblRvdWNoZWQgPyBmYWxzZSA6IHRoaXMubWV0YUtleVNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG1ldGFTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBtZXRhS2V5ID0gKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWQgPyBudWxsIDogb3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUub25PcHRpb25DbGlja011bHRpcGxlID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb24pIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5pc1NlbGVjdGVkKG9wdGlvbik7XG4gICAgICAgIHZhciB2YWx1ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG1ldGFTZWxlY3Rpb24gPSB0aGlzLm9wdGlvblRvdWNoZWQgPyBmYWxzZSA6IHRoaXMubWV0YUtleVNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG1ldGFTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBtZXRhS2V5ID0gKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU9wdGlvbihvcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtvcHRpb24udmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IChtZXRhS2V5KSA/IHRoaXMudmFsdWUgfHwgW10gOiBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5jb25jYXQoW29wdGlvbi52YWx1ZV0pO1xuICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU9wdGlvbihvcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICh0aGlzLnZhbHVlIHx8IFtdKS5jb25jYXQoW29wdGlvbi52YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUucmVtb3ZlT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gIV90aGlzLm9iamVjdFV0aWxzLmVxdWFscyh2YWwsIG9wdGlvbi52YWx1ZSwgX3RoaXMuZGF0YUtleSk7IH0pO1xuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnZhbHVlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmplY3RVdGlscy5lcXVhbHModmFsLCBvcHRpb24udmFsdWUsIHRoaXMuZGF0YUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLm9iamVjdFV0aWxzLmVxdWFscyh0aGlzLnZhbHVlLCBvcHRpb24udmFsdWUsIHRoaXMuZGF0YUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3Rib3gucHJvdG90eXBlLCBcImFsbENoZWNrZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlclZhbHVlICYmIHRoaXMuZmlsdGVyVmFsdWUudHJpbSgpLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbGxGaWx0ZXJlZFNlbGVjdGVkKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgJiYgdGhpcy5vcHRpb25zICYmICh0aGlzLnZhbHVlLmxlbmd0aCA9PSB0aGlzLm9wdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGlzdGJveC5wcm90b3R5cGUuYWxsRmlsdGVyZWRTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbFNlbGVjdGVkO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAmJiB0aGlzLnZpc2libGVPcHRpb25zICYmIHRoaXMudmlzaWJsZU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhbGxTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy52aXNpYmxlT3B0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy52YWx1ZTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqZWN0VXRpbHMuZXF1YWxzKHZhbCwgb3B0LnZhbHVlLCB0aGlzLmRhdGFLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbFNlbGVjdGVkO1xuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUub25GaWx0ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy52aXNpYmxlT3B0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChvcHRpb24ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZU9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyZWQgPSB0cnVlO1xuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUudG9nZ2xlQWxsID0gZnVuY3Rpb24gKGV2ZW50LCBjaGVja2JveCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAodGhpcy5maWx0ZXJWYWx1ZSAmJiB0aGlzLmZpbHRlclZhbHVlLnRyaW0oKS5sZW5ndGggJiYgKCF0aGlzLnZpc2libGVPcHRpb25zIHx8IHRoaXMudmlzaWJsZU9wdGlvbnMubGVuZ3RoID09PSAwKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSAodGhpcy52aXNpYmxlT3B0aW9ucyAmJiB0aGlzLnZpc2libGVPcHRpb25zLmxlbmd0aCkgPyB0aGlzLnZpc2libGVPcHRpb25zIDogdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUucHVzaChvcHRzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9ICFjaGVja2JveC5jaGVja2VkO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCB2YWx1ZTogdGhpcy52YWx1ZSB9KTtcbiAgICB9O1xuICAgIExpc3Rib3gucHJvdG90eXBlLmlzSXRlbVZpc2libGUgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlclZhbHVlICYmIHRoaXMuZmlsdGVyVmFsdWUudHJpbSgpLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZpc2libGVPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlzaWJsZU9wdGlvbnNbaV0udmFsdWUgPT0gb3B0aW9uLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaXN0Ym94LnByb3RvdHlwZS5vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRGJsQ2xpY2suZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGlzdGJveC5wcm90b3R5cGUub25DaGVja2JveENsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrYm94Q2xpY2sgPSB0cnVlO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLmlzU2VsZWN0ZWQob3B0aW9uKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU9wdGlvbihvcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlIDogW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5jb25jYXQoW29wdGlvbi52YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGlzdGJveDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBMaXN0Ym94LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExpc3Rib3gucHJvdG90eXBlLCBcIm11bHRpcGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGlzdGJveC5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMaXN0Ym94LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExpc3Rib3gucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExpc3Rib3gucHJvdG90eXBlLCBcImNoZWNrYm94XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExpc3Rib3gucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMaXN0Ym94LnByb3RvdHlwZSwgXCJtZXRhS2V5U2VsZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTGlzdGJveC5wcm90b3R5cGUsIFwiZGF0YUtleVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgTGlzdGJveC5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIExpc3Rib3gucHJvdG90eXBlLCBcIm9uRGJsQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oc2hhcmVkXzEuUHJpbWVUZW1wbGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5RdWVyeUxpc3QpXG5dLCBMaXN0Ym94LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZXNcIiwgdm9pZCAwKTtcbkxpc3Rib3ggPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLWxpc3Rib3gnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJ7J3VpLWxpc3Rib3ggdWktaW5wdXR0ZXh0IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1zdGF0ZS1kaXNhYmxlZCc6ZGlzYWJsZWR9XFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGwgdWktbGlzdGJveC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4XFxcIiAqbmdJZj1cXFwiKGNoZWNrYm94ICYmIG11bHRpcGxlKSB8fCBmaWx0ZXJcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1saXN0Ym94LWhlYWRlci13LWNoZWNrYm94JzogY2hlY2tib3h9XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY2hrYm94IHVpLXdpZGdldFxcXCIgKm5nSWY9XFxcImNoZWNrYm94ICYmIG11bHRpcGxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0ICNjYiB0eXBlPVxcXCJjaGVja2JveFxcXCIgcmVhZG9ubHk9XFxcInJlYWRvbmx5XFxcIiBbY2hlY2tlZF09XFxcImFsbENoZWNrZWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jaGtib3gtYm94IHVpLXdpZGdldCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRlZmF1bHRcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1hY3RpdmUnOmFsbENoZWNrZWR9XFxcIiAoY2xpY2spPVxcXCJ0b2dnbGVBbGwoJGV2ZW50LGNiKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWNoa2JveC1pY29uIHVpLWNsaWNrYWJsZVxcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhIGZhLWNoZWNrJzphbGxDaGVja2VkfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1saXN0Ym94LWZpbHRlci1jb250YWluZXJcXFwiICpuZ0lmPVxcXCJmaWx0ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHJvbGU9XFxcInRleHRib3hcXFwiIChpbnB1dCk9XFxcIm9uRmlsdGVyKCRldmVudClcXFwiIGNsYXNzPVxcXCJ1aS1pbnB1dHRleHQgdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLXNlYXJjaFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcInVpLWxpc3Rib3gtbGlzdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSAqbmdGb3I9XFxcImxldCBvcHRpb24gb2Ygb3B0aW9uczsgbGV0IGkgPSBpbmRleDtcXFwiIFtzdHlsZS5kaXNwbGF5XT1cXFwiaXNJdGVtVmlzaWJsZShvcHRpb24pID8gJ2Jsb2NrJyA6ICdub25lJ1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1saXN0Ym94LWl0ZW0gdWktY29ybmVyLWFsbCc6dHJ1ZSwndWktc3RhdGUtaGlnaGxpZ2h0Jzppc1NlbGVjdGVkKG9wdGlvbil9XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwib25PcHRpb25DbGljaygkZXZlbnQsb3B0aW9uKVxcXCIgKGRibGNsaWNrKT1cXFwib25Eb3VibGVDbGljaygkZXZlbnQsb3B0aW9uKVxcXCIgKHRvdWNoZW5kKT1cXFwib25PcHRpb25Ub3VjaEVuZCgkZXZlbnQsb3B0aW9uKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jaGtib3ggdWktd2lkZ2V0XFxcIiAqbmdJZj1cXFwiY2hlY2tib3ggJiYgbXVsdGlwbGVcXFwiIChjbGljayk9XFxcIm9uQ2hlY2tib3hDbGljaygkZXZlbnQsb3B0aW9uKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBbY2hlY2tlZF09XFxcImlzU2VsZWN0ZWQob3B0aW9uKVxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWNoa2JveC1ib3ggdWktd2lkZ2V0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGVmYXVsdFxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWFjdGl2ZSc6aXNTZWxlY3RlZChvcHRpb24pfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1jaGtib3gtaWNvbiB1aS1jbGlja2FibGVcXFwiIFtuZ0NsYXNzXT1cXFwieydmYSBmYS1jaGVjayc6aXNTZWxlY3RlZChvcHRpb24pfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiIWl0ZW1UZW1wbGF0ZVxcXCI+e3tvcHRpb24ubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cXFwiaXRlbVRlbXBsYXRlXFxcIiBbcFRlbXBsYXRlV3JhcHBlcl09XFxcIml0ZW1UZW1wbGF0ZVxcXCIgW2l0ZW1dPVxcXCJvcHRpb25cXFwiIFtpbmRleF09XFxcImlcXFwiPjwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIsIG9iamVjdHV0aWxzXzEuT2JqZWN0VXRpbHMsIGV4cG9ydHMuTElTVEJPWF9WQUxVRV9BQ0NFU1NPUl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgb2JqZWN0dXRpbHNfMS5PYmplY3RVdGlsc10pXG5dLCBMaXN0Ym94KTtcbmV4cG9ydHMuTGlzdGJveCA9IExpc3Rib3g7XG52YXIgTGlzdGJveE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlzdGJveE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIExpc3Rib3hNb2R1bGU7XG59KCkpO1xuTGlzdGJveE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtMaXN0Ym94LCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtMaXN0Ym94XVxuICAgIH0pXG5dLCBMaXN0Ym94TW9kdWxlKTtcbmV4cG9ydHMuTGlzdGJveE1vZHVsZSA9IExpc3Rib3hNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0Ym94LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvbGlzdGJveC9saXN0Ym94LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvbGlzdGJveC9saXN0Ym94LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL3JvdXRlclwiKTtcbnZhciBNZWdhTWVudSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVnYU1lbnUoZWwsIGRvbUhhbmRsZXIsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICBNZWdhTWVudS5wcm90b3R5cGUub25JdGVtTW91c2VFbnRlciA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSwgbWVudWl0ZW0pIHtcbiAgICAgICAgaWYgKG1lbnVpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gaXRlbTtcbiAgICAgICAgdmFyIHN1Ym1lbnUgPSBpdGVtLmNoaWxkcmVuWzBdLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgaWYgKHN1Ym1lbnUpIHtcbiAgICAgICAgICAgIHN1Ym1lbnUuc3R5bGUuekluZGV4ID0gKytkb21oYW5kbGVyXzEuRG9tSGFuZGxlci56aW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgc3VibWVudS5zdHlsZS50b3AgPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJIZWlnaHQoaXRlbS5jaGlsZHJlblswXSkgKyAncHgnO1xuICAgICAgICAgICAgICAgIHN1Ym1lbnUuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHN1Ym1lbnUuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICAgICAgc3VibWVudS5zdHlsZS5sZWZ0ID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVyV2lkdGgoaXRlbS5jaGlsZHJlblswXSkgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNZWdhTWVudS5wcm90b3R5cGUub25JdGVtTW91c2VMZWF2ZSA9IGZ1bmN0aW9uIChldmVudCwgbGluaykge1xuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSBudWxsO1xuICAgIH07XG4gICAgTWVnYU1lbnUucHJvdG90eXBlLml0ZW1DbGljayA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWl0ZW0udXJsKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmNvbW1hbmQpIHtcbiAgICAgICAgICAgIGl0ZW0uY29tbWFuZCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gbnVsbDtcbiAgICB9O1xuICAgIE1lZ2FNZW51LnByb3RvdHlwZS5nZXRDb2x1bW5DbGFzcyA9IGZ1bmN0aW9uIChtZW51aXRlbSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gbWVudWl0ZW0uaXRlbXMgPyBtZW51aXRlbS5pdGVtcy5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgY29sdW1uQ2xhc3M7XG4gICAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY29sdW1uQ2xhc3MgPSAndWktZy02JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjb2x1bW5DbGFzcyA9ICd1aS1nLTQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNvbHVtbkNsYXNzID0gJ3VpLWctMyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgY29sdW1uQ2xhc3MgPSAndWktZy0yJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29sdW1uQ2xhc3MgPSAndWktZy0xMic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbkNsYXNzO1xuICAgIH07XG4gICAgcmV0dXJuIE1lZ2FNZW51O1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIE1lZ2FNZW51LnByb3RvdHlwZSwgXCJtb2RlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE1lZ2FNZW51LnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lZ2FNZW51LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTWVnYU1lbnUucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5NZWdhTWVudSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtbWVnYU1lbnUnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCJcXG4gICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktbWVudSB1aS1tZW51YmFyIHVpLW1lZ2FtZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLWhlbHBlci1jbGVhcmZpeCc6dHJ1ZSwndWktbWVnYW1lbnUtdmVydGljYWwnOiBvcmllbnRhdGlvbiA9PSAndmVydGljYWwnfVxcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS1tZW51LWxpc3QgdWktaGVscGVyLXJlc2V0IHVpLW1lbnViYXItcm9vdC1saXN0XFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jYXRlZ29yeSBbbmdGb3JPZl09XFxcIm1vZGVsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxsaSAqbmdJZj1cXFwiY2F0ZWdvcnkuc2VwYXJhdG9yXFxcIiBjbGFzcz1cXFwidWktbWVudS1zZXBhcmF0b3IgdWktd2lkZ2V0LWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGxpICpuZ0lmPVxcXCIhY2F0ZWdvcnkuc2VwYXJhdG9yXFxcIiAjaXRlbSBbbmdDbGFzc109XFxcInsndWktbWVudWl0ZW0gdWktd2lkZ2V0IHVpLWNvcm5lci1hbGwnOnRydWUsJ3VpLW1lbnUtcGFyZW50JzpjYXRlZ29yeS5pdGVtcywndWktbWVudWl0ZW0tYWN0aXZlJzppdGVtPT1hY3RpdmVJdGVtfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAobW91c2VlbnRlcik9XFxcIm9uSXRlbU1vdXNlRW50ZXIoJGV2ZW50LCBpdGVtLCBjYXRlZ29yeSlcXFwiIChtb3VzZWxlYXZlKT1cXFwib25JdGVtTW91c2VMZWF2ZSgkZXZlbnQsIGl0ZW0pXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwidWktbWVudWl0ZW0tbGluayB1aS1jb3JuZXItYWxsIHVpLXN1Ym1lbnUtbGlua1xcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzpjYXRlZ29yeS5kaXNhYmxlZH1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYSBmYS1md1xcXCIgW25nQ2xhc3NdPVxcXCJjYXRlZ29yeS5pY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS10ZXh0XFxcIj57e2NhdGVnb3J5LmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1zdWJtZW51LWljb24gZmEgZmEtZndcXFwiIFtuZ0NsYXNzXT1cXFwieydmYS1jYXJldC1kb3duJzpvcmllbnRhdGlvbj09J2hvcml6b250YWwnLCdmYS1jYXJldC1yaWdodCc6b3JpZW50YXRpb249PSd2ZXJ0aWNhbCd9XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW1lZ2FtZW51LXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLW1lbnUtbGlzdCB1aS1jb3JuZXItYWxsIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1tZW51LWNoaWxkIHVpLXNoYWRvd1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWdcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jb2x1bW4gW25nRm9yT2ZdPVxcXCJjYXRlZ29yeS5pdGVtc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBbY2xhc3NdPVxcXCJnZXRDb2x1bW5DbGFzcyhjYXRlZ29yeSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LXN1Ym1lbnUgW25nRm9yT2ZdPVxcXCJjb2x1bW5cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS1tZW51LWxpc3QgdWktaGVscGVyLXJlc2V0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcInVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFxcXCI+PGgzPnt7c3VibWVudS5sYWJlbH19PC9oMz48L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XFxcInN1Ym1lbnUuaXRlbXNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgKm5nSWY9XFxcIml0ZW0uc2VwYXJhdG9yXFxcIiBjbGFzcz1cXFwidWktbWVudS1zZXBhcmF0b3IgdWktd2lkZ2V0LWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgKm5nSWY9XFxcIiFpdGVtLnNlcGFyYXRvclxcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtIHVpLXdpZGdldCB1aS1jb3JuZXItYWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCIhaXRlbS5yb3V0ZXJMaW5rXFxcIiBbaHJlZl09XFxcIml0ZW0udXJsfHwnIydcXFwiIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1saW5rIHVpLWNvcm5lci1hbGxcXFwiIFthdHRyLnRhcmdldF09XFxcIml0ZW0udGFyZ2V0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1kaXNhYmxlZCc6aXRlbS5kaXNhYmxlZH1cXFwiIChjbGljayk9XFxcIml0ZW1DbGljaygkZXZlbnQsIGl0ZW0pXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYSBmYS1md1xcXCIgKm5nSWY9XFxcIml0ZW0uaWNvblxcXCIgW25nQ2xhc3NdPVxcXCJpdGVtLmljb25cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0tdGV4dFxcXCI+e3tpdGVtLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiaXRlbS5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua109XFxcIml0ZW0ucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCIndWktc3RhdGUtYWN0aXZlJ1xcXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cXFwiaXRlbS5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc3x8e2V4YWN0OmZhbHNlfVxcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtLWxpbmsgdWktY29ybmVyLWFsbFxcXCIgW2F0dHIudGFyZ2V0XT1cXFwiaXRlbS50YXJnZXRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzppdGVtLmRpc2FibGVkfVxcXCIgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgaXRlbSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1pY29uIGZhIGZhLWZ3XFxcIiAqbmdJZj1cXFwiaXRlbS5pY29uXFxcIiBbbmdDbGFzc109XFxcIml0ZW0uaWNvblxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS10ZXh0XFxcIj57e2l0ZW0ubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1tZW51aXRlbSB1aS1tZW51aXRlbS1jdXN0b20gdWktd2lkZ2V0IHVpLWNvcm5lci1hbGxcXFwiICpuZ0lmPVxcXCJvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMl0pXG5dLCBNZWdhTWVudSk7XG5leHBvcnRzLk1lZ2FNZW51ID0gTWVnYU1lbnU7XG52YXIgTWVnYU1lbnVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lZ2FNZW51TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWVnYU1lbnVNb2R1bGU7XG59KCkpO1xuTWVnYU1lbnVNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlLCByb3V0ZXJfMS5Sb3V0ZXJNb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbTWVnYU1lbnUsIHJvdXRlcl8xLlJvdXRlck1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW01lZ2FNZW51XVxuICAgIH0pXG5dLCBNZWdhTWVudU1vZHVsZSk7XG5leHBvcnRzLk1lZ2FNZW51TW9kdWxlID0gTWVnYU1lbnVNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWdhbWVudS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL21lZ2FtZW51L21lZ2FtZW51LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvbWVnYW1lbnUvbWVnYW1lbnUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbnZhciByb3V0ZXJfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9yb3V0ZXJcIik7XG52YXIgTWVudUl0ZW1Db250ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZW51SXRlbUNvbnRlbnQobWVudSkge1xuICAgICAgICB0aGlzLm1lbnUgPSBtZW51O1xuICAgIH1cbiAgICByZXR1cm4gTWVudUl0ZW1Db250ZW50O1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dChcInBNZW51SXRlbUNvbnRlbnRcIiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE1lbnVJdGVtQ29udGVudC5wcm90b3R5cGUsIFwiaXRlbVwiLCB2b2lkIDApO1xuTWVudUl0ZW1Db250ZW50ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnW3BNZW51SXRlbUNvbnRlbnRdJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8YSAqbmdJZj1cXFwiIWl0ZW0ucm91dGVyTGlua1xcXCIgW2hyZWZdPVxcXCJpdGVtLnVybHx8JyMnXFxcIiBjbGFzcz1cXFwidWktbWVudWl0ZW0tbGluayB1aS1jb3JuZXItYWxsXFxcIiBbYXR0ci50YXJnZXRdPVxcXCJpdGVtLnRhcmdldFxcXCJcXG4gICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtZGlzYWJsZWQnOml0ZW0uZGlzYWJsZWR9XFxcIiAoY2xpY2spPVxcXCJtZW51Lml0ZW1DbGljaygkZXZlbnQsIGl0ZW0pXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYSBmYS1md1xcXCIgKm5nSWY9XFxcIml0ZW0uaWNvblxcXCIgW25nQ2xhc3NdPVxcXCJpdGVtLmljb25cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0tdGV4dFxcXCI+e3tpdGVtLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSAqbmdJZj1cXFwiaXRlbS5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua109XFxcIml0ZW0ucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCIndWktc3RhdGUtYWN0aXZlJ1xcXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cXFwiaXRlbS5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc3x8e2V4YWN0OmZhbHNlfVxcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtLWxpbmsgdWktY29ybmVyLWFsbFxcXCIgW2F0dHIudGFyZ2V0XT1cXFwiaXRlbS50YXJnZXRcXFwiXFxuICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzppdGVtLmRpc2FibGVkfVxcXCIgKGNsaWNrKT1cXFwibWVudS5pdGVtQ2xpY2soJGV2ZW50LCBpdGVtKVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLWljb24gZmEgZmEtZndcXFwiICpuZ0lmPVxcXCJpdGVtLmljb25cXFwiIFtuZ0NsYXNzXT1cXFwiaXRlbS5pY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLXRleHRcXFwiPnt7aXRlbS5sYWJlbH19PC9zcGFuPlxcbiAgICAgICAgPC9hPlxcbiAgICBcIlxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgY29yZV8xLkluamVjdChjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZW51OyB9KSkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTWVudV0pXG5dLCBNZW51SXRlbUNvbnRlbnQpO1xuZXhwb3J0cy5NZW51SXRlbUNvbnRlbnQgPSBNZW51SXRlbUNvbnRlbnQ7XG52YXIgTWVudSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVudShlbCwgZG9tSGFuZGxlciwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIE1lbnUucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAodGhpcy5wb3B1cCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUbyA9PT0gJ2JvZHknKVxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lciwgdGhpcy5hcHBlbmRUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnByZXZlbnREb2N1bWVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5wcmV2ZW50RG9jdW1lbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVudS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5vZmZzZXRQYXJlbnQpXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaG93KGV2ZW50KTtcbiAgICAgICAgdGhpcy5wcmV2ZW50RG9jdW1lbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIE1lbnUucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm9uUmVzaXplVGFyZ2V0ICYmIHRoaXMuY29udGFpbmVyLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24odGhpcy5jb250YWluZXIsIHRoaXMub25SZXNpemVUYXJnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZW51LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLm9uUmVzaXplVGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5hYnNvbHV0ZVBvc2l0aW9uKHRoaXMuY29udGFpbmVyLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIuZmFkZUluKHRoaXMuY29udGFpbmVyLCAyNTApO1xuICAgICAgICB0aGlzLnByZXZlbnREb2N1bWVudERlZmF1bHQgPSB0cnVlO1xuICAgIH07XG4gICAgTWVudS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9O1xuICAgIE1lbnUucHJvdG90eXBlLml0ZW1DbGljayA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWl0ZW0udXJsKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmNvbW1hbmQpIHtcbiAgICAgICAgICAgIGl0ZW0uY29tbWFuZCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9wdXApIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZW51LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUbykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lbnUucHJvdG90eXBlLmhhc1N1Yk1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5tb2RlbDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIE1lbnU7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgTWVudS5wcm90b3R5cGUsIFwibW9kZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTWVudS5wcm90b3R5cGUsIFwicG9wdXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBNZW51LnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lbnUucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBNZW51LnByb3RvdHlwZSwgXCJhcHBlbmRUb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnY29udGFpbmVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgTWVudS5wcm90b3R5cGUsIFwiY29udGFpbmVyVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5NZW51ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1tZW51JyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2ICNjb250YWluZXIgW25nQ2xhc3NdPVxcXCJ7J3VpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktaGVscGVyLWNsZWFyZml4Jzp0cnVlLCd1aS1tZW51LWR5bmFtaWMgdWktc2hhZG93Jzpwb3B1cH1cXFwiIFxcbiAgICAgICAgICAgIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIChjbGljayk9XFxcInByZXZlbnREb2N1bWVudERlZmF1bHQ9dHJ1ZVxcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS1tZW51LWxpc3QgdWktaGVscGVyLXJlc2V0XFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1zdWJtZW51IFtuZ0Zvck9mXT1cXFwibW9kZWxcXFwiICpuZ0lmPVxcXCJoYXNTdWJNZW51KClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1tZW51LXNlcGFyYXRvciB1aS13aWRnZXQtY29udGVudFxcXCIgKm5nSWY9XFxcInN1Ym1lbnUuc2VwYXJhdG9yXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXFxcIiAqbmdJZj1cXFwiIXN1Ym1lbnUuc2VwYXJhdG9yXFxcIj48aDM+e3tzdWJtZW51LmxhYmVsfX08L2gzPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWl0ZW0gW25nRm9yT2ZdPVxcXCJzdWJtZW51Lml0ZW1zXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcInVpLW1lbnUtc2VwYXJhdG9yIHVpLXdpZGdldC1jb250ZW50XFxcIiAqbmdJZj1cXFwiaXRlbS5zZXBhcmF0b3JcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktbWVudWl0ZW0gdWktd2lkZ2V0IHVpLWNvcm5lci1hbGxcXFwiICpuZ0lmPVxcXCIhaXRlbS5zZXBhcmF0b3JcXFwiIFtwTWVudUl0ZW1Db250ZW50XT1cXFwiaXRlbVxcXCI+PC9saT5cXG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XFxcIm1vZGVsXFxcIiAqbmdJZj1cXFwiIWhhc1N1Yk1lbnUoKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcInVpLW1lbnUtc2VwYXJhdG9yIHVpLXdpZGdldC1jb250ZW50XFxcIiAqbmdJZj1cXFwiaXRlbS5zZXBhcmF0b3JcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1tZW51aXRlbSB1aS13aWRnZXQgdWktY29ybmVyLWFsbFxcXCIgKm5nSWY9XFxcIiFpdGVtLnNlcGFyYXRvclxcXCIgW3BNZW51SXRlbUNvbnRlbnRdPVxcXCJpdGVtXFxcIj48L2xpPlxcbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSxcbiAgICAgICAgaG9zdDogeyAnKHdpbmRvdzpyZXNpemUpJzogJ29uUmVzaXplKCRldmVudCknIH1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMl0pXG5dLCBNZW51KTtcbmV4cG9ydHMuTWVudSA9IE1lbnU7XG52YXIgTWVudU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVudU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1lbnVNb2R1bGU7XG59KCkpO1xuTWVudU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIHJvdXRlcl8xLlJvdXRlck1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtNZW51LCByb3V0ZXJfMS5Sb3V0ZXJNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZW51LCBNZW51SXRlbUNvbnRlbnRdXG4gICAgfSlcbl0sIE1lbnVNb2R1bGUpO1xuZXhwb3J0cy5NZW51TW9kdWxlID0gTWVudU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9tZW51L21lbnUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9tZW51L21lbnUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvcm91dGVyXCIpO1xudmFyIE1lbnViYXJTdWIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lbnViYXJTdWIoZG9tSGFuZGxlcikge1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgIH1cbiAgICBNZW51YmFyU3ViLnByb3RvdHlwZS5vbkl0ZW1Nb3VzZUVudGVyID0gZnVuY3Rpb24gKGV2ZW50LCBpdGVtLCBtZW51aXRlbSkge1xuICAgICAgICBpZiAobWVudWl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSBpdGVtO1xuICAgICAgICB2YXIgbmV4dEVsZW1lbnQgPSBpdGVtLmNoaWxkcmVuWzBdLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgaWYgKG5leHRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgc3VibGlzdCA9IG5leHRFbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgc3VibGlzdC5zdHlsZS56SW5kZXggPSBTdHJpbmcoKytkb21oYW5kbGVyXzEuRG9tSGFuZGxlci56aW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgICAgIHN1Ymxpc3Quc3R5bGUudG9wID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KGl0ZW0uY2hpbGRyZW5bMF0pICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzdWJsaXN0LnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1Ymxpc3Quc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICAgICAgc3VibGlzdC5zdHlsZS5sZWZ0ID0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVyV2lkdGgoaXRlbS5jaGlsZHJlblswXSkgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNZW51YmFyU3ViLnByb3RvdHlwZS5vbkl0ZW1Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgfTtcbiAgICBNZW51YmFyU3ViLnByb3RvdHlwZS5pdGVtQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpdGVtLnVybCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5jb21tYW5kKSB7XG4gICAgICAgICAgICBpdGVtLmNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgfTtcbiAgICBNZW51YmFyU3ViLnByb3RvdHlwZS5saXN0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBNZW51YmFyU3ViO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBNZW51YmFyU3ViLnByb3RvdHlwZSwgXCJpdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE1lbnViYXJTdWIucHJvdG90eXBlLCBcInJvb3RcIiwgdm9pZCAwKTtcbk1lbnViYXJTdWIgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLW1lbnViYXJTdWInLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDx1bCBbbmdDbGFzc109XFxcInsndWktbWVudWJhci1yb290LWxpc3QgdWktaGVscGVyLWNsZWFyZml4Jzpyb290LCAndWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXggdWktbWVudS1jaGlsZCB1aS1zaGFkb3cnOiFyb290fVxcXCIgY2xhc3M9XFxcInVpLW1lbnUtbGlzdFxcXCJcXG4gICAgICAgICAgICAoY2xpY2spPVxcXCJsaXN0Q2xpY2soJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jaGlsZCBbbmdGb3JPZl09XFxcIihyb290ID8gaXRlbSA6IGl0ZW0uaXRlbXMpXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpICpuZ0lmPVxcXCJjaGlsZC5zZXBhcmF0b3JcXFwiIGNsYXNzPVxcXCJ1aS1tZW51LXNlcGFyYXRvciB1aS13aWRnZXQtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSAqbmdJZj1cXFwiIWNoaWxkLnNlcGFyYXRvclxcXCIgI2xpc3RJdGVtIFtuZ0NsYXNzXT1cXFwieyd1aS1tZW51aXRlbSB1aS13aWRnZXQgdWktY29ybmVyLWFsbCc6dHJ1ZSwndWktbWVudS1wYXJlbnQnOmNoaWxkLml0ZW1zLCd1aS1tZW51aXRlbS1hY3RpdmUnOmxpc3RJdGVtPT1hY3RpdmVJdGVtfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIChtb3VzZWVudGVyKT1cXFwib25JdGVtTW91c2VFbnRlcigkZXZlbnQsbGlzdEl0ZW0sY2hpbGQpXFxcIiAobW91c2VsZWF2ZSk9XFxcIm9uSXRlbU1vdXNlTGVhdmUoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiIWNoaWxkLnJvdXRlckxpbmtcXFwiIFtocmVmXT1cXFwiY2hpbGQudXJsfHwnIydcXFwiIFthdHRyLnRhcmdldF09XFxcImNoaWxkLnRhcmdldFxcXCIgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgY2hpbGQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktbWVudWl0ZW0tbGluayB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1zdGF0ZS1kaXNhYmxlZCc6Y2hpbGQuZGlzYWJsZWR9XFxcIiBbbmdTdHlsZV09XFxcImNoaWxkLnN0eWxlXFxcIiBbY2xhc3NdPVxcXCJjaGlsZC5zdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYSBmYS1md1xcXCIgKm5nSWY9XFxcImNoaWxkLmljb25cXFwiIFtuZ0NsYXNzXT1cXFwiY2hpbGQuaWNvblxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS10ZXh0XFxcIj57e2NoaWxkLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXN1Ym1lbnUtaWNvbiBmYSBmYS1md1xcXCIgKm5nSWY9XFxcImNoaWxkLml0ZW1zXFxcIiBbbmdDbGFzc109XFxcInsnZmEtY2FyZXQtZG93bic6cm9vdCwnZmEtY2FyZXQtcmlnaHQnOiFyb290fVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcImNoaWxkLnJvdXRlckxpbmtcXFwiIFtyb3V0ZXJMaW5rXT1cXFwiY2hpbGQucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCIndWktc3RhdGUtYWN0aXZlJ1xcXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cXFwiY2hpbGQucm91dGVyTGlua0FjdGl2ZU9wdGlvbnN8fHtleGFjdDpmYWxzZX1cXFwiIFthdHRyLnRhcmdldF09XFxcImNoaWxkLnRhcmdldFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJpdGVtQ2xpY2soJGV2ZW50LCBjaGlsZClcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1tZW51aXRlbS1saW5rIHVpLWNvcm5lci1hbGwnOnRydWUsJ3VpLXN0YXRlLWRpc2FibGVkJzpjaGlsZC5kaXNhYmxlZH1cXFwiIFtuZ1N0eWxlXT1cXFwiY2hpbGQuc3R5bGVcXFwiIFtjbGFzc109XFxcImNoaWxkLnN0eWxlQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1pY29uIGZhIGZhLWZ3XFxcIiAqbmdJZj1cXFwiY2hpbGQuaWNvblxcXCIgW25nQ2xhc3NdPVxcXCJjaGlsZC5pY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLXRleHRcXFwiPnt7Y2hpbGQubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktc3VibWVudS1pY29uIGZhIGZhLWZ3XFxcIiAqbmdJZj1cXFwiY2hpbGQuaXRlbXNcXFwiIFtuZ0NsYXNzXT1cXFwieydmYS1jYXJldC1kb3duJzpyb290LCdmYS1jYXJldC1yaWdodCc6IXJvb3R9XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8cC1tZW51YmFyU3ViIGNsYXNzPVxcXCJ1aS1zdWJtZW51XFxcIiBbaXRlbV09XFxcImNoaWxkXFxcIiAqbmdJZj1cXFwiY2hpbGQuaXRlbXNcXFwiPjwvcC1tZW51YmFyU3ViPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1tZW51aXRlbSB1aS1tZW51aXRlbS1jdXN0b20gdWktd2lkZ2V0IHVpLWNvcm5lci1hbGxcXFwiPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgIDwvdWw+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIE1lbnViYXJTdWIpO1xuZXhwb3J0cy5NZW51YmFyU3ViID0gTWVudWJhclN1YjtcbnZhciBNZW51YmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZW51YmFyKGVsLCBkb21IYW5kbGVyLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG4gICAgcmV0dXJuIE1lbnViYXI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgTWVudWJhci5wcm90b3R5cGUsIFwibW9kZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBNZW51YmFyLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE1lbnViYXIucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbk1lbnViYXIgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLW1lbnViYXInLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJ7J3VpLW1lbnViYXIgdWktbWVudSB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXgnOnRydWV9XFxcIiBcXG4gICAgICAgICAgICBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIj5cXG4gICAgICAgICAgICA8cC1tZW51YmFyU3ViIFtpdGVtXT1cXFwibW9kZWxcXFwiIHJvb3Q9XFxcInJvb3RcXFwiPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPC9wLW1lbnViYXJTdWI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuUmVuZGVyZXIyXSlcbl0sIE1lbnViYXIpO1xuZXhwb3J0cy5NZW51YmFyID0gTWVudWJhcjtcbnZhciBNZW51YmFyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZW51YmFyTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWVudWJhck1vZHVsZTtcbn0oKSk7XG5NZW51YmFyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgcm91dGVyXzEuUm91dGVyTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW01lbnViYXIsIHJvdXRlcl8xLlJvdXRlck1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW01lbnViYXIsIE1lbnViYXJTdWJdXG4gICAgfSlcbl0sIE1lbnViYXJNb2R1bGUpO1xuZXhwb3J0cy5NZW51YmFyTW9kdWxlID0gTWVudWJhck1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnViYXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9tZW51YmFyL21lbnViYXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9tZW51YmFyL21lbnViYXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBNZXNzYWdlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZXMoKSB7XG4gICAgICAgIHRoaXMuY2xvc2FibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmhhc01lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuZ2V0U2V2ZXJpdHlDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbMF0uc2V2ZXJpdHk7XG4gICAgfTtcbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZXMucHJvdG90eXBlLCBcImljb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpY29uID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc01lc3NhZ2VzKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gdGhpcy52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1zZy5zZXZlcml0eSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb24gPSAnZmEtY2hlY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9ICdmYS1pbmZvLWNpcmNsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9ICdmYS1jbG9zZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gJ2ZhLXdhcm5pbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9ICdmYS1jaGVjayc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb24gPSAnZmEtaW5mby1jaXJjbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBNZXNzYWdlcztcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTWVzc2FnZXMucHJvdG90eXBlLCBcImNsb3NhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBNZXNzYWdlcy5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgdm9pZCAwKTtcbk1lc3NhZ2VzID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1tZXNzYWdlcycsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiAqbmdJZj1cXFwiaGFzTWVzc2FnZXMoKVxcXCIgY2xhc3M9XFxcInVpLW1lc3NhZ2VzIHVpLXdpZGdldCB1aS1jb3JuZXItYWxsXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpibG9ja1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1tZXNzYWdlcy1pbmZvJzoodmFsdWVbMF0uc2V2ZXJpdHkgPT09ICdpbmZvJyksXFxuICAgICAgICAgICAgICAgICAgICAndWktbWVzc2FnZXMtd2Fybic6KHZhbHVlWzBdLnNldmVyaXR5ID09PSAnd2FybicpLFxcbiAgICAgICAgICAgICAgICAgICAgJ3VpLW1lc3NhZ2VzLWVycm9yJzoodmFsdWVbMF0uc2V2ZXJpdHkgPT09ICdlcnJvcicpLFxcbiAgICAgICAgICAgICAgICAgICAgJ3VpLW1lc3NhZ2VzLXN1Y2Nlc3MnOih2YWx1ZVswXS5zZXZlcml0eSA9PT0gJ3N1Y2Nlc3MnKX1cXFwiPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJ1aS1tZXNzYWdlcy1jbG9zZVxcXCIgKGNsaWNrKT1cXFwiY2xlYXIoJGV2ZW50KVxcXCIgKm5nSWY9XFxcImNsb3NhYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNsb3NlXFxcIj48L2k+XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZXNzYWdlcy1pY29uIGZhIGZhLWZ3IGZhLTJ4XFxcIiBbbmdDbGFzc109XFxcImljb25cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8dWw+XFxuICAgICAgICAgICAgICAgIDxsaSAqbmdGb3I9XFxcImxldCBtc2cgb2YgdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lc3NhZ2VzLXN1bW1hcnlcXFwiPnt7bXNnLnN1bW1hcnl9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZXNzYWdlcy1kZXRhaWxcXFwiPnt7bXNnLmRldGFpbH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCJcbiAgICB9KVxuXSwgTWVzc2FnZXMpO1xuZXhwb3J0cy5NZXNzYWdlcyA9IE1lc3NhZ2VzO1xudmFyIE1lc3NhZ2VzTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlc01vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VzTW9kdWxlO1xufSgpKTtcbk1lc3NhZ2VzTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtNZXNzYWdlc10sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW01lc3NhZ2VzXVxuICAgIH0pXG5dLCBNZXNzYWdlc01vZHVsZSk7XG5leHBvcnRzLk1lc3NhZ2VzTW9kdWxlID0gTWVzc2FnZXNNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL21lc3NhZ2VzL21lc3NhZ2VzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvbWVzc2FnZXMvbWVzc2FnZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgb2JqZWN0dXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9vYmplY3R1dGlsc1wiKTtcbnZhciBmb3Jtc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpO1xuZXhwb3J0cy5NVUxUSVNFTEVDVF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBmb3Jtc18xLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNdWx0aVNlbGVjdDsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgTXVsdGlTZWxlY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpU2VsZWN0KGVsLCBkb21IYW5kbGVyLCByZW5kZXJlciwgZGlmZmVycywgb2JqZWN0VXRpbHMsIGNkKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm9iamVjdFV0aWxzID0gb2JqZWN0VXRpbHM7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSAnMjAwcHgnO1xuICAgICAgICB0aGlzLmRlZmF1bHRMYWJlbCA9ICdDaG9vc2UnO1xuICAgICAgICB0aGlzLmZpbHRlciA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcGxheVNlbGVjdGVkTGFiZWwgPSB0cnVlO1xuICAgICAgICB0aGlzLm1heFNlbGVjdGVkTGFiZWxzID0gMztcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zTGFiZWwgPSAnezB9IGl0ZW1zIHNlbGVjdGVkJztcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0aGlzLnZhbHVlRGlmZmVyID0gZGlmZmVycy5maW5kKFtdKS5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMub3B0aW9uc0RpZmZlciA9IGRpZmZlcnMuZmluZChbXSkuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWwoKTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jb250YWluZXJWaWV3Q2hpbGQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5wYW5lbCA9IHRoaXMucGFuZWxWaWV3Q2hpbGQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvID09PSAnYm9keScpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYXBwZW5kQ2hpbGQodGhpcy5wYW5lbCwgdGhpcy5hcHBlbmRUbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheVZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pXG4gICAgICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24odGhpcy5wYW5lbCwgdGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5yZWxhdGl2ZVBvc2l0aW9uKHRoaXMucGFuZWwsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlQ2hhbmdlcyA9IHRoaXMudmFsdWVEaWZmZXIuZGlmZih0aGlzLnZhbHVlKTtcbiAgICAgICAgdmFyIG9wdGlvbkNoYW5nZXMgPSB0aGlzLm9wdGlvbnNEaWZmZXIuZGlmZih0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWVDaGFuZ2VzIHx8IG9wdGlvbkNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZm47XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHZhbDtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5vbkl0ZW1DbGljayA9IGZ1bmN0aW9uIChldmVudCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkluZGV4ID0gdGhpcy5maW5kU2VsZWN0aW9uSW5kZXgodmFsdWUpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uSW5kZXggIT0gLTEpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBzZWxlY3Rpb25JbmRleDsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAodGhpcy52YWx1ZSB8fCBbXSkuY29uY2F0KFt2YWx1ZV0pO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCB2YWx1ZTogdGhpcy52YWx1ZSB9KTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTZWxlY3Rpb25JbmRleCh2YWx1ZSkgIT0gLTE7XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUuZmluZFNlbGVjdGlvbkluZGV4ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iamVjdFV0aWxzLmVxdWFscyh0aGlzLnZhbHVlW2ldLCB2YWwsIHRoaXMuZGF0YUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLnRvZ2dsZUFsbCA9IGZ1bmN0aW9uIChldmVudCwgY2hlY2tib3gpIHtcbiAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5nZXRWaXNpYmxlT3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUucHVzaChvcHRzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9ICFjaGVja2JveC5jaGVja2VkO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCB2YWx1ZTogdGhpcy52YWx1ZSB9KTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5pc0FsbENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlclZhbHVlICYmIHRoaXMuZmlsdGVyVmFsdWUudHJpbSgpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlICYmIHRoaXMudmlzaWJsZU9wdGlvbnMgJiYgdGhpcy52aXNpYmxlT3B0aW9ucy5sZW5ndGggJiYgKHRoaXMudmFsdWUubGVuZ3RoID09IHRoaXMudmlzaWJsZU9wdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgJiYgdGhpcy5vcHRpb25zICYmICh0aGlzLnZhbHVlLmxlbmd0aCA9PSB0aGlzLm9wdGlvbnMubGVuZ3RoKTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYW5lbC5zdHlsZS56SW5kZXggPSBTdHJpbmcoKytkb21oYW5kbGVyXzEuRG9tSGFuZGxlci56aW5kZXgpO1xuICAgICAgICB0aGlzLmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pXG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbih0aGlzLnBhbmVsLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5yZWxhdGl2ZVBvc2l0aW9uKHRoaXMucGFuZWwsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyLmZhZGVJbih0aGlzLnBhbmVsLCAyNTApO1xuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheVZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUub25Nb3VzZWNsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wYW5lbENsaWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5VmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGZDbGljayA9IHRydWU7XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gdHJ1ZTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5vbklucHV0Qmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25CbHVyLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCB9KTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCgpO1xuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLnVwZGF0ZUxhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy52YWx1ZS5sZW5ndGggJiYgdGhpcy5kaXNwbGF5U2VsZWN0ZWRMYWJlbCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwgKyAnLCAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsICsgdGhpcy5maW5kTGFiZWxCeVZhbHVlKHRoaXMudmFsdWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoIDw9IHRoaXMubWF4U2VsZWN0ZWRMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc0FzU3RyaW5nID0gbGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IC97KC4qPyl9LywgbmV3U2VsZWN0ZWRJdGVtc0xhYmVsID0gdGhpcy5zZWxlY3RlZEl0ZW1zTGFiZWwucmVwbGFjZSh0aGlzLnNlbGVjdGVkSXRlbXNMYWJlbC5tYXRjaChwYXR0ZXJuKVswXSwgdGhpcy52YWx1ZS5sZW5ndGggKyAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNBc1N0cmluZyA9IG5ld1NlbGVjdGVkSXRlbXNMYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzQXNTdHJpbmcgPSB0aGlzLmRlZmF1bHRMYWJlbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLmZpbmRMYWJlbEJ5VmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIG9wdGlvbi52YWx1ZSA9PSBudWxsIHx8IHRoaXMub2JqZWN0VXRpbHMuZXF1YWxzKHZhbCwgb3B0aW9uLnZhbHVlLCB0aGlzLmRhdGFLZXkpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBvcHRpb24ubGFiZWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLm9uRmlsdGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZmlsdGVyVmFsdWUgPSBldmVudC50YXJnZXQudmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMudmlzaWJsZU9wdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAob3B0aW9uLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLmZpbHRlclZhbHVlLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVPcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlcmVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0LnByb3RvdHlwZS5pc0l0ZW1WaXNpYmxlID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJWYWx1ZSAmJiB0aGlzLmZpbHRlclZhbHVlLnRyaW0oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52aXNpYmxlT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGVPcHRpb25zW2ldLnZhbHVlID09IG9wdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLmdldFZpc2libGVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJWYWx1ZSAmJiB0aGlzLmZpbHRlclZhbHVlLnRyaW0oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb24ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0aGlzLmZpbHRlclZhbHVlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zZWxmQ2xpY2sgJiYgIV90aGlzLnBhbmVsQ2xpY2sgJiYgX3RoaXMub3ZlcmxheVZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zZWxmQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYW5lbENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlTZWxlY3QucHJvdG90eXBlLnVuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnBhbmVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE11bHRpU2VsZWN0O1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIE11bHRpU2VsZWN0LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBNdWx0aVNlbGVjdC5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIE11bHRpU2VsZWN0LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBNdWx0aVNlbGVjdC5wcm90b3R5cGUsIFwic2Nyb2xsSGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcImRlZmF1bHRMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE11bHRpU2VsZWN0LnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE11bHRpU2VsZWN0LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcImlucHV0SWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE11bHRpU2VsZWN0LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcIm92ZXJsYXlWaXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcImFwcGVuZFRvXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcImRhdGFLZXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcImRpc3BsYXlTZWxlY3RlZExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcIm1heFNlbGVjdGVkTGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcInNlbGVjdGVkSXRlbXNMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnY29udGFpbmVyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgTXVsdGlTZWxlY3QucHJvdG90eXBlLCBcImNvbnRhaW5lclZpZXdDaGlsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgncGFuZWwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBNdWx0aVNlbGVjdC5wcm90b3R5cGUsIFwicGFuZWxWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbk11bHRpU2VsZWN0ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1tdWx0aVNlbGVjdCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiAjY29udGFpbmVyIFtuZ0NsYXNzXT1cXFwieyd1aS1tdWx0aXNlbGVjdCB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1zdGF0ZS1mb2N1cyc6Zm9jdXMsJ3VpLXN0YXRlLWRpc2FibGVkJzogZGlzYWJsZWR9XFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIlxcbiAgICAgICAgICAgIChjbGljayk9XFxcIm9uTW91c2VjbGljaygkZXZlbnQsaW4pXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgI2luIHR5cGU9XFxcInRleHRcXFwiIHJlYWRvbmx5PVxcXCJyZWFkb25seVxcXCIgW2F0dHIuaWRdPVxcXCJpbnB1dElkXFxcIiAoZm9jdXMpPVxcXCJvbkZvY3VzKCRldmVudClcXFwiIChibHVyKT1cXFwib25JbnB1dEJsdXIoJGV2ZW50KVxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFthdHRyLnRhYmluZGV4XT1cXFwidGFiaW5kZXhcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW11bHRpc2VsZWN0LWxhYmVsLWNvbnRhaW5lclxcXCIgW3RpdGxlXT1cXFwidmFsdWVzQXNTdHJpbmdcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInVpLW11bHRpc2VsZWN0LWxhYmVsIHVpLWNvcm5lci1hbGxcXFwiPnt7dmFsdWVzQXNTdHJpbmd9fTwvbGFiZWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcInsndWktbXVsdGlzZWxlY3QtdHJpZ2dlciB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1yaWdodCc6dHJ1ZX1cXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtZncgZmEtY2FyZXQtZG93biB1aS1jbGlja2FibGVcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2ICNwYW5lbCBjbGFzcz1cXFwidWktbXVsdGlzZWxlY3QtcGFuZWwgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktc2hhZG93XFxcIiBbc3R5bGUuZGlzcGxheV09XFxcIm92ZXJsYXlWaXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJ1xcXCIgKGNsaWNrKT1cXFwicGFuZWxDbGljaz10cnVlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsIHVpLW11bHRpc2VsZWN0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXhcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY2hrYm94IHVpLXdpZGdldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0ICNjYiB0eXBlPVxcXCJjaGVja2JveFxcXCIgcmVhZG9ubHk9XFxcInJlYWRvbmx5XFxcIiBbY2hlY2tlZF09XFxcImlzQWxsQ2hlY2tlZCgpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1jaGtib3gtYm94IHVpLXdpZGdldCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRlZmF1bHRcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1hY3RpdmUnOmlzQWxsQ2hlY2tlZCgpfVxcXCIgKGNsaWNrKT1cXFwidG9nZ2xlQWxsKCRldmVudCxjYilcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY2hrYm94LWljb24gdWktY2xpY2thYmxlXFxcIiBbbmdDbGFzc109XFxcInsnZmEgZmEtY2hlY2snOmlzQWxsQ2hlY2tlZCgpfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1tdWx0aXNlbGVjdC1maWx0ZXItY29udGFpbmVyXFxcIiAqbmdJZj1cXFwiZmlsdGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcm9sZT1cXFwidGV4dGJveFxcXCIgKGlucHV0KT1cXFwib25GaWx0ZXIoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwidWktaW5wdXR0ZXh0IHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1zZWFyY2hcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcInVpLW11bHRpc2VsZWN0LWNsb3NlIHVpLWNvcm5lci1hbGxcXFwiIGhyZWY9XFxcIiNcXFwiIChjbGljayk9XFxcImNsb3NlKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1jbG9zZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktbXVsdGlzZWxlY3QtaXRlbXMtd3JhcHBlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcInVpLW11bHRpc2VsZWN0LWl0ZW1zIHVpLW11bHRpc2VsZWN0LWxpc3QgdWktd2lkZ2V0LWNvbnRlbnQgdWktd2lkZ2V0IHVpLWNvcm5lci1hbGwgdWktaGVscGVyLXJlc2V0XFxcIiBbc3R5bGUubWF4LWhlaWdodF09XFxcInNjcm9sbEhlaWdodHx8J2F1dG8nXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgKm5nRm9yPVxcXCJsZXQgb3B0aW9uIG9mIG9wdGlvbnNcXFwiIGNsYXNzPVxcXCJ1aS1tdWx0aXNlbGVjdC1pdGVtIHVpLWNvcm5lci1hbGxcXFwiIChjbGljayk9XFxcIm9uSXRlbUNsaWNrKCRldmVudCxvcHRpb24udmFsdWUpXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmRpc3BsYXldPVxcXCJpc0l0ZW1WaXNpYmxlKG9wdGlvbikgPyAnYmxvY2snIDogJ25vbmUnXFxcIiBbbmdDbGFzc109XFxcInsndWktc3RhdGUtaGlnaGxpZ2h0Jzppc1NlbGVjdGVkKG9wdGlvbi52YWx1ZSl9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY2hrYm94IHVpLXdpZGdldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgcmVhZG9ubHk9XFxcInJlYWRvbmx5XFxcIiBbY2hlY2tlZF09XFxcImlzU2VsZWN0ZWQob3B0aW9uLnZhbHVlKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWNoa2JveC1ib3ggdWktd2lkZ2V0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGVmYXVsdFxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWFjdGl2ZSc6aXNTZWxlY3RlZChvcHRpb24udmFsdWUpfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWNoa2JveC1pY29uIHVpLWNsaWNrYWJsZVxcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhIGZhLWNoZWNrJzppc1NlbGVjdGVkKG9wdGlvbi52YWx1ZSl9XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbD57e29wdGlvbi5sYWJlbH19PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBvYmplY3R1dGlsc18xLk9iamVjdFV0aWxzLCBleHBvcnRzLk1VTFRJU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuUmVuZGVyZXIyLCBjb3JlXzEuSXRlcmFibGVEaWZmZXJzLCBvYmplY3R1dGlsc18xLk9iamVjdFV0aWxzLCBjb3JlXzEuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgTXVsdGlTZWxlY3QpO1xuZXhwb3J0cy5NdWx0aVNlbGVjdCA9IE11bHRpU2VsZWN0O1xudmFyIE11bHRpU2VsZWN0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNdWx0aVNlbGVjdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE11bHRpU2VsZWN0TW9kdWxlO1xufSgpKTtcbk11bHRpU2VsZWN0TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtNdWx0aVNlbGVjdF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW011bHRpU2VsZWN0XVxuICAgIH0pXG5dLCBNdWx0aVNlbGVjdE1vZHVsZSk7XG5leHBvcnRzLk11bHRpU2VsZWN0TW9kdWxlID0gTXVsdGlTZWxlY3RNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXNlbGVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL211bHRpc2VsZWN0L211bHRpc2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvbXVsdGlzZWxlY3QvbXVsdGlzZWxlY3QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuLi9idXR0b24vYnV0dG9uXCIpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zaGFyZWRcIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIG9iamVjdHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvb2JqZWN0dXRpbHNcIik7XG52YXIgT3JkZXJMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcmRlckxpc3QoZWwsIGRvbUhhbmRsZXIsIG9iamVjdFV0aWxzKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5vYmplY3RVdGlscyA9IG9iamVjdFV0aWxzO1xuICAgICAgICB0aGlzLm1ldGFLZXlTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLm9uUmVvcmRlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRmlsdGVyRXZlbnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPcmRlckxpc3QucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saXN0Q29udGFpbmVyID0gdGhpcy5kb21IYW5kbGVyLmZpbmRTaW5nbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndWwudWktb3JkZXJsaXN0LWxpc3QnKTtcbiAgICB9O1xuICAgIE9yZGVyTGlzdC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0uZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLml0ZW1UZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLml0ZW1UZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9yZGVyTGlzdC5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb3ZlZFVwIHx8IHRoaXMubW92ZWREb3duKSB7XG4gICAgICAgICAgICB2YXIgbGlzdEl0ZW1zID0gdGhpcy5kb21IYW5kbGVyLmZpbmQodGhpcy5saXN0Q29udGFpbmVyLCAnbGkudWktc3RhdGUtaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB2YXIgbGlzdEl0ZW0gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5tb3ZlZFVwKVxuICAgICAgICAgICAgICAgIGxpc3RJdGVtID0gbGlzdEl0ZW1zWzBdO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxpc3RJdGVtID0gbGlzdEl0ZW1zW2xpc3RJdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5zY3JvbGxJblZpZXcodGhpcy5saXN0Q29udGFpbmVyLCBsaXN0SXRlbSk7XG4gICAgICAgICAgICB0aGlzLm1vdmVkVXAgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcmRlckxpc3QucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWwgPyB2YWwuc2xpY2UoKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9yZGVyTGlzdC5wcm90b3R5cGUub25JdGVtQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXhJbkxpc3QoaXRlbSwgdGhpcy5zZWxlY3RlZEl0ZW1zKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gKGluZGV4ICE9IC0xKTtcbiAgICAgICAgdmFyIG1ldGFTZWxlY3Rpb24gPSB0aGlzLml0ZW1Ub3VjaGVkID8gZmFsc2UgOiB0aGlzLm1ldGFLZXlTZWxlY3Rpb247XG4gICAgICAgIGlmIChtZXRhU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWV0YUtleSA9IChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmIG1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtcyA9IChtZXRhS2V5KSA/IHRoaXMuc2VsZWN0ZWRJdGVtcyB8fCBbXSA6IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMgPSB0aGlzLnNlbGVjdGVkSXRlbXMgfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIHZhbHVlOiB0aGlzLnNlbGVjdGVkSXRlbXMgfSk7XG4gICAgICAgIHRoaXMuaXRlbVRvdWNoZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIE9yZGVyTGlzdC5wcm90b3R5cGUub25GaWx0ZXJLZXl1cCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZpbHRlclZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLmZpbHRlcigpO1xuICAgICAgICB0aGlzLm9uRmlsdGVyRXZlbnQuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZpc2libGVPcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3JkZXJMaXN0LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWFyY2hGaWVsZHMgPSB0aGlzLmZpbHRlckJ5LnNwbGl0KCcsJyk7XG4gICAgICAgIHRoaXMudmlzaWJsZU9wdGlvbnMgPSB0aGlzLm9iamVjdFV0aWxzLmZpbHRlcih0aGlzLnZhbHVlLCBzZWFyY2hGaWVsZHMsIHRoaXMuZmlsdGVyVmFsdWUpO1xuICAgIH07XG4gICAgT3JkZXJMaXN0LnByb3RvdHlwZS5pc0l0ZW1WaXNpYmxlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyVmFsdWUgJiYgdGhpcy5maWx0ZXJWYWx1ZS50cmltKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmlzaWJsZU9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PSB0aGlzLnZpc2libGVPcHRpb25zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPcmRlckxpc3QucHJvdG90eXBlLm9uSXRlbVRvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaXRlbVRvdWNoZWQgPSB0cnVlO1xuICAgIH07XG4gICAgT3JkZXJMaXN0LnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEluZGV4SW5MaXN0KGl0ZW0sIHRoaXMuc2VsZWN0ZWRJdGVtcykgIT0gLTE7XG4gICAgfTtcbiAgICBPcmRlckxpc3QucHJvdG90eXBlLmZpbmRJbmRleEluTGlzdCA9IGZ1bmN0aW9uIChpdGVtLCBsaXN0KSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT0gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBPcmRlckxpc3QucHJvdG90eXBlLm1vdmVVcCA9IGZ1bmN0aW9uIChldmVudCwgbGlzdEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy5zZWxlY3RlZEl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW1JbmRleCA9IHRoaXMuZmluZEluZGV4SW5MaXN0KHNlbGVjdGVkSXRlbSwgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSXRlbUluZGV4ICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkSXRlbSA9IHRoaXMudmFsdWVbc2VsZWN0ZWRJdGVtSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMudmFsdWVbc2VsZWN0ZWRJdGVtSW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVtzZWxlY3RlZEl0ZW1JbmRleCAtIDFdID0gbW92ZWRJdGVtO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlW3NlbGVjdGVkSXRlbUluZGV4XSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1vdmVkVXAgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vblJlb3JkZXIuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9yZGVyTGlzdC5wcm90b3R5cGUubW92ZVRvcCA9IGZ1bmN0aW9uIChldmVudCwgbGlzdEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy5zZWxlY3RlZEl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW1JbmRleCA9IHRoaXMuZmluZEluZGV4SW5MaXN0KHNlbGVjdGVkSXRlbSwgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSXRlbUluZGV4ICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkSXRlbSA9IHRoaXMudmFsdWUuc3BsaWNlKHNlbGVjdGVkSXRlbUluZGV4LCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS51bnNoaWZ0KG1vdmVkSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUmVvcmRlci5lbWl0KGV2ZW50KTtcbiAgICAgICAgICAgIGxpc3RFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9yZGVyTGlzdC5wcm90b3R5cGUubW92ZURvd24gPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RFbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy5zZWxlY3RlZEl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW1JbmRleCA9IHRoaXMuZmluZEluZGV4SW5MaXN0KHNlbGVjdGVkSXRlbSwgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSXRlbUluZGV4ICE9ICh0aGlzLnZhbHVlLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlZEl0ZW0gPSB0aGlzLnZhbHVlW3NlbGVjdGVkSXRlbUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLnZhbHVlW3NlbGVjdGVkSXRlbUluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbc2VsZWN0ZWRJdGVtSW5kZXggKyAxXSA9IG1vdmVkSXRlbTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVtzZWxlY3RlZEl0ZW1JbmRleF0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tb3ZlZERvd24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vblJlb3JkZXIuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9yZGVyTGlzdC5wcm90b3R5cGUubW92ZUJvdHRvbSA9IGZ1bmN0aW9uIChldmVudCwgbGlzdEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSB0aGlzLnNlbGVjdGVkSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbUluZGV4ID0gdGhpcy5maW5kSW5kZXhJbkxpc3Qoc2VsZWN0ZWRJdGVtLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtSW5kZXggIT0gKHRoaXMudmFsdWUubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkSXRlbSA9IHRoaXMudmFsdWUuc3BsaWNlKHNlbGVjdGVkSXRlbUluZGV4LCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKG1vdmVkSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUmVvcmRlci5lbWl0KGV2ZW50KTtcbiAgICAgICAgICAgIGxpc3RFbGVtZW50LnNjcm9sbFRvcCA9IGxpc3RFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3JkZXJMaXN0LnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZHJhZ2dlZEl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5kcmFnZHJvcFNjb3BlKSB7XG4gICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHRcIiwgdGhpcy5kcmFnZHJvcFNjb3BlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3JkZXJMaXN0LnByb3RvdHlwZS5vbkRyYWdPdmVyID0gZnVuY3Rpb24gKGV2ZW50LCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkSXRlbUluZGV4ICE9PSBpbmRleCAmJiB0aGlzLmRyYWdnZWRJdGVtSW5kZXggKyAxICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnT3Zlckl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3JkZXJMaXN0LnByb3RvdHlwZS5vbkRyYWdMZWF2ZSA9IGZ1bmN0aW9uIChldmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5kcmFnT3Zlckl0ZW1JbmRleCA9IG51bGw7XG4gICAgfTtcbiAgICBPcmRlckxpc3QucHJvdG90eXBlLm9uRHJvcCA9IGZ1bmN0aW9uIChldmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRyb3BJbmRleCA9ICh0aGlzLmRyYWdnZWRJdGVtSW5kZXggPiBpbmRleCkgPyBpbmRleCA6IChpbmRleCA9PT0gMCkgPyAwIDogaW5kZXggLSAxO1xuICAgICAgICB0aGlzLm9iamVjdFV0aWxzLnJlb3JkZXJBcnJheSh0aGlzLnZhbHVlLCB0aGlzLmRyYWdnZWRJdGVtSW5kZXgsIGRyb3BJbmRleCk7XG4gICAgICAgIHRoaXMuZHJhZ092ZXJJdGVtSW5kZXggPSBudWxsO1xuICAgIH07XG4gICAgT3JkZXJMaXN0LnByb3RvdHlwZS5vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH07XG4gICAgT3JkZXJMaXN0LnByb3RvdHlwZS5vbkxpc3RNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gdGhpcy5saXN0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICB2YXIgYm90dG9tRGlmZiA9IChvZmZzZXRZICsgdGhpcy5saXN0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KSAtIGV2ZW50LnBhZ2VZO1xuICAgICAgICAgICAgdmFyIHRvcERpZmYgPSAoZXZlbnQucGFnZVkgLSBvZmZzZXRZKTtcbiAgICAgICAgICAgIGlmIChib3R0b21EaWZmIDwgMjUgJiYgYm90dG9tRGlmZiA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wICs9IDE1O1xuICAgICAgICAgICAgZWxzZSBpZiAodG9wRGlmZiA8IDI1ICYmIHRvcERpZmYgPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMubGlzdFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCAtPSAxNTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9yZGVyTGlzdDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgT3JkZXJMaXN0LnByb3RvdHlwZSwgXCJoZWFkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBPcmRlckxpc3QucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgT3JkZXJMaXN0LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgT3JkZXJMaXN0LnByb3RvdHlwZSwgXCJsaXN0U3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgT3JkZXJMaXN0LnByb3RvdHlwZSwgXCJyZXNwb25zaXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgT3JkZXJMaXN0LnByb3RvdHlwZSwgXCJmaWx0ZXJCeVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE9yZGVyTGlzdC5wcm90b3R5cGUsIFwiZmlsdGVyUGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgT3JkZXJMaXN0LnByb3RvdHlwZSwgXCJtZXRhS2V5U2VsZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE9yZGVyTGlzdC5wcm90b3R5cGUsIFwiZHJhZ2Ryb3BcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBPcmRlckxpc3QucHJvdG90eXBlLCBcImRyYWdkcm9wU2NvcGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIE9yZGVyTGlzdC5wcm90b3R5cGUsIFwib25SZW9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBPcmRlckxpc3QucHJvdG90eXBlLCBcIm9uU2VsZWN0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBPcmRlckxpc3QucHJvdG90eXBlLCBcIm9uRmlsdGVyRXZlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2xpc3RlbGVtZW50JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgT3JkZXJMaXN0LnByb3RvdHlwZSwgXCJsaXN0Vmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkcmVuKHNoYXJlZF8xLlByaW1lVGVtcGxhdGUpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuUXVlcnlMaXN0KVxuXSwgT3JkZXJMaXN0LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBPcmRlckxpc3QucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuT3JkZXJMaXN0ID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1vcmRlckxpc3QnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJ7J3VpLW9yZGVybGlzdCB1aS13aWRnZXQnOnRydWUsJ3VpLW9yZGVybGlzdC1yZXNwb25zaXZlJzpyZXNwb25zaXZlfVxcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktb3JkZXJsaXN0LWNvbnRyb2xzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtdXBcXFwiIChjbGljayk9XFxcIm1vdmVVcCgkZXZlbnQsbGlzdGVsZW1lbnQpXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtZG91YmxlLXVwXFxcIiAoY2xpY2spPVxcXCJtb3ZlVG9wKCRldmVudCxsaXN0ZWxlbWVudClcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgcEJ1dHRvbiBpY29uPVxcXCJmYS1hbmdsZS1kb3duXFxcIiAoY2xpY2spPVxcXCJtb3ZlRG93bigkZXZlbnQsbGlzdGVsZW1lbnQpXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtZG91YmxlLWRvd25cXFwiIChjbGljayk9XFxcIm1vdmVCb3R0b20oJGV2ZW50LGxpc3RlbGVtZW50KVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktb3JkZXJsaXN0LWxpc3QtY29udGFpbmVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktb3JkZXJsaXN0LWNhcHRpb24gdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItdG9wXFxcIiAqbmdJZj1cXFwiaGVhZGVyXFxcIj57e2hlYWRlcn19PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW9yZGVybGlzdC1maWx0ZXItY29udGFpbmVyIHVpLXdpZGdldC1jb250ZW50XFxcIiAqbmdJZj1cXFwiZmlsdGVyQnlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHJvbGU9XFxcInRleHRib3hcXFwiIChrZXl1cCk9XFxcIm9uRmlsdGVyS2V5dXAoJGV2ZW50KVxcXCIgY2xhc3M9XFxcInVpLWlucHV0dGV4dCB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW2F0dHIucGxhY2Vob2xkZXJdPVxcXCJmaWx0ZXJQbGFjZWhvbGRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtc2VhcmNoXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8dWwgI2xpc3RlbGVtZW50IGNsYXNzPVxcXCJ1aS13aWRnZXQtY29udGVudCB1aS1vcmRlcmxpc3QtbGlzdCB1aS1jb3JuZXItYm90dG9tXFxcIiBbbmdTdHlsZV09XFxcImxpc3RTdHlsZVxcXCIgKGRyYWdvdmVyKT1cXFwib25MaXN0TW91c2VNb3ZlKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cXFwidmFsdWVcXFwiIGxldC1pPVxcXCJpbmRleFxcXCIgbGV0LWw9XFxcImxhc3RcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktb3JkZXJsaXN0LWRyb3Bwb2ludFxcXCIgKm5nSWY9XFxcImRyYWdkcm9wICYmIGlzSXRlbVZpc2libGUoaXRlbSlcXFwiIChkcmFnb3Zlcik9XFxcIm9uRHJhZ092ZXIoJGV2ZW50LCBpKVxcXCIgKGRyb3ApPVxcXCJvbkRyb3AoJGV2ZW50LCBpKVxcXCIgKGRyYWdsZWF2ZSk9XFxcIm9uRHJhZ0xlYXZlKCRldmVudClcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtaGlnaGxpZ2h0JzogKGkgPT09IGRyYWdPdmVySXRlbUluZGV4KX1cXFwiPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1vcmRlcmxpc3QtaXRlbVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWhpZ2hsaWdodCc6aXNTZWxlY3RlZChpdGVtKX1cXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJvbkl0ZW1DbGljaygkZXZlbnQsaXRlbSlcXFwiICh0b3VjaGVuZCk9XFxcIm9uSXRlbVRvdWNoRW5kKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5kaXNwbGF5XT1cXFwiaXNJdGVtVmlzaWJsZShpdGVtKSA/ICdibG9jaycgOiAnbm9uZSdcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkcmFnZ2FibGVdPVxcXCJkcmFnZHJvcFxcXCIgKGRyYWdzdGFydCk9XFxcIm9uRHJhZ1N0YXJ0KCRldmVudCwgaSlcXFwiIChkcmFnZW5kKT1cXFwib25EcmFnRW5kKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW3BUZW1wbGF0ZVdyYXBwZXJdPVxcXCJpdGVtVGVtcGxhdGVcXFwiIFtpdGVtXT1cXFwiaXRlbVxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktb3JkZXJsaXN0LWRyb3Bwb2ludFxcXCIgKm5nSWY9XFxcImRyYWdkcm9wICYmIGxcXFwiIChkcmFnb3Zlcik9XFxcIm9uRHJhZ092ZXIoJGV2ZW50LCBpICsgMSlcXFwiIChkcm9wKT1cXFwib25Ecm9wKCRldmVudCwgaSArIDEpXFxcIiAoZHJhZ2xlYXZlKT1cXFwib25EcmFnTGVhdmUoJGV2ZW50KVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1oaWdobGlnaHQnOiAoaSArIDEgPT09IGRyYWdPdmVySXRlbUluZGV4KX1cXFwiPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgb2JqZWN0dXRpbHNfMS5PYmplY3RVdGlsc11cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgb2JqZWN0dXRpbHNfMS5PYmplY3RVdGlsc10pXG5dLCBPcmRlckxpc3QpO1xuZXhwb3J0cy5PcmRlckxpc3QgPSBPcmRlckxpc3Q7XG52YXIgT3JkZXJMaXN0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcmRlckxpc3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBPcmRlckxpc3RNb2R1bGU7XG59KCkpO1xuT3JkZXJMaXN0TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgYnV0dG9uXzEuQnV0dG9uTW9kdWxlLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbT3JkZXJMaXN0LCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtPcmRlckxpc3RdXG4gICAgfSlcbl0sIE9yZGVyTGlzdE1vZHVsZSk7XG5leHBvcnRzLk9yZGVyTGlzdE1vZHVsZSA9IE9yZGVyTGlzdE1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yZGVybGlzdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL29yZGVybGlzdC9vcmRlcmxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9vcmRlcmxpc3Qvb3JkZXJsaXN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGFuaW1hdGlvbnNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9hbmltYXRpb25zXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBzaGFyZWRfMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vc2hhcmVkXCIpO1xudmFyIE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZVRlbXBsYXRlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcmdhbml6YXRpb25DaGFydE5vZGVUZW1wbGF0ZUxvYWRlcih2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XG4gICAgfVxuICAgIE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZVRlbXBsYXRlTG9hZGVyLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlLCB7XG4gICAgICAgICAgICAnXFwkaW1wbGljaXQnOiB0aGlzLm5vZGVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcmdhbml6YXRpb25DaGFydE5vZGVUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XG4gICAgfTtcbiAgICByZXR1cm4gT3JnYW5pemF0aW9uQ2hhcnROb2RlVGVtcGxhdGVMb2FkZXI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZVRlbXBsYXRlTG9hZGVyLnByb3RvdHlwZSwgXCJub2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlRlbXBsYXRlUmVmKVxuXSwgT3JnYW5pemF0aW9uQ2hhcnROb2RlVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLCBcInRlbXBsYXRlXCIsIHZvaWQgMCk7XG5Pcmdhbml6YXRpb25DaGFydE5vZGVUZW1wbGF0ZUxvYWRlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3Atb3JnYW5pemF0aW9uQ2hhcnROb2RlVGVtcGxhdGVMb2FkZXInLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcIlxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLlZpZXdDb250YWluZXJSZWZdKVxuXSwgT3JnYW5pemF0aW9uQ2hhcnROb2RlVGVtcGxhdGVMb2FkZXIpO1xuZXhwb3J0cy5Pcmdhbml6YXRpb25DaGFydE5vZGVUZW1wbGF0ZUxvYWRlciA9IE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZVRlbXBsYXRlTG9hZGVyO1xudmFyIE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3JnYW5pemF0aW9uQ2hhcnROb2RlKGNoYXJ0KSB7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZS5wcm90b3R5cGUsIFwibGVhZlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5sZWFmID09IGZhbHNlID8gZmFsc2UgOiAhKHRoaXMubm9kZS5jaGlsZHJlbiAmJiB0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZS5wcm90b3R5cGUsIFwiY29sc3BhblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5vZGUuY2hpbGRyZW4gJiYgdGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCkgPyB0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoICogMiA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZS5wcm90b3R5cGUub25Ob2RlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGFydC5vbk5vZGVDbGljayhldmVudCwgbm9kZSk7XG4gICAgfTtcbiAgICBPcmdhbml6YXRpb25DaGFydE5vZGUucHJvdG90eXBlLnRvZ2dsZU5vZGUgPSBmdW5jdGlvbiAoZXZlbnQsIG5vZGUpIHtcbiAgICAgICAgbm9kZS5leHBhbmRlZCA9ICFub2RlLmV4cGFuZGVkO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgT3JnYW5pemF0aW9uQ2hhcnROb2RlLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC5pc1NlbGVjdGVkKHRoaXMubm9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3JnYW5pemF0aW9uQ2hhcnROb2RlO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBPcmdhbml6YXRpb25DaGFydE5vZGUucHJvdG90eXBlLCBcIm5vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgT3JnYW5pemF0aW9uQ2hhcnROb2RlLnByb3RvdHlwZSwgXCJyb290XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZS5wcm90b3R5cGUsIFwiZmlyc3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgT3JnYW5pemF0aW9uQ2hhcnROb2RlLnByb3RvdHlwZSwgXCJsYXN0XCIsIHZvaWQgMCk7XG5Pcmdhbml6YXRpb25DaGFydE5vZGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdbcE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZV0nLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XFxcImNvbHNwYW5cXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1vcmdhbml6YXRpb25jaGFydC1ub2RlLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB7e25vZGUuc3R5bGVDbGFzc319XFxcIiBcXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1vcmdhbml6YXRpb25jaGFydC1zZWxlY3RhYmxlLW5vZGUnOiBjaGFydC5zZWxlY3Rpb25Nb2RlICYmIG5vZGUuc2VsZWN0YWJsZSAhPT0gZmFsc2UsJ3VpLXN0YXRlLWhpZ2hsaWdodCc6aXNTZWxlY3RlZCgpfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XFxcIm9uTm9kZUNsaWNrKCRldmVudCxub2RlKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCIhY2hhcnQuZ2V0VGVtcGxhdGVGb3JOb2RlKG5vZGUpXFxcIj57e25vZGUubGFiZWx9fTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cXFwiY2hhcnQuZ2V0VGVtcGxhdGVGb3JOb2RlKG5vZGUpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8cC1vcmdhbml6YXRpb25DaGFydE5vZGVUZW1wbGF0ZUxvYWRlciBbbm9kZV09XFxcIm5vZGVcXFwiIFt0ZW1wbGF0ZV09XFxcImNoYXJ0LmdldFRlbXBsYXRlRm9yTm9kZShub2RlKVxcXCI+PC9wLW9yZ2FuaXphdGlvbkNoYXJ0Tm9kZVRlbXBsYXRlTG9hZGVyPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiIWxlYWZcXFwiIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJ1aS1ub2RlLXRvZ2dsZXJcXFwiIChjbGljayk9XFxcInRvZ2dsZU5vZGUoJGV2ZW50LCBub2RlKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIHVpLW5vZGUtdG9nZ2xlci1pY29uXFxcIiBbbmdDbGFzc109XFxcInsnZmEtY2hldnJvbi1kb3duJzogbm9kZS5leHBhbmRlZCwgJ2ZhLWNoZXZyb24tdXAnOiAhbm9kZS5leHBhbmRlZH1cXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgICA8dHIgW3N0eWxlLnZpc2liaWxpdHldPVxcXCIhbGVhZiYmbm9kZS5leHBhbmRlZCA/ICdpbmhlcml0JyA6ICdoaWRkZW4nXFxcIiBjbGFzcz1cXFwidWktb3JnYW5pemF0aW9uY2hhcnQtbGluZXNcXFwiIFtAY2hpbGRTdGF0ZV09XFxcIidpbidcXFwiPlxcbiAgICAgICAgICAgIDx0ZCBbYXR0ci5jb2xzcGFuXT1cXFwiY29sc3BhblxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW9yZ2FuaXphdGlvbmNoYXJ0LWxpbmUtZG93blxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgICA8dHIgW3N0eWxlLnZpc2liaWxpdHldPVxcXCIhbGVhZiYmbm9kZS5leHBhbmRlZCA/ICdpbmhlcml0JyA6ICdoaWRkZW4nXFxcIiBjbGFzcz1cXFwidWktb3JnYW5pemF0aW9uY2hhcnQtbGluZXNcXFwiIFtAY2hpbGRTdGF0ZV09XFxcIidpbidcXFwiPlxcbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY2hpbGQgW25nRm9yT2ZdPVxcXCJub2RlLmNoaWxkcmVuXFxcIiBsZXQtZmlyc3Q9XFxcImZpcnN0XFxcIiBsZXQtbGFzdD1cXFwibGFzdFxcXCI+XFxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidWktb3JnYW5pemF0aW9uY2hhcnQtbGluZS1sZWZ0XFxcIiBbbmdDbGFzc109XFxcInsndWktb3JnYW5pemF0aW9uY2hhcnQtbGluZS10b3AnOiFmaXJzdH1cXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidWktb3JnYW5pemF0aW9uY2hhcnQtbGluZS1yaWdodFxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLW9yZ2FuaXphdGlvbmNoYXJ0LWxpbmUtdG9wJzohbGFzdH1cXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgICA8dHIgW3N0eWxlLnZpc2liaWxpdHldPVxcXCIhbGVhZiYmbm9kZS5leHBhbmRlZCA/ICdpbmhlcml0JyA6ICdoaWRkZW4nXFxcIiBjbGFzcz1cXFwidWktb3JnYW5pemF0aW9uY2hhcnQtbm9kZXNcXFwiIFtAY2hpbGRTdGF0ZV09XFxcIidpbidcXFwiPlxcbiAgICAgICAgICAgIDx0ZCAqbmdGb3I9XFxcImxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuXFxcIiBjb2xzcGFuPVxcXCIyXFxcIj5cXG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJ1aS1vcmdhbml6YXRpb25jaGFydC10YWJsZVxcXCIgcE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZSBbbm9kZV09XFxcImNoaWxkXFxcIj48L3RhYmxlPlxcbiAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICA8L3RyPlxcbiAgICBcIixcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyaWdnZXIoJ2NoaWxkU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCdpbicsIGFuaW1hdGlvbnNfMS5zdHlsZSh7IG9wYWNpdHk6IDEgfSkpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS50cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5zdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5hbmltYXRlKDE1MClcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEudHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuYW5pbWF0ZSgxNTAsIGFuaW1hdGlvbnNfMS5zdHlsZSh7IG9wYWNpdHk6IDAgfSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0sXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBjb3JlXzEuSW5qZWN0KGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9yZ2FuaXphdGlvbkNoYXJ0OyB9KSkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT3JnYW5pemF0aW9uQ2hhcnRdKVxuXSwgT3JnYW5pemF0aW9uQ2hhcnROb2RlKTtcbmV4cG9ydHMuT3JnYW5pemF0aW9uQ2hhcnROb2RlID0gT3JnYW5pemF0aW9uQ2hhcnROb2RlO1xudmFyIE9yZ2FuaXphdGlvbkNoYXJ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcmdhbml6YXRpb25DaGFydChlbCwgZG9tSGFuZGxlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk5vZGVTZWxlY3QgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTm9kZVVuc2VsZWN0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yZ2FuaXphdGlvbkNoYXJ0LnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCA/IHRoaXMudmFsdWVbMF0gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPcmdhbml6YXRpb25DaGFydC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlTWFwID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgX3RoaXMudGVtcGxhdGVNYXBbaXRlbS5nZXRUeXBlKCldID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcmdhbml6YXRpb25DaGFydC5wcm90b3R5cGUuZ2V0VGVtcGxhdGVGb3JOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGVNYXApXG4gICAgICAgICAgICByZXR1cm4gbm9kZS50eXBlID8gdGhpcy50ZW1wbGF0ZU1hcFtub2RlLnR5cGVdIDogdGhpcy50ZW1wbGF0ZU1hcFsnZGVmYXVsdCddO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE9yZ2FuaXphdGlvbkNoYXJ0LnByb3RvdHlwZS5vbk5vZGVDbGljayA9IGZ1bmN0aW9uIChldmVudCwgbm9kZSkge1xuICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmIChldmVudFRhcmdldC5jbGFzc05hbWUgJiYgKGV2ZW50VGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCd1aS1ub2RlLXRvZ2dsZXInKSAhPT0gLTEgfHwgZXZlbnRUYXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ3VpLW5vZGUtdG9nZ2xlci1pY29uJykgIT09IC0xKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc2VsZWN0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXhfMSA9IHRoaXMuZmluZEluZGV4SW5TZWxlY3Rpb24obm9kZSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSAoaW5kZXhfMSA+PSAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVVbnNlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIG5vZGU6IG5vZGUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlU2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBpbmRleF8xOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVVbnNlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIG5vZGU6IG5vZGUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9ICh0aGlzLnNlbGVjdGlvbiB8fCBbXSkuY29uY2F0KFtub2RlXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlU2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3JnYW5pemF0aW9uQ2hhcnQucHJvdG90eXBlLmZpbmRJbmRleEluU2VsZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgJiYgdGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAodGhpcy5zZWxlY3Rpb24gPT0gbm9kZSkgPyAwIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbltpXSA9PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBPcmdhbml6YXRpb25DaGFydC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRJbmRleEluU2VsZWN0aW9uKG5vZGUpICE9IC0xO1xuICAgIH07XG4gICAgcmV0dXJuIE9yZ2FuaXphdGlvbkNoYXJ0O1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIE9yZ2FuaXphdGlvbkNoYXJ0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE9yZ2FuaXphdGlvbkNoYXJ0LnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE9yZ2FuaXphdGlvbkNoYXJ0LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgT3JnYW5pemF0aW9uQ2hhcnQucHJvdG90eXBlLCBcInNlbGVjdGlvbk1vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBPcmdhbml6YXRpb25DaGFydC5wcm90b3R5cGUsIFwic2VsZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBPcmdhbml6YXRpb25DaGFydC5wcm90b3R5cGUsIFwic2VsZWN0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBPcmdhbml6YXRpb25DaGFydC5wcm90b3R5cGUsIFwib25Ob2RlU2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBPcmdhbml6YXRpb25DaGFydC5wcm90b3R5cGUsIFwib25Ob2RlVW5zZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oc2hhcmVkXzIuUHJpbWVUZW1wbGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5RdWVyeUxpc3QpXG5dLCBPcmdhbml6YXRpb25DaGFydC5wcm90b3R5cGUsIFwidGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5Pcmdhbml6YXRpb25DaGFydCA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3Atb3JnYW5pemF0aW9uQ2hhcnQnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCIgW25nQ2xhc3NdPVxcXCIndWktb3JnYW5pemF0aW9uY2hhcnQgdWktd2lkZ2V0J1xcXCI+XFxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJ1aS1vcmdhbml6YXRpb25jaGFydC10YWJsZVxcXCIgcE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZSBbbm9kZV09XFxcInJvb3RcXFwiPjwvdGFibGU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIE9yZ2FuaXphdGlvbkNoYXJ0KTtcbmV4cG9ydHMuT3JnYW5pemF0aW9uQ2hhcnQgPSBPcmdhbml6YXRpb25DaGFydDtcbnZhciBPcmdhbml6YXRpb25DaGFydE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3JnYW5pemF0aW9uQ2hhcnRNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBPcmdhbml6YXRpb25DaGFydE1vZHVsZTtcbn0oKSk7XG5Pcmdhbml6YXRpb25DaGFydE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbT3JnYW5pemF0aW9uQ2hhcnQsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW09yZ2FuaXphdGlvbkNoYXJ0LCBPcmdhbml6YXRpb25DaGFydE5vZGUsIE9yZ2FuaXphdGlvbkNoYXJ0Tm9kZVRlbXBsYXRlTG9hZGVyXVxuICAgIH0pXG5dLCBPcmdhbml6YXRpb25DaGFydE1vZHVsZSk7XG5leHBvcnRzLk9yZ2FuaXphdGlvbkNoYXJ0TW9kdWxlID0gT3JnYW5pemF0aW9uQ2hhcnRNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcmdhbml6YXRpb25jaGFydC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL29yZ2FuaXphdGlvbmNoYXJ0L29yZ2FuaXphdGlvbmNoYXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvb3JnYW5pemF0aW9uY2hhcnQvb3JnYW5pemF0aW9uY2hhcnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgT3ZlcmxheVBhbmVsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5UGFuZWwoZWwsIGRvbUhhbmRsZXIsIHJlbmRlcmVyLCBjZCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmRpc21pc3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbkJlZm9yZVNob3cgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQWZ0ZXJTaG93ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkJlZm9yZUhpZGUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQWZ0ZXJIaWRlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIE92ZXJsYXlQYW5lbC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRpc21pc3NhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNlbGZDbGljayAmJiAhX3RoaXMudGFyZ2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zZWxmQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXRFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE92ZXJsYXlQYW5lbC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvID09PSAnYm9keScpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyLCB0aGlzLmFwcGVuZFRvKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3ZlcmxheVBhbmVsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCkge1xuICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9ICh0YXJnZXQgfHwgZXZlbnQuY3VycmVudFRhcmdldCB8fCBldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0IHx8IHRoaXMudGFyZ2V0ID09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGUpXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc21pc3NhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgfTtcbiAgICBPdmVybGF5UGFuZWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5kaXNtaXNzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkJlZm9yZVNob3cuZW1pdChudWxsKTtcbiAgICAgICAgdmFyIGVsZW1lbnRUYXJnZXQgPSB0YXJnZXQgfHwgZXZlbnQuY3VycmVudFRhcmdldCB8fCBldmVudC50YXJnZXQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCA9ICsrZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4O1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbih0aGlzLmNvbnRhaW5lciwgZWxlbWVudFRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24odGhpcy5jb250YWluZXIsIGVsZW1lbnRUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmZhZGVJbih0aGlzLmNvbnRhaW5lciwgMjUwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQWZ0ZXJTaG93LmVtaXQobnVsbCk7XG4gICAgfTtcbiAgICBPdmVybGF5UGFuZWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMub25CZWZvcmVIaWRlLmVtaXQobnVsbCk7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25BZnRlckhpZGUuZW1pdChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3ZlcmxheVBhbmVsLnByb3RvdHlwZS5vblBhbmVsQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc21pc3NhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGZDbGljayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE92ZXJsYXlQYW5lbC5wcm90b3R5cGUub25DbG9zZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICBpZiAodGhpcy5kaXNtaXNzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxmQ2xpY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBPdmVybGF5UGFuZWwucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8pIHtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE92ZXJsYXlQYW5lbDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE92ZXJsYXlQYW5lbC5wcm90b3R5cGUsIFwiZGlzbWlzc2FibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgT3ZlcmxheVBhbmVsLnByb3RvdHlwZSwgXCJzaG93Q2xvc2VJY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgT3ZlcmxheVBhbmVsLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE92ZXJsYXlQYW5lbC5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE92ZXJsYXlQYW5lbC5wcm90b3R5cGUsIFwiYXBwZW5kVG9cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIE92ZXJsYXlQYW5lbC5wcm90b3R5cGUsIFwib25CZWZvcmVTaG93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBPdmVybGF5UGFuZWwucHJvdG90eXBlLCBcIm9uQWZ0ZXJTaG93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBPdmVybGF5UGFuZWwucHJvdG90eXBlLCBcIm9uQmVmb3JlSGlkZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgT3ZlcmxheVBhbmVsLnByb3RvdHlwZSwgXCJvbkFmdGVySGlkZVwiLCB2b2lkIDApO1xuT3ZlcmxheVBhbmVsID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1vdmVybGF5UGFuZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCIndWktb3ZlcmxheXBhbmVsIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLXNoYWRvdydcXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiXFxuICAgICAgICAgICAgW3N0eWxlLmRpc3BsYXldPVxcXCJ2aXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJ1xcXCIgKGNsaWNrKT1cXFwib25QYW5lbENsaWNrKClcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLW92ZXJsYXlwYW5lbC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiICpuZ0lmPVxcXCJzaG93Q2xvc2VJY29uXFxcIiBjbGFzcz1cXFwidWktb3ZlcmxheXBhbmVsLWNsb3NlIHVpLXN0YXRlLWRlZmF1bHRcXFwiIChjbGljayk9XFxcIm9uQ2xvc2VDbGljaygkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWZ3IGZhLWNsb3NlXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMiwgY29yZV8xLkNoYW5nZURldGVjdG9yUmVmXSlcbl0sIE92ZXJsYXlQYW5lbCk7XG5leHBvcnRzLk92ZXJsYXlQYW5lbCA9IE92ZXJsYXlQYW5lbDtcbnZhciBPdmVybGF5UGFuZWxNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlQYW5lbE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE92ZXJsYXlQYW5lbE1vZHVsZTtcbn0oKSk7XG5PdmVybGF5UGFuZWxNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW092ZXJsYXlQYW5lbF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW092ZXJsYXlQYW5lbF1cbiAgICB9KVxuXSwgT3ZlcmxheVBhbmVsTW9kdWxlKTtcbmV4cG9ydHMuT3ZlcmxheVBhbmVsTW9kdWxlID0gT3ZlcmxheVBhbmVsTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3ZlcmxheXBhbmVsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvb3ZlcmxheXBhbmVsL292ZXJsYXlwYW5lbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL292ZXJsYXlwYW5lbC9vdmVybGF5cGFuZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBQYWdpbmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZ2luYXRvcigpIHtcbiAgICAgICAgdGhpcy5wYWdlTGlua1NpemUgPSA1O1xuICAgICAgICB0aGlzLm9uUGFnZUNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWx3YXlzU2hvdyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RvdGFsUmVjb3JkcyA9IDA7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gMDtcbiAgICAgICAgdGhpcy5fcm93cyA9IDA7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdpbmF0b3IucHJvdG90eXBlLCBcInRvdGFsUmVjb3Jkc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsUmVjb3JkcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl90b3RhbFJlY29yZHMgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VMaW5rcygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFnaW5hdG9yLnByb3RvdHlwZSwgXCJmaXJzdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gdmFsO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdlTGlua3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhZ2luYXRvci5wcm90b3R5cGUsIFwicm93c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fcm93cyA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFnZUxpbmtzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFBhZ2luYXRvci5wcm90b3R5cGUuaXNGaXJzdFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2UoKSA9PT0gMDtcbiAgICB9O1xuICAgIFBhZ2luYXRvci5wcm90b3R5cGUuaXNMYXN0UGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZSgpID09PSB0aGlzLmdldFBhZ2VDb3VudCgpIC0gMTtcbiAgICB9O1xuICAgIFBhZ2luYXRvci5wcm90b3R5cGUuZ2V0UGFnZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMudG90YWxSZWNvcmRzIC8gdGhpcy5yb3dzKSB8fCAxO1xuICAgIH07XG4gICAgUGFnaW5hdG9yLnByb3RvdHlwZS5jYWxjdWxhdGVQYWdlTGlua0JvdW5kYXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZlBhZ2VzID0gdGhpcy5nZXRQYWdlQ291bnQoKSwgdmlzaWJsZVBhZ2VzID0gTWF0aC5taW4odGhpcy5wYWdlTGlua1NpemUsIG51bWJlck9mUGFnZXMpO1xuICAgICAgICAvL2NhbGN1bGF0ZSByYW5nZSwga2VlcCBjdXJyZW50IGluIG1pZGRsZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHRoaXMuZ2V0UGFnZSgpIC0gKCh2aXNpYmxlUGFnZXMpIC8gMikpKSwgZW5kID0gTWF0aC5taW4obnVtYmVyT2ZQYWdlcyAtIDEsIHN0YXJ0ICsgdmlzaWJsZVBhZ2VzIC0gMSk7XG4gICAgICAgIC8vY2hlY2sgd2hlbiBhcHByb2FjaGluZyB0byBsYXN0IHBhZ2VcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5wYWdlTGlua1NpemUgLSAoZW5kIC0gc3RhcnQgKyAxKTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCAtIGRlbHRhKTtcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgICB9O1xuICAgIFBhZ2luYXRvci5wcm90b3R5cGUudXBkYXRlUGFnZUxpbmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhZ2VMaW5rcyA9IFtdO1xuICAgICAgICB2YXIgYm91bmRhcmllcyA9IHRoaXMuY2FsY3VsYXRlUGFnZUxpbmtCb3VuZGFyaWVzKCksIHN0YXJ0ID0gYm91bmRhcmllc1swXSwgZW5kID0gYm91bmRhcmllc1sxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VMaW5rcy5wdXNoKGkgKyAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFnaW5hdG9yLnByb3RvdHlwZS5jaGFuZ2VQYWdlID0gZnVuY3Rpb24gKHAsIGV2ZW50KSB7XG4gICAgICAgIHZhciBwYyA9IHRoaXMuZ2V0UGFnZUNvdW50KCk7XG4gICAgICAgIGlmIChwID49IDAgJiYgcCA8IHBjKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gdGhpcy5yb3dzICogcDtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBwYWdlOiBwLFxuICAgICAgICAgICAgICAgIGZpcnN0OiB0aGlzLmZpcnN0LFxuICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMucm93cyxcbiAgICAgICAgICAgICAgICBwYWdlQ291bnQ6IHBjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdlTGlua3MoKTtcbiAgICAgICAgICAgIHRoaXMub25QYWdlQ2hhbmdlLmVtaXQoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFnaW5hdG9yLnByb3RvdHlwZS5nZXRQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmZpcnN0IC8gdGhpcy5yb3dzKTtcbiAgICB9O1xuICAgIFBhZ2luYXRvci5wcm90b3R5cGUuY2hhbmdlUGFnZVRvRmlyc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKDAsIGV2ZW50KTtcbiAgICB9O1xuICAgIFBhZ2luYXRvci5wcm90b3R5cGUuY2hhbmdlUGFnZVRvUHJldiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmNoYW5nZVBhZ2UodGhpcy5nZXRQYWdlKCkgLSAxLCBldmVudCk7XG4gICAgfTtcbiAgICBQYWdpbmF0b3IucHJvdG90eXBlLmNoYW5nZVBhZ2VUb05leHQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKHRoaXMuZ2V0UGFnZSgpICsgMSwgZXZlbnQpO1xuICAgIH07XG4gICAgUGFnaW5hdG9yLnByb3RvdHlwZS5jaGFuZ2VQYWdlVG9MYXN0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlUGFnZSh0aGlzLmdldFBhZ2VDb3VudCgpIC0gMSwgZXZlbnQpO1xuICAgIH07XG4gICAgUGFnaW5hdG9yLnByb3RvdHlwZS5vblJwcENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3NQZXJQYWdlT3B0aW9uc1tldmVudC50YXJnZXQuc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIHRoaXMuY2hhbmdlUGFnZVRvRmlyc3QoZXZlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhZ2luYXRvcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUGFnaW5hdG9yLnByb3RvdHlwZSwgXCJwYWdlTGlua1NpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFBhZ2luYXRvci5wcm90b3R5cGUsIFwib25QYWdlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFnaW5hdG9yLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhZ2luYXRvci5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgUGFnaW5hdG9yLnByb3RvdHlwZSwgXCJyb3dzUGVyUGFnZU9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGFnaW5hdG9yLnByb3RvdHlwZSwgXCJhbHdheXNTaG93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBQYWdpbmF0b3IucHJvdG90eXBlLCBcInRvdGFsUmVjb3Jkc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIFBhZ2luYXRvci5wcm90b3R5cGUsIFwiZmlyc3RcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBQYWdpbmF0b3IucHJvdG90eXBlLCBcInJvd3NcIiwgbnVsbCk7XG5QYWdpbmF0b3IgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLXBhZ2luYXRvcicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbbmdDbGFzc109XFxcIid1aS1wYWdpbmF0b3IgdWktd2lkZ2V0IHVpLXdpZGdldC1oZWFkZXIgdWktdW5zZWxlY3RhYmxlLXRleHQnXFxcIlxcbiAgICAgICAgICAgICpuZ0lmPVxcXCJhbHdheXNTaG93ID8gdHJ1ZSA6IChwYWdlTGlua3MgJiYgcGFnZUxpbmtzLmxlbmd0aCA+IDEpXFxcIj5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwidWktcGFnaW5hdG9yLWZpcnN0IHVpLXBhZ2luYXRvci1lbGVtZW50IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XFxcImNoYW5nZVBhZ2VUb0ZpcnN0KCRldmVudClcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1kaXNhYmxlZCc6aXNGaXJzdFBhZ2UoKX1cXFwiIFt0YWJpbmRleF09XFxcImlzRmlyc3RQYWdlKCkgPyAtMSA6IG51bGxcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtc3RlcC1iYWNrd2FyZFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwidWktcGFnaW5hdG9yLXByZXYgdWktcGFnaW5hdG9yLWVsZW1lbnQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwiY2hhbmdlUGFnZVRvUHJldigkZXZlbnQpXFxcIiBbbmdDbGFzc109XFxcInsndWktc3RhdGUtZGlzYWJsZWQnOmlzRmlyc3RQYWdlKCl9XFxcIiBbdGFiaW5kZXhdPVxcXCJpc0ZpcnN0UGFnZSgpID8gLTEgOiBudWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWJhY2t3YXJkXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1wYWdpbmF0b3ItcGFnZXNcXFwiPlxcbiAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiAqbmdGb3I9XFxcImxldCBwYWdlTGluayBvZiBwYWdlTGlua3NcXFwiIGNsYXNzPVxcXCJ1aS1wYWdpbmF0b3ItcGFnZSB1aS1wYWdpbmF0b3ItZWxlbWVudCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJjaGFuZ2VQYWdlKHBhZ2VMaW5rIC0gMSwgJGV2ZW50KVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWFjdGl2ZSc6IChwYWdlTGluay0xID09IGdldFBhZ2UoKSl9XFxcIj57e3BhZ2VMaW5rfX08L2E+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJ1aS1wYWdpbmF0b3ItbmV4dCB1aS1wYWdpbmF0b3ItZWxlbWVudCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJjaGFuZ2VQYWdlVG9OZXh0KCRldmVudClcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1kaXNhYmxlZCc6aXNMYXN0UGFnZSgpfVxcXCIgW3RhYmluZGV4XT1cXFwiaXNMYXN0UGFnZSgpID8gLTEgOiBudWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWZvcndhcmRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInVpLXBhZ2luYXRvci1sYXN0IHVpLXBhZ2luYXRvci1lbGVtZW50IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XFxcImNoYW5nZVBhZ2VUb0xhc3QoJGV2ZW50KVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzppc0xhc3RQYWdlKCl9XFxcIiBbdGFiaW5kZXhdPVxcXCJpc0xhc3RQYWdlKCkgPyAtMSA6IG51bGxcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtc3RlcC1mb3J3YXJkXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XFxcInVpLXBhZ2luYXRvci1ycHAtb3B0aW9ucyB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdFxcXCIgKm5nSWY9XFxcInJvd3NQZXJQYWdlT3B0aW9uc1xcXCIgKGNoYW5nZSk9XFxcIm9uUnBwQ2hhbmdlKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICA8b3B0aW9uICpuZ0Zvcj1cXFwibGV0IG9wdCBvZiByb3dzUGVyUGFnZU9wdGlvbnNcXFwiIFt2YWx1ZV09XFxcIm9wdFxcXCIgW3NlbGVjdGVkXT1cXFwicm93cyA9PSBvcHRcXFwiPnt7b3B0fX08L29wdGlvbj5cXG4gICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIlxuICAgIH0pXG5dLCBQYWdpbmF0b3IpO1xuZXhwb3J0cy5QYWdpbmF0b3IgPSBQYWdpbmF0b3I7XG52YXIgUGFnaW5hdG9yTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWdpbmF0b3JNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBQYWdpbmF0b3JNb2R1bGU7XG59KCkpO1xuUGFnaW5hdG9yTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtQYWdpbmF0b3JdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtQYWdpbmF0b3JdXG4gICAgfSlcbl0sIFBhZ2luYXRvck1vZHVsZSk7XG5leHBvcnRzLlBhZ2luYXRvck1vZHVsZSA9IFBhZ2luYXRvck1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2luYXRvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL3BhZ2luYXRvci9wYWdpbmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9wYWdpbmF0b3IvcGFnaW5hdG9yLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBhbmltYXRpb25zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvYW5pbWF0aW9uc1wiKTtcbnZhciBQYW5lbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFuZWwoZWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV4cGFuZEljb24gPSAnZmEtcGx1cyc7XG4gICAgICAgIHRoaXMuY29sbGFwc2VJY29uID0gJ2ZhLW1pbnVzJztcbiAgICAgICAgdGhpcy5jb2xsYXBzZWRDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQmVmb3JlVG9nZ2xlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkFmdGVyVG9nZ2xlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgUGFuZWwucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub25CZWZvcmVUb2dnbGUuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBjb2xsYXBzZWQ6IHRoaXMuY29sbGFwc2VkIH0pO1xuICAgICAgICBpZiAodGhpcy50b2dnbGVhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmQoZXZlbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25BZnRlclRvZ2dsZS5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGNvbGxhcHNlZDogdGhpcy5jb2xsYXBzZWQgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBQYW5lbC5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkQ2hhbmdlLmVtaXQodGhpcy5jb2xsYXBzZWQpO1xuICAgIH07XG4gICAgUGFuZWwucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZWRDaGFuZ2UuZW1pdCh0aGlzLmNvbGxhcHNlZCk7XG4gICAgfTtcbiAgICBQYW5lbC5wcm90b3R5cGUuZ2V0QmxvY2thYmxlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICB9O1xuICAgIFBhbmVsLnByb3RvdHlwZS5vblRvZ2dsZURvbmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBQYW5lbDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFBhbmVsLnByb3RvdHlwZSwgXCJ0b2dnbGVhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZWwucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQYW5lbC5wcm90b3R5cGUsIFwiY29sbGFwc2VkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZWwucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZWwucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lbC5wcm90b3R5cGUsIFwiZXhwYW5kSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVsLnByb3RvdHlwZSwgXCJjb2xsYXBzZUljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFBhbmVsLnByb3RvdHlwZSwgXCJjb2xsYXBzZWRDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFBhbmVsLnByb3RvdHlwZSwgXCJvbkJlZm9yZVRvZ2dsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgUGFuZWwucHJvdG90eXBlLCBcIm9uQWZ0ZXJUb2dnbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGQoc2hhcmVkXzEuRm9vdGVyKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZWwucHJvdG90eXBlLCBcImZvb3RlckZhY2V0XCIsIHZvaWQgMCk7XG5QYW5lbCA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtcGFuZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCIndWktcGFuZWwgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1wYW5lbC10aXRsZWJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXBhbmVsLXRpdGxlXFxcIiAqbmdJZj1cXFwiaGVhZGVyXFxcIj57e2hlYWRlcn19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcInAtaGVhZGVyXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCJ0b2dnbGVhYmxlXFxcIiBjbGFzcz1cXFwidWktcGFuZWwtdGl0bGViYXItaWNvbiB1aS1wYW5lbC10aXRsZWJhci10b2dnbGVyIHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGVmYXVsdFxcXCIgaHJlZj1cXFwiI1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XFxcInRvZ2dsZSgkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIFtjbGFzc109XFxcImNvbGxhcHNlZCA/ICdmYSBmYS1mdyAnICsgZXhwYW5kSWNvbiA6ICdmYSBmYS1mdyAnICsgY29sbGFwc2VJY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1wYW5lbC1jb250ZW50LXdyYXBwZXJcXFwiIFtAcGFuZWxDb250ZW50XT1cXFwiY29sbGFwc2VkID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcXFwiIChAcGFuZWxDb250ZW50LmRvbmUpPVxcXCJvblRvZ2dsZURvbmUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXBhbmVsLWNvbnRlbnQtd3JhcHBlci1vdmVyZmxvd24nOiBjb2xsYXBzZWR8fGFuaW1hdGluZ31cXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1wYW5lbC1jb250ZW50IHVpLXdpZGdldC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1wYW5lbC1mb290ZXIgdWktd2lkZ2V0LWNvbnRlbnRcXFwiICpuZ0lmPVxcXCJmb290ZXJGYWNldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcInAtZm9vdGVyXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICBhbmltYXRpb25zXzEudHJpZ2dlcigncGFuZWxDb250ZW50JywgW1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5zdGF0ZSgnaGlkZGVuJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMCdcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCd2aXNpYmxlJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnKidcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyYW5zaXRpb24oJ3Zpc2libGUgPD0+IGhpZGRlbicsIGFuaW1hdGlvbnNfMS5hbmltYXRlKCc0MDBtcyBjdWJpYy1iZXppZXIoMC44NiwgMCwgMC4wNywgMSknKSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmXSlcbl0sIFBhbmVsKTtcbmV4cG9ydHMuUGFuZWwgPSBQYW5lbDtcbnZhciBQYW5lbE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFuZWxNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbE1vZHVsZTtcbn0oKSk7XG5QYW5lbE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbUGFuZWwsIHNoYXJlZF8xLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1BhbmVsXVxuICAgIH0pXG5dLCBQYW5lbE1vZHVsZSk7XG5leHBvcnRzLlBhbmVsTW9kdWxlID0gUGFuZWxNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYW5lbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL3BhbmVsL3BhbmVsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvcGFuZWwvcGFuZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYW5pbWF0aW9uc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2FuaW1hdGlvbnNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL3JvdXRlclwiKTtcbnZhciBCYXNlUGFuZWxNZW51SXRlbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVBhbmVsTWVudUl0ZW0oKSB7XG4gICAgfVxuICAgIEJhc2VQYW5lbE1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLmV4cGFuZGVkID0gIWl0ZW0uZXhwYW5kZWQ7XG4gICAgICAgIGlmICghaXRlbS51cmwpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0uY29tbWFuZCkge1xuICAgICAgICAgICAgaXRlbS5jb21tYW5kKHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJhc2VQYW5lbE1lbnVJdGVtO1xufSgpKTtcbmV4cG9ydHMuQmFzZVBhbmVsTWVudUl0ZW0gPSBCYXNlUGFuZWxNZW51SXRlbTtcbnZhciBQYW5lbE1lbnVTdWIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbE1lbnVTdWIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxNZW51U3ViKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5lbE1lbnVTdWI7XG59KEJhc2VQYW5lbE1lbnVJdGVtKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZWxNZW51U3ViLnByb3RvdHlwZSwgXCJpdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFBhbmVsTWVudVN1Yi5wcm90b3R5cGUsIFwiZXhwYW5kZWRcIiwgdm9pZCAwKTtcblBhbmVsTWVudVN1YiA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtcGFuZWxNZW51U3ViJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8dWwgY2xhc3M9XFxcInVpLW1lbnUtbGlzdCB1aS1oZWxwZXItcmVzZXRcXFwiIFtAc3VibWVudV09XFxcImV4cGFuZGVkID8gJ3Zpc2libGUnIDogJ2hpZGRlbidcXFwiPlxcbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY2hpbGQgW25nRm9yT2ZdPVxcXCJpdGVtLml0ZW1zXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpICpuZ0lmPVxcXCJjaGlsZC5zZXBhcmF0b3JcXFwiIGNsYXNzPVxcXCJ1aS1tZW51LXNlcGFyYXRvciB1aS13aWRnZXQtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSAqbmdJZj1cXFwiIWNoaWxkLnNlcGFyYXRvclxcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtIHVpLWNvcm5lci1hbGxcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1tZW51LXBhcmVudCc6Y2hpbGQuaXRlbXN9XFxcIiBbY2xhc3NdPVxcXCJjaGlsZC5zdHlsZUNsYXNzXFxcIiBbbmdTdHlsZV09XFxcImNoaWxkLnN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCIhY2hpbGQucm91dGVyTGlua1xcXCIgW2hyZWZdPVxcXCJjaGlsZC51cmx8fCcjJ1xcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtLWxpbmsgdWktY29ybmVyLWFsbFxcXCIgW2F0dHIudGFiaW5kZXhdPVxcXCJpdGVtLmV4cGFuZGVkID8gbnVsbCA6ICctMSdcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLW1lbnVpdGVtLWxpbmstaGFzaWNvbic6Y2hpbGQuaWNvbiYmY2hpbGQuaXRlbXMsJ3VpLXN0YXRlLWRpc2FibGVkJzpjaGlsZC5kaXNhYmxlZH1cXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XFxcImhhbmRsZUNsaWNrKCRldmVudCxjaGlsZClcXFwiIFthdHRyLnRhcmdldF09XFxcImNoaWxkLnRhcmdldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXBhbmVsbWVudS1pY29uIGZhIGZhLWZ3XFxcIiBbbmdDbGFzc109XFxcInsnZmEtY2FyZXQtcmlnaHQnOiFjaGlsZC5leHBhbmRlZCwnZmEtY2FyZXQtZG93bic6Y2hpbGQuZXhwYW5kZWR9XFxcIiAqbmdJZj1cXFwiY2hpbGQuaXRlbXNcXFwiPjwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgID48c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYSBmYS1md1xcXCIgW25nQ2xhc3NdPVxcXCJjaGlsZC5pY29uXFxcIiAqbmdJZj1cXFwiY2hpbGQuaWNvblxcXCI+PC9zcGFuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPjxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS10ZXh0XFxcIj57e2NoaWxkLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiY2hpbGQucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtdPVxcXCJjaGlsZC5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIid1aS1zdGF0ZS1hY3RpdmUnXFxcIiBbcm91dGVyTGlua0FjdGl2ZU9wdGlvbnNdPVxcXCJjaGlsZC5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc3x8e2V4YWN0OmZhbHNlfVxcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtLWxpbmsgdWktY29ybmVyLWFsbFxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLW1lbnVpdGVtLWxpbmstaGFzaWNvbic6Y2hpbGQuaWNvbiYmY2hpbGQuaXRlbXMsJ3VpLXN0YXRlLWRpc2FibGVkJzpjaGlsZC5kaXNhYmxlZH1cXFwiIFthdHRyLnRhYmluZGV4XT1cXFwiaXRlbS5leHBhbmRlZCA/IG51bGwgOiAnLTEnXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJoYW5kbGVDbGljaygkZXZlbnQsY2hpbGQpXFxcIiBbYXR0ci50YXJnZXRdPVxcXCJjaGlsZC50YXJnZXRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1wYW5lbG1lbnUtaWNvbiBmYSBmYS1md1xcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhLWNhcmV0LXJpZ2h0JzohY2hpbGQuZXhwYW5kZWQsJ2ZhLWNhcmV0LWRvd24nOmNoaWxkLmV4cGFuZGVkfVxcXCIgKm5nSWY9XFxcImNoaWxkLml0ZW1zXFxcIj48L3NwYW5cXG4gICAgICAgICAgICAgICAgICAgICAgICA+PHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLWljb24gZmEgZmEtZndcXFwiIFtuZ0NsYXNzXT1cXFwiY2hpbGQuaWNvblxcXCIgKm5nSWY9XFxcImNoaWxkLmljb25cXFwiPjwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgID48c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0tdGV4dFxcXCI+e3tjaGlsZC5sYWJlbH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPHAtcGFuZWxNZW51U3ViIFtpdGVtXT1cXFwiY2hpbGRcXFwiIFtleHBhbmRlZF09XFxcImNoaWxkLmV4cGFuZGVkXFxcIiAqbmdJZj1cXFwiY2hpbGQuaXRlbXNcXFwiPjwvcC1wYW5lbE1lbnVTdWI+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgIDwvdWw+XFxuICAgIFwiLFxuICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICBhbmltYXRpb25zXzEudHJpZ2dlcignc3VibWVudScsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuc3RhdGUoJ2hpZGRlbicsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzBweCdcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCd2aXNpYmxlJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnKidcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyYW5zaXRpb24oJ3Zpc2libGUgPT4gaGlkZGVuJywgYW5pbWF0aW9uc18xLmFuaW1hdGUoJzQwMG1zIGN1YmljLWJlemllcigwLjg2LCAwLCAwLjA3LCAxKScpKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEudHJhbnNpdGlvbignaGlkZGVuID0+IHZpc2libGUnLCBhbmltYXRpb25zXzEuYW5pbWF0ZSgnNDAwbXMgY3ViaWMtYmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpJykpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdXG4gICAgfSlcbl0sIFBhbmVsTWVudVN1Yik7XG5leHBvcnRzLlBhbmVsTWVudVN1YiA9IFBhbmVsTWVudVN1YjtcbnZhciBQYW5lbE1lbnUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5lbE1lbnUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxNZW51KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFBhbmVsTWVudS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcywgZXZlbnQsIGl0ZW0pO1xuICAgIH07XG4gICAgUGFuZWxNZW51LnByb3RvdHlwZS5vblRvZ2dsZURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gUGFuZWxNZW51O1xufShCYXNlUGFuZWxNZW51SXRlbSkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgUGFuZWxNZW51LnByb3RvdHlwZSwgXCJtb2RlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVsTWVudS5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lbE1lbnUucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcblBhbmVsTWVudSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtcGFuZWxNZW51JyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtuZ0NsYXNzXT1cXFwiJ3VpLXBhbmVsbWVudSB1aS13aWRnZXQnXFxcIj5cXG4gICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IGl0ZW0gb2YgbW9kZWw7bGV0IGY9Zmlyc3Q7bGV0IGw9bGFzdDtcXFwiIGNsYXNzPVxcXCJ1aS1wYW5lbG1lbnUtcGFuZWxcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwieyd1aS13aWRnZXQgdWktcGFuZWxtZW51LWhlYWRlciB1aS1zdGF0ZS1kZWZhdWx0Jzp0cnVlLCd1aS1jb3JuZXItdG9wJzpmLCd1aS1jb3JuZXItYm90dG9tJzpsJiYhaXRlbS5leHBhbmRlZCxcXG4gICAgICAgICAgICAgICAgICAgICd1aS1zdGF0ZS1hY3RpdmUnOml0ZW0uZXhwYW5kZWQsJ3VpLXN0YXRlLWRpc2FibGVkJzppdGVtLmRpc2FibGVkfVxcXCIgW2NsYXNzXT1cXFwiaXRlbS5zdHlsZUNsYXNzXFxcIiBbbmdTdHlsZV09XFxcIml0ZW0uc3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcIiFpdGVtLnJvdXRlckxpbmtcXFwiIFtocmVmXT1cXFwiaXRlbS51cmx8fCcjJ1xcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXBhbmVsbWVudS1oZWFkZXJsaW5rLWhhc2ljb24nOml0ZW0uaWNvbn1cXFwiIChjbGljayk9XFxcImhhbmRsZUNsaWNrKCRldmVudCxpdGVtKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50YXJnZXRdPVxcXCJpdGVtLnRhcmdldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcIml0ZW0uaXRlbXNcXFwiIGNsYXNzPVxcXCJ1aS1wYW5lbG1lbnUtaWNvbiBmYVxcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhLWNhcmV0LXJpZ2h0JzohaXRlbS5leHBhbmRlZCwnZmEtY2FyZXQtZG93bic6aXRlbS5leHBhbmRlZH1cXFwiPjwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgID48c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYVxcXCIgW25nQ2xhc3NdPVxcXCJpdGVtLmljb25cXFwiICpuZ0lmPVxcXCJpdGVtLmljb25cXFwiPjwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgID48c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0tdGV4dFxcXCI+e3tpdGVtLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiaXRlbS5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua109XFxcIml0ZW0ucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCIndWktc3RhdGUtYWN0aXZlJ1xcXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cXFwiaXRlbS5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc3x8e2V4YWN0OmZhbHNlfVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXBhbmVsbWVudS1oZWFkZXJsaW5rLWhhc2ljb24nOml0ZW0uaWNvbn1cXFwiIChjbGljayk9XFxcImhhbmRsZUNsaWNrKCRldmVudCxpdGVtKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50YXJnZXRdPVxcXCJpdGVtLnRhcmdldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcIml0ZW0uaXRlbXNcXFwiIGNsYXNzPVxcXCJ1aS1wYW5lbG1lbnUtaWNvbiBmYVxcXCIgW25nQ2xhc3NdPVxcXCJ7J2ZhLWNhcmV0LXJpZ2h0JzohaXRlbS5leHBhbmRlZCwnZmEtY2FyZXQtZG93bic6aXRlbS5leHBhbmRlZH1cXFwiPjwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgID48c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYVxcXCIgW25nQ2xhc3NdPVxcXCJpdGVtLmljb25cXFwiICpuZ0lmPVxcXCJpdGVtLmljb25cXFwiPjwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgID48c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0tdGV4dFxcXCI+e3tpdGVtLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCJpdGVtLml0ZW1zXFxcIiBjbGFzcz1cXFwidWktcGFuZWxtZW51LWNvbnRlbnQtd3JhcHBlclxcXCIgW0Byb290SXRlbV09XFxcIml0ZW0uZXhwYW5kZWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1xcXCIgIChAcm9vdEl0ZW0uZG9uZSk9XFxcIm9uVG9nZ2xlRG9uZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXBhbmVsbWVudS1jb250ZW50LXdyYXBwZXItb3ZlcmZsb3duJzogIWl0ZW0uZXhwYW5kZWR8fGFuaW1hdGluZ31cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktcGFuZWxtZW51LWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwLXBhbmVsTWVudVN1YiBbaXRlbV09XFxcIml0ZW1cXFwiIFtleHBhbmRlZF09XFxcInRydWVcXFwiPjwvcC1wYW5lbE1lbnVTdWI+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIGFuaW1hdGlvbnNfMS50cmlnZ2VyKCdyb290SXRlbScsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEuc3RhdGUoJ2hpZGRlbicsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzBweCdcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCd2aXNpYmxlJywgYW5pbWF0aW9uc18xLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnKidcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyYW5zaXRpb24oJ3Zpc2libGUgPT4gaGlkZGVuJywgYW5pbWF0aW9uc18xLmFuaW1hdGUoJzQwMG1zIGN1YmljLWJlemllcigwLjg2LCAwLCAwLjA3LCAxKScpKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zXzEudHJhbnNpdGlvbignaGlkZGVuID0+IHZpc2libGUnLCBhbmltYXRpb25zXzEuYW5pbWF0ZSgnNDAwbXMgY3ViaWMtYmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpJykpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdXG4gICAgfSlcbl0sIFBhbmVsTWVudSk7XG5leHBvcnRzLlBhbmVsTWVudSA9IFBhbmVsTWVudTtcbnZhciBQYW5lbE1lbnVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhbmVsTWVudU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFBhbmVsTWVudU1vZHVsZTtcbn0oKSk7XG5QYW5lbE1lbnVNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlLCByb3V0ZXJfMS5Sb3V0ZXJNb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbUGFuZWxNZW51LCByb3V0ZXJfMS5Sb3V0ZXJNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtQYW5lbE1lbnUsIFBhbmVsTWVudVN1Yl1cbiAgICB9KVxuXSwgUGFuZWxNZW51TW9kdWxlKTtcbmV4cG9ydHMuUGFuZWxNZW51TW9kdWxlID0gUGFuZWxNZW51TW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFuZWxtZW51LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvcGFuZWxtZW51L3BhbmVsbWVudS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3BhbmVsbWVudS9wYW5lbG1lbnUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgUGFzc3dvcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhc3N3b3JkKGVsLCBkb21IYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5wcm9tcHRMYWJlbCA9ICdQbGVhc2UgZW50ZXIgYSBwYXNzd29yZCc7XG4gICAgICAgIHRoaXMud2Vha0xhYmVsID0gJ1dlYWsnO1xuICAgICAgICB0aGlzLm1lZGl1bUxhYmVsID0gJ01lZGl1bSc7XG4gICAgICAgIHRoaXMuc3Ryb25nTGFiZWwgPSAnU3Ryb25nJztcbiAgICAgICAgdGhpcy5mZWVkYmFjayA9IHRydWU7XG4gICAgfVxuICAgIFBhc3N3b3JkLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5wYW5lbC5jbGFzc05hbWUgPSAndWktcGFzc3dvcmQtcGFuZWwgdWktd2lkZ2V0IHVpLXN0YXRlLWhpZ2hsaWdodCB1aS1jb3JuZXItYWxsIHVpLWhlbHBlci1oaWRkZW4gdWktcGFzc3dvcmQtcGFuZWwtb3ZlcmxheSc7XG4gICAgICAgIHRoaXMubWV0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5tZXRlci5jbGFzc05hbWUgPSAndWktcGFzc3dvcmQtbWV0ZXInO1xuICAgICAgICB0aGlzLmluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5pbmZvLmNsYXNzTmFtZSA9ICd1aS1wYXNzd29yZC1pbmZvJztcbiAgICAgICAgdGhpcy5pbmZvLnRleHRDb250ZW50ID0gdGhpcy5wcm9tcHRMYWJlbDtcbiAgICAgICAgaWYgKHRoaXMuZmVlZGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucGFuZWwuYXBwZW5kQ2hpbGQodGhpcy5tZXRlcik7XG4gICAgICAgICAgICB0aGlzLnBhbmVsLmFwcGVuZENoaWxkKHRoaXMuaW5mbyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucGFuZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXNzd29yZC5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgfTtcbiAgICAvL1RvIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiB0byBtYW5hZ2UgdWktc3RhdGUtZmlsbGVkIGZvciBtYXRlcmlhbCBsYWJlbHMgd2hlbiB0aGVyZSBpcyBubyB2YWx1ZSBiaW5kaW5nXG4gICAgUGFzc3dvcmQucHJvdG90eXBlLm9uSW5wdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgfTtcbiAgICBQYXNzd29yZC5wcm90b3R5cGUudXBkYXRlRmlsbGVkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlsbGVkID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LnZhbHVlICYmIHRoaXMuZWwubmF0aXZlRWxlbWVudC52YWx1ZS5sZW5ndGg7XG4gICAgfTtcbiAgICBQYXNzd29yZC5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMucGFuZWwuc3R5bGUuekluZGV4ID0gU3RyaW5nKCsrZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4KTtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyLnJlbW92ZUNsYXNzKHRoaXMucGFuZWwsICd1aS1oZWxwZXItaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5hYnNvbHV0ZVBvc2l0aW9uKHRoaXMucGFuZWwsIHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5mYWRlSW4odGhpcy5wYW5lbCwgMjUwKTtcbiAgICB9O1xuICAgIFBhc3N3b3JkLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYWRkQ2xhc3ModGhpcy5wYW5lbCwgJ3VpLWhlbHBlci1oaWRkZW4nKTtcbiAgICB9O1xuICAgIFBhc3N3b3JkLnByb3RvdHlwZS5vbktleXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZS50YXJnZXQudmFsdWUsIGxhYmVsID0gbnVsbCwgbWV0ZXJQb3MgPSBudWxsO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHRoaXMucHJvbXB0TGFiZWw7XG4gICAgICAgICAgICBtZXRlclBvcyA9ICcwcHggMHB4JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY29yZSA9IHRoaXMudGVzdFN0cmVuZ3RoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChzY29yZSA8IDMwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSB0aGlzLndlYWtMYWJlbDtcbiAgICAgICAgICAgICAgICBtZXRlclBvcyA9ICcwcHggLTEwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NvcmUgPj0gMzAgJiYgc2NvcmUgPCA4MCkge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gdGhpcy5tZWRpdW1MYWJlbDtcbiAgICAgICAgICAgICAgICBtZXRlclBvcyA9ICcwcHggLTIwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NvcmUgPj0gODApIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMuc3Ryb25nTGFiZWw7XG4gICAgICAgICAgICAgICAgbWV0ZXJQb3MgPSAnMHB4IC0zMHB4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGVyLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IG1ldGVyUG9zO1xuICAgICAgICB0aGlzLmluZm8udGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICB9O1xuICAgIFBhc3N3b3JkLnByb3RvdHlwZS50ZXN0U3RyZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBncmFkZSA9IDA7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIHZhbCA9IHN0ci5tYXRjaCgnWzAtOV0nKTtcbiAgICAgICAgZ3JhZGUgKz0gdGhpcy5ub3JtYWxpemUodmFsID8gdmFsLmxlbmd0aCA6IDEgLyA0LCAxKSAqIDI1O1xuICAgICAgICB2YWwgPSBzdHIubWF0Y2goJ1thLXpBLVpdJyk7XG4gICAgICAgIGdyYWRlICs9IHRoaXMubm9ybWFsaXplKHZhbCA/IHZhbC5sZW5ndGggOiAxIC8gMiwgMykgKiAxMDtcbiAgICAgICAgdmFsID0gc3RyLm1hdGNoKCdbIUAjJCVeJio/X34uLDs9XScpO1xuICAgICAgICBncmFkZSArPSB0aGlzLm5vcm1hbGl6ZSh2YWwgPyB2YWwubGVuZ3RoIDogMSAvIDYsIDEpICogMzU7XG4gICAgICAgIHZhbCA9IHN0ci5tYXRjaCgnW0EtWl0nKTtcbiAgICAgICAgZ3JhZGUgKz0gdGhpcy5ub3JtYWxpemUodmFsID8gdmFsLmxlbmd0aCA6IDEgLyA2LCAxKSAqIDMwO1xuICAgICAgICBncmFkZSAqPSBzdHIubGVuZ3RoIC8gODtcbiAgICAgICAgcmV0dXJuIGdyYWRlID4gMTAwID8gMTAwIDogZ3JhZGU7XG4gICAgfTtcbiAgICBQYXNzd29yZC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGRpZmYgPSB4IC0geTtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIHJldHVybiB4IC8geTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDEgKyAwLjUgKiAoeCAvICh4ICsgeSAvIDQpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXNzd29yZC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuZGlzYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFBhc3N3b3JkLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZlZWRiYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnBhbmVsLnJlbW92ZUNoaWxkKHRoaXMubWV0ZXIpO1xuICAgICAgICB0aGlzLnBhbmVsLnJlbW92ZUNoaWxkKHRoaXMuaW5mbyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5wYW5lbCk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBudWxsO1xuICAgICAgICB0aGlzLm1ldGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQYXNzd29yZDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFzc3dvcmQucHJvdG90eXBlLCBcInByb21wdExhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFzc3dvcmQucHJvdG90eXBlLCBcIndlYWtMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhc3N3b3JkLnByb3RvdHlwZSwgXCJtZWRpdW1MYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhc3N3b3JkLnByb3RvdHlwZSwgXCJzdHJvbmdMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQYXNzd29yZC5wcm90b3R5cGUsIFwiZmVlZGJhY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Ib3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBQYXNzd29yZC5wcm90b3R5cGUsIFwib25JbnB1dFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Ib3N0TGlzdGVuZXIoJ2ZvY3VzJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBQYXNzd29yZC5wcm90b3R5cGUsIFwib25Gb2N1c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Ib3N0TGlzdGVuZXIoJ2JsdXInLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFBhc3N3b3JkLnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdrZXl1cCcsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgUGFzc3dvcmQucHJvdG90eXBlLCBcIm9uS2V5dXBcIiwgbnVsbCk7XG5QYXNzd29yZCA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5EaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1twUGFzc3dvcmRdJyxcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ1tjbGFzcy51aS1pbnB1dHRleHRdJzogJ3RydWUnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS1jb3JuZXItYWxsXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICdbY2xhc3MudWktc3RhdGUtZGVmYXVsdF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAnW2NsYXNzLnVpLXdpZGdldF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAnW2NsYXNzLnVpLXN0YXRlLWZpbGxlZF0nOiAnZmlsbGVkJ1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl0pXG5dLCBQYXNzd29yZCk7XG5leHBvcnRzLlBhc3N3b3JkID0gUGFzc3dvcmQ7XG52YXIgUGFzc3dvcmRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhc3N3b3JkTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gUGFzc3dvcmRNb2R1bGU7XG59KCkpO1xuUGFzc3dvcmRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1Bhc3N3b3JkXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbUGFzc3dvcmRdXG4gICAgfSlcbl0sIFBhc3N3b3JkTW9kdWxlKTtcbmV4cG9ydHMuUGFzc3dvcmRNb2R1bGUgPSBQYXNzd29yZE1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhc3N3b3JkLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvcGFzc3dvcmQvcGFzc3dvcmQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9wYXNzd29yZC9wYXNzd29yZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL2J1dHRvbi9idXR0b25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgb2JqZWN0dXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9vYmplY3R1dGlsc1wiKTtcbnZhciBQaWNrTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGlja0xpc3QoZWwsIGRvbUhhbmRsZXIsIG9iamVjdFV0aWxzKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5vYmplY3RVdGlscyA9IG9iamVjdFV0aWxzO1xuICAgICAgICB0aGlzLm1ldGFLZXlTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLnNob3dTb3VyY2VDb250cm9scyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd1RhcmdldENvbnRyb2xzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk1vdmVUb1NvdXJjZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Nb3ZlQWxsVG9Tb3VyY2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTW92ZUFsbFRvVGFyZ2V0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk1vdmVUb1RhcmdldCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Tb3VyY2VSZW9yZGVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vblRhcmdldFJlb3JkZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXNTb3VyY2UgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zVGFyZ2V0ID0gW107XG4gICAgfVxuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5nZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRlbVRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW92ZWRVcCB8fCB0aGlzLm1vdmVkRG93bikge1xuICAgICAgICAgICAgdmFyIGxpc3RJdGVtcyA9IHRoaXMuZG9tSGFuZGxlci5maW5kKHRoaXMucmVvcmRlcmVkTGlzdEVsZW1lbnQsICdsaS51aS1zdGF0ZS1oaWdobGlnaHQnKTtcbiAgICAgICAgICAgIHZhciBsaXN0SXRlbSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdmVkVXApXG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0gPSBsaXN0SXRlbXNbMF07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0gPSBsaXN0SXRlbXNbbGlzdEl0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLnNjcm9sbEluVmlldyh0aGlzLnJlb3JkZXJlZExpc3RFbGVtZW50LCBsaXN0SXRlbSk7XG4gICAgICAgICAgICB0aGlzLm1vdmVkVXAgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJlZExpc3RFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm9uSXRlbUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBpdGVtLCBzZWxlY3RlZEl0ZW1zKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4SW5TZWxlY3Rpb24oaXRlbSwgc2VsZWN0ZWRJdGVtcyk7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IChpbmRleCAhPSAtMSk7XG4gICAgICAgIHZhciBtZXRhU2VsZWN0aW9uID0gdGhpcy5pdGVtVG91Y2hlZCA/IGZhbHNlIDogdGhpcy5tZXRhS2V5U2VsZWN0aW9uO1xuICAgICAgICBpZiAobWV0YVNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIG1ldGFLZXkgPSAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiBtZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtVG91Y2hlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm9uU291cmNlSXRlbURibENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVSaWdodCgpO1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm9uVGFyZ2V0SXRlbURibENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVMZWZ0KCk7XG4gICAgfTtcbiAgICBQaWNrTGlzdC5wcm90b3R5cGUub25GaWx0ZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEsIGxpc3RUeXBlKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IGV2ZW50LnRhcmdldC52YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxpc3RUeXBlID09PSAtMSlcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyVmFsdWVTb3VyY2UgPSBxdWVyeTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5maWx0ZXJWYWx1ZVRhcmdldCA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmFjdGl2YXRlRmlsdGVyKGRhdGEsIGxpc3RUeXBlKTtcbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5hY3RpdmF0ZUZpbHRlciA9IGZ1bmN0aW9uIChkYXRhLCBsaXN0VHlwZSkge1xuICAgICAgICB2YXIgc2VhcmNoRmllbGRzID0gdGhpcy5maWx0ZXJCeS5zcGxpdCgnLCcpO1xuICAgICAgICBpZiAobGlzdFR5cGUgPT09IC0xKVxuICAgICAgICAgICAgdGhpcy52aXNpYmxlT3B0aW9uc1NvdXJjZSA9IHRoaXMub2JqZWN0VXRpbHMuZmlsdGVyKGRhdGEsIHNlYXJjaEZpZWxkcywgdGhpcy5maWx0ZXJWYWx1ZVNvdXJjZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZU9wdGlvbnNUYXJnZXQgPSB0aGlzLm9iamVjdFV0aWxzLmZpbHRlcihkYXRhLCBzZWFyY2hGaWVsZHMsIHRoaXMuZmlsdGVyVmFsdWVUYXJnZXQpO1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLmlzSXRlbVZpc2libGUgPSBmdW5jdGlvbiAoaXRlbSwgbGlzdFR5cGUpIHtcbiAgICAgICAgaWYgKGxpc3RUeXBlID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWaXNpYmxlSW5MaXN0KHRoaXMudmlzaWJsZU9wdGlvbnNTb3VyY2UsIGl0ZW0sIHRoaXMuZmlsdGVyVmFsdWVTb3VyY2UpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1Zpc2libGVJbkxpc3QodGhpcy52aXNpYmxlT3B0aW9uc1RhcmdldCwgaXRlbSwgdGhpcy5maWx0ZXJWYWx1ZVRhcmdldCk7XG4gICAgfTtcbiAgICBQaWNrTGlzdC5wcm90b3R5cGUuaXNWaXNpYmxlSW5MaXN0ID0gZnVuY3Rpb24gKGRhdGEsIGl0ZW0sIGZpbHRlclZhbHVlKSB7XG4gICAgICAgIGlmIChmaWx0ZXJWYWx1ZSAmJiBmaWx0ZXJWYWx1ZS50cmltKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PSBkYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQaWNrTGlzdC5wcm90b3R5cGUub25JdGVtVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pdGVtVG91Y2hlZCA9IHRydWU7XG4gICAgfTtcbiAgICBQaWNrTGlzdC5wcm90b3R5cGUubW92ZVVwID0gZnVuY3Rpb24gKGxpc3RFbGVtZW50LCBsaXN0LCBzZWxlY3RlZEl0ZW1zLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtcyAmJiBzZWxlY3RlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbUluZGV4ID0gdGhpcy5maW5kSW5kZXhJbkxpc3Qoc2VsZWN0ZWRJdGVtLCBsaXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtSW5kZXggIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZWRJdGVtID0gbGlzdFtzZWxlY3RlZEl0ZW1JbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gbGlzdFtzZWxlY3RlZEl0ZW1JbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsaXN0W3NlbGVjdGVkSXRlbUluZGV4IC0gMV0gPSBtb3ZlZEl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGxpc3Rbc2VsZWN0ZWRJdGVtSW5kZXhdID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW92ZWRVcCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJlZExpc3RFbGVtZW50ID0gbGlzdEVsZW1lbnQ7XG4gICAgICAgICAgICBjYWxsYmFjay5lbWl0KHsgaXRlbXM6IHNlbGVjdGVkSXRlbXMgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5tb3ZlVG9wID0gZnVuY3Rpb24gKGxpc3RFbGVtZW50LCBsaXN0LCBzZWxlY3RlZEl0ZW1zLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtcyAmJiBzZWxlY3RlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbUluZGV4ID0gdGhpcy5maW5kSW5kZXhJbkxpc3Qoc2VsZWN0ZWRJdGVtLCBsaXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtSW5kZXggIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZWRJdGVtID0gbGlzdC5zcGxpY2Uoc2VsZWN0ZWRJdGVtSW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnVuc2hpZnQobW92ZWRJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICBjYWxsYmFjay5lbWl0KHsgaXRlbXM6IHNlbGVjdGVkSXRlbXMgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5tb3ZlRG93biA9IGZ1bmN0aW9uIChsaXN0RWxlbWVudCwgbGlzdCwgc2VsZWN0ZWRJdGVtcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkSXRlbXMgJiYgc2VsZWN0ZWRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxlY3RlZEl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbUluZGV4ID0gdGhpcy5maW5kSW5kZXhJbkxpc3Qoc2VsZWN0ZWRJdGVtLCBsaXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtSW5kZXggIT0gKGxpc3QubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkSXRlbSA9IGxpc3Rbc2VsZWN0ZWRJdGVtSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGxpc3Rbc2VsZWN0ZWRJdGVtSW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFtzZWxlY3RlZEl0ZW1JbmRleCArIDFdID0gbW92ZWRJdGVtO1xuICAgICAgICAgICAgICAgICAgICBsaXN0W3NlbGVjdGVkSXRlbUluZGV4XSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1vdmVkRG93biA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJlZExpc3RFbGVtZW50ID0gbGlzdEVsZW1lbnQ7XG4gICAgICAgICAgICBjYWxsYmFjay5lbWl0KHsgaXRlbXM6IHNlbGVjdGVkSXRlbXMgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5tb3ZlQm90dG9tID0gZnVuY3Rpb24gKGxpc3RFbGVtZW50LCBsaXN0LCBzZWxlY3RlZEl0ZW1zLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtcyAmJiBzZWxlY3RlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGVjdGVkSXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRJdGVtc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtSW5kZXggPSB0aGlzLmZpbmRJbmRleEluTGlzdChzZWxlY3RlZEl0ZW0sIGxpc3QpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEl0ZW1JbmRleCAhPSAobGlzdC5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZWRJdGVtID0gbGlzdC5zcGxpY2Uoc2VsZWN0ZWRJdGVtSW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2gobW92ZWRJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RFbGVtZW50LnNjcm9sbFRvcCA9IGxpc3RFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIGNhbGxiYWNrLmVtaXQoeyBpdGVtczogc2VsZWN0ZWRJdGVtcyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm1vdmVSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtc1NvdXJjZSAmJiB0aGlzLnNlbGVjdGVkSXRlbXNTb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWRJdGVtc1NvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSB0aGlzLnNlbGVjdGVkSXRlbXNTb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZEluZGV4SW5MaXN0KHNlbGVjdGVkSXRlbSwgdGhpcy50YXJnZXQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnB1c2godGhpcy5zb3VyY2Uuc3BsaWNlKHRoaXMuZmluZEluZGV4SW5MaXN0KHNlbGVjdGVkSXRlbSwgdGhpcy5zb3VyY2UpLCAxKVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk1vdmVUb1RhcmdldC5lbWl0KHtcbiAgICAgICAgICAgICAgICBpdGVtczogdGhpcy5zZWxlY3RlZEl0ZW1zU291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtc1NvdXJjZSA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQaWNrTGlzdC5wcm90b3R5cGUubW92ZUFsbFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5wdXNoKHRoaXMuc291cmNlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25Nb3ZlVG9UYXJnZXQuZW1pdCh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub25Nb3ZlQWxsVG9UYXJnZXQuZW1pdCh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnNwbGljZSgwLCB0aGlzLnNvdXJjZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zU291cmNlID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5tb3ZlTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtc1RhcmdldCAmJiB0aGlzLnNlbGVjdGVkSXRlbXNUYXJnZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWRJdGVtc1RhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSB0aGlzLnNlbGVjdGVkSXRlbXNUYXJnZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZEluZGV4SW5MaXN0KHNlbGVjdGVkSXRlbSwgdGhpcy5zb3VyY2UpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlLnB1c2godGhpcy50YXJnZXQuc3BsaWNlKHRoaXMuZmluZEluZGV4SW5MaXN0KHNlbGVjdGVkSXRlbSwgdGhpcy50YXJnZXQpLCAxKVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk1vdmVUb1NvdXJjZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBpdGVtczogdGhpcy5zZWxlY3RlZEl0ZW1zVGFyZ2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtc1RhcmdldCA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQaWNrTGlzdC5wcm90b3R5cGUubW92ZUFsbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlLnB1c2godGhpcy50YXJnZXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk1vdmVUb1NvdXJjZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBpdGVtczogdGhpcy50YXJnZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbk1vdmVBbGxUb1NvdXJjZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBpdGVtczogdGhpcy50YXJnZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuc3BsaWNlKDAsIHRoaXMudGFyZ2V0Lmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXNUYXJnZXQgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoaXRlbSwgc2VsZWN0ZWRJdGVtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kSW5kZXhJblNlbGVjdGlvbihpdGVtLCBzZWxlY3RlZEl0ZW1zKSAhPSAtMTtcbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5maW5kSW5kZXhJblNlbGVjdGlvbiA9IGZ1bmN0aW9uIChpdGVtLCBzZWxlY3RlZEl0ZW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRJbmRleEluTGlzdChpdGVtLCBzZWxlY3RlZEl0ZW1zKTtcbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5maW5kSW5kZXhJbkxpc3QgPSBmdW5jdGlvbiAoaXRlbSwgbGlzdCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0W2ldID09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBpbmRleCwgbGlzdFR5cGUpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZnJvbUxpc3RUeXBlID0gbGlzdFR5cGU7XG4gICAgICAgIGlmIChsaXN0VHlwZSA9PT0gLTEpXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRJdGVtSW5kZXhTb3VyY2UgPSBpbmRleDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkSXRlbUluZGV4VGFyZ2V0ID0gaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmRyYWdkcm9wU2NvcGUpIHtcbiAgICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCB0aGlzLmRyYWdkcm9wU2NvcGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQaWNrTGlzdC5wcm90b3R5cGUub25EcmFnT3ZlciA9IGZ1bmN0aW9uIChldmVudCwgaW5kZXgsIGxpc3RUeXBlKSB7XG4gICAgICAgIGlmIChsaXN0VHlwZSA9PSAtMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dlZEl0ZW1JbmRleFNvdXJjZSAhPT0gaW5kZXggJiYgdGhpcy5kcmFnZ2VkSXRlbUluZGV4U291cmNlICsgMSAhPT0gaW5kZXggfHwgKHRoaXMuZnJvbUxpc3RUeXBlID09PSAxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJJdGVtSW5kZXhTb3VyY2UgPSBpbmRleDtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dlZEl0ZW1JbmRleFRhcmdldCAhPT0gaW5kZXggJiYgdGhpcy5kcmFnZ2VkSXRlbUluZGV4VGFyZ2V0ICsgMSAhPT0gaW5kZXggfHwgKHRoaXMuZnJvbUxpc3RUeXBlID09PSAtMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdPdmVySXRlbUluZGV4VGFyZ2V0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uTGlzdEl0ZW1Ecm9wcG9pbnQgPSB0cnVlO1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm9uRHJhZ0xlYXZlID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0VHlwZSkge1xuICAgICAgICB0aGlzLmRyYWdPdmVySXRlbUluZGV4U291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnT3Zlckl0ZW1JbmRleFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMub25MaXN0SXRlbURyb3Bwb2ludCA9IGZhbHNlO1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm9uRHJvcCA9IGZ1bmN0aW9uIChldmVudCwgaW5kZXgsIGxpc3RUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLm9uTGlzdEl0ZW1Ecm9wcG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VHlwZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tTGlzdFR5cGUgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuZHJhZ2dlZEl0ZW1JbmRleFRhcmdldCwgdGhpcy50YXJnZXQsIGluZGV4LCB0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iamVjdFV0aWxzLnJlb3JkZXJBcnJheSh0aGlzLnNvdXJjZSwgdGhpcy5kcmFnZ2VkSXRlbUluZGV4U291cmNlLCAodGhpcy5kcmFnZ2VkSXRlbUluZGV4U291cmNlID4gaW5kZXgpID8gaW5kZXggOiAoaW5kZXggPT09IDApID8gMCA6IGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnT3Zlckl0ZW1JbmRleFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tTGlzdFR5cGUgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydCh0aGlzLmRyYWdnZWRJdGVtSW5kZXhTb3VyY2UsIHRoaXMuc291cmNlLCBpbmRleCwgdGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmplY3RVdGlscy5yZW9yZGVyQXJyYXkodGhpcy50YXJnZXQsIHRoaXMuZHJhZ2dlZEl0ZW1JbmRleFRhcmdldCwgKHRoaXMuZHJhZ2dlZEl0ZW1JbmRleFRhcmdldCA+IGluZGV4KSA/IGluZGV4IDogKGluZGV4ID09PSAwKSA/IDAgOiBpbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJJdGVtSW5kZXhUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0SGlnaGxpZ2h0VGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxpc3RIaWdobGlnaHRTb3VyY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm9uTGlzdERyb3AgPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RUeXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5vbkxpc3RJdGVtRHJvcHBvaW50KSB7XG4gICAgICAgICAgICBpZiAobGlzdFR5cGUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbUxpc3RUeXBlID09PSAxKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydCh0aGlzLmRyYWdnZWRJdGVtSW5kZXhUYXJnZXQsIHRoaXMudGFyZ2V0LCBudWxsLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tTGlzdFR5cGUgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydCh0aGlzLmRyYWdnZWRJdGVtSW5kZXhTb3VyY2UsIHRoaXMuc291cmNlLCBudWxsLCB0aGlzLnRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpc3RIaWdobGlnaHRUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGlzdEhpZ2hsaWdodFNvdXJjZSA9IGZhbHNlO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChmcm9tSW5kZXgsIGZyb21MaXN0LCB0b0luZGV4LCB0b0xpc3QpIHtcbiAgICAgICAgaWYgKHRvSW5kZXggPT09IG51bGwpXG4gICAgICAgICAgICB0b0xpc3QucHVzaChmcm9tTGlzdC5zcGxpY2UoZnJvbUluZGV4LCAxKVswXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRvTGlzdC5zcGxpY2UodG9JbmRleCwgMCwgZnJvbUxpc3Quc3BsaWNlKGZyb21JbmRleCwgMSlbMF0pO1xuICAgIH07XG4gICAgUGlja0xpc3QucHJvdG90eXBlLm9uTGlzdE1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCwgbGlzdFR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZhciBtb3ZlTGlzdFR5cGUgPSAobGlzdFR5cGUgPT0gMCA/IHRoaXMubGlzdFZpZXdTb3VyY2VDaGlsZCA6IHRoaXMubGlzdFZpZXdUYXJnZXRDaGlsZCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IG1vdmVMaXN0VHlwZS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgdmFyIGJvdHRvbURpZmYgPSAob2Zmc2V0WSArIG1vdmVMaXN0VHlwZS5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCkgLSBldmVudC5wYWdlWTtcbiAgICAgICAgICAgIHZhciB0b3BEaWZmID0gKGV2ZW50LnBhZ2VZIC0gb2Zmc2V0WSk7XG4gICAgICAgICAgICBpZiAoYm90dG9tRGlmZiA8IDI1ICYmIGJvdHRvbURpZmYgPiAwKVxuICAgICAgICAgICAgICAgIG1vdmVMaXN0VHlwZS5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCArPSAxNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvcERpZmYgPCAyNSAmJiB0b3BEaWZmID4gMClcbiAgICAgICAgICAgICAgICBtb3ZlTGlzdFR5cGUubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgLT0gMTU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RUeXBlID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbUxpc3RUeXBlID09PSAxKVxuICAgICAgICAgICAgICAgIHRoaXMubGlzdEhpZ2hsaWdodFNvdXJjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tTGlzdFR5cGUgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMubGlzdEhpZ2hsaWdodFRhcmdldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIFBpY2tMaXN0LnByb3RvdHlwZS5vbkxpc3REcmFnTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGlzdEhpZ2hsaWdodFRhcmdldCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpc3RIaWdobGlnaHRTb3VyY2UgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBQaWNrTGlzdDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwic291cmNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcInNvdXJjZUhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBpY2tMaXN0LnByb3RvdHlwZSwgXCJ0YXJnZXRIZWFkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcInJlc3BvbnNpdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwiZmlsdGVyQnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcIm1ldGFLZXlTZWxlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcImRyYWdkcm9wXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcImRyYWdkcm9wU2NvcGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBpY2tMaXN0LnByb3RvdHlwZSwgXCJzb3VyY2VTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBpY2tMaXN0LnByb3RvdHlwZSwgXCJ0YXJnZXRTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwic2hvd1NvdXJjZUNvbnRyb2xzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFBpY2tMaXN0LnByb3RvdHlwZSwgXCJzaG93VGFyZ2V0Q29udHJvbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwic291cmNlRmlsdGVyUGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwidGFyZ2V0RmlsdGVyUGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFBpY2tMaXN0LnByb3RvdHlwZSwgXCJvbk1vdmVUb1NvdXJjZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcIm9uTW92ZUFsbFRvU291cmNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwib25Nb3ZlQWxsVG9UYXJnZXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFBpY2tMaXN0LnByb3RvdHlwZSwgXCJvbk1vdmVUb1RhcmdldFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcIm9uU291cmNlUmVvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcIm9uVGFyZ2V0UmVvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLlZpZXdDaGlsZCgnc291cmNlbGlzdCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFBpY2tMaXN0LnByb3RvdHlwZSwgXCJsaXN0Vmlld1NvdXJjZUNoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCd0YXJnZXRsaXN0JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgUGlja0xpc3QucHJvdG90eXBlLCBcImxpc3RWaWV3VGFyZ2V0Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oc2hhcmVkXzEuUHJpbWVUZW1wbGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5RdWVyeUxpc3QpXG5dLCBQaWNrTGlzdC5wcm90b3R5cGUsIFwidGVtcGxhdGVzXCIsIHZvaWQgMCk7XG5QaWNrTGlzdCA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtcGlja0xpc3QnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXBpY2tsaXN0IHVpLXdpZGdldCB1aS1oZWxwZXItY2xlYXJmaXgnOiB0cnVlLCd1aS1waWNrbGlzdC1yZXNwb25zaXZlJzogcmVzcG9uc2l2ZX1cXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXBpY2tsaXN0LXNvdXJjZS1jb250cm9scyB1aS1waWNrbGlzdC1idXR0b25zXFxcIiAqbmdJZj1cXFwic2hvd1NvdXJjZUNvbnRyb2xzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktcGlja2xpc3QtYnV0dG9ucy1jZWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBwQnV0dG9uIGljb249XFxcImZhLWFuZ2xlLXVwXFxcIiAoY2xpY2spPVxcXCJtb3ZlVXAoc291cmNlbGlzdCxzb3VyY2Usc2VsZWN0ZWRJdGVtc1NvdXJjZSxvblNvdXJjZVJlb3JkZXIpXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBwQnV0dG9uIGljb249XFxcImZhLWFuZ2xlLWRvdWJsZS11cFxcXCIgKGNsaWNrKT1cXFwibW92ZVRvcChzb3VyY2VsaXN0LHNvdXJjZSxzZWxlY3RlZEl0ZW1zU291cmNlLG9uU291cmNlUmVvcmRlcilcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtZG93blxcXCIgKGNsaWNrKT1cXFwibW92ZURvd24oc291cmNlbGlzdCxzb3VyY2Usc2VsZWN0ZWRJdGVtc1NvdXJjZSxvblNvdXJjZVJlb3JkZXIpXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBwQnV0dG9uIGljb249XFxcImZhLWFuZ2xlLWRvdWJsZS1kb3duXFxcIiAoY2xpY2spPVxcXCJtb3ZlQm90dG9tKHNvdXJjZWxpc3Qsc291cmNlLHNlbGVjdGVkSXRlbXNTb3VyY2Usb25Tb3VyY2VSZW9yZGVyKVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXBpY2tsaXN0LWxpc3R3cmFwcGVyIHVpLXBpY2tsaXN0LXNvdXJjZS13cmFwcGVyXFxcIiBbbmdDbGFzc109XFxcInsndWktcGlja2xpc3QtbGlzdHdyYXBwZXItbm9jb250cm9scyc6IXNob3dTb3VyY2VDb250cm9sc31cXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1jYXB0aW9uIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLXRsIHVpLWNvcm5lci10clxcXCIgKm5nSWY9XFxcInNvdXJjZUhlYWRlclxcXCI+e3tzb3VyY2VIZWFkZXJ9fTwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1maWx0ZXItY29udGFpbmVyIHVpLXdpZGdldC1jb250ZW50XFxcIiAqbmdJZj1cXFwiZmlsdGVyQnlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHJvbGU9XFxcInRleHRib3hcXFwiIChrZXl1cCk9XFxcIm9uRmlsdGVyKCRldmVudCxzb3VyY2UsLTEpXFxcIiBjbGFzcz1cXFwidWktcGlja2xpc3QtZmlsdGVyIHVpLWlucHV0dGV4dCB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW2F0dHIucGxhY2Vob2xkZXJdPVxcXCJzb3VyY2VGaWx0ZXJQbGFjZWhvbGRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtc2VhcmNoXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8dWwgI3NvdXJjZWxpc3QgY2xhc3M9XFxcInVpLXdpZGdldC1jb250ZW50IHVpLXBpY2tsaXN0LWxpc3QgdWktcGlja2xpc3Qtc291cmNlIHVpLWNvcm5lci1ib3R0b21cXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1waWNrbGlzdC1oaWdobGlnaHQnOiBsaXN0SGlnaGxpZ2h0U291cmNlfVxcXCIgW25nU3R5bGVdPVxcXCJzb3VyY2VTdHlsZVxcXCIgKGRyYWdvdmVyKT1cXFwib25MaXN0TW91c2VNb3ZlKCRldmVudCwtMSlcXFwiIChkcmFnbGVhdmUpPVxcXCJvbkxpc3REcmFnTGVhdmUoKVxcXCIgKGRyb3ApPVxcXCJvbkxpc3REcm9wKCRldmVudCwgLTEpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XFxcInNvdXJjZVxcXCIgbGV0LWk9XFxcImluZGV4XFxcIiBsZXQtbD1cXFwibGFzdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1kcm9wcG9pbnRcXFwiICpuZ0lmPVxcXCJkcmFnZHJvcFxcXCIgKGRyYWdvdmVyKT1cXFwib25EcmFnT3ZlcigkZXZlbnQsIGksIC0xKVxcXCIgKGRyb3ApPVxcXCJvbkRyb3AoJGV2ZW50LCBpLCAtMSlcXFwiIChkcmFnbGVhdmUpPVxcXCJvbkRyYWdMZWF2ZSgkZXZlbnQsIC0xKVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXBpY2tsaXN0LWRyb3Bwb2ludC1oaWdobGlnaHQnOiAoaSA9PT0gZHJhZ092ZXJJdGVtSW5kZXhTb3VyY2UpfVxcXCIgW3N0eWxlLmRpc3BsYXldPVxcXCJpc0l0ZW1WaXNpYmxlKGl0ZW0sIC0xKSA/ICdibG9jaycgOiAnbm9uZSdcXFwiPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIFtuZ0NsYXNzXT1cXFwieyd1aS1waWNrbGlzdC1pdGVtJzp0cnVlLCd1aS1zdGF0ZS1oaWdobGlnaHQnOmlzU2VsZWN0ZWQoaXRlbSxzZWxlY3RlZEl0ZW1zU291cmNlKX1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XFxcIm9uSXRlbUNsaWNrKCRldmVudCxpdGVtLHNlbGVjdGVkSXRlbXNTb3VyY2UpXFxcIiAoZGJsY2xpY2spPVxcXCJvblNvdXJjZUl0ZW1EYmxDbGljaygpXFxcIiAodG91Y2hlbmQpPVxcXCJvbkl0ZW1Ub3VjaEVuZCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuZGlzcGxheV09XFxcImlzSXRlbVZpc2libGUoaXRlbSwgLTEpID8gJ2Jsb2NrJyA6ICdub25lJ1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RyYWdnYWJsZV09XFxcImRyYWdkcm9wXFxcIiAoZHJhZ3N0YXJ0KT1cXFwib25EcmFnU3RhcnQoJGV2ZW50LCBpLCAtMSlcXFwiIChkcmFnZW5kKT1cXFwib25EcmFnRW5kKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW3BUZW1wbGF0ZVdyYXBwZXJdPVxcXCJpdGVtVGVtcGxhdGVcXFwiIFtpdGVtXT1cXFwiaXRlbVxcXCI+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktcGlja2xpc3QtZHJvcHBvaW50XFxcIiAqbmdJZj1cXFwiZHJhZ2Ryb3AmJmxcXFwiIChkcmFnb3Zlcik9XFxcIm9uRHJhZ092ZXIoJGV2ZW50LCBpICsgMSwgLTEpXFxcIiAoZHJvcCk9XFxcIm9uRHJvcCgkZXZlbnQsIGkgKyAxLCAtMSlcXFwiIChkcmFnbGVhdmUpPVxcXCJvbkRyYWdMZWF2ZSgkZXZlbnQsIC0xKVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXBpY2tsaXN0LWRyb3Bwb2ludC1oaWdobGlnaHQnOiAoaSArIDEgPT09IGRyYWdPdmVySXRlbUluZGV4U291cmNlKX1cXFwiPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXBpY2tsaXN0LWJ1dHRvbnNcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1idXR0b25zLWNlbGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtcmlnaHRcXFwiIChjbGljayk9XFxcIm1vdmVSaWdodCgpXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBwQnV0dG9uIGljb249XFxcImZhLWFuZ2xlLWRvdWJsZS1yaWdodFxcXCIgKGNsaWNrKT1cXFwibW92ZUFsbFJpZ2h0KClcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtbGVmdFxcXCIgKGNsaWNrKT1cXFwibW92ZUxlZnQoKVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgcEJ1dHRvbiBpY29uPVxcXCJmYS1hbmdsZS1kb3VibGUtbGVmdFxcXCIgKGNsaWNrKT1cXFwibW92ZUFsbExlZnQoKVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXBpY2tsaXN0LWxpc3R3cmFwcGVyIHVpLXBpY2tsaXN0LXRhcmdldC13cmFwcGVyXFxcIiBbbmdDbGFzc109XFxcInsndWktcGlja2xpc3QtbGlzdHdyYXBwZXItbm9jb250cm9scyc6IXNob3dUYXJnZXRDb250cm9sc31cXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1jYXB0aW9uIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLXRsIHVpLWNvcm5lci10clxcXCIgKm5nSWY9XFxcInRhcmdldEhlYWRlclxcXCI+e3t0YXJnZXRIZWFkZXJ9fTwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1maWx0ZXItY29udGFpbmVyIHVpLXdpZGdldC1jb250ZW50XFxcIiAqbmdJZj1cXFwiZmlsdGVyQnlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHJvbGU9XFxcInRleHRib3hcXFwiIChrZXl1cCk9XFxcIm9uRmlsdGVyKCRldmVudCx0YXJnZXQsMSlcXFwiIGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1maWx0ZXIgdWktaW5wdXR0ZXh0IHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbYXR0ci5wbGFjZWhvbGRlcl09XFxcInRhcmdldEZpbHRlclBsYWNlaG9sZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1zZWFyY2hcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDx1bCAjdGFyZ2V0bGlzdCBjbGFzcz1cXFwidWktd2lkZ2V0LWNvbnRlbnQgdWktcGlja2xpc3QtbGlzdCB1aS1waWNrbGlzdC10YXJnZXQgdWktY29ybmVyLWJvdHRvbVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXBpY2tsaXN0LWhpZ2hsaWdodCc6IGxpc3RIaWdobGlnaHRUYXJnZXR9XFxcIiBbbmdTdHlsZV09XFxcInRhcmdldFN0eWxlXFxcIiAoZHJhZ292ZXIpPVxcXCJvbkxpc3RNb3VzZU1vdmUoJGV2ZW50LDEpXFxcIiAoZHJhZ2xlYXZlKT1cXFwib25MaXN0RHJhZ0xlYXZlKClcXFwiIChkcm9wKT1cXFwib25MaXN0RHJvcCgkZXZlbnQsMSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cXFwidGFyZ2V0XFxcIiBsZXQtaT1cXFwiaW5kZXhcXFwiIGxldC1sPVxcXCJsYXN0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcInVpLXBpY2tsaXN0LWRyb3Bwb2ludFxcXCIgKm5nSWY9XFxcImRyYWdkcm9wXFxcIiAoZHJhZ292ZXIpPVxcXCJvbkRyYWdPdmVyKCRldmVudCwgaSwgMSlcXFwiIChkcm9wKT1cXFwib25Ecm9wKCRldmVudCwgaSwgMSlcXFwiIChkcmFnbGVhdmUpPVxcXCJvbkRyYWdMZWF2ZSgkZXZlbnQsIDEpXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktcGlja2xpc3QtZHJvcHBvaW50LWhpZ2hsaWdodCc6IChpID09PSBkcmFnT3Zlckl0ZW1JbmRleFRhcmdldCl9XFxcIiBbc3R5bGUuZGlzcGxheV09XFxcImlzSXRlbVZpc2libGUoaXRlbSwgMSkgPyAnYmxvY2snIDogJ25vbmUnXFxcIj48L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBbbmdDbGFzc109XFxcInsndWktcGlja2xpc3QtaXRlbSc6dHJ1ZSwndWktc3RhdGUtaGlnaGxpZ2h0Jzppc1NlbGVjdGVkKGl0ZW0sc2VsZWN0ZWRJdGVtc1RhcmdldCl9XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJvbkl0ZW1DbGljaygkZXZlbnQsaXRlbSxzZWxlY3RlZEl0ZW1zVGFyZ2V0KVxcXCIgKGRibGNsaWNrKT1cXFwib25UYXJnZXRJdGVtRGJsQ2xpY2soKVxcXCIgKHRvdWNoZW5kKT1cXFwib25JdGVtVG91Y2hFbmQoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmRpc3BsYXldPVxcXCJpc0l0ZW1WaXNpYmxlKGl0ZW0sIDEpID8gJ2Jsb2NrJyA6ICdub25lJ1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RyYWdnYWJsZV09XFxcImRyYWdkcm9wXFxcIiAoZHJhZ3N0YXJ0KT1cXFwib25EcmFnU3RhcnQoJGV2ZW50LCBpLCAxKVxcXCIgKGRyYWdlbmQpPVxcXCJvbkRyYWdFbmQoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbcFRlbXBsYXRlV3JhcHBlcl09XFxcIml0ZW1UZW1wbGF0ZVxcXCIgW2l0ZW1dPVxcXCJpdGVtXFxcIj48L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1kcm9wcG9pbnRcXFwiICpuZ0lmPVxcXCJkcmFnZHJvcCYmbFxcXCIgKGRyYWdvdmVyKT1cXFwib25EcmFnT3ZlcigkZXZlbnQsIGkgKyAxLCAxKVxcXCIgKGRyb3ApPVxcXCJvbkRyb3AoJGV2ZW50LCBpICsgMSwgMSlcXFwiIChkcmFnbGVhdmUpPVxcXCJvbkRyYWdMZWF2ZSgkZXZlbnQsIDEpXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktcGlja2xpc3QtZHJvcHBvaW50LWhpZ2hsaWdodCc6IChpICsgMSA9PT0gZHJhZ092ZXJJdGVtSW5kZXhUYXJnZXQpfVxcXCI+PC9saT5cXG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktcGlja2xpc3QtdGFyZ2V0LWNvbnRyb2xzIHVpLXBpY2tsaXN0LWJ1dHRvbnNcXFwiICpuZ0lmPVxcXCJzaG93VGFyZ2V0Q29udHJvbHNcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS1waWNrbGlzdC1idXR0b25zLWNlbGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtdXBcXFwiIChjbGljayk9XFxcIm1vdmVVcCh0YXJnZXRsaXN0LHRhcmdldCxzZWxlY3RlZEl0ZW1zVGFyZ2V0LG9uVGFyZ2V0UmVvcmRlcilcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtZG91YmxlLXVwXFxcIiAoY2xpY2spPVxcXCJtb3ZlVG9wKHRhcmdldGxpc3QsdGFyZ2V0LHNlbGVjdGVkSXRlbXNUYXJnZXQsb25UYXJnZXRSZW9yZGVyKVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgcEJ1dHRvbiBpY29uPVxcXCJmYS1hbmdsZS1kb3duXFxcIiAoY2xpY2spPVxcXCJtb3ZlRG93bih0YXJnZXRsaXN0LHRhcmdldCxzZWxlY3RlZEl0ZW1zVGFyZ2V0LG9uVGFyZ2V0UmVvcmRlcilcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gaWNvbj1cXFwiZmEtYW5nbGUtZG91YmxlLWRvd25cXFwiIChjbGljayk9XFxcIm1vdmVCb3R0b20odGFyZ2V0bGlzdCx0YXJnZXQsc2VsZWN0ZWRJdGVtc1RhcmdldCxvblRhcmdldFJlb3JkZXIpXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBvYmplY3R1dGlsc18xLk9iamVjdFV0aWxzXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBvYmplY3R1dGlsc18xLk9iamVjdFV0aWxzXSlcbl0sIFBpY2tMaXN0KTtcbmV4cG9ydHMuUGlja0xpc3QgPSBQaWNrTGlzdDtcbnZhciBQaWNrTGlzdE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGlja0xpc3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBQaWNrTGlzdE1vZHVsZTtcbn0oKSk7XG5QaWNrTGlzdE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIGJ1dHRvbl8xLkJ1dHRvbk1vZHVsZSwgc2hhcmVkXzEuU2hhcmVkTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1BpY2tMaXN0LCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtQaWNrTGlzdF1cbiAgICB9KVxuXSwgUGlja0xpc3RNb2R1bGUpO1xuZXhwb3J0cy5QaWNrTGlzdE1vZHVsZSA9IFBpY2tMaXN0TW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2xpc3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9waWNrbGlzdC9waWNrbGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3BpY2tsaXN0L3BpY2tsaXN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgUHJvZ3Jlc3NCYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb2dyZXNzQmFyKCkge1xuICAgICAgICB0aGlzLnNob3dWYWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pdCA9ICclJztcbiAgICB9XG4gICAgcmV0dXJuIFByb2dyZXNzQmFyO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcInNob3dWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFByb2dyZXNzQmFyLnByb3RvdHlwZSwgXCJ1bml0XCIsIHZvaWQgMCk7XG5Qcm9ncmVzc0JhciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtcHJvZ3Jlc3NCYXInLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXByb2dyZXNzYmFyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXFxcIiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgW2F0dHIuYXJpYS12YWx1ZW5vd109XFxcInZhbHVlXFxcIiBhcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXByb2dyZXNzYmFyLXZhbHVlIHVpLXByb2dyZXNzYmFyLXZhbHVlLWFuaW1hdGUgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXFxcIiBbc3R5bGUud2lkdGhdPVxcXCJ2YWx1ZSArICclJ1xcXCIgc3R5bGU9XFxcImRpc3BsYXk6YmxvY2tcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXByb2dyZXNzYmFyLWxhYmVsXFxcIiBbc3R5bGUuZGlzcGxheV09XFxcInZhbHVlID8gJ2Jsb2NrJyA6ICdub25lJ1xcXCIgKm5nSWY9XFxcInNob3dWYWx1ZVxcXCI+e3t2YWx1ZX19e3t1bml0fX08L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIlxuICAgIH0pXG5dLCBQcm9ncmVzc0Jhcik7XG5leHBvcnRzLlByb2dyZXNzQmFyID0gUHJvZ3Jlc3NCYXI7XG52YXIgUHJvZ3Jlc3NCYXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb2dyZXNzQmFyTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gUHJvZ3Jlc3NCYXJNb2R1bGU7XG59KCkpO1xuUHJvZ3Jlc3NCYXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1Byb2dyZXNzQmFyXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbUHJvZ3Jlc3NCYXJdXG4gICAgfSlcbl0sIFByb2dyZXNzQmFyTW9kdWxlKTtcbmV4cG9ydHMuUHJvZ3Jlc3NCYXJNb2R1bGUgPSBQcm9ncmVzc0Jhck1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2dyZXNzYmFyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGZvcm1zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIik7XG5leHBvcnRzLlJBRElPX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IGZvcm1zXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJhZGlvQnV0dG9uOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBSYWRpb0J1dHRvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFkaW9CdXR0b24oY2QpIHtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIFJhZGlvQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xpY2suZW1pdChudWxsKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJhZGlvQnV0dG9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFkaW9CdXR0b24ucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gKHZhbHVlID09IHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgUmFkaW9CdXR0b24ucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICBSYWRpb0J1dHRvbi5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgUmFkaW9CdXR0b24ucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB2YWw7XG4gICAgfTtcbiAgICBSYWRpb0J1dHRvbi5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgIH07XG4gICAgUmFkaW9CdXR0b24ucHJvdG90eXBlLm9uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCgpO1xuICAgIH07XG4gICAgUmFkaW9CdXR0b24ucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFkaW9CdXR0b247XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJvbkNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdyYicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJpbnB1dFZpZXdDaGlsZFwiLCB2b2lkIDApO1xuUmFkaW9CdXR0b24gPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLXJhZGlvQnV0dG9uJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtuZ0NsYXNzXT1cXFwiJ3VpLXJhZGlvYnV0dG9uIHVpLXdpZGdldCdcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCAjcmIgdHlwZT1cXFwicmFkaW9cXFwiIFthdHRyLmlkXT1cXFwiaW5wdXRJZFxcXCIgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiIFthdHRyLnZhbHVlXT1cXFwidmFsdWVcXFwiIFthdHRyLnRhYmluZGV4XT1cXFwidGFiaW5kZXhcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgW2NoZWNrZWRdPVxcXCJjaGVja2VkXFxcIiAoY2hhbmdlKT1cXFwib25DaGFuZ2UoJGV2ZW50KVxcXCIgKGZvY3VzKT1cXFwib25Gb2N1cygkZXZlbnQpXFxcIiAoYmx1cik9XFxcIm9uQmx1cigkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IChjbGljayk9XFxcImhhbmRsZUNsaWNrKClcXFwiXFxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1yYWRpb2J1dHRvbi1ib3ggdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQnOnRydWUsXFxuICAgICAgICAgICAgICAgICd1aS1zdGF0ZS1hY3RpdmUnOnJiLmNoZWNrZWQsJ3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZCwndWktc3RhdGUtZm9jdXMnOmZvY3VzZWR9XFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXJhZGlvYnV0dG9uLWljb24gdWktY2xpY2thYmxlXFxcIiBbbmdDbGFzc109XFxcInsnZmEgZmEtY2lyY2xlJzpyYi5jaGVja2VkfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInVpLXJhZGlvYnV0dG9uLWxhYmVsXFxcIiAoY2xpY2spPVxcXCJzZWxlY3QoKVxcXCIgKm5nSWY9XFxcImxhYmVsXFxcIj57e2xhYmVsfX08L2xhYmVsPlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZXhwb3J0cy5SQURJT19WQUxVRV9BQ0NFU1NPUl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5DaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBSYWRpb0J1dHRvbik7XG5leHBvcnRzLlJhZGlvQnV0dG9uID0gUmFkaW9CdXR0b247XG52YXIgUmFkaW9CdXR0b25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhZGlvQnV0dG9uTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gUmFkaW9CdXR0b25Nb2R1bGU7XG59KCkpO1xuUmFkaW9CdXR0b25Nb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1JhZGlvQnV0dG9uXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbUmFkaW9CdXR0b25dXG4gICAgfSlcbl0sIFJhZGlvQnV0dG9uTW9kdWxlKTtcbmV4cG9ydHMuUmFkaW9CdXR0b25Nb2R1bGUgPSBSYWRpb0J1dHRvbk1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhZGlvYnV0dG9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvcmFkaW9idXR0b24vcmFkaW9idXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9yYWRpb2J1dHRvbi9yYWRpb2J1dHRvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGZvcm1zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIik7XG5leHBvcnRzLlJBVElOR19WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBmb3Jtc18xLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSYXRpbmc7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIFJhdGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmF0aW5nKCkge1xuICAgICAgICB0aGlzLnN0YXJzID0gNTtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uUmF0ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25DYW5jZWwgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIFJhdGluZy5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhcnNBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhcnM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zdGFyc0FycmF5W2ldID0gaTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmF0aW5nLnByb3RvdHlwZS5yYXRlID0gZnVuY3Rpb24gKGV2ZW50LCBpKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkb25seSAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IChpICsgMSk7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkKCk7XG4gICAgICAgICAgICB0aGlzLm9uUmF0ZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKGkgKyAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIFJhdGluZy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRvbmx5ICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMub25DYW5jZWwuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIFJhdGluZy5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICBSYXRpbmcucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICBSYXRpbmcucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIFJhdGluZy5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHZhbDtcbiAgICB9O1xuICAgIHJldHVybiBSYXRpbmc7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBSYXRpbmcucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFJhdGluZy5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBSYXRpbmcucHJvdG90eXBlLCBcInN0YXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFJhdGluZy5wcm90b3R5cGUsIFwiY2FuY2VsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBSYXRpbmcucHJvdG90eXBlLCBcIm9uUmF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgUmF0aW5nLnByb3RvdHlwZSwgXCJvbkNhbmNlbFwiLCB2b2lkIDApO1xuUmF0aW5nID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1yYXRpbmcnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXJhdGluZ1xcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzogZGlzYWJsZWR9XFxcIj5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiAqbmdJZj1cXFwiY2FuY2VsXFxcIiAoY2xpY2spPVxcXCJjbGVhcigkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWJhblxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiAqbmdGb3I9XFxcImxldCBzdGFyIG9mIHN0YXJzQXJyYXk7bGV0IGk9aW5kZXhcXFwiIChjbGljayk9XFxcInJhdGUoJGV2ZW50LGkpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhXFxcIiBbbmdDbGFzc109XFxcInsnZmEtc3Rhci1vJzogKCF2YWx1ZSB8fCBpID49IHZhbHVlKSwgJ2ZhLXN0YXInOihpIDwgdmFsdWUpfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZXhwb3J0cy5SQVRJTkdfVkFMVUVfQUNDRVNTT1JdXG4gICAgfSlcbl0sIFJhdGluZyk7XG5leHBvcnRzLlJhdGluZyA9IFJhdGluZztcbnZhciBSYXRpbmdNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhdGluZ01vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFJhdGluZ01vZHVsZTtcbn0oKSk7XG5SYXRpbmdNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1JhdGluZ10sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1JhdGluZ11cbiAgICB9KVxuXSwgUmF0aW5nTW9kdWxlKTtcbmV4cG9ydHMuUmF0aW5nTW9kdWxlID0gUmF0aW5nTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmF0aW5nLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvcmF0aW5nL3JhdGluZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3JhdGluZy9yYXRpbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBTY2hlZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NoZWR1bGUoZWwsIGRpZmZlcnMpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gMS4zNTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmlldyA9ICdtb250aCc7XG4gICAgICAgIHRoaXMuYWxsRGF5U2xvdCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxsRGF5VGV4dCA9ICdhbGwtZGF5JztcbiAgICAgICAgdGhpcy5zbG90RHVyYXRpb24gPSAnMDA6MzA6MDAnO1xuICAgICAgICB0aGlzLnNjcm9sbFRpbWUgPSAnMDY6MDA6MDAnO1xuICAgICAgICB0aGlzLm1pblRpbWUgPSAnMDA6MDA6MDAnO1xuICAgICAgICB0aGlzLm1heFRpbWUgPSAnMjQ6MDA6MDAnO1xuICAgICAgICB0aGlzLnNsb3RFdmVudE92ZXJsYXAgPSB0cnVlO1xuICAgICAgICB0aGlzLmRyYWdSZXZlcnREdXJhdGlvbiA9IDUwMDtcbiAgICAgICAgdGhpcy5kcmFnT3BhY2l0eSA9IC43NTtcbiAgICAgICAgdGhpcy5kcmFnU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aW1lem9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVGb3JtYXQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uRGF5Q2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRHJvcCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25FdmVudENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkV2ZW50TW91c2VvdmVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkV2ZW50TW91c2VvdXQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRXZlbnREcmFnU3RhcnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRXZlbnREcmFnU3RvcCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25FdmVudERyb3AgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRXZlbnRSZXNpemVTdGFydCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25FdmVudFJlc2l6ZVN0b3AgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRXZlbnRSZXNpemUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uVmlld1JlbmRlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25WaWV3RGVzdHJveSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGlmZmVyID0gZGlmZmVycy5maW5kKFtdKS5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgU2NoZWR1bGUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRoZW1lOiB0cnVlLFxuICAgICAgICAgICAgaGVhZGVyOiB0aGlzLmhlYWRlcixcbiAgICAgICAgICAgIGlzUlRMOiB0aGlzLnJ0bCxcbiAgICAgICAgICAgIHdlZWtlbmRzOiB0aGlzLndlZWtlbmRzLFxuICAgICAgICAgICAgaGlkZGVuRGF5czogdGhpcy5oaWRkZW5EYXlzLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRoaXMuZml4ZWRXZWVrQ291bnQsXG4gICAgICAgICAgICB3ZWVrTnVtYmVyczogdGhpcy53ZWVrTnVtYmVycyxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBjb250ZW50SGVpZ2h0OiB0aGlzLmNvbnRlbnRIZWlnaHQsXG4gICAgICAgICAgICBhc3BlY3RSYXRpbzogdGhpcy5hc3BlY3RSYXRpbyxcbiAgICAgICAgICAgIGV2ZW50TGltaXQ6IHRoaXMuZXZlbnRMaW1pdCxcbiAgICAgICAgICAgIGRlZmF1bHREYXRlOiB0aGlzLmRlZmF1bHREYXRlLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgIHRpbWV6b25lOiB0aGlzLnRpbWV6b25lLFxuICAgICAgICAgICAgdGltZUZvcm1hdDogdGhpcy50aW1lRm9ybWF0LFxuICAgICAgICAgICAgZWRpdGFibGU6IHRoaXMuZWRpdGFibGUsXG4gICAgICAgICAgICBkcm9wcGFibGU6IHRoaXMuZHJvcHBhYmxlLFxuICAgICAgICAgICAgZXZlbnRTdGFydEVkaXRhYmxlOiB0aGlzLmV2ZW50U3RhcnRFZGl0YWJsZSxcbiAgICAgICAgICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogdGhpcy5ldmVudER1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgICAgICBkZWZhdWx0VmlldzogdGhpcy5kZWZhdWx0VmlldyxcbiAgICAgICAgICAgIGFsbERheVNsb3Q6IHRoaXMuYWxsRGF5U2xvdCxcbiAgICAgICAgICAgIGFsbERheVRleHQ6IHRoaXMuYWxsRGF5VGV4dCxcbiAgICAgICAgICAgIHNsb3REdXJhdGlvbjogdGhpcy5zbG90RHVyYXRpb24sXG4gICAgICAgICAgICBzbG90TGFiZWxJbnRlcnZhbDogdGhpcy5zbG90TGFiZWxJbnRlcnZhbCxcbiAgICAgICAgICAgIHNuYXBEdXJhdGlvbjogdGhpcy5zbmFwRHVyYXRpb24sXG4gICAgICAgICAgICBzY3JvbGxUaW1lOiB0aGlzLnNjcm9sbFRpbWUsXG4gICAgICAgICAgICBtaW5UaW1lOiB0aGlzLm1pblRpbWUsXG4gICAgICAgICAgICBtYXhUaW1lOiB0aGlzLm1heFRpbWUsXG4gICAgICAgICAgICBzbG90RXZlbnRPdmVybGFwOiB0aGlzLnNsb3RFdmVudE92ZXJsYXAsXG4gICAgICAgICAgICBub3dJbmRpY2F0b3I6IHRoaXMubm93SW5kaWNhdG9yLFxuICAgICAgICAgICAgZHJhZ1JldmVydER1cmF0aW9uOiB0aGlzLmRyYWdSZXZlcnREdXJhdGlvbixcbiAgICAgICAgICAgIGRyYWdPcGFjaXR5OiB0aGlzLmRyYWdPcGFjaXR5LFxuICAgICAgICAgICAgZHJhZ1Njcm9sbDogdGhpcy5kcmFnU2Nyb2xsLFxuICAgICAgICAgICAgZXZlbnRPdmVybGFwOiB0aGlzLmV2ZW50T3ZlcmxhcCxcbiAgICAgICAgICAgIGV2ZW50Q29uc3RyYWludDogdGhpcy5ldmVudENvbnN0cmFpbnQsXG4gICAgICAgICAgICBldmVudFJlbmRlcjogdGhpcy5ldmVudFJlbmRlcixcbiAgICAgICAgICAgIGRheVJlbmRlcjogdGhpcy5kYXlSZW5kZXIsXG4gICAgICAgICAgICBkYXlDbGljazogZnVuY3Rpb24gKGRhdGUsIGpzRXZlbnQsIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRheUNsaWNrLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAnZGF0ZSc6IGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICdqc0V2ZW50JzoganNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZXcnOiB2aWV3XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJvcDogZnVuY3Rpb24gKGRhdGUsIGpzRXZlbnQsIHVpLCByZXNvdXJjZUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Ecm9wLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAnZGF0ZSc6IGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICdqc0V2ZW50JzoganNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ3VpJzogdWksXG4gICAgICAgICAgICAgICAgICAgICdyZXNvdXJjZUlkJzogcmVzb3VyY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV2ZW50Q2xpY2s6IGZ1bmN0aW9uIChjYWxFdmVudCwganNFdmVudCwgdmlldykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRXZlbnRDbGljay5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgJ2NhbEV2ZW50JzogY2FsRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICdqc0V2ZW50JzoganNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZXcnOiB2aWV3XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXZlbnRNb3VzZW92ZXI6IGZ1bmN0aW9uIChjYWxFdmVudCwganNFdmVudCwgdmlldykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRXZlbnRNb3VzZW92ZXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICdjYWxFdmVudCc6IGNhbEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAnanNFdmVudCc6IGpzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICd2aWV3Jzogdmlld1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV2ZW50TW91c2VvdXQ6IGZ1bmN0aW9uIChjYWxFdmVudCwganNFdmVudCwgdmlldykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRXZlbnRNb3VzZW91dC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgJ2NhbEV2ZW50JzogY2FsRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICdqc0V2ZW50JzoganNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZXcnOiB2aWV3XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXZlbnREcmFnU3RhcnQ6IGZ1bmN0aW9uIChldmVudCwganNFdmVudCwgdWksIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkV2ZW50RHJhZ1N0YXJ0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ2pzRXZlbnQnOiBqc0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICAndmlldyc6IHZpZXdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldmVudERyYWdTdG9wOiBmdW5jdGlvbiAoZXZlbnQsIGpzRXZlbnQsIHVpLCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25FdmVudERyYWdTdG9wLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ2pzRXZlbnQnOiBqc0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICAndmlldyc6IHZpZXdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldmVudERyb3A6IGZ1bmN0aW9uIChldmVudCwgZGVsdGEsIHJldmVydEZ1bmMsIGpzRXZlbnQsIHVpLCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRXZlbnREcm9wLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbHRhJzogZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICdyZXZlcnRGdW5jJzogcmV2ZXJ0RnVuYyxcbiAgICAgICAgICAgICAgICAgICAgJ2pzRXZlbnQnOiBqc0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICAndmlldyc6IHZpZXdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldmVudFJlc2l6ZVN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQsIGpzRXZlbnQsIHVpLCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25FdmVudFJlc2l6ZVN0YXJ0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ2pzRXZlbnQnOiBqc0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICAndmlldyc6IHZpZXdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldmVudFJlc2l6ZVN0b3A6IGZ1bmN0aW9uIChldmVudCwganNFdmVudCwgdWksIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkV2ZW50UmVzaXplU3RvcC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgJ2V2ZW50JzogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICdqc0V2ZW50JzoganNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZXcnOiB2aWV3XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IGZ1bmN0aW9uIChldmVudCwgZGVsdGEsIHJldmVydEZ1bmMsIGpzRXZlbnQsIHVpLCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRXZlbnRSZXNpemUuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICdldmVudCc6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAnZGVsdGEnOiBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgJ3JldmVydEZ1bmMnOiByZXZlcnRGdW5jLFxuICAgICAgICAgICAgICAgICAgICAnanNFdmVudCc6IGpzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICd2aWV3Jzogdmlld1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpZXdSZW5kZXI6IGZ1bmN0aW9uICh2aWV3LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25WaWV3UmVuZGVyLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAndmlldyc6IHZpZXcsXG4gICAgICAgICAgICAgICAgICAgICdlbGVtZW50JzogZWxlbWVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpZXdEZXN0cm95OiBmdW5jdGlvbiAodmlldywgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uVmlld0Rlc3Ryb3kuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICd2aWV3JzogdmlldyxcbiAgICAgICAgICAgICAgICAgICAgJ2VsZW1lbnQnOiBlbGVtZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdbcHJvcF0gPSB0aGlzLm9wdGlvbnNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjaGVkdWxlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCAmJiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2NoZWR1bGUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZWR1bGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBjaGFuZ2UgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UgIT09ICdldmVudHMnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbY2hhbmdlXSA9IGNoYW5nZXNbY2hhbmdlXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUuZnVsbENhbGVuZGFyKCdvcHRpb24nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2NoZWR1bGUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUgPSBqUXVlcnkodGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZS5mdWxsQ2FsZW5kYXIodGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlLmZ1bGxDYWxlbmRhcignYWRkRXZlbnRTb3VyY2UnLCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgU2NoZWR1bGUucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLmRpZmZlci5kaWZmKHRoaXMuZXZlbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuc2NoZWR1bGUgJiYgY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZS5mdWxsQ2FsZW5kYXIoJ3JlbW92ZUV2ZW50U291cmNlcycpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZS5mdWxsQ2FsZW5kYXIoJ2FkZEV2ZW50U291cmNlJywgdGhpcy5ldmVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY2hlZHVsZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGpRdWVyeSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0pLmZ1bGxDYWxlbmRhcignZGVzdHJveScpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUgPSBudWxsO1xuICAgIH07XG4gICAgU2NoZWR1bGUucHJvdG90eXBlLmdvdG9EYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZS5mdWxsQ2FsZW5kYXIoJ2dvdG9EYXRlJywgZGF0ZSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZS5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZS5mdWxsQ2FsZW5kYXIoJ3ByZXYnKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlLmZ1bGxDYWxlbmRhcignbmV4dCcpO1xuICAgIH07XG4gICAgU2NoZWR1bGUucHJvdG90eXBlLnByZXZZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlLmZ1bGxDYWxlbmRhcigncHJldlllYXInKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlLnByb3RvdHlwZS5uZXh0WWVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZS5mdWxsQ2FsZW5kYXIoJ25leHRZZWFyJyk7XG4gICAgfTtcbiAgICBTY2hlZHVsZS5wcm90b3R5cGUudG9kYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUuZnVsbENhbGVuZGFyKCd0b2RheScpO1xuICAgIH07XG4gICAgU2NoZWR1bGUucHJvdG90eXBlLmluY3JlbWVudERhdGUgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZS5mdWxsQ2FsZW5kYXIoJ2luY3JlbWVudERhdGUnLCBkdXJhdGlvbik7XG4gICAgfTtcbiAgICBTY2hlZHVsZS5wcm90b3R5cGUuY2hhbmdlVmlldyA9IGZ1bmN0aW9uICh2aWV3TmFtZSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlLmZ1bGxDYWxlbmRhcignY2hhbmdlVmlldycsIHZpZXdOYW1lKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZS5mdWxsQ2FsZW5kYXIoJ2dldERhdGUnKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlLnByb3RvdHlwZS5maW5kRXZlbnQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICBpZiAodGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmV2ZW50czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgU2NoZWR1bGUucHJvdG90eXBlLnVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBzb3VyY2VFdmVudCA9IHRoaXMuZmluZEV2ZW50KGV2ZW50LmlkKTtcbiAgICAgICAgaWYgKHNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICBzb3VyY2VFdmVudC5zdGFydCA9IGV2ZW50LnN0YXJ0LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmVuZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUV2ZW50LmVuZCA9IGV2ZW50LmVuZC5mb3JtYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjaGVkdWxlO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJldmVudHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcInJ0bFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwid2Vla2VuZHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJoaWRkZW5EYXlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJmaXhlZFdlZWtDb3VudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwid2Vla051bWJlcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwiYnVzaW5lc3NIb3Vyc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwiY29udGVudEhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJhc3BlY3RSYXRpb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJldmVudExpbWl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcImRlZmF1bHREYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJlZGl0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwiZHJvcHBhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJldmVudFN0YXJ0RWRpdGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcImV2ZW50RHVyYXRpb25FZGl0YWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJkZWZhdWx0Vmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwiYWxsRGF5U2xvdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJhbGxEYXlUZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcInNsb3REdXJhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJzbG90TGFiZWxJbnRlcnZhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJzbmFwRHVyYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwic2Nyb2xsVGltZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJtaW5UaW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm1heFRpbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcInNsb3RFdmVudE92ZXJsYXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm5vd0luZGljYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJkcmFnUmV2ZXJ0RHVyYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwiZHJhZ09wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcImRyYWdTY3JvbGxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwiZXZlbnRPdmVybGFwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcImV2ZW50Q29uc3RyYWludFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJsb2NhbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwidGltZXpvbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwidGltZUZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcImV2ZW50UmVuZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwiZGF5UmVuZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJvbkRheUNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwib25Ecm9wXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwib25FdmVudENsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwib25FdmVudE1vdXNlb3ZlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm9uRXZlbnRNb3VzZW91dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm9uRXZlbnREcmFnU3RhcnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJvbkV2ZW50RHJhZ1N0b3BcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFNjaGVkdWxlLnByb3RvdHlwZSwgXCJvbkV2ZW50RHJvcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm9uRXZlbnRSZXNpemVTdGFydFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm9uRXZlbnRSZXNpemVTdG9wXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBTY2hlZHVsZS5wcm90b3R5cGUsIFwib25FdmVudFJlc2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm9uVmlld1JlbmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU2NoZWR1bGUucHJvdG90eXBlLCBcIm9uVmlld0Rlc3Ryb3lcIiwgdm9pZCAwKTtcblNjaGVkdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1zY2hlZHVsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnPGRpdiBbbmdTdHlsZV09XCJzdHlsZVwiIFtjbGFzc109XCJzdHlsZUNsYXNzXCI+PC9kaXY+J1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGNvcmVfMS5JdGVyYWJsZURpZmZlcnNdKVxuXSwgU2NoZWR1bGUpO1xuZXhwb3J0cy5TY2hlZHVsZSA9IFNjaGVkdWxlO1xudmFyIFNjaGVkdWxlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNjaGVkdWxlTW9kdWxlO1xufSgpKTtcblNjaGVkdWxlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtTY2hlZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1NjaGVkdWxlXVxuICAgIH0pXG5dLCBTY2hlZHVsZU1vZHVsZSk7XG5leHBvcnRzLlNjaGVkdWxlTW9kdWxlID0gU2NoZWR1bGVNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL3NjaGVkdWxlL3NjaGVkdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvc2NoZWR1bGUvc2NoZWR1bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBmb3Jtc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpO1xuZXhwb3J0cy5TRUxFQ1RCVVRUT05fVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogZm9ybXNfMS5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VsZWN0QnV0dG9uOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBTZWxlY3RCdXR0b24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdEJ1dHRvbigpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgU2VsZWN0QnV0dG9uLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIFNlbGVjdEJ1dHRvbi5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIFNlbGVjdEJ1dHRvbi5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgU2VsZWN0QnV0dG9uLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdmFsO1xuICAgIH07XG4gICAgU2VsZWN0QnV0dG9uLnByb3RvdHlwZS5vbkl0ZW1DbGljayA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9uLCBjaGVja2JveCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrYm94LmZvY3VzKCk7XG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUluZGV4XzEgPSB0aGlzLmZpbmRJdGVtSW5kZXgob3B0aW9uKTtcbiAgICAgICAgICAgIGlmIChpdGVtSW5kZXhfMSAhPSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBpdGVtSW5kZXhfMTsgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICh0aGlzLnZhbHVlIHx8IFtdKS5jb25jYXQoW29wdGlvbi52YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbi52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0QnV0dG9uLnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZEl0ZW0gPSBldmVudC50YXJnZXQ7XG4gICAgfTtcbiAgICBTZWxlY3RCdXR0b24ucHJvdG90eXBlLm9uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzZWRJdGVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCgpO1xuICAgIH07XG4gICAgU2VsZWN0QnV0dG9uLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRJdGVtSW5kZXgob3B0aW9uKSAhPSAtMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSA9PSB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgU2VsZWN0QnV0dG9uLnByb3RvdHlwZS5maW5kSXRlbUluZGV4ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlW2ldID09IG9wdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0QnV0dG9uO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFNlbGVjdEJ1dHRvbi5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlbGVjdEJ1dHRvbi5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VsZWN0QnV0dG9uLnByb3RvdHlwZSwgXCJtdWx0aXBsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlbGVjdEJ1dHRvbi5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZWxlY3RCdXR0b24ucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VsZWN0QnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU2VsZWN0QnV0dG9uLnByb3RvdHlwZSwgXCJvbkNoYW5nZVwiLCB2b2lkIDApO1xuU2VsZWN0QnV0dG9uID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1zZWxlY3RCdXR0b24nLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCIndWktc2VsZWN0YnV0dG9uIHVpLWJ1dHRvbnNldCB1aS13aWRnZXQgdWktY29ybmVyLWFsbCB1aS1idXR0b25zZXQtJyArIG9wdGlvbnMubGVuZ3RoXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IG9wdGlvbiBvZiBvcHRpb25zO1xcXCIgY2xhc3M9XFxcInVpLWJ1dHRvbiB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1idXR0b24tdGV4dC1vbmx5XFxcIlxcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtYWN0aXZlJzppc1NlbGVjdGVkKG9wdGlvbiksICd1aS1zdGF0ZS1kaXNhYmxlZCc6ZGlzYWJsZWQsICd1aS1zdGF0ZS1mb2N1cyc6IGNib3ggPT0gZm9jdXNlZEl0ZW19XFxcIiAoY2xpY2spPVxcXCJvbkl0ZW1DbGljaygkZXZlbnQsb3B0aW9uLGNib3gpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWJ1dHRvbi10ZXh0IHVpLWNsaWNrYWJsZVxcXCI+e3tvcHRpb24ubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCAjY2JveCB0eXBlPVxcXCJjaGVja2JveFxcXCIgW2NoZWNrZWRdPVxcXCJpc1NlbGVjdGVkKG9wdGlvbilcXFwiIChmb2N1cyk9XFxcIm9uRm9jdXMoJGV2ZW50KVxcXCIgKGJsdXIpPVxcXCJvbkJsdXIoJGV2ZW50KVxcXCIgW2F0dHIudGFiaW5kZXhdPVxcXCJ0YWJpbmRleFxcXCIgW2F0dHIuZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCI+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLlNFTEVDVEJVVFRPTl9WQUxVRV9BQ0NFU1NPUl1cbiAgICB9KVxuXSwgU2VsZWN0QnV0dG9uKTtcbmV4cG9ydHMuU2VsZWN0QnV0dG9uID0gU2VsZWN0QnV0dG9uO1xudmFyIFNlbGVjdEJ1dHRvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0QnV0dG9uTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gU2VsZWN0QnV0dG9uTW9kdWxlO1xufSgpKTtcblNlbGVjdEJ1dHRvbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbU2VsZWN0QnV0dG9uXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbU2VsZWN0QnV0dG9uXVxuICAgIH0pXG5dLCBTZWxlY3RCdXR0b25Nb2R1bGUpO1xuZXhwb3J0cy5TZWxlY3RCdXR0b25Nb2R1bGUgPSBTZWxlY3RCdXR0b25Nb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3RidXR0b24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy9zZWxlY3RidXR0b24vc2VsZWN0YnV0dG9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvc2VsZWN0YnV0dG9uL3NlbGVjdGJ1dHRvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL3JvdXRlclwiKTtcbnZhciBTbGlkZU1lbnVTdWIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWRlTWVudVN1YihzbGlkZU1lbnUpIHtcbiAgICAgICAgdGhpcy5zbGlkZU1lbnUgPSBzbGlkZU1lbnU7XG4gICAgICAgIHRoaXMuYmFja0xhYmVsID0gJ0JhY2snO1xuICAgICAgICB0aGlzLmVhc2luZyA9ICdlYXNlLW91dCc7XG4gICAgfVxuICAgIFNsaWRlTWVudVN1Yi5wcm90b3R5cGUuaXRlbUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBpdGVtLCBsaXN0aXRlbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWl0ZW0udXJsKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmNvbW1hbmQpIHtcbiAgICAgICAgICAgIGl0ZW0uY29tbWFuZCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0uaXRlbXMgJiYgIXRoaXMuc2xpZGVNZW51LmFuaW1hdGluZykge1xuICAgICAgICAgICAgdGhpcy5zbGlkZU1lbnUubGVmdCAtPSB0aGlzLnNsaWRlTWVudS5tZW51V2lkdGg7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSBsaXN0aXRlbTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVNZW51LmFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNsaWRlTWVudS5hbmltYXRpbmcgPSBmYWxzZTsgfSwgdGhpcy5lZmZlY3REdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNsaWRlTWVudVN1Yi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU2xpZGVNZW51U3ViO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTbGlkZU1lbnVTdWIucHJvdG90eXBlLCBcIml0ZW1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2xpZGVNZW51U3ViLnByb3RvdHlwZSwgXCJyb290XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2xpZGVNZW51U3ViLnByb3RvdHlwZSwgXCJiYWNrTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTbGlkZU1lbnVTdWIucHJvdG90eXBlLCBcIm1lbnVXaWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNsaWRlTWVudVN1Yi5wcm90b3R5cGUsIFwiZWZmZWN0RHVyYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTbGlkZU1lbnVTdWIucHJvdG90eXBlLCBcImVhc2luZ1wiLCB2b2lkIDApO1xuU2xpZGVNZW51U3ViID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1zbGlkZU1lbnVTdWInLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDx1bCBbbmdDbGFzc109XFxcInsndWktaGVscGVyLXJlc2V0IHVpLW1lbnUtcm9vdGxpc3QnOnJvb3QsICd1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1tZW51LWNoaWxkJzohcm9vdH1cXFwiIGNsYXNzPVxcXCJ1aS1tZW51LWxpc3RcXFwiXFxuICAgICAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cXFwibWVudVdpZHRoXFxcIiBbc3R5bGUubGVmdC5weF09XFxcInJvb3QgPyBzbGlkZU1lbnUubGVmdCA6IHNsaWRlTWVudS5tZW51V2lkdGhcXFwiIFxcbiAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uUHJvcGVydHldPVxcXCJyb290ID8gJ2xlZnQnIDogJ25vbmUnXFxcIiBbc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uXT1cXFwiZWZmZWN0RHVyYXRpb24gKyAnbXMnXFxcIiBbc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXT1cXFwiZWFzaW5nXFxcIj5cXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWNoaWxkIFtuZ0Zvck9mXT1cXFwiKHJvb3QgPyBpdGVtIDogaXRlbS5pdGVtcylcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGkgKm5nSWY9XFxcImNoaWxkLnNlcGFyYXRvclxcXCIgY2xhc3M9XFxcInVpLW1lbnUtc2VwYXJhdG9yIHVpLXdpZGdldC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpICpuZ0lmPVxcXCIhY2hpbGQuc2VwYXJhdG9yXFxcIiAjbGlzdGl0ZW0gW25nQ2xhc3NdPVxcXCJ7J3VpLW1lbnVpdGVtIHVpLXdpZGdldCB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1tZW51LXBhcmVudCc6Y2hpbGQuaXRlbXMsJ3VpLXNsaWRlbWVudWl0ZW0tYWN0aXZlJzpsaXN0aXRlbT09YWN0aXZlSXRlbX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcIiFjaGlsZC5yb3V0ZXJMaW5rXFxcIiBbaHJlZl09XFxcImNoaWxkLnVybHx8JyMnXFxcIiBjbGFzcz1cXFwidWktbWVudWl0ZW0tbGluayB1aS1jb3JuZXItYWxsXFxcIiBbYXR0ci50YXJnZXRdPVxcXCJjaGlsZC50YXJnZXRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLW1lbnVpdGVtLWxpbmstcGFyZW50JzpjaGlsZC5pdGVtcywndWktc3RhdGUtZGlzYWJsZWQnOmNoaWxkLmRpc2FibGVkfVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgY2hpbGQsIGxpc3RpdGVtKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXN1Ym1lbnUtaWNvbiBmYSBmYS1mdyBmYS1jYXJldC1yaWdodFxcXCIgKm5nSWY9XFxcImNoaWxkLml0ZW1zXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLWljb24gZmEgZmEtZndcXFwiICpuZ0lmPVxcXCJjaGlsZC5pY29uXFxcIiBbbmdDbGFzc109XFxcImNoaWxkLmljb25cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0tdGV4dFxcXCI+e3tjaGlsZC5sYWJlbH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcImNoaWxkLnJvdXRlckxpbmtcXFwiIFtyb3V0ZXJMaW5rXT1cXFwiY2hpbGQucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCIndWktc3RhdGUtYWN0aXZlJ1xcXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cXFwiY2hpbGQucm91dGVyTGlua0FjdGl2ZU9wdGlvbnN8fHtleGFjdDpmYWxzZX1cXFwiIFtocmVmXT1cXFwiY2hpbGQudXJsfHwnIydcXFwiIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1saW5rIHVpLWNvcm5lci1hbGxcXFwiIFthdHRyLnRhcmdldF09XFxcImNoaWxkLnRhcmdldFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktbWVudWl0ZW0tbGluay1wYXJlbnQnOmNoaWxkLml0ZW1zLCd1aS1zdGF0ZS1kaXNhYmxlZCc6Y2hpbGQuZGlzYWJsZWR9XFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJpdGVtQ2xpY2soJGV2ZW50LCBjaGlsZCwgbGlzdGl0ZW0pXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktc3VibWVudS1pY29uIGZhIGZhLWZ3IGZhLWNhcmV0LXJpZ2h0XFxcIiAqbmdJZj1cXFwiY2hpbGQuaXRlbXNcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYSBmYS1md1xcXCIgKm5nSWY9XFxcImNoaWxkLmljb25cXFwiIFtuZ0NsYXNzXT1cXFwiY2hpbGQuaWNvblxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS10ZXh0XFxcIj57e2NoaWxkLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8cC1zbGlkZU1lbnVTdWIgY2xhc3M9XFxcInVpLXN1Ym1lbnVcXFwiIFtpdGVtXT1cXFwiY2hpbGRcXFwiIFttZW51V2lkdGhdPVxcXCJtZW51V2lkdGhcXFwiICpuZ0lmPVxcXCJjaGlsZC5pdGVtc1xcXCI+PC9wLXNsaWRlTWVudVN1Yj5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgPC91bD5cXG4gICAgXCJcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIGNvcmVfMS5JbmplY3QoY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2xpZGVNZW51OyB9KSkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU2xpZGVNZW51XSlcbl0sIFNsaWRlTWVudVN1Yik7XG5leHBvcnRzLlNsaWRlTWVudVN1YiA9IFNsaWRlTWVudVN1YjtcbnZhciBTbGlkZU1lbnUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWRlTWVudShlbCwgZG9tSGFuZGxlciwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubWVudVdpZHRoID0gMTkwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gMTc1O1xuICAgICAgICB0aGlzLmVmZmVjdER1cmF0aW9uID0gMjUwO1xuICAgICAgICB0aGlzLmVhc2luZyA9ICdlYXNlLW91dCc7XG4gICAgICAgIHRoaXMuYmFja0xhYmVsID0gJ0JhY2snO1xuICAgICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgICB0aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBTbGlkZU1lbnUucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lclZpZXdDaGlsZC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLmJhY2t3YXJkRWxlbWVudCA9IHRoaXMuYmFja3dhcmRWaWV3Q2hpbGQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5zbGlkZU1lbnVDb250ZW50RWxlbWVudCA9IHRoaXMuc2xpZGVNZW51Q29udGVudFZpZXdDaGlsZC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnNsaWRlTWVudUNvbnRlbnRFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMudmlld3BvcnRIZWlnaHQgLSB0aGlzLmRvbUhhbmRsZXIuZ2V0SGlkZGVuRWxlbWVudE91dGVySGVpZ2h0KHRoaXMuYmFja3dhcmRFbGVtZW50KSArICdweCc7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnByZXZlbnREb2N1bWVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5wcmV2ZW50RG9jdW1lbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2xpZGVNZW51LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLm9mZnNldFBhcmVudClcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNob3coZXZlbnQpO1xuICAgIH07XG4gICAgU2xpZGVNZW51LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucHJldmVudERvY3VtZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbih0aGlzLmNvbnRhaW5lciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyLmZhZGVJbih0aGlzLmNvbnRhaW5lciwgMjUwKTtcbiAgICB9O1xuICAgIFNsaWRlTWVudS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9O1xuICAgIFNsaWRlTWVudS5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnByZXZlbnREb2N1bWVudERlZmF1bHQgPSB0cnVlO1xuICAgIH07XG4gICAgU2xpZGVNZW51LnByb3RvdHlwZS5nb0JhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGVmdCArPSB0aGlzLm1lbnVXaWR0aDtcbiAgICB9O1xuICAgIFNsaWRlTWVudS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNsaWRlTWVudTtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBTbGlkZU1lbnUucHJvdG90eXBlLCBcIm1vZGVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNsaWRlTWVudS5wcm90b3R5cGUsIFwicG9wdXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTbGlkZU1lbnUucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2xpZGVNZW51LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVNZW51LnByb3RvdHlwZSwgXCJtZW51V2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTbGlkZU1lbnUucHJvdG90eXBlLCBcInZpZXdwb3J0SGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2xpZGVNZW51LnByb3RvdHlwZSwgXCJlZmZlY3REdXJhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNsaWRlTWVudS5wcm90b3R5cGUsIFwiZWFzaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2xpZGVNZW51LnByb3RvdHlwZSwgXCJiYWNrTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2NvbnRhaW5lcicpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFNsaWRlTWVudS5wcm90b3R5cGUsIFwiY29udGFpbmVyVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdiYWNrd2FyZCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRWxlbWVudFJlZilcbl0sIFNsaWRlTWVudS5wcm90b3R5cGUsIFwiYmFja3dhcmRWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ3NsaWRlTWVudUNvbnRlbnQnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBTbGlkZU1lbnUucHJvdG90eXBlLCBcInNsaWRlTWVudUNvbnRlbnRWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcblNsaWRlTWVudSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3Atc2xpZGVNZW51JyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2ICNjb250YWluZXIgW25nQ2xhc3NdPVxcXCJ7J3VpLW1lbnUgdWktc2xpZGVtZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsJzp0cnVlLCd1aS1tZW51LWR5bmFtaWMgdWktc2hhZG93Jzpwb3B1cH1cXFwiIFxcbiAgICAgICAgICAgIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIChjbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktc2xpZGVtZW51LXdyYXBwZXJcXFwiIFtzdHlsZS5oZWlnaHQucHhdPVxcXCJ2aWV3cG9ydEhlaWdodFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgI3NsaWRlTWVudUNvbnRlbnQgY2xhc3M9XFxcInVpLXNsaWRlbWVudS1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwLXNsaWRlTWVudVN1YiBbaXRlbV09XFxcIm1vZGVsXFxcIiByb290PVxcXCJyb290XFxcIiBbbWVudVdpZHRoXT1cXFwibWVudVdpZHRoXFxcIiBbZWZmZWN0RHVyYXRpb25dPVxcXCJlZmZlY3REdXJhdGlvblxcXCIgW2Vhc2luZ109XFxcImVhc2luZ1xcXCI+PC9wLXNsaWRlTWVudVN1Yj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgI2JhY2t3YXJkIGNsYXNzPVxcXCJ1aS1zbGlkZW1lbnUtYmFja3dhcmQgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXFxcIiBbc3R5bGUuZGlzcGxheV09XFxcImxlZnQgPyAnYmxvY2snIDogJ25vbmUnXFxcIiAoY2xpY2spPVxcXCJnb0JhY2soKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtZncgZmEtY2FyZXQtbGVmdFxcXCI+PC9zcGFuPjxzcGFuPnt7YmFja0xhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMl0pXG5dLCBTbGlkZU1lbnUpO1xuZXhwb3J0cy5TbGlkZU1lbnUgPSBTbGlkZU1lbnU7XG52YXIgU2xpZGVNZW51TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGlkZU1lbnVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBTbGlkZU1lbnVNb2R1bGU7XG59KCkpO1xuU2xpZGVNZW51TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgcm91dGVyXzEuUm91dGVyTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1NsaWRlTWVudSwgcm91dGVyXzEuUm91dGVyTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbU2xpZGVNZW51LCBTbGlkZU1lbnVTdWJdXG4gICAgfSlcbl0sIFNsaWRlTWVudU1vZHVsZSk7XG5leHBvcnRzLlNsaWRlTWVudU1vZHVsZSA9IFNsaWRlTWVudU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWRlbWVudS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL3NsaWRlbWVudS9zbGlkZW1lbnUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9zbGlkZW1lbnUvc2xpZGVtZW51LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIGZvcm1zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIik7XG5leHBvcnRzLlNMSURFUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBmb3Jtc18xLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBTbGlkZXI7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIFNsaWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpZGVyKGVsLCBkb21IYW5kbGVyLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5taW4gPSAwO1xuICAgICAgICB0aGlzLm1heCA9IDEwMDtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25TbGlkZUVuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsdWVzID0gW107XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgU2xpZGVyLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVEb21EYXRhKCk7XG4gICAgICAgIHRoaXMuc2xpZGVySGFuZGxlQ2xpY2sgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhbmRsZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBTbGlkZXIucHJvdG90eXBlLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRvdWNob2JqID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgIHRoaXMuc3RhcnRIYW5kbGVWYWx1ZSA9ICh0aGlzLnJhbmdlKSA/IHRoaXMuaGFuZGxlVmFsdWVzW2luZGV4XSA6IHRoaXMuaGFuZGxlVmFsdWU7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhbmRsZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnR4ID0gcGFyc2VJbnQodG91Y2hvYmouY2xpZW50WCwgMTApO1xuICAgICAgICAgICAgdGhpcy5iYXJXaWR0aCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnR5ID0gcGFyc2VJbnQodG91Y2hvYmouY2xpZW50WSwgMTApO1xuICAgICAgICAgICAgdGhpcy5iYXJIZWlnaHQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBTbGlkZXIucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgdG91Y2hvYmogPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSwgaGFuZGxlVmFsdWUgPSAwO1xuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBoYW5kbGVWYWx1ZSA9IE1hdGguZmxvb3IoKChwYXJzZUludCh0b3VjaG9iai5jbGllbnRYLCAxMCkgLSB0aGlzLnN0YXJ0eCkgKiAxMDApIC8gKHRoaXMuYmFyV2lkdGgpKSArIHRoaXMuc3RhcnRIYW5kbGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVZhbHVlID0gTWF0aC5mbG9vcigoKHRoaXMuc3RhcnR5IC0gcGFyc2VJbnQodG91Y2hvYmouY2xpZW50WSwgMTApKSAqIDEwMCkgLyAodGhpcy5iYXJIZWlnaHQpKSArIHRoaXMuc3RhcnRIYW5kbGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFZhbHVlRnJvbUhhbmRsZShldmVudCwgaGFuZGxlVmFsdWUpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgU2xpZGVyLnByb3RvdHlwZS5vbkJhckNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNsaWRlckhhbmRsZUNsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURvbURhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNsaWRlckhhbmRsZUNsaWNrID0gZmFsc2U7XG4gICAgfTtcbiAgICBTbGlkZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vdXNldXBMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdtb3VzZXVwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblNsaWRlRW5kLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgdmFsdWVzOiBfdGhpcy52YWx1ZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblNsaWRlRW5kLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgdmFsdWU6IF90aGlzLnZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlVmFsdWUgPSB0aGlzLmNhbGN1bGF0ZUhhbmRsZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZUZyb21IYW5kbGUoZXZlbnQsIGhhbmRsZVZhbHVlKTtcbiAgICB9O1xuICAgIFNsaWRlci5wcm90b3R5cGUuc2V0VmFsdWVGcm9tSGFuZGxlID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVWYWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmdldFZhbHVlRnJvbUhhbmRsZShoYW5kbGVWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGVwQ2hhbmdlKG5ld1ZhbHVlLCB0aGlzLnZhbHVlc1t0aGlzLmhhbmRsZUluZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlc1t0aGlzLmhhbmRsZUluZGV4XSA9IGhhbmRsZVZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUobmV3VmFsdWUsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN0ZXBDaGFuZ2UobmV3VmFsdWUsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSA9IGhhbmRsZVZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUobmV3VmFsdWUsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVTdGVwQ2hhbmdlID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YXIgZGlmZiA9IChuZXdWYWx1ZSAtIG9sZFZhbHVlKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwICYmICgtMSAqIGRpZmYpID49IHRoaXMuc3RlcCAvIDIpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSB0aGlzLnN0ZXA7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSGFuZGxlVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWZmID4gMCAmJiBkaWZmID49IHRoaXMuc3RlcCAvIDIpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgKyB0aGlzLnN0ZXA7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSGFuZGxlVmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2xpZGVyLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlKVxuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZSB8fCBbMCwgMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZSB8fCAwO1xuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZVZhbHVlKCk7XG4gICAgfTtcbiAgICBTbGlkZXIucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICBTbGlkZXIucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIFNsaWRlci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHZhbDtcbiAgICB9O1xuICAgIFNsaWRlci5wcm90b3R5cGUudXBkYXRlRG9tRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdFggPSByZWN0LmxlZnQgKyB0aGlzLmRvbUhhbmRsZXIuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICB0aGlzLmluaXRZID0gcmVjdC50b3AgKyB0aGlzLmRvbUhhbmRsZXIuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIHRoaXMuYmFyV2lkdGggPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgIHRoaXMuYmFySGVpZ2h0ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLm9mZnNldEhlaWdodDtcbiAgICB9O1xuICAgIFNsaWRlci5wcm90b3R5cGUuY2FsY3VsYXRlSGFuZGxlVmFsdWUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJylcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgoZXZlbnQucGFnZVggLSB0aGlzLmluaXRYKSAqIDEwMCkgLyAodGhpcy5iYXJXaWR0aCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoKCh0aGlzLmluaXRZICsgdGhpcy5iYXJIZWlnaHQpIC0gZXZlbnQucGFnZVkpICogMTAwKSAvICh0aGlzLmJhckhlaWdodCkpO1xuICAgIH07XG4gICAgU2xpZGVyLnByb3RvdHlwZS51cGRhdGVIYW5kbGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWVzWzBdID0gKHRoaXMudmFsdWVzWzBdIDwgdGhpcy5taW4gPyAwIDogdGhpcy52YWx1ZXNbMF0gLSB0aGlzLm1pbikgKiAxMDAgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlc1sxXSA9ICh0aGlzLnZhbHVlc1sxXSA+IHRoaXMubWF4ID8gMTAwIDogdGhpcy52YWx1ZXNbMV0gLSB0aGlzLm1pbikgKiAxMDAgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA8IHRoaXMubWluKVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAwO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZSA+IHRoaXMubWF4KVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAxMDA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSA9ICh0aGlzLnZhbHVlIC0gdGhpcy5taW4pICogMTAwIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTbGlkZXIucHJvdG90eXBlLnVwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZUluZGV4ID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCB0aGlzLm1pbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlc1swXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gdGhpcy52YWx1ZXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZXNbMF0gPSB0aGlzLmhhbmRsZVZhbHVlc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWF4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlc1sxXSA9IDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPCB0aGlzLnZhbHVlc1swXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlc1sxXSA9IHRoaXMuaGFuZGxlVmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsdWVzW3RoaXMuaGFuZGxlSW5kZXhdID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZXZlbnQ6IGV2ZW50LCB2YWx1ZXM6IHRoaXMudmFsdWVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbCA8IHRoaXMubWluKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdGhpcy5taW47XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMubWF4O1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gTWF0aC5mbG9vcih2YWwpO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZXZlbnQ6IGV2ZW50LCB2YWx1ZTogdGhpcy52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2xpZGVyLnByb3RvdHlwZS5nZXRWYWx1ZUZyb21IYW5kbGUgPSBmdW5jdGlvbiAoaGFuZGxlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChoYW5kbGVWYWx1ZSAvIDEwMCkgKyB0aGlzLm1pbjtcbiAgICB9O1xuICAgIFNsaWRlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb3VzZXVwTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2V1cExpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTbGlkZXI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTbGlkZXIucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2xpZGVyLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNsaWRlci5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVyLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTbGlkZXIucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2xpZGVyLnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNsaWRlci5wcm90b3R5cGUsIFwicmFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTbGlkZXIucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2xpZGVyLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBTbGlkZXIucHJvdG90eXBlLCBcIm9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBTbGlkZXIucHJvdG90eXBlLCBcIm9uU2xpZGVFbmRcIiwgdm9pZCAwKTtcblNsaWRlciA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3Atc2xpZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1zbGlkZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnOnRydWUsJ3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZCxcXG4gICAgICAgICAgICAndWktc2xpZGVyLWhvcml6b250YWwnOm9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJywndWktc2xpZGVyLXZlcnRpY2FsJzpvcmllbnRhdGlvbiA9PSAndmVydGljYWwnLCd1aS1zbGlkZXItYW5pbWF0ZSc6YW5pbWF0ZX1cXFwiXFxuICAgICAgICAgICAgKGNsaWNrKT1cXFwib25CYXJDbGljaygkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwicmFuZ2VcXFwiIGNsYXNzPVxcXCJ1aS1zbGlkZXItcmFuZ2UgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXFxcIiBbbmdTdHlsZV09XFxcInsnbGVmdCc6aGFuZGxlVmFsdWVzWzBdICsgJyUnLHdpZHRoOiAoaGFuZGxlVmFsdWVzWzFdIC0gaGFuZGxlVmFsdWVzWzBdICsgJyUnKX1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwib3JpZW50YXRpb249PSd2ZXJ0aWNhbCdcXFwiIGNsYXNzPVxcXCJ1aS1zbGlkZXItcmFuZ2UgdWktc2xpZGVyLXJhbmdlLW1pbiB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcXFwiIFtuZ1N0eWxlXT1cXFwieydoZWlnaHQnOiBoYW5kbGVWYWx1ZSArICclJ31cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiIXJhbmdlXFxcIiBjbGFzcz1cXFwidWktc2xpZGVyLWhhbmRsZSB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGwgdWktY2xpY2thYmxlXFxcIiAobW91c2Vkb3duKT1cXFwib25Nb3VzZURvd24oJGV2ZW50KVxcXCIgKHRvdWNoc3RhcnQpPVxcXCJvblRvdWNoU3RhcnQoJGV2ZW50KVxcXCIgKHRvdWNobW92ZSk9XFxcIm9uVG91Y2hNb3ZlKCRldmVudClcXFwiICh0b3VjaGVuZCk9XFxcImRyYWdnaW5nPWZhbHNlXFxcIlxcbiAgICAgICAgICAgICAgICBbc3R5bGUudHJhbnNpdGlvbl09XFxcImRyYWdnaW5nID8gJ25vbmUnOiBudWxsXFxcIiBbbmdTdHlsZV09XFxcInsnbGVmdCc6IG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJyA/IGhhbmRsZVZhbHVlICsgJyUnIDogbnVsbCwnYm90dG9tJzogb3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJyA/IGhhbmRsZVZhbHVlICsgJyUnIDogbnVsbH1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwicmFuZ2VcXFwiIChtb3VzZWRvd24pPVxcXCJvbk1vdXNlRG93bigkZXZlbnQsMClcXFwiICh0b3VjaHN0YXJ0KT1cXFwib25Ub3VjaFN0YXJ0KCRldmVudCwwKVxcXCIgKHRvdWNobW92ZSk9XFxcIm9uVG91Y2hNb3ZlKCRldmVudCwwKVxcXCIgKHRvdWNoZW5kKT1cXFwiZHJhZ2dpbmc9ZmFsc2VcXFwiIFtzdHlsZS50cmFuc2l0aW9uXT1cXFwiZHJhZ2dpbmcgPyAnbm9uZSc6IG51bGxcXFwiIGNsYXNzPVxcXCJ1aS1zbGlkZXItaGFuZGxlIHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCB1aS1jbGlja2FibGVcXFwiIFxcbiAgICAgICAgICAgICAgICBbbmdTdHlsZV09XFxcInsnbGVmdCc6aGFuZGxlVmFsdWVzWzBdICsgJyUnfVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXNsaWRlci1oYW5kbGUtYWN0aXZlJzpoYW5kbGVJbmRleD09MH1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwicmFuZ2VcXFwiIChtb3VzZWRvd24pPVxcXCJvbk1vdXNlRG93bigkZXZlbnQsMSlcXFwiICh0b3VjaHN0YXJ0KT1cXFwib25Ub3VjaFN0YXJ0KCRldmVudCwxKVxcXCIgKHRvdWNobW92ZSk9XFxcIm9uVG91Y2hNb3ZlKCRldmVudCwxKVxcXCIgKHRvdWNoZW5kKT1cXFwiZHJhZ2dpbmc9ZmFsc2VcXFwiIFtzdHlsZS50cmFuc2l0aW9uXT1cXFwiZHJhZ2dpbmcgPyAnbm9uZSc6IG51bGxcXFwiIGNsYXNzPVxcXCJ1aS1zbGlkZXItaGFuZGxlIHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCB1aS1jbGlja2FibGVcXFwiIFxcbiAgICAgICAgICAgICAgICBbbmdTdHlsZV09XFxcInsnbGVmdCc6aGFuZGxlVmFsdWVzWzFdICsgJyUnfVxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXNsaWRlci1oYW5kbGUtYWN0aXZlJzpoYW5kbGVJbmRleD09MX1cXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZXhwb3J0cy5TTElERVJfVkFMVUVfQUNDRVNTT1IsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuUmVuZGVyZXIyXSlcbl0sIFNsaWRlcik7XG5leHBvcnRzLlNsaWRlciA9IFNsaWRlcjtcbnZhciBTbGlkZXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWRlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNsaWRlck1vZHVsZTtcbn0oKSk7XG5TbGlkZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1NsaWRlcl0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1NsaWRlcl1cbiAgICB9KVxuXSwgU2xpZGVyTW9kdWxlKTtcbmV4cG9ydHMuU2xpZGVyTW9kdWxlID0gU2xpZGVyTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpZGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBpbnB1dHRleHRfMSA9IHJlcXVpcmUoXCIuLi9pbnB1dHRleHQvaW5wdXR0ZXh0XCIpO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbnZhciBmb3Jtc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpO1xuZXhwb3J0cy5TUElOTkVSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IGZvcm1zXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNwaW5uZXI7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIFNwaW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNwaW5uZXIoZWwsIGRvbUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN0ZXAgPSAxO1xuICAgICAgICB0aGlzLmRlY2ltYWxTZXBhcmF0b3IgPSAnLic7XG4gICAgICAgIHRoaXMudGhvdXNhbmRTZXBhcmF0b3IgPSAnLCc7XG4gICAgICAgIHRoaXMuZm9ybWF0SW5wdXQgPSB0cnVlO1xuICAgICAgICB0aGlzLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMudmFsdWVBc1N0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMua2V5UGF0dGVybiA9IC9bMC05XFwrXFwtXS87XG4gICAgfVxuICAgIFNwaW5uZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoTWF0aC5mbG9vcih0aGlzLnN0ZXApID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHRoaXMuc3RlcC50b1N0cmluZygpLnNwbGl0KC9bLF18Wy5dLylbMV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbiAoaW50ZXJ2YWwsIGRpcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaSA9IGludGVydmFsIHx8IDUwMDtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlcGVhdCg0MCwgZGlyKTtcbiAgICAgICAgfSwgaSk7XG4gICAgICAgIHRoaXMuc3BpbihkaXIpO1xuICAgIH07XG4gICAgU3Bpbm5lci5wcm90b3R5cGUuc3BpbiA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXAgKiBkaXI7XG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlIHx8IDA7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnByZWNpc2lvbilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMudG9GaXhlZChjdXJyZW50VmFsdWUgKyBzdGVwLCB0aGlzLnByZWNpc2lvbikpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gY3VycmVudFZhbHVlICsgc3RlcDtcbiAgICAgICAgaWYgKHRoaXMubWF4bGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdGhpcy52YWx1ZS50b1N0cmluZygpLmxlbmd0aCA+IHRoaXMubWF4bGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pbiAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWUgPCB0aGlzLm1pbikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubWluO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heCAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubWF4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9ybWF0VmFsdWUoKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoKTtcbiAgICB9O1xuICAgIFNwaW5uZXIucHJvdG90eXBlLnRvRml4ZWQgPSBmdW5jdGlvbiAodmFsdWUsIHByZWNpc2lvbikge1xuICAgICAgICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uIHx8IDApO1xuICAgICAgICByZXR1cm4gU3RyaW5nKE1hdGgucm91bmQodmFsdWUgKiBwb3dlcikgLyBwb3dlcik7XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5vblVwQnV0dG9uTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdChudWxsLCAxKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmlsbGVkU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Bpbm5lci5wcm90b3R5cGUub25VcEJ1dHRvbk1vdXNldXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Bpbm5lci5wcm90b3R5cGUub25VcEJ1dHRvbk1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Bpbm5lci5wcm90b3R5cGUub25Eb3duQnV0dG9uTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdChudWxsLCAtMSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNwaW5uZXIucHJvdG90eXBlLm9uRG93bkJ1dHRvbk1vdXNldXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Bpbm5lci5wcm90b3R5cGUub25Eb3duQnV0dG9uTW91c2VsZWF2ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5vbklucHV0S2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT0gMzgpIHtcbiAgICAgICAgICAgIHRoaXMuc3BpbigxKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQud2hpY2ggPT0gNDApIHtcbiAgICAgICAgICAgIHRoaXMuc3BpbigtMSk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5vbklucHV0S2V5UHJlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGlucHV0Q2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgICAgICBpZiAoIXRoaXMua2V5UGF0dGVybi50ZXN0KGlucHV0Q2hhcikgJiYgaW5wdXRDaGFyICE9IHRoaXMuZGVjaW1hbFNlcGFyYXRvciAmJiBldmVudC5rZXlDb2RlICE9IDkgJiYgZXZlbnQua2V5Q29kZSAhPSA4ICYmIGV2ZW50LmtleUNvZGUgIT0gMzcgJiYgZXZlbnQua2V5Q29kZSAhPSAzOSAmJiBldmVudC5rZXlDb2RlICE9IDQ2KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5vbklucHV0ID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnBhcnNlVmFsdWUoaW5wdXRWYWx1ZSk7XG4gICAgICAgIHRoaXMuZm9ybWF0VmFsdWUoKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5vbklucHV0Qmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQoKTtcbiAgICAgICAgdGhpcy5vbkJsdXIuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNwaW5uZXIucHJvdG90eXBlLnBhcnNlVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zcGxpdCh0aGlzLnRob3VzYW5kU2VwYXJhdG9yKS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWwucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5tYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgdGhpcy5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgU3Bpbm5lci5wcm90b3R5cGUuZm9ybWF0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBudWxsICYmIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHRleHRWYWx1ZSA9IFN0cmluZyh0aGlzLnZhbHVlKS5yZXBsYWNlKCcuJywgdGhpcy5kZWNpbWFsU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdElucHV0KSB7XG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlID0gdGV4dFZhbHVlLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIHRoaXMudGhvdXNhbmRTZXBhcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZUFzU3RyaW5nID0gdGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFzU3RyaW5nID0gJyc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNwaW5uZXIucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgU3Bpbm5lci5wcm90b3R5cGUuY2xlYXJUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNwaW5uZXIucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmZvcm1hdFZhbHVlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRmlsbGVkU3RhdGUoKTtcbiAgICB9O1xuICAgIFNwaW5uZXIucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZm47XG4gICAgfTtcbiAgICBTcGlubmVyLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdmFsO1xuICAgIH07XG4gICAgU3Bpbm5lci5wcm90b3R5cGUudXBkYXRlRmlsbGVkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlsbGVkID0gKHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlICE9IG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIFNwaW5uZXI7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU3Bpbm5lci5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFNwaW5uZXIucHJvdG90eXBlLCBcIm9uQmx1clwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNwaW5uZXIucHJvdG90eXBlLCBcInN0ZXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTcGlubmVyLnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTcGlubmVyLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTcGlubmVyLnByb3RvdHlwZSwgXCJtYXhsZW5ndGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTcGlubmVyLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3Bpbm5lci5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTcGlubmVyLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNwaW5uZXIucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNwaW5uZXIucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3Bpbm5lci5wcm90b3R5cGUsIFwiZGVjaW1hbFNlcGFyYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwaW5uZXIucHJvdG90eXBlLCBcInRob3VzYW5kU2VwYXJhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU3Bpbm5lci5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU3Bpbm5lci5wcm90b3R5cGUsIFwiZm9ybWF0SW5wdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTcGlubmVyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5TcGlubmVyID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1zcGlubmVyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktc3Bpbm5lciB1aS13aWRnZXQgdWktY29ybmVyLWFsbFxcXCI+XFxuICAgICAgICAgICAgPGlucHV0ICNpbiBbYXR0ci50eXBlXT1cXFwidHlwZVxcXCIgW2F0dHIuaWRdPVxcXCJpbnB1dElkXFxcIiBjbGFzcz1cXFwidWktc3Bpbm5lci1pbnB1dFxcXCIgW3ZhbHVlXT1cXFwidmFsdWVBc1N0cmluZ1xcXCIgY2xhc3M9XFxcInVpLWlucHV0dGV4dCB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnNpemVdPVxcXCJzaXplXFxcIiBbYXR0ci5tYXhsZW5ndGhdPVxcXCJtYXhsZW5ndGhcXFwiIFthdHRyLnRhYmluZGV4XT1cXFwidGFiaW5kZXhcXFwiIFthdHRyLnBsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbcmVhZG9ubHldPVxcXCJyZWFkb25seVxcXCJcXG4gICAgICAgICAgICAoa2V5ZG93bik9XFxcIm9uSW5wdXRLZXlkb3duKCRldmVudClcXFwiIChrZXl1cCk9XFxcIm9uSW5wdXQoJGV2ZW50LGluLnZhbHVlKVxcXCIgKGtleXByZXNzKT1cXFwib25JbnB1dEtleVByZXNzKCRldmVudClcXFwiIChibHVyKT1cXFwib25JbnB1dEJsdXIoJGV2ZW50KVxcXCIgKGNoYW5nZSk9XFxcImhhbmRsZUNoYW5nZSgkZXZlbnQpXFxcIiAoZm9jdXMpPVxcXCJvbkZvY3VzKClcXFwiPlxcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBbbmdDbGFzc109XFxcInsndWktc3Bpbm5lci1idXR0b24gdWktc3Bpbm5lci11cCB1aS1jb3JuZXItdHIgdWktYnV0dG9uIHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0Jzp0cnVlLCd1aS1zdGF0ZS1kaXNhYmxlZCc6ZGlzYWJsZWR9XFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgKG1vdXNlbGVhdmUpPVxcXCJvblVwQnV0dG9uTW91c2VsZWF2ZSgkZXZlbnQpXFxcIiAobW91c2Vkb3duKT1cXFwib25VcEJ1dHRvbk1vdXNlZG93bigkZXZlbnQsaW4pXFxcIiAobW91c2V1cCk9XFxcIm9uVXBCdXR0b25Nb3VzZXVwKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtY2FyZXQtdXAgdWktY2xpY2thYmxlXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1zcGlubmVyLWJ1dHRvbiB1aS1zcGlubmVyLWRvd24gdWktY29ybmVyLWJyIHVpLWJ1dHRvbiB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCc6dHJ1ZSwndWktc3RhdGUtZGlzYWJsZWQnOmRpc2FibGVkfVxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIChtb3VzZWxlYXZlKT1cXFwib25Eb3duQnV0dG9uTW91c2VsZWF2ZSgkZXZlbnQpXFxcIiAobW91c2Vkb3duKT1cXFwib25Eb3duQnV0dG9uTW91c2Vkb3duKCRldmVudCxpbilcXFwiIChtb3VzZXVwKT1cXFwib25Eb3duQnV0dG9uTW91c2V1cCgkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWNhcmV0LWRvd24gdWktY2xpY2thYmxlXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L3NwYW4+XFxuICAgIFwiLFxuICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAnW2NsYXNzLnVpLWlucHV0d3JhcHBlci1maWxsZWRdJzogJ2ZpbGxlZCcsXG4gICAgICAgICAgICAnW2NsYXNzLnVpLWlucHV0d3JhcHBlci1mb2N1c10nOiAnZm9jdXMnXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBleHBvcnRzLlNQSU5ORVJfVkFMVUVfQUNDRVNTT1JdLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIFNwaW5uZXIpO1xuZXhwb3J0cy5TcGlubmVyID0gU3Bpbm5lcjtcbnZhciBTcGlubmVyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGlubmVyTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gU3Bpbm5lck1vZHVsZTtcbn0oKSk7XG5TcGlubmVyTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgaW5wdXR0ZXh0XzEuSW5wdXRUZXh0TW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1NwaW5uZXJdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtTcGlubmVyXVxuICAgIH0pXG5dLCBTcGlubmVyTW9kdWxlKTtcbmV4cG9ydHMuU3Bpbm5lck1vZHVsZSA9IFNwaW5uZXJNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGlubmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBhbmltYXRpb25zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvYW5pbWF0aW9uc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIGJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL2J1dHRvbi9idXR0b25cIik7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvcm91dGVyXCIpO1xudmFyIHJvdXRlcl8yID0gcmVxdWlyZShcIkBhbmd1bGFyL3JvdXRlclwiKTtcbnZhciBTcGxpdEJ1dHRvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3BsaXRCdXR0b24oZWwsIGRvbUhhbmRsZXIsIHJlbmRlcmVyLCByb3V0ZXIsIGNkKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmljb25Qb3MgPSAnbGVmdCc7XG4gICAgICAgIHRoaXMub25DbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Ecm9wZG93bkNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5tZW51VmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBTcGxpdEJ1dHRvbi5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRUbykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8gPT09ICdib2R5JylcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheVZpZXdDaGlsZC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQsIHRoaXMuYXBwZW5kVG8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGxpdEJ1dHRvbi5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaG93bikge1xuICAgICAgICAgICAgdGhpcy5vblNob3coKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3BsaXRCdXR0b24ucHJvdG90eXBlLm9uRGVmYXVsdEJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMub25DbGljay5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIFNwbGl0QnV0dG9uLnByb3RvdHlwZS5pdGVtQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpdGVtLnVybCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5jb21tYW5kKSB7XG4gICAgICAgICAgICBpdGVtLmNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVudVZpc2libGUgPSBmYWxzZTtcbiAgICB9O1xuICAgIFNwbGl0QnV0dG9uLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNob3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tZW51VmlzaWJsZSA9ICF0aGlzLm1lbnVWaXNpYmxlO1xuICAgICAgICB0aGlzLmFsaWduUGFuZWwoKTtcbiAgICAgICAgdGhpcy5vdmVybGF5Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQuc3R5bGUuekluZGV4ID0gU3RyaW5nKCsrZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4KTtcbiAgICB9O1xuICAgIFNwbGl0QnV0dG9uLnByb3RvdHlwZS5vblNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWxpZ25QYW5lbCgpO1xuICAgICAgICB0aGlzLmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIFNwbGl0QnV0dG9uLnByb3RvdHlwZS5vbkRyb3Bkb3duQnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vbkRyb3Bkb3duQ2xpY2suZW1pdChldmVudCk7XG4gICAgICAgIHRoaXMuZHJvcGRvd25DbGljayA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH07XG4gICAgU3BsaXRCdXR0b24ucHJvdG90eXBlLmFsaWduUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKVxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24odGhpcy5vdmVybGF5Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQsIHRoaXMuYnV0dG9uVmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIucmVsYXRpdmVQb3NpdGlvbih0aGlzLm92ZXJsYXlWaWV3Q2hpbGQubmF0aXZlRWxlbWVudCwgdGhpcy5idXR0b25WaWV3Q2hpbGQubmF0aXZlRWxlbWVudCk7XG4gICAgfTtcbiAgICBTcGxpdEJ1dHRvbi5wcm90b3R5cGUuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRyb3Bkb3duQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHJvcGRvd25DbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWVudVZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGxpdEJ1dHRvbi5wcm90b3R5cGUudW5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNwbGl0QnV0dG9uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIHJldHVybiBTcGxpdEJ1dHRvbjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBTcGxpdEJ1dHRvbi5wcm90b3R5cGUsIFwibW9kZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTcGxpdEJ1dHRvbi5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwbGl0QnV0dG9uLnByb3RvdHlwZSwgXCJpY29uUG9zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3BsaXRCdXR0b24ucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBTcGxpdEJ1dHRvbi5wcm90b3R5cGUsIFwib25DbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU3BsaXRCdXR0b24ucHJvdG90eXBlLCBcIm9uRHJvcGRvd25DbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNwbGl0QnV0dG9uLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwbGl0QnV0dG9uLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU3BsaXRCdXR0b24ucHJvdG90eXBlLCBcIm1lbnVTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNwbGl0QnV0dG9uLnByb3RvdHlwZSwgXCJtZW51U3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTcGxpdEJ1dHRvbi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTcGxpdEJ1dHRvbi5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTcGxpdEJ1dHRvbi5wcm90b3R5cGUsIFwiYXBwZW5kVG9cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2RlZmF1bHRidG4nKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBTcGxpdEJ1dHRvbi5wcm90b3R5cGUsIFwiYnV0dG9uVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCdvdmVybGF5JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgU3BsaXRCdXR0b24ucHJvdG90eXBlLCBcIm92ZXJsYXlWaWV3Q2hpbGRcIiwgdm9pZCAwKTtcblNwbGl0QnV0dG9uID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC1zcGxpdEJ1dHRvbicsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiAjY29udGFpbmVyIFtuZ0NsYXNzXT1cXFwieyd1aS1zcGxpdGJ1dHRvbiB1aS1idXR0b25zZXQgdWktd2lkZ2V0Jzp0cnVlLCd1aS1zdGF0ZS1kaXNhYmxlZCc6ZGlzYWJsZWR9XFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8YnV0dG9uICNkZWZhdWx0YnRuIHR5cGU9XFxcImJ1dHRvblxcXCIgcEJ1dHRvbiBbaWNvbl09XFxcImljb25cXFwiIFtpY29uUG9zXT1cXFwiaWNvblBvc1xcXCIgW2xhYmVsXT1cXFwibGFiZWxcXFwiIGNvcm5lclN0eWxlQ2xhc3M9XFxcInVpLWNvcm5lci1sZWZ0XFxcIiAoY2xpY2spPVxcXCJvbkRlZmF1bHRCdXR0b25DbGljaygkZXZlbnQpXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW2F0dHIudGFiaW5kZXhdPVxcXCJ0YWJpbmRleFxcXCI+XFxuICAgICAgICAgICAgPC9idXR0b24+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHBCdXR0b24gY2xhc3M9XFxcInVpLXNwbGl0YnV0dG9uLW1lbnVidXR0b25cXFwiIGljb249XFxcImZhLWNhcmV0LWRvd25cXFwiIGNvcm5lclN0eWxlQ2xhc3M9XFxcInVpLWNvcm5lci1yaWdodFxcXCIgKGNsaWNrKT1cXFwib25Ecm9wZG93bkJ1dHRvbkNsaWNrKCRldmVudClcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICA8ZGl2ICNvdmVybGF5IFtuZ0NsYXNzXT1cXFwiJ3VpLW1lbnUgdWktbWVudS1keW5hbWljIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1zaGFkb3cnXFxcIiBbc3R5bGUuZGlzcGxheV09XFxcIm1lbnVWaXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJ1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cXFwibWVudVN0eWxlXFxcIiBbY2xhc3NdPVxcXCJtZW51U3R5bGVDbGFzc1xcXCIgW0BvdmVybGF5U3RhdGVdPVxcXCJtZW51VmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXFxcIj5cXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS1tZW51LWxpc3QgdWktaGVscGVyLXJlc2V0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktbWVudWl0ZW0gdWktd2lkZ2V0IHVpLWNvcm5lci1hbGxcXFwiIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiAqbmdGb3I9XFxcImxldCBpdGVtIG9mIG1vZGVsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiIWl0ZW0ucm91dGVyTGlua1xcXCIgW2hyZWZdPVxcXCJpdGVtLnVybHx8JyMnXFxcIiBjbGFzcz1cXFwidWktbWVudWl0ZW0tbGluayB1aS1jb3JuZXItYWxsXFxcIiBbYXR0ci50YXJnZXRdPVxcXCJpdGVtLnRhcmdldFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0YXRlLWRpc2FibGVkJzppdGVtLmRpc2FibGVkfVxcXCIgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgaXRlbSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbbmdDbGFzc109XFxcIid1aS1tZW51aXRlbS1pY29uIGZhIGZhLWZ3J1xcXCIgW2NsYXNzXT1cXFwiaXRlbS5pY29uXFxcIiAqbmdJZj1cXFwiaXRlbS5pY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS10ZXh0XFxcIj57e2l0ZW0ubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcIml0ZW0ucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtdPVxcXCJpdGVtLnJvdXRlckxpbmtcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1saW5rIHVpLWNvcm5lci1hbGxcXFwiIFthdHRyLnRhcmdldF09XFxcIml0ZW0udGFyZ2V0XFxcIiBbbmdDbGFzc109XFxcInsndWktc3RhdGUtZGlzYWJsZWQnOml0ZW0uZGlzYWJsZWR9XFxcIiAoY2xpY2spPVxcXCJpdGVtQ2xpY2soJGV2ZW50LCBpdGVtKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT1cXFwiJ3VpLW1lbnVpdGVtLWljb24gZmEgZmEtZncnXFxcIiBbY2xhc3NdPVxcXCJpdGVtLmljb25cXFwiICpuZ0lmPVxcXCJpdGVtLmljb25cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLXRleHRcXFwiPnt7aXRlbS5sYWJlbH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIGFuaW1hdGlvbnNfMS50cmlnZ2VyKCdvdmVybGF5U3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnN0YXRlKCdoaWRkZW4nLCBhbmltYXRpb25zXzEuc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5zdGF0ZSgndmlzaWJsZScsIGFuaW1hdGlvbnNfMS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyYW5zaXRpb24oJ3Zpc2libGUgPT4gaGlkZGVuJywgYW5pbWF0aW9uc18xLmFuaW1hdGUoJzQwMG1zIGVhc2UtaW4nKSksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnRyYW5zaXRpb24oJ2hpZGRlbiA9PiB2aXNpYmxlJywgYW5pbWF0aW9uc18xLmFuaW1hdGUoJzQwMG1zIGVhc2Utb3V0JykpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMiwgcm91dGVyXzEuUm91dGVyLCBjb3JlXzEuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgU3BsaXRCdXR0b24pO1xuZXhwb3J0cy5TcGxpdEJ1dHRvbiA9IFNwbGl0QnV0dG9uO1xudmFyIFNwbGl0QnV0dG9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGxpdEJ1dHRvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNwbGl0QnV0dG9uTW9kdWxlO1xufSgpKTtcblNwbGl0QnV0dG9uTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgYnV0dG9uXzEuQnV0dG9uTW9kdWxlLCByb3V0ZXJfMi5Sb3V0ZXJNb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbU3BsaXRCdXR0b24sIGJ1dHRvbl8xLkJ1dHRvbk1vZHVsZSwgcm91dGVyXzIuUm91dGVyTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbU3BsaXRCdXR0b25dXG4gICAgfSlcbl0sIFNwbGl0QnV0dG9uTW9kdWxlKTtcbmV4cG9ydHMuU3BsaXRCdXR0b25Nb2R1bGUgPSBTcGxpdEJ1dHRvbk1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwbGl0YnV0dG9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvc3BsaXRidXR0b24vc3BsaXRidXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9zcGxpdGJ1dHRvbi9zcGxpdGJ1dHRvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL3JvdXRlclwiKTtcbnZhciBTdGVwcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RlcHMoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleENoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIFN0ZXBzLnByb3RvdHlwZS5pdGVtQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGl0ZW0sIGkpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZG9ubHkgfHwgaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4Q2hhbmdlLmVtaXQoaSk7XG4gICAgICAgIGlmICghaXRlbS51cmwpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0uY29tbWFuZCkge1xuICAgICAgICAgICAgaXRlbS5jb21tYW5kKHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0ZXBzO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTdGVwcy5wcm90b3R5cGUsIFwiYWN0aXZlSW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFN0ZXBzLnByb3RvdHlwZSwgXCJtb2RlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTdGVwcy5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTdGVwcy5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTdGVwcy5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgU3RlcHMucHJvdG90eXBlLCBcImFjdGl2ZUluZGV4Q2hhbmdlXCIsIHZvaWQgMCk7XG5TdGVwcyA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3Atc3RlcHMnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJ7J3VpLXN0ZXBzIHVpLXdpZGdldCB1aS1oZWxwZXItY2xlYXJmaXgnOnRydWUsJ3VpLXN0ZXBzLXJlYWRvbmx5JzpyZWFkb25seX1cXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDx1bCByb2xlPVxcXCJ0YWJsaXN0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpICpuZ0Zvcj1cXFwibGV0IGl0ZW0gb2YgbW9kZWw7IGxldCBpID0gaW5kZXhcXFwiIGNsYXNzPVxcXCJ1aS1zdGVwcy1pdGVtXFxcIiAjbWVudWl0ZW1cXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1oaWdobGlnaHQnOihpID09PSBhY3RpdmVJbmRleCksJ3VpLXN0YXRlLWRlZmF1bHQnOihpICE9PSBhY3RpdmVJbmRleCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VpLXN0YXRlLWRpc2FibGVkJzppdGVtLmRpc2FibGVkfHwoaSAhPT0gYWN0aXZlSW5kZXggJiYgcmVhZG9ubHkpfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiIWl0ZW0ucm91dGVyTGlua1xcXCIgW2hyZWZdPVxcXCJpdGVtLnVybHx8JyMnXFxcIiBjbGFzcz1cXFwidWktbWVudWl0ZW0tbGlua1xcXCIgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgaXRlbSwgaSlcXFwiIFthdHRyLnRhcmdldF09XFxcIml0ZW0udGFyZ2V0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktc3RlcHMtbnVtYmVyXFxcIj57e2kgKyAxfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXN0ZXBzLXRpdGxlXFxcIj57e2l0ZW0ubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDxhICpuZ0lmPVxcXCJpdGVtLnJvdXRlckxpbmtcXFwiIFtyb3V0ZXJMaW5rXT1cXFwiaXRlbS5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIid1aS1zdGF0ZS1hY3RpdmUnXFxcIiBbcm91dGVyTGlua0FjdGl2ZU9wdGlvbnNdPVxcXCJpdGVtLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zfHx7ZXhhY3Q6ZmFsc2V9XFxcIiBjbGFzcz1cXFwidWktbWVudWl0ZW0tbGlua1xcXCIgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgaXRlbSwgaSlcXFwiIFthdHRyLnRhcmdldF09XFxcIml0ZW0udGFyZ2V0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktc3RlcHMtbnVtYmVyXFxcIj57e2kgKyAxfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXN0ZXBzLXRpdGxlXFxcIj57e2l0ZW0ubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiXG4gICAgfSlcbl0sIFN0ZXBzKTtcbmV4cG9ydHMuU3RlcHMgPSBTdGVwcztcbnZhciBTdGVwc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RlcHNNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBTdGVwc01vZHVsZTtcbn0oKSk7XG5TdGVwc01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIHJvdXRlcl8xLlJvdXRlck1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtTdGVwcywgcm91dGVyXzEuUm91dGVyTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbU3RlcHNdXG4gICAgfSlcbl0sIFN0ZXBzTW9kdWxlKTtcbmV4cG9ydHMuU3RlcHNNb2R1bGUgPSBTdGVwc01vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZXBzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvc3RlcHMvc3RlcHMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy9zdGVwcy9zdGVwcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbnZhciByb3V0ZXJfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9yb3V0ZXJcIik7XG52YXIgVGFiTWVudSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFiTWVudSgpIHtcbiAgICB9XG4gICAgVGFiTWVudS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVJdGVtICYmIHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IHRoaXMubW9kZWxbMF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYk1lbnUucHJvdG90eXBlLml0ZW1DbGljayA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWl0ZW0udXJsKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmNvbW1hbmQpIHtcbiAgICAgICAgICAgIGl0ZW0uY29tbWFuZCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gaXRlbTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJNZW51O1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFRhYk1lbnUucHJvdG90eXBlLCBcIm1vZGVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGFiTWVudS5wcm90b3R5cGUsIFwiYWN0aXZlSXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJNZW51LnByb3RvdHlwZSwgXCJwb3B1cFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRhYk1lbnUucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFiTWVudS5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuVGFiTWVudSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtdGFiTWVudScsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcIid1aS10YWJtZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsJ1xcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS10YWJtZW51LW5hdiB1aS1oZWxwZXItcmVzZXQgdWktaGVscGVyLWNsZWFyZml4IHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFxcXCIgcm9sZT1cXFwidGFibGlzdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSAqbmdGb3I9XFxcImxldCBpdGVtIG9mIG1vZGVsXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS10YWJtZW51aXRlbSB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci10b3AnOnRydWUsJ3VpLXN0YXRlLWRpc2FibGVkJzppdGVtLmRpc2FibGVkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1aS10YWJtZW51aXRlbS1oYXNpY29uJzppdGVtLmljb24sJ3VpLXN0YXRlLWFjdGl2ZSc6YWN0aXZlSXRlbT09aXRlbX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcIiFpdGVtLnJvdXRlckxpbmtcXFwiIFtocmVmXT1cXFwiaXRlbS51cmx8fCcjJ1xcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtLWxpbmsgdWktY29ybmVyLWFsbFxcXCIgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCxpdGVtKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50YXJnZXRdPVxcXCJpdGVtLnRhcmdldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLWljb24gZmFcXFwiIFtuZ0NsYXNzXT1cXFwiaXRlbS5pY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLXRleHRcXFwiPnt7aXRlbS5sYWJlbH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcIml0ZW0ucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtdPVxcXCJpdGVtLnJvdXRlckxpbmtcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiJ3VpLXN0YXRlLWFjdGl2ZSdcXFwiICBbcm91dGVyTGlua0FjdGl2ZU9wdGlvbnNdPVxcXCJpdGVtLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zfHx7ZXhhY3Q6ZmFsc2V9XFxcIiBjbGFzcz1cXFwidWktbWVudWl0ZW0tbGluayB1aS1jb3JuZXItYWxsXFxcIiAoY2xpY2spPVxcXCJpdGVtQ2xpY2soJGV2ZW50LGl0ZW0pXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLnRhcmdldF09XFxcIml0ZW0udGFyZ2V0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYVxcXCIgW25nQ2xhc3NdPVxcXCJpdGVtLmljb25cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0tdGV4dFxcXCI+e3tpdGVtLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZG9taGFuZGxlcl8xLkRvbUhhbmRsZXJdXG4gICAgfSlcbl0sIFRhYk1lbnUpO1xuZXhwb3J0cy5UYWJNZW51ID0gVGFiTWVudTtcbnZhciBUYWJNZW51TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJNZW51TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gVGFiTWVudU1vZHVsZTtcbn0oKSk7XG5UYWJNZW51TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgcm91dGVyXzEuUm91dGVyTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1RhYk1lbnUsIHJvdXRlcl8xLlJvdXRlck1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1RhYk1lbnVdXG4gICAgfSlcbl0sIFRhYk1lbnVNb2R1bGUpO1xuZXhwb3J0cy5UYWJNZW51TW9kdWxlID0gVGFiTWVudU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYm1lbnUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy90YWJtZW51L3RhYm1lbnUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ByaW1lbmcvY29tcG9uZW50cy90YWJtZW51L3RhYm1lbnUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBUYWJWaWV3TmF2ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJWaWV3TmF2KCkge1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3RvcCc7XG4gICAgICAgIHRoaXMub25UYWJDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25UYWJDbG9zZUNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgVGFiVmlld05hdi5wcm90b3R5cGUuZ2V0RGVmYXVsdEhlYWRlckNsYXNzID0gZnVuY3Rpb24gKHRhYikge1xuICAgICAgICB2YXIgc3R5bGVDbGFzcyA9ICd1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci0nICsgdGhpcy5vcmllbnRhdGlvbjtcbiAgICAgICAgaWYgKHRhYi5oZWFkZXJTdHlsZUNsYXNzKSB7XG4gICAgICAgICAgICBzdHlsZUNsYXNzID0gc3R5bGVDbGFzcyArIFwiIFwiICsgdGFiLmhlYWRlclN0eWxlQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlQ2xhc3M7XG4gICAgfTtcbiAgICBUYWJWaWV3TmF2LnByb3RvdHlwZS5jbGlja1RhYiA9IGZ1bmN0aW9uIChldmVudCwgdGFiKSB7XG4gICAgICAgIHRoaXMub25UYWJDbGljay5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgdGFiOiB0YWJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUYWJWaWV3TmF2LnByb3RvdHlwZS5jbGlja0Nsb3NlID0gZnVuY3Rpb24gKGV2ZW50LCB0YWIpIHtcbiAgICAgICAgdGhpcy5vblRhYkNsb3NlQ2xpY2suZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHRhYjogdGFiXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYlZpZXdOYXY7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgVGFiVmlld05hdi5wcm90b3R5cGUsIFwidGFic1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRhYlZpZXdOYXYucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBUYWJWaWV3TmF2LnByb3RvdHlwZSwgXCJvblRhYkNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBUYWJWaWV3TmF2LnByb3RvdHlwZSwgXCJvblRhYkNsb3NlQ2xpY2tcIiwgdm9pZCAwKTtcblRhYlZpZXdOYXYgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdbcC10YWJWaWV3TmF2XScsXG4gICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICdbY2xhc3MudWktdGFidmlldy1uYXZdJzogJ3RydWUnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS1oZWxwZXItcmVzZXRdJzogJ3RydWUnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS1oZWxwZXItY2xlYXJmaXhdJzogJ3RydWUnLFxuICAgICAgICAgICAgJ1tjbGFzcy51aS13aWRnZXQtaGVhZGVyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICdbY2xhc3MudWktY29ybmVyLWFsbF0nOiAndHJ1ZSdcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LXRhYiBbbmdGb3JPZl09XFxcInRhYnNcXFwiPlxcbiAgICAgICAgICAgIDxsaSBbY2xhc3NdPVxcXCJnZXREZWZhdWx0SGVhZGVyQ2xhc3ModGFiKVxcXCIgW25nU3R5bGVdPVxcXCJ0YWIuaGVhZGVyU3R5bGVcXFwiIHJvbGU9XFxcInRhYlxcXCJcXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXRhYnZpZXctc2VsZWN0ZWQgdWktc3RhdGUtYWN0aXZlJzogdGFiLnNlbGVjdGVkLCAndWktc3RhdGUtZGlzYWJsZWQnOiB0YWIuZGlzYWJsZWR9XFxcIlxcbiAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJjbGlja1RhYigkZXZlbnQsdGFiKVxcXCIgKm5nSWY9XFxcIiF0YWIuY2xvc2VkXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cXFwidGFiLnNlbGVjdGVkXFxcIiBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cXFwidGFiLnNlbGVjdGVkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktdGFidmlldy1sZWZ0LWljb24gZmFcXFwiIFtuZ0NsYXNzXT1cXFwidGFiLmxlZnRJY29uXFxcIiAqbmdJZj1cXFwidGFiLmxlZnRJY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktdGFidmlldy10aXRsZVxcXCI+e3t0YWIuaGVhZGVyfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktdGFidmlldy1yaWdodC1pY29uIGZhXFxcIiBbbmdDbGFzc109XFxcInRhYi5yaWdodEljb25cXFwiICpuZ0lmPVxcXCJ0YWIucmlnaHRJY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcInRhYi5jbG9zYWJsZVxcXCIgY2xhc3M9XFxcInVpLXRhYnZpZXctY2xvc2UgZmEgZmEtY2xvc2VcXFwiIChjbGljayk9XFxcImNsaWNrQ2xvc2UoJGV2ZW50LHRhYilcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgXCIsXG4gICAgfSlcbl0sIFRhYlZpZXdOYXYpO1xuZXhwb3J0cy5UYWJWaWV3TmF2ID0gVGFiVmlld05hdjtcbnZhciBUYWJQYW5lbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFiUGFuZWwoKSB7XG4gICAgfVxuICAgIHJldHVybiBUYWJQYW5lbDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFiUGFuZWwucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJQYW5lbC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGFiUGFuZWwucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRhYlBhbmVsLnByb3RvdHlwZSwgXCJjbG9zYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRhYlBhbmVsLnByb3RvdHlwZSwgXCJoZWFkZXJTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRhYlBhbmVsLnByb3RvdHlwZSwgXCJoZWFkZXJTdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFiUGFuZWwucHJvdG90eXBlLCBcImxlZnRJY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFiUGFuZWwucHJvdG90eXBlLCBcInJpZ2h0SWNvblwiLCB2b2lkIDApO1xuVGFiUGFuZWwgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLXRhYlBhbmVsJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10YWJ2aWV3LXBhbmVsIHVpLXdpZGdldC1jb250ZW50XFxcIiBbc3R5bGUuZGlzcGxheV09XFxcInNlbGVjdGVkID8gJ2Jsb2NrJyA6ICdub25lJ1xcXCIgXFxuICAgICAgICAgICAgcm9sZT1cXFwidGFicGFuZWxcXFwiIFthdHRyLmFyaWEtaGlkZGVuXT1cXFwiIXNlbGVjdGVkXFxcIiAqbmdJZj1cXFwiY2xvc2VkID8gZmFsc2UgOlxcdTAwQTAobGF6eSA/IHNlbGVjdGVkIDogdHJ1ZSlcXFwiPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIlxuICAgIH0pXG5dLCBUYWJQYW5lbCk7XG5leHBvcnRzLlRhYlBhbmVsID0gVGFiUGFuZWw7XG52YXIgVGFiVmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFiVmlldyhlbCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSAndG9wJztcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25DbG9zZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIFRhYlZpZXcucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbml0VGFicygpO1xuICAgICAgICB0aGlzLnRhYlBhbmVscy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgX3RoaXMuaW5pdFRhYnMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUYWJWaWV3LnByb3RvdHlwZS5pbml0VGFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50YWJzID0gdGhpcy50YWJQYW5lbHMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy50YWJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHRhYiA9IF9hW19pXTtcbiAgICAgICAgICAgIHRhYi5sYXp5ID0gdGhpcy5sYXp5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RlZFRhYiA9IHRoaXMuZmluZFNlbGVjdGVkVGFiKCk7XG4gICAgICAgIGlmICghc2VsZWN0ZWRUYWIgJiYgdGhpcy50YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggIT0gbnVsbCAmJiB0aGlzLnRhYnMubGVuZ3RoID4gdGhpcy5hY3RpdmVJbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLnRhYnNbdGhpcy5hY3RpdmVJbmRleF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMudGFic1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYlZpZXcucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQsIHRhYikge1xuICAgICAgICBpZiAodGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFiLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRUYWIgPSB0aGlzLmZpbmRTZWxlY3RlZFRhYigpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkVGFiKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRUYWIuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgaW5kZXg6IHRoaXMuZmluZFRhYkluZGV4KHRhYikgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJWaWV3LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChldmVudCwgdGFiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmZpbmRUYWJJbmRleCh0YWIpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlVGFiKHRhYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlVGFiKHRhYik7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZmluZFRhYkluZGV4KHRhYilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgVGFiVmlldy5wcm90b3R5cGUuY2xvc2VUYWIgPSBmdW5jdGlvbiAodGFiKSB7XG4gICAgICAgIGlmICh0YWIuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRhYi5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFiUGFuZWwgPSB0aGlzLnRhYnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWJQYW5lbC5jbG9zZWQgJiYgIXRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0YWJQYW5lbC5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YWIuY2xvc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRhYlZpZXcucHJvdG90eXBlLmZpbmRTZWxlY3RlZFRhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYnNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YWJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFiVmlldy5wcm90b3R5cGUuZmluZFRhYkluZGV4ID0gZnVuY3Rpb24gKHRhYikge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYnNbaV0gPT0gdGFiKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIFRhYlZpZXcucHJvdG90eXBlLmdldEJsb2NrYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiVmlldy5wcm90b3R5cGUsIFwiYWN0aXZlSW5kZXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVJbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVJbmRleCA9IHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYnMgJiYgdGhpcy50YWJzLmxlbmd0aCAmJiB0aGlzLl9hY3RpdmVJbmRleCAhPSBudWxsICYmIHRoaXMudGFicy5sZW5ndGggPiB0aGlzLl9hY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZFNlbGVjdGVkVGFiKCkuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYnNbdGhpcy5fYWN0aXZlSW5kZXhdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYlZpZXc7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRhYlZpZXcucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGFiVmlldy5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUYWJWaWV3LnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRhYlZpZXcucHJvdG90eXBlLCBcImNvbnRyb2xDbG9zZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUYWJWaWV3LnByb3RvdHlwZSwgXCJsYXp5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29udGVudENoaWxkcmVuKFRhYlBhbmVsKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlF1ZXJ5TGlzdClcbl0sIFRhYlZpZXcucHJvdG90eXBlLCBcInRhYlBhbmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgVGFiVmlldy5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFRhYlZpZXcucHJvdG90eXBlLCBcIm9uQ2xvc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIFRhYlZpZXcucHJvdG90eXBlLCBcImFjdGl2ZUluZGV4XCIsIG51bGwpO1xuVGFiVmlldyA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtdGFiVmlldycsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcIid1aS10YWJ2aWV3IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLXRhYnZpZXctJyArIG9yaWVudGF0aW9uXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8dWwgcC10YWJWaWV3TmF2IHJvbGU9XFxcInRhYmxpc3RcXFwiICpuZ0lmPVxcXCJvcmllbnRhdGlvbiE9J2JvdHRvbSdcXFwiIFt0YWJzXT1cXFwidGFic1xcXCIgW29yaWVudGF0aW9uXT1cXFwib3JpZW50YXRpb25cXFwiIFxcbiAgICAgICAgICAgICAgICAob25UYWJDbGljayk9XFxcIm9wZW4oJGV2ZW50Lm9yaWdpbmFsRXZlbnQsICRldmVudC50YWIpXFxcIiAob25UYWJDbG9zZUNsaWNrKT1cXFwiY2xvc2UoJGV2ZW50Lm9yaWdpbmFsRXZlbnQsICRldmVudC50YWIpXFxcIj48L3VsPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRhYnZpZXctcGFuZWxzXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDx1bCBwLXRhYlZpZXdOYXYgcm9sZT1cXFwidGFibGlzdFxcXCIgKm5nSWY9XFxcIm9yaWVudGF0aW9uPT0nYm90dG9tJ1xcXCIgW3RhYnNdPVxcXCJ0YWJzXFxcIiBbb3JpZW50YXRpb25dPVxcXCJvcmllbnRhdGlvblxcXCJcXG4gICAgICAgICAgICAgICAgKG9uVGFiQ2xpY2spPVxcXCJvcGVuKCRldmVudC5vcmlnaW5hbEV2ZW50LCAkZXZlbnQudGFiKVxcXCIgKG9uVGFiQ2xvc2VDbGljayk9XFxcImNsb3NlKCRldmVudC5vcmlnaW5hbEV2ZW50LCAkZXZlbnQudGFiKVxcXCI+PC91bD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmXSlcbl0sIFRhYlZpZXcpO1xuZXhwb3J0cy5UYWJWaWV3ID0gVGFiVmlldztcbnZhciBUYWJWaWV3TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJWaWV3TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gVGFiVmlld01vZHVsZTtcbn0oKSk7XG5UYWJWaWV3TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtUYWJWaWV3LCBUYWJQYW5lbCwgVGFiVmlld05hdl0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1RhYlZpZXcsIFRhYlBhbmVsLCBUYWJWaWV3TmF2XVxuICAgIH0pXG5dLCBUYWJWaWV3TW9kdWxlKTtcbmV4cG9ydHMuVGFiVmlld01vZHVsZSA9IFRhYlZpZXdNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJ2aWV3LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvdGFidmlldy90YWJ2aWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvdGFidmlldy90YWJ2aWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBmb3Jtc18xID0gcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbWhhbmRsZXJcIik7XG52YXIgVGVybWluYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsKGVsLCBkb21IYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5yZXNwb25zZUNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB9XG4gICAgVGVybWluYWwucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmRvbUhhbmRsZXIuZmluZCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICcudWktdGVybWluYWwnKVswXTtcbiAgICB9O1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbW1hbmRQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMuY29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZFByb2Nlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVybWluYWwucHJvdG90eXBlLCBcInJlc3BvbnNlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHNbdGhpcy5jb21tYW5kcy5sZW5ndGggLSAxXS5yZXNwb25zZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZFByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5oYW5kbGVDb21tYW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goeyB0ZXh0OiB0aGlzLmNvbW1hbmQgfSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBjb21tYW5kOiB0aGlzLmNvbW1hbmQgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmQgPSAnJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVybWluYWwucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlcm1pbmFsO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXJtaW5hbC5wcm90b3R5cGUsIFwid2VsY29tZU1lc3NhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUZXJtaW5hbC5wcm90b3R5cGUsIFwicHJvbXB0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGVybWluYWwucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGVybWluYWwucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFRlcm1pbmFsLnByb3RvdHlwZSwgXCJyZXNwb25zZUNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgVGVybWluYWwucHJvdG90eXBlLCBcImhhbmRsZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFRlcm1pbmFsLnByb3RvdHlwZSwgXCJyZXNwb25zZVwiLCBudWxsKTtcblRlcm1pbmFsID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC10ZXJtaW5hbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcIid1aS10ZXJtaW5hbCB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCdcXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIChjbGljayk9XFxcImZvY3VzKGluKVxcXCI+XFxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cXFwid2VsY29tZU1lc3NhZ2VcXFwiPnt7d2VsY29tZU1lc3NhZ2V9fTwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRlcm1pbmFsLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IGNvbW1hbmQgb2YgY29tbWFuZHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3twcm9tcHR9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS10ZXJtaW5hbC1jb21tYW5kXFxcIj57e2NvbW1hbmQudGV4dH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdj57e2NvbW1hbmQucmVzcG9uc2V9fTwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktdGVybWluYWwtY29udGVudC1wcm9tcHRcXFwiPnt7cHJvbXB0fX08L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCAjaW4gdHlwZT1cXFwidGV4dFxcXCIgWyhuZ01vZGVsKV09XFxcImNvbW1hbmRcXFwiIGNsYXNzPVxcXCJ1aS10ZXJtaW5hbC1pbnB1dFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIChrZXlkb3duKT1cXFwiaGFuZGxlQ29tbWFuZCgkZXZlbnQpXFxcIiBhdXRvZm9jdXM+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIFRlcm1pbmFsKTtcbmV4cG9ydHMuVGVybWluYWwgPSBUZXJtaW5hbDtcbnZhciBUZXJtaW5hbE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVybWluYWxNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBUZXJtaW5hbE1vZHVsZTtcbn0oKSk7XG5UZXJtaW5hbE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIGZvcm1zXzEuRm9ybXNNb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbVGVybWluYWxdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtUZXJtaW5hbF1cbiAgICB9KVxuXSwgVGVybWluYWxNb2R1bGUpO1xuZXhwb3J0cy5UZXJtaW5hbE1vZHVsZSA9IFRlcm1pbmFsTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVybWluYWwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy90ZXJtaW5hbC90ZXJtaW5hbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3Rlcm1pbmFsL3Rlcm1pbmFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL3JvdXRlclwiKTtcbnZhciBUaWVyZWRNZW51U3ViID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaWVyZWRNZW51U3ViKGRvbUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICB9XG4gICAgVGllcmVkTWVudVN1Yi5wcm90b3R5cGUub25JdGVtTW91c2VFbnRlciA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSwgbWVudWl0ZW0pIHtcbiAgICAgICAgaWYgKG1lbnVpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gaXRlbTtcbiAgICAgICAgdmFyIG5leHRFbGVtZW50ID0gaXRlbS5jaGlsZHJlblswXS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGlmIChuZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHN1Ymxpc3QgPSBuZXh0RWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHN1Ymxpc3Quc3R5bGUuekluZGV4ID0gU3RyaW5nKCsrZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4KTtcbiAgICAgICAgICAgIHN1Ymxpc3Quc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICBzdWJsaXN0LnN0eWxlLmxlZnQgPSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aChpdGVtLmNoaWxkcmVuWzBdKSArICdweCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpZXJlZE1lbnVTdWIucHJvdG90eXBlLm9uSXRlbU1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gbnVsbDtcbiAgICB9O1xuICAgIFRpZXJlZE1lbnVTdWIucHJvdG90eXBlLml0ZW1DbGljayA9IGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXRlbS51cmwpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0uY29tbWFuZCkge1xuICAgICAgICAgICAgaXRlbS5jb21tYW5kKHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGllcmVkTWVudVN1Yi5wcm90b3R5cGUubGlzdENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVGllcmVkTWVudVN1Yjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGllcmVkTWVudVN1Yi5wcm90b3R5cGUsIFwiaXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaWVyZWRNZW51U3ViLnByb3RvdHlwZSwgXCJyb290XCIsIHZvaWQgMCk7XG5UaWVyZWRNZW51U3ViID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC10aWVyZWRNZW51U3ViJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8dWwgW25nQ2xhc3NdPVxcXCJ7J3VpLWhlbHBlci1yZXNldCc6cm9vdCwgJ3VpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktaGVscGVyLWNsZWFyZml4IHVpLW1lbnUtY2hpbGQgdWktc2hhZG93Jzohcm9vdH1cXFwiIGNsYXNzPVxcXCJ1aS1tZW51LWxpc3RcXFwiXFxuICAgICAgICAgICAgKGNsaWNrKT1cXFwibGlzdENsaWNrKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY2hpbGQgW25nRm9yT2ZdPVxcXCIocm9vdCA/IGl0ZW0gOiBpdGVtLml0ZW1zKVxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSAqbmdJZj1cXFwiY2hpbGQuc2VwYXJhdG9yXFxcIiBjbGFzcz1cXFwidWktbWVudS1zZXBhcmF0b3IgdWktd2lkZ2V0LWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGkgKm5nSWY9XFxcIiFjaGlsZC5zZXBhcmF0b3JcXFwiICNsaXN0SXRlbSBbbmdDbGFzc109XFxcInsndWktbWVudWl0ZW0gdWktd2lkZ2V0IHVpLWNvcm5lci1hbGwnOnRydWUsJ3VpLW1lbnUtcGFyZW50JzpjaGlsZC5pdGVtcywndWktbWVudWl0ZW0tYWN0aXZlJzpsaXN0SXRlbT09YWN0aXZlSXRlbX1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAobW91c2VlbnRlcik9XFxcIm9uSXRlbU1vdXNlRW50ZXIoJGV2ZW50LCBsaXN0SXRlbSwgY2hpbGQpXFxcIiAobW91c2VsZWF2ZSk9XFxcIm9uSXRlbU1vdXNlTGVhdmUoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiIWNoaWxkLnJvdXRlckxpbmtcXFwiIFtocmVmXT1cXFwiY2hpbGQudXJsfHwnIydcXFwiIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1saW5rIHVpLWNvcm5lci1hbGxcXFwiIFthdHRyLnRhcmdldF09XFxcImNoaWxkLnRhcmdldFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtZGlzYWJsZWQnOmNoaWxkLmRpc2FibGVkfVxcXCIgKGNsaWNrKT1cXFwiaXRlbUNsaWNrKCRldmVudCwgY2hpbGQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktc3VibWVudS1pY29uIGZhIGZhLWZ3IGZhLWNhcmV0LXJpZ2h0XFxcIiAqbmdJZj1cXFwiY2hpbGQuaXRlbXNcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktbWVudWl0ZW0taWNvbiBmYSBmYS1md1xcXCIgKm5nSWY9XFxcImNoaWxkLmljb25cXFwiIFtuZ0NsYXNzXT1cXFwiY2hpbGQuaWNvblxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS10ZXh0XFxcIj57e2NoaWxkLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8YSAqbmdJZj1cXFwiY2hpbGQucm91dGVyTGlua1xcXCIgW3JvdXRlckxpbmtdPVxcXCJjaGlsZC5yb3V0ZXJMaW5rXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIid1aS1zdGF0ZS1hY3RpdmUnXFxcIiBbcm91dGVyTGlua0FjdGl2ZU9wdGlvbnNdPVxcXCJjaGlsZC5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc3x8e2V4YWN0OmZhbHNlfVxcXCIgW2hyZWZdPVxcXCJjaGlsZC51cmx8fCcjJ1xcXCIgY2xhc3M9XFxcInVpLW1lbnVpdGVtLWxpbmsgdWktY29ybmVyLWFsbFxcXCIgW2F0dHIudGFyZ2V0XT1cXFwiY2hpbGQudGFyZ2V0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1kaXNhYmxlZCc6Y2hpbGQuZGlzYWJsZWR9XFxcIiAoY2xpY2spPVxcXCJpdGVtQ2xpY2soJGV2ZW50LCBjaGlsZClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1zdWJtZW51LWljb24gZmEgZmEtZncgZmEtY2FyZXQtcmlnaHRcXFwiICpuZ0lmPVxcXCJjaGlsZC5pdGVtc1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1tZW51aXRlbS1pY29uIGZhIGZhLWZ3XFxcIiAqbmdJZj1cXFwiY2hpbGQuaWNvblxcXCIgW25nQ2xhc3NdPVxcXCJjaGlsZC5pY29uXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLW1lbnVpdGVtLXRleHRcXFwiPnt7Y2hpbGQubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDxwLXRpZXJlZE1lbnVTdWIgY2xhc3M9XFxcInVpLXN1Ym1lbnVcXFwiIFtpdGVtXT1cXFwiY2hpbGRcXFwiICpuZ0lmPVxcXCJjaGlsZC5pdGVtc1xcXCI+PC9wLXRpZXJlZE1lbnVTdWI+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgIDwvdWw+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXSlcbl0sIFRpZXJlZE1lbnVTdWIpO1xuZXhwb3J0cy5UaWVyZWRNZW51U3ViID0gVGllcmVkTWVudVN1YjtcbnZhciBUaWVyZWRNZW51ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaWVyZWRNZW51KGVsLCBkb21IYW5kbGVyLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGRvbUhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG4gICAgVGllcmVkTWVudS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKHRoaXMucG9wdXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG8gPT09ICdib2R5JylcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIsIHRoaXMuYXBwZW5kVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUaWVyZWRNZW51LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLm9mZnNldFBhcmVudClcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNob3coZXZlbnQpO1xuICAgIH07XG4gICAgVGllcmVkTWVudS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnByZXZlbnREb2N1bWVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24odGhpcy5jb250YWluZXIsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIuZmFkZUluKHRoaXMuY29udGFpbmVyLCAyNTApO1xuICAgICAgICB0aGlzLmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIFRpZXJlZE1lbnUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMudW5iaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgfTtcbiAgICBUaWVyZWRNZW51LnByb3RvdHlwZS51bmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGllcmVkTWVudS5wcm90b3R5cGUuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wcmV2ZW50RG9jdW1lbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucHJldmVudERvY3VtZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpZXJlZE1lbnUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cCAmJiB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy51bmJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRpZXJlZE1lbnU7XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgVGllcmVkTWVudS5wcm90b3R5cGUsIFwibW9kZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVGllcmVkTWVudS5wcm90b3R5cGUsIFwicG9wdXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUaWVyZWRNZW51LnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpZXJlZE1lbnUucHJvdG90eXBlLCBcInN0eWxlQ2xhc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUaWVyZWRNZW51LnByb3RvdHlwZSwgXCJhcHBlbmRUb1wiLCB2b2lkIDApO1xuVGllcmVkTWVudSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtdGllcmVkTWVudScsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcInsndWktdGllcmVkbWVudSB1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLWhlbHBlci1jbGVhcmZpeCc6dHJ1ZSwndWktbWVudS1keW5hbWljIHVpLXNoYWRvdyc6cG9wdXB9XFxcIiBcXG4gICAgICAgICAgICBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIj5cXG4gICAgICAgICAgICA8cC10aWVyZWRNZW51U3ViIFtpdGVtXT1cXFwibW9kZWxcXFwiIHJvb3Q9XFxcInJvb3RcXFwiPjwvcC10aWVyZWRNZW51U3ViPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtkb21oYW5kbGVyXzEuRG9tSGFuZGxlcl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLCBkb21oYW5kbGVyXzEuRG9tSGFuZGxlciwgY29yZV8xLlJlbmRlcmVyMl0pXG5dLCBUaWVyZWRNZW51KTtcbmV4cG9ydHMuVGllcmVkTWVudSA9IFRpZXJlZE1lbnU7XG52YXIgVGllcmVkTWVudU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGllcmVkTWVudU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFRpZXJlZE1lbnVNb2R1bGU7XG59KCkpO1xuVGllcmVkTWVudU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIHJvdXRlcl8xLlJvdXRlck1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtUaWVyZWRNZW51LCByb3V0ZXJfMS5Sb3V0ZXJNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtUaWVyZWRNZW51LCBUaWVyZWRNZW51U3ViXVxuICAgIH0pXG5dLCBUaWVyZWRNZW51TW9kdWxlKTtcbmV4cG9ydHMuVGllcmVkTWVudU1vZHVsZSA9IFRpZXJlZE1lbnVNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWVyZWRtZW51LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvdGllcmVkbWVudS90aWVyZWRtZW51LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvdGllcmVkbWVudS90aWVyZWRtZW51LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZm9ybXNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKTtcbmV4cG9ydHMuVE9HR0xFQlVUVE9OX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IGZvcm1zXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFRvZ2dsZUJ1dHRvbjsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgVG9nZ2xlQnV0dG9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2dnbGVCdXR0b24oKSB7XG4gICAgICAgIHRoaXMub25MYWJlbCA9ICdZZXMnO1xuICAgICAgICB0aGlzLm9mZkxhYmVsID0gJ05vJztcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgVG9nZ2xlQnV0dG9uLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tib3ggPSB0aGlzLmNoZWNrYm94Vmlld0NoaWxkLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfTtcbiAgICBUb2dnbGVCdXR0b24ucHJvdG90eXBlLmdldEljb25DbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2VDbGFzcyA9ICd1aS1idXR0b24taWNvbi1sZWZ0IGZhIGZhLWZ3JztcbiAgICAgICAgcmV0dXJuIGJhc2VDbGFzcyArICcgJyArICh0aGlzLmNoZWNrZWQgPyB0aGlzLm9uSWNvbiA6IHRoaXMub2ZmSWNvbik7XG4gICAgfTtcbiAgICBUb2dnbGVCdXR0b24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy5jaGVja2VkKTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogdGhpcy5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tib3guZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9nZ2xlQnV0dG9uLnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUub25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQoKTtcbiAgICB9O1xuICAgIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgVG9nZ2xlQnV0dG9uLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdmFsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwiaGFzT25MYWJlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25MYWJlbCAmJiB0aGlzLm9uTGFiZWwubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwiaGFzT2ZmTGFiZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uTGFiZWwgJiYgdGhpcy5vbkxhYmVsLmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUb2dnbGVCdXR0b247XG59KCkpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwib25MYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwib2ZmTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb2dnbGVCdXR0b24ucHJvdG90eXBlLCBcIm9uSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwib2ZmSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUb2dnbGVCdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVG9nZ2xlQnV0dG9uLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwidGFiaW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFRvZ2dsZUJ1dHRvbi5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5WaWV3Q2hpbGQoJ2NoZWNrYm94JyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FbGVtZW50UmVmKVxuXSwgVG9nZ2xlQnV0dG9uLnByb3RvdHlwZSwgXCJjaGVja2JveFZpZXdDaGlsZFwiLCB2b2lkIDApO1xuVG9nZ2xlQnV0dG9uID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC10b2dnbGVCdXR0b24nLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJ7J3VpLWJ1dHRvbiB1aS10b2dnbGVidXR0b24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCc6IHRydWUsICd1aS1idXR0b24tdGV4dC1vbmx5JzogKCFvbkljb24mJiFvZmZJY29uKSwgXFxuICAgICAgICAgICAgICAgICd1aS1idXR0b24tdGV4dC1pY29uLWxlZnQnOiAob25JY29uJiZvZmZJY29uJiZoYXNPbkxhYmVsJiZoYXNPZmZMYWJlbCksICd1aS1idXR0b24taWNvbi1vbmx5JzogKG9uSWNvbiYmb2ZmSWNvbiYmIWhhc09uTGFiZWwmJiFoYXNPZmZMYWJlbCksXFxuICAgICAgICAgICAgICAgICd1aS1zdGF0ZS1hY3RpdmUnOiBjaGVja2VkLCd1aS1zdGF0ZS1mb2N1cyc6Zm9jdXMsJ3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZH1cXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiIFxcbiAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJ0b2dnbGUoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0ICNjaGVja2JveCB0eXBlPVxcXCJjaGVja2JveFxcXCIgW2F0dHIuaWRdPVxcXCJpbnB1dElkXFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIChmb2N1cyk9XFxcIm9uRm9jdXMoKVxcXCIgKGJsdXIpPVxcXCJvbkJsdXIoKVxcXCIgW2F0dHIudGFiaW5kZXhdPVxcXCJ0YWJpbmRleFxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcIm9uSWNvbnx8b2ZmSWNvblxcXCIgW2NsYXNzXT1cXFwiZ2V0SWNvbkNsYXNzKClcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktYnV0dG9uLXRleHQgdWktdW5zZWxlY3RhYmxlLXRleHRcXFwiPnt7Y2hlY2tlZCA/IGhhc09uTGFiZWwgPyBvbkxhYmVsIDogJ3VpLWJ0bicgOiBoYXNPZmZMYWJlbCA/IG9mZkxhYmVsIDogJ3VpLWJ0bid9fTwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcbiAgICAgICAgcHJvdmlkZXJzOiBbZXhwb3J0cy5UT0dHTEVCVVRUT05fVkFMVUVfQUNDRVNTT1JdXG4gICAgfSlcbl0sIFRvZ2dsZUJ1dHRvbik7XG5leHBvcnRzLlRvZ2dsZUJ1dHRvbiA9IFRvZ2dsZUJ1dHRvbjtcbnZhciBUb2dnbGVCdXR0b25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvZ2dsZUJ1dHRvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFRvZ2dsZUJ1dHRvbk1vZHVsZTtcbn0oKSk7XG5Ub2dnbGVCdXR0b25Nb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1RvZ2dsZUJ1dHRvbl0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1RvZ2dsZUJ1dHRvbl1cbiAgICB9KVxuXSwgVG9nZ2xlQnV0dG9uTW9kdWxlKTtcbmV4cG9ydHMuVG9nZ2xlQnV0dG9uTW9kdWxlID0gVG9nZ2xlQnV0dG9uTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9nZ2xlYnV0dG9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvdG9nZ2xlYnV0dG9uL3RvZ2dsZWJ1dHRvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3RvZ2dsZWJ1dHRvbi90b2dnbGVidXR0b24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvbW1vblwiKTtcbnZhciBUb29sYmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sYmFyKCkge1xuICAgIH1cbiAgICByZXR1cm4gVG9vbGJhcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVG9vbGJhci5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sYmFyLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5Ub29sYmFyID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC10b29sYmFyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwiJ3VpLXRvb2xiYXIgdWktd2lkZ2V0IHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXgnXFxcIiBbbmdTdHlsZV09XFxcInN0eWxlXFxcIiBbY2xhc3NdPVxcXCJzdHlsZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCJcbiAgICB9KVxuXSwgVG9vbGJhcik7XG5leHBvcnRzLlRvb2xiYXIgPSBUb29sYmFyO1xudmFyIFRvb2xiYXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBUb29sYmFyTW9kdWxlO1xufSgpKTtcblRvb2xiYXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1Rvb2xiYXJdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtUb29sYmFyXVxuICAgIH0pXG5dLCBUb29sYmFyTW9kdWxlKTtcbmV4cG9ydHMuVG9vbGJhck1vZHVsZSA9IFRvb2xiYXJNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b29sYmFyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvdG9vbGJhci90b29sYmFyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvdG9vbGJhci90b29sYmFyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21oYW5kbGVyXCIpO1xudmFyIFRvb2x0aXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvb2x0aXAoZWwsIGRvbUhhbmRsZXIsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kb21IYW5kbGVyID0gZG9tSGFuZGxlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnRvb2x0aXBQb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIHRoaXMudG9vbHRpcEV2ZW50ID0gJ2hvdmVyJztcbiAgICAgICAgdGhpcy5hcHBlbmRUbyA9ICdib2R5JztcbiAgICAgICAgdGhpcy5lc2NhcGUgPSB0cnVlO1xuICAgIH1cbiAgICBUb29sdGlwLnByb3RvdHlwZS5vbk1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy50b29sdGlwRXZlbnQgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMudG9vbHRpcEV2ZW50ID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXBFdmVudCA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy50b29sdGlwRXZlbnQgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5oaWRlVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3dEZWxheSlcbiAgICAgICAgICAgIHRoaXMuc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgX3RoaXMuc2hvdygpOyB9LCB0aGlzLnNob3dEZWxheSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWRlRGVsYXkpXG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IF90aGlzLmhpZGUoKTsgfSwgdGhpcy5oaWRlRGVsYXkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb29sdGlwLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIub2Zmc2V0UGFyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciB0b29sdGlwQXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9vbHRpcEFycm93LmNsYXNzTmFtZSA9ICd1aS10b29sdGlwLWFycm93JztcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodG9vbHRpcEFycm93KTtcbiAgICAgICAgdGhpcy50b29sdGlwVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRvb2x0aXBUZXh0LmNsYXNzTmFtZSA9ICd1aS10b29sdGlwLXRleHQgdWktc2hhZG93IHVpLWNvcm5lci1hbGwnO1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25TdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uU3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwVGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFRvID09PSAnYm9keScpXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcHBlbmRUbyA9PT0gJ3RhcmdldCcpXG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIsIHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lciwgdGhpcy5hcHBlbmRUbyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0IHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLmFsaWduKCk7XG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXBTdHlsZUNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgKyAnICcgKyB0aGlzLnRvb2x0aXBTdHlsZUNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tSGFuZGxlci5mYWRlSW4odGhpcy5jb250YWluZXIsIDI1MCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCA9ICsrZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIuemluZGV4O1xuICAgICAgICB0aGlzLmJpbmREb2N1bWVudFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnVwZGF0ZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVzY2FwZSkge1xuICAgICAgICAgICAgdGhpcy50b29sdGlwVGV4dC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcFRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5fdGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b29sdGlwVGV4dC5pbm5lckhUTUwgPSB0aGlzLl90ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5hbGlnbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy50b29sdGlwUG9zaXRpb247XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgdGhpcy5hbGlnblRvcCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3V0T2ZCb3VuZHMoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaWduQm90dG9tKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB0aGlzLmFsaWduQm90dG9tKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPdXRPZkJvdW5kcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25Ub3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICB0aGlzLmFsaWduTGVmdCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3V0T2ZCb3VuZHMoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaWduUmlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPdXRPZkJvdW5kcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaWduVG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc091dE9mQm91bmRzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaWduQm90dG9tKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgdGhpcy5hbGlnblJpZ2h0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPdXRPZkJvdW5kcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25MZWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3V0T2ZCb3VuZHMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGlnblRvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPdXRPZkJvdW5kcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGlnbkJvdHRvbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5nZXRIb3N0T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgdGFyZ2V0TGVmdCA9IG9mZnNldC5sZWZ0ICsgdGhpcy5kb21IYW5kbGVyLmdldFdpbmRvd1Njcm9sbExlZnQoKTtcbiAgICAgICAgdmFyIHRhcmdldFRvcCA9IG9mZnNldC50b3AgKyB0aGlzLmRvbUhhbmRsZXIuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIHJldHVybiB7IGxlZnQ6IHRhcmdldExlZnQsIHRvcDogdGFyZ2V0VG9wIH07XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5hbGlnblJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByZUFsaWduKCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9ICd1aS10b29sdGlwIHVpLXdpZGdldCB1aS10b29sdGlwLXJpZ2h0JztcbiAgICAgICAgdmFyIGhvc3RPZmZzZXQgPSB0aGlzLmdldEhvc3RPZmZzZXQoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBob3N0T2Zmc2V0LmxlZnQgKyB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB2YXIgdG9wID0gaG9zdE9mZnNldC50b3AgKyAodGhpcy5kb21IYW5kbGVyLmdldE91dGVySGVpZ2h0KHRoaXMuZWwubmF0aXZlRWxlbWVudCkgLSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJIZWlnaHQodGhpcy5jb250YWluZXIpKSAvIDI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmFsaWduTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcmVBbGlnbigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSAndWktdG9vbHRpcCB1aS13aWRnZXQgdWktdG9vbHRpcC1sZWZ0JztcbiAgICAgICAgdmFyIGhvc3RPZmZzZXQgPSB0aGlzLmdldEhvc3RPZmZzZXQoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBob3N0T2Zmc2V0LmxlZnQgLSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHZhciB0b3AgPSBob3N0T2Zmc2V0LnRvcCArICh0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJIZWlnaHQodGhpcy5lbC5uYXRpdmVFbGVtZW50KSAtIHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlckhlaWdodCh0aGlzLmNvbnRhaW5lcikpIC8gMjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuYWxpZ25Ub3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJlQWxpZ24oKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gJ3VpLXRvb2x0aXAgdWktd2lkZ2V0IHVpLXRvb2x0aXAtdG9wJztcbiAgICAgICAgdmFyIGhvc3RPZmZzZXQgPSB0aGlzLmdldEhvc3RPZmZzZXQoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBob3N0T2Zmc2V0LmxlZnQgKyAodGhpcy5kb21IYW5kbGVyLmdldE91dGVyV2lkdGgodGhpcy5lbC5uYXRpdmVFbGVtZW50KSAtIHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlcldpZHRoKHRoaXMuY29udGFpbmVyKSkgLyAyO1xuICAgICAgICB2YXIgdG9wID0gaG9zdE9mZnNldC50b3AgLSB0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJIZWlnaHQodGhpcy5jb250YWluZXIpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5hbGlnbkJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcmVBbGlnbigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSAndWktdG9vbHRpcCB1aS13aWRnZXQgdWktdG9vbHRpcC1ib3R0b20nO1xuICAgICAgICB2YXIgaG9zdE9mZnNldCA9IHRoaXMuZ2V0SG9zdE9mZnNldCgpO1xuICAgICAgICB2YXIgbGVmdCA9IGhvc3RPZmZzZXQubGVmdCArICh0aGlzLmRvbUhhbmRsZXIuZ2V0T3V0ZXJXaWR0aCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpIC0gdGhpcy5kb21IYW5kbGVyLmdldE91dGVyV2lkdGgodGhpcy5jb250YWluZXIpKSAvIDI7XG4gICAgICAgIHZhciB0b3AgPSBob3N0T2Zmc2V0LnRvcCArIHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlckhlaWdodCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5wcmVBbGlnbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUubGVmdCA9IC05OTkgKyAncHgnO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS50b3AgPSAtOTk5ICsgJ3B4JztcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmlzT3V0T2ZCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHRhcmdldFRvcCA9IG9mZnNldC50b3A7XG4gICAgICAgIHZhciB0YXJnZXRMZWZ0ID0gb2Zmc2V0LmxlZnQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlcldpZHRoKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZG9tSGFuZGxlci5nZXRPdXRlckhlaWdodCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuZG9tSGFuZGxlci5nZXRWaWV3cG9ydCgpO1xuICAgICAgICByZXR1cm4gKHRhcmdldExlZnQgKyB3aWR0aCA+IHZpZXdwb3J0LndpZHRoKSB8fCAodGFyZ2V0TGVmdCA8IDApIHx8ICh0YXJnZXRUb3AgPCAwKSB8fCAodGFyZ2V0VG9wICsgaGVpZ2h0ID4gdmlld3BvcnQuaGVpZ2h0KTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmJpbmREb2N1bWVudFJlc2l6ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRvY3VtZW50UmVzaXplTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbignd2luZG93JywgJ3Jlc2l6ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnVuYmluZERvY3VtZW50UmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50UmVzaXplTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFJlc2l6ZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmJpbmREb2N1bWVudFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUbyA9PT0gJ2JvZHknKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hcHBlbmRUbyA9PT0gJ3RhcmdldCcpXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIsIHRoaXMuYXBwZW5kVG8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sdGlwO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJ0b29sdGlwUG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJ0b29sdGlwRXZlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJhcHBlbmRUb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInBvc2l0aW9uU3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJ0b29sdGlwU3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KFwidG9vbHRpcERpc2FibGVkXCIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZXNjYXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwic2hvd0RlbGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiaGlkZURlbGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0V2ZW50XSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcIm9uTW91c2VFbnRlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Ib3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRXZlbnRdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwib25Nb3VzZUxlYXZlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkhvc3RMaXN0ZW5lcignZm9jdXMnLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRXZlbnRdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwib25Gb2N1c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Ib3N0TGlzdGVuZXIoJ2JsdXInLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRXZlbnRdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwib25CbHVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCdwVG9vbHRpcCcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInRleHRcIiwgbnVsbCk7XG5Ub29sdGlwID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkRpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW3BUb29sdGlwXScsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuUmVuZGVyZXIyXSlcbl0sIFRvb2x0aXApO1xuZXhwb3J0cy5Ub29sdGlwID0gVG9vbHRpcDtcbnZhciBUb29sdGlwTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gVG9vbHRpcE1vZHVsZTtcbn0oKSk7XG5Ub29sdGlwTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtUb29sdGlwXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbVG9vbHRpcF1cbiAgICB9KVxuXSwgVG9vbHRpcE1vZHVsZSk7XG5leHBvcnRzLlRvb2x0aXBNb2R1bGUgPSBUb29sdGlwTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbHRpcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb3JlXzIgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBzaGFyZWRfMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vc2hhcmVkXCIpO1xudmFyIHRyZWVkcmFnZHJvcHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJlZWRyYWdkcm9wc2VydmljZVwiKTtcbnZhciBUcmVlTm9kZVRlbXBsYXRlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlTm9kZVRlbXBsYXRlTG9hZGVyKHZpZXdDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgVHJlZU5vZGVUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSwge1xuICAgICAgICAgICAgJ1xcJGltcGxpY2l0JzogdGhpcy5ub2RlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJlZU5vZGVUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJlZU5vZGVUZW1wbGF0ZUxvYWRlcjtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVHJlZU5vZGVUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUsIFwibm9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5UZW1wbGF0ZVJlZilcbl0sIFRyZWVOb2RlVGVtcGxhdGVMb2FkZXIucHJvdG90eXBlLCBcInRlbXBsYXRlXCIsIHZvaWQgMCk7XG5UcmVlTm9kZVRlbXBsYXRlTG9hZGVyID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAncC10cmVlTm9kZVRlbXBsYXRlTG9hZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiXCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5WaWV3Q29udGFpbmVyUmVmXSlcbl0sIFRyZWVOb2RlVGVtcGxhdGVMb2FkZXIpO1xuZXhwb3J0cy5UcmVlTm9kZVRlbXBsYXRlTG9hZGVyID0gVHJlZU5vZGVUZW1wbGF0ZUxvYWRlcjtcbnZhciBVSVRyZWVOb2RlID0gVUlUcmVlTm9kZV8xID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVSVRyZWVOb2RlKHRyZWUpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICB9XG4gICAgVUlUcmVlTm9kZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm9kZS5wYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5nZXRJY29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWNvbjtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pY29uKVxuICAgICAgICAgICAgaWNvbiA9IHRoaXMubm9kZS5pY29uO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpY29uID0gdGhpcy5ub2RlLmV4cGFuZGVkICYmIHRoaXMubm9kZS5jaGlsZHJlbiAmJiB0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5ub2RlLmV4cGFuZGVkSWNvbiA6IHRoaXMubm9kZS5jb2xsYXBzZWRJY29uO1xuICAgICAgICByZXR1cm4gVUlUcmVlTm9kZV8xLklDT05fQ0xBU1MgKyAnICcgKyBpY29uO1xuICAgIH07XG4gICAgVUlUcmVlTm9kZS5wcm90b3R5cGUuaXNMZWFmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmxlYWYgPT0gZmFsc2UgPyBmYWxzZSA6ICEodGhpcy5ub2RlLmNoaWxkcmVuICYmIHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH07XG4gICAgVUlUcmVlTm9kZS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuZXhwYW5kZWQpXG4gICAgICAgICAgICB0aGlzLnRyZWUub25Ob2RlQ29sbGFwc2UuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiB0aGlzLm5vZGUgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudHJlZS5vbk5vZGVFeHBhbmQuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiB0aGlzLm5vZGUgfSk7XG4gICAgICAgIHRoaXMubm9kZS5leHBhbmRlZCA9ICF0aGlzLm5vZGUuZXhwYW5kZWQ7XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbk5vZGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnRyZWUub25Ob2RlQ2xpY2soZXZlbnQsIHRoaXMubm9kZSk7XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbk5vZGVUb3VjaEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmVlLm9uTm9kZVRvdWNoRW5kKCk7XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbk5vZGVSaWdodENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudHJlZS5vbk5vZGVSaWdodENsaWNrKGV2ZW50LCB0aGlzLm5vZGUpO1xuICAgIH07XG4gICAgVUlUcmVlTm9kZS5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5pc1NlbGVjdGVkKHRoaXMubm9kZSk7XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbkRyb3BQb2ludCA9IGZ1bmN0aW9uIChldmVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGRyYWdOb2RlID0gdGhpcy50cmVlLmRyYWdOb2RlO1xuICAgICAgICB2YXIgZHJhZ05vZGVJbmRleCA9IHRoaXMudHJlZS5kcmFnTm9kZUluZGV4O1xuICAgICAgICB2YXIgZHJhZ05vZGVTY29wZSA9IHRoaXMudHJlZS5kcmFnTm9kZVNjb3BlO1xuICAgICAgICB2YXIgaXNWYWxpZERyb3BQb2ludEluZGV4ID0gdGhpcy50cmVlLmRyYWdOb2RlVHJlZSA9PT0gdGhpcy50cmVlID8gKHBvc2l0aW9uID09PSAxIHx8IGRyYWdOb2RlSW5kZXggIT09IHRoaXMuaW5kZXggLSAxKSA6IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnRyZWUuYWxsb3dEcm9wKGRyYWdOb2RlLCB0aGlzLm5vZGUsIGRyYWdOb2RlU2NvcGUpICYmIGlzVmFsaWREcm9wUG9pbnRJbmRleCkge1xuICAgICAgICAgICAgdmFyIG5ld05vZGVMaXN0ID0gdGhpcy5ub2RlLnBhcmVudCA/IHRoaXMubm9kZS5wYXJlbnQuY2hpbGRyZW4gOiB0aGlzLnRyZWUudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyZWUuZHJhZ05vZGVTdWJOb2Rlcy5zcGxpY2UoZHJhZ05vZGVJbmRleCwgMSk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BJbmRleCA9ICh0aGlzLnRyZWUuZHJhZ05vZGVTdWJOb2RlcyA9PT0gbmV3Tm9kZUxpc3QpID8gKCh0aGlzLnRyZWUuZHJhZ05vZGVJbmRleCA+IHRoaXMuaW5kZXgpID8gdGhpcy5pbmRleCA6IHRoaXMuaW5kZXggLSAxKSA6IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZUxpc3Quc3BsaWNlKGRyb3BJbmRleCwgMCwgZHJhZ05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZUxpc3QucHVzaChkcmFnTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWUuZHJhZ0Ryb3BTZXJ2aWNlLnN0b3BEcmFnKHtcbiAgICAgICAgICAgICAgICBub2RlOiBkcmFnTm9kZSxcbiAgICAgICAgICAgICAgICBzdWJOb2RlczogdGhpcy5ub2RlLnBhcmVudCA/IHRoaXMubm9kZS5wYXJlbnQuY2hpbGRyZW4gOiB0aGlzLnRyZWUudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGRyYWdOb2RlSW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlLm9uTm9kZURyb3AuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgZHJhZ05vZGU6IGRyYWdOb2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdob3ZlclByZXYgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnaG92ZXJOZXh0ID0gZmFsc2U7XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbkRyb3BQb2ludERyYWdPdmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgVUlUcmVlTm9kZS5wcm90b3R5cGUub25Ecm9wUG9pbnREcmFnRW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnRyZWUuYWxsb3dEcm9wKHRoaXMudHJlZS5kcmFnTm9kZSwgdGhpcy5ub2RlLCB0aGlzLnRyZWUuZHJhZ05vZGVTY29wZSkpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnaG92ZXJQcmV2ID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdob3Zlck5leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbkRyb3BQb2ludERyYWdMZWF2ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmRyYWdob3ZlclByZXYgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnaG92ZXJOZXh0ID0gZmFsc2U7XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy50cmVlLmRyYWdnYWJsZU5vZGVzICYmIHRoaXMubm9kZS5kcmFnZ2FibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHRcIiwgXCJkYXRhXCIpO1xuICAgICAgICAgICAgdGhpcy50cmVlLmRyYWdEcm9wU2VydmljZS5zdGFydERyYWcoe1xuICAgICAgICAgICAgICAgIHRyZWU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgIHN1Yk5vZGVzOiB0aGlzLm5vZGUucGFyZW50ID8gdGhpcy5ub2RlLnBhcmVudC5jaGlsZHJlbiA6IHRoaXMudHJlZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBzY29wZTogdGhpcy50cmVlLmRyYWdnYWJsZVNjb3BlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVJVHJlZU5vZGUucHJvdG90eXBlLm9uRHJhZ1N0b3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy50cmVlLmRyYWdEcm9wU2VydmljZS5zdG9wRHJhZyh7XG4gICAgICAgICAgICBub2RlOiB0aGlzLm5vZGUsXG4gICAgICAgICAgICBzdWJOb2RlczogdGhpcy5ub2RlLnBhcmVudCA/IHRoaXMubm9kZS5wYXJlbnQuY2hpbGRyZW4gOiB0aGlzLnRyZWUudmFsdWUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVJVHJlZU5vZGUucHJvdG90eXBlLm9uRHJvcE5vZGVEcmFnT3ZlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgICAgICAgaWYgKHRoaXMudHJlZS5kcm9wcGFibGVOb2Rlcykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbkRyb3BOb2RlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnRyZWUuZHJvcHBhYmxlTm9kZXMgJiYgdGhpcy5ub2RlLmRyb3BwYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciBkcmFnTm9kZSA9IHRoaXMudHJlZS5kcmFnTm9kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWUuYWxsb3dEcm9wKGRyYWdOb2RlLCB0aGlzLm5vZGUsIHRoaXMudHJlZS5kcmFnTm9kZVNjb3BlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkcmFnTm9kZUluZGV4ID0gdGhpcy50cmVlLmRyYWdOb2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLmRyYWdOb2RlU3ViTm9kZXMuc3BsaWNlKGRyYWdOb2RlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGUuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5jaGlsZHJlbi5wdXNoKGRyYWdOb2RlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5jaGlsZHJlbiA9IFtkcmFnTm9kZV07XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLmRyYWdEcm9wU2VydmljZS5zdG9wRHJhZyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGRyYWdOb2RlLFxuICAgICAgICAgICAgICAgICAgICBzdWJOb2RlczogdGhpcy5ub2RlLnBhcmVudCA/IHRoaXMubm9kZS5wYXJlbnQuY2hpbGRyZW4gOiB0aGlzLnRyZWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLnRyZWUuZHJhZ05vZGVJbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZS5vbk5vZGVEcm9wLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ05vZGU6IGRyYWdOb2RlLFxuICAgICAgICAgICAgICAgICAgICBkcm9wTm9kZTogdGhpcy5ub2RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnaG92ZXJOb2RlID0gZmFsc2U7XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbkRyb3BOb2RlRHJhZ0VudGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnRyZWUuZHJvcHBhYmxlTm9kZXMgJiYgdGhpcy5ub2RlLmRyb3BwYWJsZSAhPT0gZmFsc2UgJiYgdGhpcy50cmVlLmFsbG93RHJvcCh0aGlzLnRyZWUuZHJhZ05vZGUsIHRoaXMubm9kZSwgdGhpcy50cmVlLmRyYWdOb2RlU2NvcGUpKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdob3Zlck5vZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVSVRyZWVOb2RlLnByb3RvdHlwZS5vbkRyb3BOb2RlRHJhZ0xlYXZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnRyZWUuZHJvcHBhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmIChldmVudC54ID4gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCB8fCBldmVudC54IDwgcmVjdC5sZWZ0IHx8IGV2ZW50LnkgPj0gTWF0aC5mbG9vcihyZWN0LnRvcCArIHJlY3QuaGVpZ2h0KSB8fCBldmVudC55IDwgcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdob3Zlck5vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFVJVHJlZU5vZGU7XG59KCkpO1xuVUlUcmVlTm9kZS5JQ09OX0NMQVNTID0gJ3VpLXRyZWVub2RlLWljb24gZmEgZmEtZncnO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFVJVHJlZU5vZGUucHJvdG90eXBlLCBcIm5vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBVSVRyZWVOb2RlLnByb3RvdHlwZSwgXCJwYXJlbnROb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFVJVHJlZU5vZGUucHJvdG90eXBlLCBcInJvb3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBVSVRyZWVOb2RlLnByb3RvdHlwZSwgXCJpbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBVSVRyZWVOb2RlLnByb3RvdHlwZSwgXCJmaXJzdENoaWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFVJVHJlZU5vZGUucHJvdG90eXBlLCBcImxhc3RDaGlsZFwiLCB2b2lkIDApO1xuVUlUcmVlTm9kZSA9IFVJVHJlZU5vZGVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ3AtdHJlZU5vZGUnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XFxcIm5vZGVcXFwiPlxcbiAgICAgICAgICAgIDxsaSAqbmdJZj1cXFwidHJlZS5kcm9wcGFibGVOb2Rlc1xcXCIgY2xhc3M9XFxcInVpLXRyZWVub2RlLWRyb3Bwb2ludFxcXCIgW25nQ2xhc3NdPVxcXCJ7J3VpLXRyZWVub2RlLWRyb3Bwb2ludC1hY3RpdmUgdWktc3RhdGUtaGlnaGxpZ2h0JzpkcmFnaG92ZXJQcmV2fVxcXCJcXG4gICAgICAgICAgICAoZHJvcCk9XFxcIm9uRHJvcFBvaW50KCRldmVudCwtMSlcXFwiIChkcmFnb3Zlcik9XFxcIm9uRHJvcFBvaW50RHJhZ092ZXIoJGV2ZW50KVxcXCIgKGRyYWdlbnRlcik9XFxcIm9uRHJvcFBvaW50RHJhZ0VudGVyKCRldmVudCwtMSlcXFwiIChkcmFnbGVhdmUpPVxcXCJvbkRyb3BQb2ludERyYWdMZWF2ZSgkZXZlbnQpXFxcIj48L2xpPlxcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwidWktdHJlZW5vZGUge3tub2RlLnN0eWxlQ2xhc3N9fVxcXCIgKm5nSWY9XFxcIiF0cmVlLmhvcml6b250YWxcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS10cmVlbm9kZS1sZWFmJzogaXNMZWFmKCl9XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdHJlZW5vZGUtY29udGVudFxcXCIgKGNsaWNrKT1cXFwib25Ob2RlQ2xpY2soJGV2ZW50KVxcXCIgKGNvbnRleHRtZW51KT1cXFwib25Ob2RlUmlnaHRDbGljaygkZXZlbnQpXFxcIiAodG91Y2hlbmQpPVxcXCJvbk5vZGVUb3VjaEVuZCgpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgKGRyb3ApPVxcXCJvbkRyb3BOb2RlKCRldmVudClcXFwiIChkcmFnb3Zlcik9XFxcIm9uRHJvcE5vZGVEcmFnT3ZlcigkZXZlbnQpXFxcIiAoZHJhZ2VudGVyKT1cXFwib25Ecm9wTm9kZURyYWdFbnRlcigkZXZlbnQpXFxcIiAoZHJhZ2xlYXZlKT1cXFwib25Ecm9wTm9kZURyYWdMZWF2ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7J3VpLXRyZWVub2RlLXNlbGVjdGFibGUnOnRyZWUuc2VsZWN0aW9uTW9kZSAmJiBub2RlLnNlbGVjdGFibGUgIT09IGZhbHNlLCd1aS10cmVlbm9kZS1kcmFnb3Zlcic6ZHJhZ2hvdmVyTm9kZX1cXFwiIFtkcmFnZ2FibGVdPVxcXCJ0cmVlLmRyYWdnYWJsZU5vZGVzXFxcIiAoZHJhZ3N0YXJ0KT1cXFwib25EcmFnU3RhcnQoJGV2ZW50KVxcXCIgKGRyYWdlbmQpPVxcXCJvbkRyYWdTdG9wKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLXRyZWUtdG9nZ2xlciAgZmEgZmEtZndcXFwiIFtuZ0NsYXNzXT1cXFwieydmYS1jYXJldC1yaWdodCc6IW5vZGUuZXhwYW5kZWQsJ2ZhLWNhcmV0LWRvd24nOm5vZGUuZXhwYW5kZWR9XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJ0b2dnbGUoJGV2ZW50KVxcXCI+PC9zcGFuXFxuICAgICAgICAgICAgICAgICAgICA+PGRpdiBjbGFzcz1cXFwidWktY2hrYm94XFxcIiAqbmdJZj1cXFwidHJlZS5zZWxlY3Rpb25Nb2RlID09ICdjaGVja2JveCdcXFwiPjxkaXYgY2xhc3M9XFxcInVpLWNoa2JveC1ib3ggdWktd2lkZ2V0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGVmYXVsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWNoa2JveC1pY29uIHVpLWNsaWNrYWJsZSBmYVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieydmYS1jaGVjayc6aXNTZWxlY3RlZCgpLCdmYS1taW51cyc6bm9kZS5wYXJ0aWFsU2VsZWN0ZWR9XFxcIj48L3NwYW4+PC9kaXY+PC9kaXZcXG4gICAgICAgICAgICAgICAgICAgID48c3BhbiBbY2xhc3NdPVxcXCJnZXRJY29uKClcXFwiICpuZ0lmPVxcXCJub2RlLmljb258fG5vZGUuZXhwYW5kZWRJY29ufHxub2RlLmNvbGxhcHNlZEljb25cXFwiPjwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgPjxzcGFuIGNsYXNzPVxcXCJ1aS10cmVlbm9kZS1sYWJlbCB1aS1jb3JuZXItYWxsXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsndWktc3RhdGUtaGlnaGxpZ2h0Jzppc1NlbGVjdGVkKCl9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiF0cmVlLmdldFRlbXBsYXRlRm9yTm9kZShub2RlKVxcXCI+e3tub2RlLmxhYmVsfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVxcXCJ0cmVlLmdldFRlbXBsYXRlRm9yTm9kZShub2RlKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cC10cmVlTm9kZVRlbXBsYXRlTG9hZGVyIFtub2RlXT1cXFwibm9kZVxcXCIgW3RlbXBsYXRlXT1cXFwidHJlZS5nZXRUZW1wbGF0ZUZvck5vZGUobm9kZSlcXFwiPjwvcC10cmVlTm9kZVRlbXBsYXRlTG9hZGVyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcInVpLXRyZWVub2RlLWNoaWxkcmVuXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTtcXFwiICpuZ0lmPVxcXCJub2RlLmNoaWxkcmVuICYmIG5vZGUuZXhwYW5kZWRcXFwiIFtzdHlsZS5kaXNwbGF5XT1cXFwibm9kZS5leHBhbmRlZCA/ICdibG9jaycgOiAnbm9uZSdcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHAtdHJlZU5vZGUgKm5nRm9yPVxcXCJsZXQgY2hpbGROb2RlIG9mIG5vZGUuY2hpbGRyZW47bGV0IGZpcnN0Q2hpbGQ9Zmlyc3Q7bGV0IGxhc3RDaGlsZD1sYXN0OyBsZXQgaW5kZXg9aW5kZXhcXFwiIFtub2RlXT1cXFwiY2hpbGROb2RlXFxcIiBbcGFyZW50Tm9kZV09XFxcIm5vZGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgW2ZpcnN0Q2hpbGRdPVxcXCJmaXJzdENoaWxkXFxcIiBbbGFzdENoaWxkXT1cXFwibGFzdENoaWxkXFxcIiBbaW5kZXhdPVxcXCJpbmRleFxcXCI+PC9wLXRyZWVOb2RlPlxcbiAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPGxpICpuZ0lmPVxcXCJ0cmVlLmRyb3BwYWJsZU5vZGVzJiZsYXN0Q2hpbGRcXFwiIGNsYXNzPVxcXCJ1aS10cmVlbm9kZS1kcm9wcG9pbnRcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS10cmVlbm9kZS1kcm9wcG9pbnQtYWN0aXZlIHVpLXN0YXRlLWhpZ2hsaWdodCc6ZHJhZ2hvdmVyTmV4dH1cXFwiXFxuICAgICAgICAgICAgKGRyb3ApPVxcXCJvbkRyb3BQb2ludCgkZXZlbnQsMSlcXFwiIChkcmFnb3Zlcik9XFxcIm9uRHJvcFBvaW50RHJhZ092ZXIoJGV2ZW50KVxcXCIgKGRyYWdlbnRlcik9XFxcIm9uRHJvcFBvaW50RHJhZ0VudGVyKCRldmVudCwxKVxcXCIgKGRyYWdsZWF2ZSk9XFxcIm9uRHJvcFBvaW50RHJhZ0xlYXZlKCRldmVudClcXFwiPjwvbGk+XFxuICAgICAgICAgICAgPHRhYmxlICpuZ0lmPVxcXCJ0cmVlLmhvcml6b250YWxcXFwiIFtjbGFzc109XFxcIm5vZGUuc3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInVpLXRyZWVub2RlLWNvbm5lY3RvclxcXCIgKm5nSWY9XFxcIiFyb290XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJ1aS10cmVlbm9kZS1jb25uZWN0b3ItdGFibGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIFtuZ0NsYXNzXT1cXFwieyd1aS10cmVlbm9kZS1jb25uZWN0b3ItbGluZSc6IWZpcnN0Q2hpbGR9XFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgW25nQ2xhc3NdPVxcXCJ7J3VpLXRyZWVub2RlLWNvbm5lY3Rvci1saW5lJzohbGFzdENoaWxkfVxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidWktdHJlZW5vZGVcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS10cmVlbm9kZS1jb2xsYXBzZWQnOiFub2RlLmV4cGFuZGVkfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRyZWVub2RlLWNvbnRlbnQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS10cmVlbm9kZS1zZWxlY3RhYmxlJzp0cmVlLnNlbGVjdGlvbk1vZGUsJ3VpLXN0YXRlLWhpZ2hsaWdodCc6aXNTZWxlY3RlZCgpfVxcXCIgKGNsaWNrKT1cXFwib25Ob2RlQ2xpY2soJGV2ZW50KVxcXCIgKGNvbnRleHRtZW51KT1cXFwib25Ob2RlUmlnaHRDbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRvdWNoZW5kKT1cXFwib25Ob2RlVG91Y2hFbmQoKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktdHJlZS10b2dnbGVyIGZhIGZhLWZ3XFxcIiBbbmdDbGFzc109XFxcInsnZmEtcGx1cyc6IW5vZGUuZXhwYW5kZWQsJ2ZhLW1pbnVzJzpub2RlLmV4cGFuZGVkfVxcXCIgKm5nSWY9XFxcIiFpc0xlYWYoKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwidG9nZ2xlKCRldmVudClcXFwiPjwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjxzcGFuIFtjbGFzc109XFxcImdldEljb24oKVxcXCIgKm5nSWY9XFxcIm5vZGUuaWNvbnx8bm9kZS5leHBhbmRlZEljb258fG5vZGUuY29sbGFwc2VkSWNvblxcXCI+PC9zcGFuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PHNwYW4gY2xhc3M9XFxcInVpLXRyZWVub2RlLWxhYmVsIHVpLWNvcm5lci1hbGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiIXRyZWUuZ2V0VGVtcGxhdGVGb3JOb2RlKG5vZGUpXFxcIj57e25vZGUubGFiZWx9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcInRyZWUuZ2V0VGVtcGxhdGVGb3JOb2RlKG5vZGUpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwLXRyZWVOb2RlVGVtcGxhdGVMb2FkZXIgW25vZGVdPVxcXCJub2RlXFxcIiBbdGVtcGxhdGVdPVxcXCJ0cmVlLmdldFRlbXBsYXRlRm9yTm9kZShub2RlKVxcXCI+PC9wLXRyZWVOb2RlVGVtcGxhdGVMb2FkZXI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInVpLXRyZWVub2RlLWNoaWxkcmVuLWNvbnRhaW5lclxcXCIgKm5nSWY9XFxcIm5vZGUuY2hpbGRyZW4gJiYgbm9kZS5leHBhbmRlZFxcXCIgW3N0eWxlLmRpc3BsYXldPVxcXCJub2RlLmV4cGFuZGVkID8gJ3RhYmxlLWNlbGwnIDogJ25vbmUnXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdHJlZW5vZGUtY2hpbGRyZW5cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAtdHJlZU5vZGUgKm5nRm9yPVxcXCJsZXQgY2hpbGROb2RlIG9mIG5vZGUuY2hpbGRyZW47bGV0IGZpcnN0Q2hpbGQ9Zmlyc3Q7bGV0IGxhc3RDaGlsZD1sYXN0O1xcXCIgW25vZGVdPVxcXCJjaGlsZE5vZGVcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlyc3RDaGlsZF09XFxcImZpcnN0Q2hpbGRcXFwiIFtsYXN0Q2hpbGRdPVxcXCJsYXN0Q2hpbGRcXFwiPjwvcC10cmVlTm9kZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgIDwvbmctdGVtcGxhdGU+XFxuICAgIFwiXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBjb3JlXzEuSW5qZWN0KGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFRyZWU7IH0pKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUcmVlXSlcbl0sIFVJVHJlZU5vZGUpO1xuZXhwb3J0cy5VSVRyZWVOb2RlID0gVUlUcmVlTm9kZTtcbnZhciBUcmVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlKGRyYWdEcm9wU2VydmljZSkge1xuICAgICAgICB0aGlzLmRyYWdEcm9wU2VydmljZSA9IGRyYWdEcm9wU2VydmljZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTm9kZVNlbGVjdCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Ob2RlVW5zZWxlY3QgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTm9kZUV4cGFuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Ob2RlQ29sbGFwc2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTm9kZUNvbnRleHRNZW51U2VsZWN0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk5vZGVEcm9wID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSAndmVydGljYWwnO1xuICAgICAgICB0aGlzLm1ldGFLZXlTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLnByb3BhZ2F0ZVNlbGVjdGlvblVwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVTZWxlY3Rpb25Eb3duID0gdHJ1ZTtcbiAgICB9XG4gICAgVHJlZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRyb3BwYWJsZU5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydFN1YnNjcmlwdGlvbiA9IHRoaXMuZHJhZ0Ryb3BTZXJ2aWNlLmRyYWdTdGFydCQuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdOb2RlVHJlZSA9IGV2ZW50LnRyZWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ05vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdOb2RlU3ViTm9kZXMgPSBldmVudC5zdWJOb2RlcztcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTm9kZUluZGV4ID0gZXZlbnQuaW5kZXg7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ05vZGVTY29wZSA9IGV2ZW50LnNjb3BlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdG9wU3Vic2NyaXB0aW9uID0gdGhpcy5kcmFnRHJvcFNlcnZpY2UuZHJhZ1N0b3AkLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTm9kZVRyZWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTm9kZVN1Yk5vZGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTm9kZUluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTm9kZVNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnSG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZS5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0ID09ICdob3Jpem9udGFsJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVHJlZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlTWFwID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgX3RoaXMudGVtcGxhdGVNYXBbaXRlbS5uYW1lXSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJlZS5wcm90b3R5cGUub25Ob2RlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIG5vZGUpIHtcbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAoZXZlbnRUYXJnZXQuY2xhc3NOYW1lICYmIGV2ZW50VGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCd1aS10cmVlLXRvZ2dsZXInKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc2VsZWN0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXhfMSA9IHRoaXMuZmluZEluZGV4SW5TZWxlY3Rpb24obm9kZSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSAoaW5kZXhfMSA+PSAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2hlY2tib3hTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcGFnYXRlU2VsZWN0aW9uRG93bilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRG93bihub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIGkgIT0gaW5kZXhfMTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BhZ2F0ZVNlbGVjdGlvblVwICYmIG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwKG5vZGUucGFyZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlVW5zZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcGFnYXRlU2VsZWN0aW9uRG93bilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRG93bihub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSAodGhpcy5zZWxlY3Rpb24gfHwgW10pLmNvbmNhdChbbm9kZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wYWdhdGVTZWxlY3Rpb25VcCAmJiBub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVVcChub2RlLnBhcmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlU2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0YVNlbGVjdGlvbiA9IHRoaXMubm9kZVRvdWNoZWQgPyBmYWxzZSA6IHRoaXMubWV0YUtleVNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobWV0YVNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YUtleSA9IChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgbWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTaW5nbGVTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBpbmRleF8xOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlVW5zZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTaW5nbGVTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc011bHRpcGxlU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSAoIW1ldGFLZXkpID8gW10gOiB0aGlzLnNlbGVjdGlvbiB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uLmNvbmNhdChbbm9kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVTZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVNlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlVW5zZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlU2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIGkgIT0gaW5kZXhfMTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVVbnNlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIG5vZGU6IG5vZGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9ICh0aGlzLnNlbGVjdGlvbiB8fCBbXSkuY29uY2F0KFtub2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVTZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVUb3VjaGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBUcmVlLnByb3RvdHlwZS5vbk5vZGVUb3VjaEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub2RlVG91Y2hlZCA9IHRydWU7XG4gICAgfTtcbiAgICBUcmVlLnByb3RvdHlwZS5vbk5vZGVSaWdodENsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZXZlbnRUYXJnZXQuY2xhc3NOYW1lICYmIGV2ZW50VGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCd1aS10cmVlLXRvZ2dsZXInKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4SW5TZWxlY3Rpb24obm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gKGluZGV4ID49IDApO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTaW5nbGVTZWxlY3Rpb25Nb2RlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KFtub2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnUuc2hvdyhldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVDb250ZXh0TWVudVNlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIG5vZGU6IG5vZGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLmZpbmRJbmRleEluU2VsZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgJiYgdGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2luZ2xlU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAodGhpcy5zZWxlY3Rpb24gPT0gbm9kZSkgPyAwIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbltpXSA9PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBUcmVlLnByb3RvdHlwZS5wcm9wYWdhdGVVcCA9IGZ1bmN0aW9uIChub2RlLCBzZWxlY3QpIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjaGlsZFBhcnRpYWxTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG5vZGUuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFydGlhbFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUGFydGlhbFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0ICYmIHNlbGVjdGVkQ291bnQgPT0gbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9ICh0aGlzLnNlbGVjdGlvbiB8fCBbXSkuY29uY2F0KFtub2RlXSk7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJ0aWFsU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleF8yID0gdGhpcy5maW5kSW5kZXhJblNlbGVjdGlvbihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4XzIgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBpbmRleF8yOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRQYXJ0aWFsU2VsZWN0ZWQgfHwgc2VsZWN0ZWRDb3VudCA+IDAgJiYgc2VsZWN0ZWRDb3VudCAhPSBub2RlLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJ0aWFsU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJ0aWFsU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlVXAocGFyZW50LCBzZWxlY3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlLnByb3RvdHlwZS5wcm9wYWdhdGVEb3duID0gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleEluU2VsZWN0aW9uKG5vZGUpO1xuICAgICAgICBpZiAoc2VsZWN0ICYmIGluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9ICh0aGlzLnNlbGVjdGlvbiB8fCBbXSkuY29uY2F0KFtub2RlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNlbGVjdCAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uLmZpbHRlcihmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiBpICE9IGluZGV4OyB9KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnBhcnRpYWxTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG5vZGUuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRG93bihjaGlsZCwgc2VsZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZS5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRJbmRleEluU2VsZWN0aW9uKG5vZGUpICE9IC0xO1xuICAgIH07XG4gICAgVHJlZS5wcm90b3R5cGUuaXNTaW5nbGVTZWxlY3Rpb25Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PSAnc2luZ2xlJztcbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLmlzTXVsdGlwbGVTZWxlY3Rpb25Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PSAnbXVsdGlwbGUnO1xuICAgIH07XG4gICAgVHJlZS5wcm90b3R5cGUuaXNDaGVja2JveFNlbGVjdGlvbk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGUgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09ICdjaGVja2JveCc7XG4gICAgfTtcbiAgICBUcmVlLnByb3RvdHlwZS5nZXRUZW1wbGF0ZUZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZU1hcClcbiAgICAgICAgICAgIHJldHVybiBub2RlLnR5cGUgPyB0aGlzLnRlbXBsYXRlTWFwW25vZGUudHlwZV0gOiB0aGlzLnRlbXBsYXRlTWFwWydkZWZhdWx0J107XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVHJlZS5wcm90b3R5cGUub25EcmFnT3ZlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcm9wcGFibGVOb2RlcyAmJiAoIXRoaXMudmFsdWUgfHwgdGhpcy52YWx1ZS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLm9uRHJvcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcm9wcGFibGVOb2RlcyAmJiAoIXRoaXMudmFsdWUgfHwgdGhpcy52YWx1ZS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGRyYWdOb2RlID0gdGhpcy5kcmFnTm9kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93RHJvcChkcmFnTm9kZSwgbnVsbCwgdGhpcy5kcmFnTm9kZVNjb3BlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkcmFnTm9kZUluZGV4ID0gdGhpcy5kcmFnTm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ05vZGVTdWJOb2Rlcy5zcGxpY2UoZHJhZ05vZGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUgfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKGRyYWdOb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdEcm9wU2VydmljZS5zdG9wRHJhZyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGRyYWdOb2RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLm9uRHJhZ0VudGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3BwYWJsZU5vZGVzICYmIHRoaXMuYWxsb3dEcm9wKHRoaXMuZHJhZ05vZGUsIG51bGwsIHRoaXMuZHJhZ05vZGVTY29wZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0hvdmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZS5wcm90b3R5cGUub25EcmFnTGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJvcHBhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmIChldmVudC54ID4gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCB8fCBldmVudC54IDwgcmVjdC5sZWZ0IHx8IGV2ZW50LnkgPiByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IHx8IGV2ZW50LnkgPCByZWN0LnRvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0hvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLmFsbG93RHJvcCA9IGZ1bmN0aW9uIChkcmFnTm9kZSwgZHJvcE5vZGUsIGRyYWdOb2RlU2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZERyYWdTY29wZShkcmFnTm9kZVNjb3BlKSkge1xuICAgICAgICAgICAgdmFyIGFsbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkcm9wTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChkcmFnTm9kZSA9PT0gZHJvcE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IGRyb3BOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudF8xICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfMSA9PT0gZHJhZ05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XzEgPSBwYXJlbnRfMS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLmlzVmFsaWREcmFnU2NvcGUgPSBmdW5jdGlvbiAoZHJhZ1Njb3BlKSB7XG4gICAgICAgIHZhciBkcm9wU2NvcGUgPSB0aGlzLmRyb3BwYWJsZVNjb3BlO1xuICAgICAgICBpZiAoZHJvcFNjb3BlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRyb3BTY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRyYWdTY29wZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcm9wU2NvcGUgPT09IGRyYWdTY29wZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkcmFnU2NvcGUgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyYWdTY29wZS5pbmRleE9mKGRyb3BTY29wZSkgIT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkcm9wU2NvcGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZHJhZ1Njb3BlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHJvcFNjb3BlLmluZGV4T2YoZHJhZ1Njb3BlKSAhPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHJhZ1Njb3BlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkcm9wU2NvcGVfMSA9IGRyb3BTY29wZTsgX2kgPCBkcm9wU2NvcGVfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gZHJvcFNjb3BlXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBkcmFnU2NvcGVfMSA9IGRyYWdTY29wZTsgX2EgPCBkcmFnU2NvcGVfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHMgPSBkcmFnU2NvcGVfMVtfYV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09IGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1N0YXJ0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRyYWdTdG9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdG9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmVlO1xufSgpKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFRyZWUucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZS5wcm90b3R5cGUsIFwic2VsZWN0aW9uTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyZWUucHJvdG90eXBlLCBcInNlbGVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgVHJlZS5wcm90b3R5cGUsIFwic2VsZWN0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBUcmVlLnByb3RvdHlwZSwgXCJvbk5vZGVTZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFRyZWUucHJvdG90eXBlLCBcIm9uTm9kZVVuc2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBUcmVlLnByb3RvdHlwZSwgXCJvbk5vZGVFeHBhbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFRyZWUucHJvdG90eXBlLCBcIm9uTm9kZUNvbGxhcHNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBUcmVlLnByb3RvdHlwZSwgXCJvbk5vZGVDb250ZXh0TWVudVNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgVHJlZS5wcm90b3R5cGUsIFwib25Ob2RlRHJvcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyZWUucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZS5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyZWUucHJvdG90eXBlLCBcImNvbnRleHRNZW51XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZS5wcm90b3R5cGUsIFwibGF5b3V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVHJlZS5wcm90b3R5cGUsIFwiZHJhZ2dhYmxlU2NvcGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUcmVlLnByb3RvdHlwZSwgXCJkcm9wcGFibGVTY29wZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlLnByb3RvdHlwZSwgXCJkcmFnZ2FibGVOb2Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlLnByb3RvdHlwZSwgXCJkcm9wcGFibGVOb2Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlLnByb3RvdHlwZSwgXCJtZXRhS2V5U2VsZWN0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWUucHJvdG90eXBlLCBcInByb3BhZ2F0ZVNlbGVjdGlvblVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyZWUucHJvdG90eXBlLCBcInByb3BhZ2F0ZVNlbGVjdGlvbkRvd25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4oc2hhcmVkXzIuUHJpbWVUZW1wbGF0ZSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5RdWVyeUxpc3QpXG5dLCBUcmVlLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZXNcIiwgdm9pZCAwKTtcblRyZWUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLXRyZWUnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJ7J3VpLXRyZWUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnOnRydWUsJ3VpLXRyZWUtc2VsZWN0YWJsZSc6c2VsZWN0aW9uTW9kZSwndWktdHJlZW5vZGUtZHJhZ292ZXInOmRyYWdIb3Zlcn1cXFwiIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiICpuZ0lmPVxcXCIhaG9yaXpvbnRhbFxcXCJcXG4gICAgICAgICAgICAoZHJvcCk9XFxcIm9uRHJvcCgkZXZlbnQpXFxcIiAoZHJhZ292ZXIpPVxcXCJvbkRyYWdPdmVyKCRldmVudClcXFwiIChkcmFnZW50ZXIpPVxcXCJvbkRyYWdFbnRlcigkZXZlbnQpXFxcIiAoZHJhZ2xlYXZlKT1cXFwib25EcmFnTGVhdmUoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJ1aS10cmVlLWNvbnRhaW5lclxcXCI+XFxuICAgICAgICAgICAgICAgIDxwLXRyZWVOb2RlICpuZ0Zvcj1cXFwibGV0IG5vZGUgb2YgdmFsdWU7bGV0IGZpcnN0Q2hpbGQ9Zmlyc3Q7bGV0IGxhc3RDaGlsZD1sYXN0OyBsZXQgaW5kZXg9aW5kZXhcXFwiIFtub2RlXT1cXFwibm9kZVxcXCIgXFxuICAgICAgICAgICAgICAgIFtmaXJzdENoaWxkXT1cXFwiZmlyc3RDaGlsZFxcXCIgW2xhc3RDaGlsZF09XFxcImxhc3RDaGlsZFxcXCIgW2luZGV4XT1cXFwiaW5kZXhcXFwiPjwvcC10cmVlTm9kZT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwieyd1aS10cmVlIHVpLXRyZWUtaG9yaXpvbnRhbCB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCc6dHJ1ZSwndWktdHJlZS1zZWxlY3RhYmxlJzpzZWxlY3Rpb25Nb2RlfVxcXCIgIFtuZ1N0eWxlXT1cXFwic3R5bGVcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiICpuZ0lmPVxcXCJob3Jpem9udGFsXFxcIj5cXG4gICAgICAgICAgICA8dGFibGUgKm5nSWY9XFxcInZhbHVlJiZ2YWx1ZVswXVxcXCI+XFxuICAgICAgICAgICAgICAgIDxwLXRyZWVOb2RlIFtub2RlXT1cXFwidmFsdWVbMF1cXFwiIFtyb290XT1cXFwidHJ1ZVxcXCI+PC9wLXRyZWVOb2RlPlxcbiAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCJcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIGNvcmVfMi5PcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3RyZWVkcmFnZHJvcHNlcnZpY2VfMS5UcmVlRHJhZ0Ryb3BTZXJ2aWNlXSlcbl0sIFRyZWUpO1xuZXhwb3J0cy5UcmVlID0gVHJlZTtcbnZhciBUcmVlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gVHJlZU1vZHVsZTtcbn0oKSk7XG5UcmVlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtUcmVlLCBzaGFyZWRfMS5TaGFyZWRNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtUcmVlLCBVSVRyZWVOb2RlLCBUcmVlTm9kZVRlbXBsYXRlTG9hZGVyXVxuICAgIH0pXG5dLCBUcmVlTW9kdWxlKTtcbmV4cG9ydHMuVHJlZU1vZHVsZSA9IFRyZWVNb2R1bGU7XG52YXIgVUlUcmVlTm9kZV8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJlZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9jb21wb25lbnRzL3RyZWUvdHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3RyZWUvdHJlZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIik7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3NoYXJlZFwiKTtcbnZhciBzaGFyZWRfMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vc2hhcmVkXCIpO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9taGFuZGxlclwiKTtcbnZhciBVSVRyZWVSb3cgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJVHJlZVJvdyh0cmVlVGFibGUpIHtcbiAgICAgICAgdGhpcy50cmVlVGFibGUgPSB0cmVlVGFibGU7XG4gICAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLmxhYmVsRXhwYW5kID0gXCJFeHBhbmRcIjtcbiAgICAgICAgdGhpcy5sYWJlbENvbGxhcHNlID0gXCJDb2xsYXBzZVwiO1xuICAgIH1cbiAgICBVSVRyZWVSb3cucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vZGUucGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIH07XG4gICAgVUlUcmVlUm93LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5leHBhbmRlZClcbiAgICAgICAgICAgIHRoaXMudHJlZVRhYmxlLm9uTm9kZUNvbGxhcHNlLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogdGhpcy5ub2RlIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnRyZWVUYWJsZS5vbk5vZGVFeHBhbmQuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiB0aGlzLm5vZGUgfSk7XG4gICAgICAgIHRoaXMubm9kZS5leHBhbmRlZCA9ICF0aGlzLm5vZGUuZXhwYW5kZWQ7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBVSVRyZWVSb3cucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5sZWFmID09IGZhbHNlID8gZmFsc2UgOiAhKHRoaXMubm9kZS5jaGlsZHJlbiAmJiB0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9O1xuICAgIFVJVHJlZVJvdy5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZVRhYmxlLmlzU2VsZWN0ZWQodGhpcy5ub2RlKTtcbiAgICB9O1xuICAgIFVJVHJlZVJvdy5wcm90b3R5cGUub25Sb3dDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnRyZWVUYWJsZS5vblJvd0NsaWNrKGV2ZW50LCB0aGlzLm5vZGUpO1xuICAgIH07XG4gICAgVUlUcmVlUm93LnByb3RvdHlwZS5vblJvd1JpZ2h0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy50cmVlVGFibGUub25Sb3dSaWdodENsaWNrKGV2ZW50LCB0aGlzLm5vZGUpO1xuICAgIH07XG4gICAgVUlUcmVlUm93LnByb3RvdHlwZS5yb3dEYmxDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnRyZWVUYWJsZS5vblJvd0RibGNsaWNrLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogdGhpcy5ub2RlIH0pO1xuICAgIH07XG4gICAgVUlUcmVlUm93LnByb3RvdHlwZS5vblJvd1RvdWNoRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyZWVUYWJsZS5vblJvd1RvdWNoRW5kKCk7XG4gICAgfTtcbiAgICBVSVRyZWVSb3cucHJvdG90eXBlLnJlc29sdmVGaWVsZERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZmllbGQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5pbmRleE9mKCcuJykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtmaWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtmaWVsZHNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFVJVHJlZVJvdztcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVUlUcmVlUm93LnByb3RvdHlwZSwgXCJub2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVUlUcmVlUm93LnByb3RvdHlwZSwgXCJwYXJlbnROb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVUlUcmVlUm93LnByb3RvdHlwZSwgXCJsZXZlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFVJVHJlZVJvdy5wcm90b3R5cGUsIFwibGFiZWxFeHBhbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBVSVRyZWVSb3cucHJvdG90eXBlLCBcImxhYmVsQ29sbGFwc2VcIiwgdm9pZCAwKTtcblVJVHJlZVJvdyA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1twVHJlZVJvd10nLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRyZWV0YWJsZS1yb3dcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1oaWdobGlnaHQnOmlzU2VsZWN0ZWQoKSwndWktdHJlZXRhYmxlLXJvdy1zZWxlY3RhYmxlJzp0cmVlVGFibGUuc2VsZWN0aW9uTW9kZSAmJiBub2RlLnNlbGVjdGFibGUgIT09IGZhbHNlfVxcXCI+XFxuICAgICAgICAgICAgPHRkICpuZ0Zvcj1cXFwibGV0IGNvbCBvZiB0cmVlVGFibGUuY29sdW1uczsgbGV0IGk9aW5kZXhcXFwiIFtuZ1N0eWxlXT1cXFwiY29sLnN0eWxlXFxcIiBbY2xhc3NdPVxcXCJjb2wuc3R5bGVDbGFzc1xcXCIgKGNsaWNrKT1cXFwib25Sb3dDbGljaygkZXZlbnQpXFxcIiAoZGJsY2xpY2spPVxcXCJyb3dEYmxDbGljaygkZXZlbnQpXFxcIiAodG91Y2hlbmQpPVxcXCJvblJvd1RvdWNoRW5kKClcXFwiIChjb250ZXh0bWVudSk9XFxcIm9uUm93UmlnaHRDbGljaygkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgKm5nSWY9XFxcImkgPT0gdHJlZVRhYmxlLnRvZ2dsZUNvbHVtbkluZGV4XFxcIiBjbGFzcz1cXFwidWktdHJlZXRhYmxlLXRvZ2dsZXIgZmEgZmEtZncgdWktY2xpY2thYmxlXFxcIiBbbmdDbGFzc109XFxcInsnZmEtY2FyZXQtZG93bic6bm9kZS5leHBhbmRlZCwnZmEtY2FyZXQtcmlnaHQnOiFub2RlLmV4cGFuZGVkfVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cXFwieydtYXJnaW4tbGVmdCc6bGV2ZWwqMTYgKyAncHgnLCd2aXNpYmlsaXR5JzogaXNMZWFmKCkgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJ31cXFwiXFxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJ0b2dnbGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XFxcIm5vZGUuZXhwYW5kZWQgPyBsYWJlbENvbGxhcHNlIDogbGFiZWxFeHBhbmRcXFwiPlxcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWNoa2JveCB1aS10cmVldGFibGUtY2hlY2tib3hcXFwiICpuZ0lmPVxcXCJ0cmVlVGFibGUuc2VsZWN0aW9uTW9kZSA9PSAnY2hlY2tib3gnICYmIGk9PTBcXFwiPjxkaXYgY2xhc3M9XFxcInVpLWNoa2JveC1ib3ggdWktd2lkZ2V0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGVmYXVsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY2hrYm94LWljb24gdWktY2xpY2thYmxlIGZhXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcInsnZmEtY2hlY2snOmlzU2VsZWN0ZWQoKSwnZmEtbWludXMnOm5vZGUucGFydGlhbFNlbGVjdGVkfVxcXCI+PC9zcGFuPjwvZGl2PjwvZGl2XFxuICAgICAgICAgICAgICAgID48c3BhbiAqbmdJZj1cXFwiIWNvbC50ZW1wbGF0ZVxcXCI+e3tyZXNvbHZlRmllbGREYXRhKG5vZGUuZGF0YSxjb2wuZmllbGQpfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxwLWNvbHVtbkJvZHlUZW1wbGF0ZUxvYWRlciBbY29sdW1uXT1cXFwiY29sXFxcIiBbcm93RGF0YV09XFxcIm5vZGVcXFwiICpuZ0lmPVxcXCJjb2wudGVtcGxhdGVcXFwiPjwvcC1jb2x1bW5Cb2R5VGVtcGxhdGVMb2FkZXI+XFxuICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiAqbmdJZj1cXFwibm9kZS5jaGlsZHJlbiAmJiBub2RlLmV4cGFuZGVkXFxcIiBjbGFzcz1cXFwidWktdHJlZXRhYmxlLXJvd1xcXCIgc3R5bGU9XFxcImRpc3BsYXk6dGFibGUtcm93XFxcIj5cXG4gICAgICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XFxcInRyZWVUYWJsZS5jb2x1bW5zLmxlbmd0aFxcXCIgY2xhc3M9XFxcInVpLXRyZWV0YWJsZS1jaGlsZC10YWJsZS1jb250YWluZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8dGFibGUgW2NsYXNzXT1cXFwidHJlZVRhYmxlLnRhYmxlU3R5bGVDbGFzc1xcXCIgW25nU3R5bGVdPVxcXCJ0cmVlVGFibGUudGFibGVTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGJvZHkgcFRyZWVSb3cgKm5nRm9yPVxcXCJsZXQgY2hpbGROb2RlIG9mIG5vZGUuY2hpbGRyZW5cXFwiIFtub2RlXT1cXFwiY2hpbGROb2RlXFxcIiBbbGV2ZWxdPVxcXCJsZXZlbCsxXFxcIiBbbGFiZWxFeHBhbmRdPVxcXCJsYWJlbEV4cGFuZFxcXCIgW2xhYmVsQ29sbGFwc2VdPVxcXCJsYWJlbENvbGxhcHNlXFxcIiBbcGFyZW50Tm9kZV09XFxcIm5vZGVcXFwiPjwvdGJvZHk+XFxuICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIlxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgY29yZV8xLkluamVjdChjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBUcmVlVGFibGU7IH0pKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUcmVlVGFibGVdKVxuXSwgVUlUcmVlUm93KTtcbmV4cG9ydHMuVUlUcmVlUm93ID0gVUlUcmVlUm93O1xudmFyIFRyZWVUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJlZVRhYmxlKGVsLCBkb21IYW5kbGVyLCBjaGFuZ2VEZXRlY3RvciwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmRvbUhhbmRsZXIgPSBkb21IYW5kbGVyO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5sYWJlbEV4cGFuZCA9IFwiRXhwYW5kXCI7XG4gICAgICAgIHRoaXMubGFiZWxDb2xsYXBzZSA9IFwiQ29sbGFwc2VcIjtcbiAgICAgICAgdGhpcy5tZXRhS2V5U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50b2dnbGVDb2x1bW5JbmRleCA9IDA7XG4gICAgICAgIHRoaXMub25Sb3dEYmxjbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk5vZGVTZWxlY3QgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTm9kZVVuc2VsZWN0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk5vZGVFeHBhbmQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTm9kZUNvbGxhcHNlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51U2VsZWN0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgVHJlZVRhYmxlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5pdENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zU3Vic2NyaXB0aW9uID0gdGhpcy5jb2xzLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBfdGhpcy5pbml0Q29sdW1ucygpO1xuICAgICAgICAgICAgX3RoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJlZVRhYmxlLnByb3RvdHlwZS5pbml0Q29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gdGhpcy5jb2xzLnRvQXJyYXkoKTtcbiAgICB9O1xuICAgIFRyZWVUYWJsZS5wcm90b3R5cGUub25Sb3dDbGljayA9IGZ1bmN0aW9uIChldmVudCwgbm9kZSkge1xuICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmIChldmVudFRhcmdldC5jbGFzc05hbWUgJiYgZXZlbnRUYXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ3VpLXRyZWV0YWJsZS10b2dnbGVyJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnNlbGVjdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1ldGFTZWxlY3Rpb24gPSB0aGlzLnJvd1RvdWNoZWQgPyBmYWxzZSA6IHRoaXMubWV0YUtleVNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBpbmRleF8xID0gdGhpcy5maW5kSW5kZXhJblNlbGVjdGlvbihub2RlKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IChpbmRleF8xID49IDApO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGVja2JveFNlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZVNlbGVjdGlvbkRvd24obm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlU2VsZWN0aW9uVXAobm9kZS5wYXJlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVVbnNlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIG5vZGU6IG5vZGUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZVNlbGVjdGlvbkRvd24obm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVTZWxlY3Rpb25VcChub2RlLnBhcmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlU2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YVNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YUtleSA9IChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgbWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTaW5nbGVTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBpbmRleF8xOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlVW5zZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTaW5nbGVTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc011bHRpcGxlU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSAoIW1ldGFLZXkpID8gW10gOiB0aGlzLnNlbGVjdGlvbiB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uLmNvbmNhdChbbm9kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVTZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVNlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlVW5zZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlU2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIGkgIT0gaW5kZXhfMTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVVbnNlbGVjdC5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIG5vZGU6IG5vZGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9ICh0aGlzLnNlbGVjdGlvbiB8fCBbXSkuY29uY2F0KFtub2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vZGVTZWxlY3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd1RvdWNoZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRyZWVUYWJsZS5wcm90b3R5cGUub25Sb3dUb3VjaEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yb3dUb3VjaGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRyZWVUYWJsZS5wcm90b3R5cGUub25Sb3dSaWdodENsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleEluU2VsZWN0aW9uKG5vZGUpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gKGluZGV4ID49IDApO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2luZ2xlU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc011bHRpcGxlU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gW25vZGVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51LnNob3coZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51U2VsZWN0LmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZVRhYmxlLnByb3RvdHlwZS5maW5kSW5kZXhJblNlbGVjdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlICYmIHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVNlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gKHRoaXMuc2VsZWN0aW9uID09IG5vZGUpID8gMCA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25baV0gPT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgVHJlZVRhYmxlLnByb3RvdHlwZS5wcm9wYWdhdGVTZWxlY3Rpb25VcCA9IGZ1bmN0aW9uIChub2RlLCBzZWxlY3QpIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjaGlsZFBhcnRpYWxTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG5vZGUuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFydGlhbFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUGFydGlhbFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0ICYmIHNlbGVjdGVkQ291bnQgPT0gbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9ICh0aGlzLnNlbGVjdGlvbiB8fCBbXSkuY29uY2F0KFtub2RlXSk7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJ0aWFsU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleF8yID0gdGhpcy5maW5kSW5kZXhJblNlbGVjdGlvbihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4XzIgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaSAhPSBpbmRleF8yOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRQYXJ0aWFsU2VsZWN0ZWQgfHwgc2VsZWN0ZWRDb3VudCA+IDAgJiYgc2VsZWN0ZWRDb3VudCAhPSBub2RlLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJ0aWFsU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJ0aWFsU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlU2VsZWN0aW9uVXAocGFyZW50LCBzZWxlY3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlVGFibGUucHJvdG90eXBlLnByb3BhZ2F0ZVNlbGVjdGlvbkRvd24gPSBmdW5jdGlvbiAobm9kZSwgc2VsZWN0KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4SW5TZWxlY3Rpb24obm9kZSk7XG4gICAgICAgIGlmIChzZWxlY3QgJiYgaW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gKHRoaXMuc2VsZWN0aW9uIHx8IFtdKS5jb25jYXQoW25vZGVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2VsZWN0ICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIGkgIT0gaW5kZXg7IH0pO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucGFydGlhbFNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbm9kZS5jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVTZWxlY3Rpb25Eb3duKGNoaWxkLCBzZWxlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlVGFibGUucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kSW5kZXhJblNlbGVjdGlvbihub2RlKSAhPSAtMTtcbiAgICB9O1xuICAgIFRyZWVUYWJsZS5wcm90b3R5cGUuaXNTaW5nbGVTZWxlY3Rpb25Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PSAnc2luZ2xlJztcbiAgICB9O1xuICAgIFRyZWVUYWJsZS5wcm90b3R5cGUuaXNNdWx0aXBsZVNlbGVjdGlvbk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGUgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09ICdtdWx0aXBsZSc7XG4gICAgfTtcbiAgICBUcmVlVGFibGUucHJvdG90eXBlLmlzQ2hlY2tib3hTZWxlY3Rpb25Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PSAnY2hlY2tib3gnO1xuICAgIH07XG4gICAgVHJlZVRhYmxlLnByb3RvdHlwZS5oYXNGb290ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW5zQXJyID0gdGhpcy5jb2xzLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uc0Fyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zQXJyW2ldLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFRyZWVUYWJsZTtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZVRhYmxlLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25Nb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVHJlZVRhYmxlLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZVRhYmxlLnByb3RvdHlwZSwgXCJzdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJlZVRhYmxlLnByb3RvdHlwZSwgXCJsYWJlbEV4cGFuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRyZWVUYWJsZS5wcm90b3R5cGUsIFwibGFiZWxDb2xsYXBzZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcIm1ldGFLZXlTZWxlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcImNvbnRleHRNZW51XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVHJlZVRhYmxlLnByb3RvdHlwZSwgXCJ0b2dnbGVDb2x1bW5JbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyZWVUYWJsZS5wcm90b3R5cGUsIFwidGFibGVTdHlsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRyZWVUYWJsZS5wcm90b3R5cGUsIFwidGFibGVTdHlsZUNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcIm9uUm93RGJsY2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFRyZWVUYWJsZS5wcm90b3R5cGUsIFwic2VsZWN0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcIm9uTm9kZVNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVRhYmxlLnByb3RvdHlwZSwgXCJvbk5vZGVVbnNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgVHJlZVRhYmxlLnByb3RvdHlwZSwgXCJvbk5vZGVFeHBhbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFRyZWVUYWJsZS5wcm90b3R5cGUsIFwib25Ob2RlQ29sbGFwc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5PdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkV2ZW50RW1pdHRlcilcbl0sIFRyZWVUYWJsZS5wcm90b3R5cGUsIFwib25Db250ZXh0TWVudVNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMS5IZWFkZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBzaGFyZWRfMS5IZWFkZXIpXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZChzaGFyZWRfMS5Gb290ZXIpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBzaGFyZWRfMS5Gb290ZXIpXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcImZvb3RlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkNvbnRlbnRDaGlsZHJlbihzaGFyZWRfMS5Db2x1bW4pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuUXVlcnlMaXN0KVxuXSwgVHJlZVRhYmxlLnByb3RvdHlwZSwgXCJjb2xzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuVmlld0NoaWxkKCd0YmwnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLkVsZW1lbnRSZWYpXG5dLCBUcmVlVGFibGUucHJvdG90eXBlLCBcInRhYmxlVmlld0NoaWxkXCIsIHZvaWQgMCk7XG5UcmVlVGFibGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLXRyZWVUYWJsZScsXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcIid1aS10cmVldGFibGUgdWktd2lkZ2V0J1xcXCIgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW2NsYXNzXT1cXFwic3R5bGVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktdHJlZXRhYmxlLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyXFxcIiAqbmdJZj1cXFwiaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJwLWhlYWRlclxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLXRyZWV0YWJsZS10YWJsZXdyYXBwZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8dGFibGUgI3RibCBjbGFzcz1cXFwidWktd2lkZ2V0LWNvbnRlbnRcXFwiIFtjbGFzc109XFxcInRhYmxlU3R5bGVDbGFzc1xcXCIgW25nU3R5bGVdPVxcXCJ0YWJsZVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcInVpLXN0YXRlLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggI2hlYWRlckNlbGwgKm5nRm9yPVxcXCJsZXQgY29sIG9mIGNvbHVtbnM7IGxldCBsYXN0Q29sPWxhc3QgXFxcIiAgW25nU3R5bGVdPVxcXCJjb2wuc3R5bGVcXFwiIFtjbGFzc109XFxcImNvbC5zdHlsZUNsYXNzXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwiJ3VpLXN0YXRlLWRlZmF1bHQgdWktdW5zZWxlY3RhYmxlLXRleHQnXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1jb2x1bW4tdGl0bGVcXFwiICpuZ0lmPVxcXCIhY29sLmhlYWRlclRlbXBsYXRlXFxcIj57e2NvbC5oZWFkZXJ9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ1aS1jb2x1bW4tdGl0bGVcXFwiICpuZ0lmPVxcXCJjb2wuaGVhZGVyVGVtcGxhdGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwLWNvbHVtbkhlYWRlclRlbXBsYXRlTG9hZGVyIFtjb2x1bW5dPVxcXCJjb2xcXFwiPjwvcC1jb2x1bW5IZWFkZXJUZW1wbGF0ZUxvYWRlcj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cXG4gICAgICAgICAgICAgICAgICAgIDx0Zm9vdCAqbmdJZj1cXFwiaGFzRm9vdGVyKClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkICpuZ0Zvcj1cXFwibGV0IGNvbCBvZiBjb2x1bW5zXFxcIiBbbmdTdHlsZV09XFxcImNvbC5zdHlsZVxcXCIgW2NsYXNzXT1cXFwiY29sLnN0eWxlQ2xhc3NcXFwiIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1kZWZhdWx0Jzp0cnVlfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY29sdW1uLWZvb3RlclxcXCIgKm5nSWY9XFxcIiFjb2wuZm9vdGVyVGVtcGxhdGVcXFwiPnt7Y29sLmZvb3Rlcn19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInVpLWNvbHVtbi1mb290ZXJcXFwiICpuZ0lmPVxcXCJjb2wuZm9vdGVyVGVtcGxhdGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwLWNvbHVtbkZvb3RlclRlbXBsYXRlTG9hZGVyIFtjb2x1bW5dPVxcXCJjb2xcXFwiPjwvcC1jb2x1bW5Gb290ZXJUZW1wbGF0ZUxvYWRlcj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgPC90Zm9vdD5cXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keSBwVHJlZVJvdyAqbmdGb3I9XFxcImxldCBub2RlIG9mIHZhbHVlXFxcIiBjbGFzcz1cXFwidWktdHJlZXRhYmxlLWRhdGEgdWktd2lkZ2V0LWNvbnRlbnRcXFwiIFtub2RlXT1cXFwibm9kZVxcXCIgW2xldmVsXT1cXFwiMFxcXCIgW2xhYmVsRXhwYW5kXT1cXFwibGFiZWxFeHBhbmRcXFwiIFtsYWJlbENvbGxhcHNlXT1cXFwibGFiZWxDb2xsYXBzZVxcXCI+PC90Ym9keT5cXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aS10cmVldGFibGUtZm9vdGVyIHVpLXdpZGdldC1oZWFkZXJcXFwiICpuZ0lmPVxcXCJmb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcInAtZm9vdGVyXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgIHByb3ZpZGVyczogW2RvbWhhbmRsZXJfMS5Eb21IYW5kbGVyXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyLCBjb3JlXzEuQ2hhbmdlRGV0ZWN0b3JSZWYsIGNvcmVfMS5SZW5kZXJlcjJdKVxuXSwgVHJlZVRhYmxlKTtcbmV4cG9ydHMuVHJlZVRhYmxlID0gVHJlZVRhYmxlO1xudmFyIFRyZWVUYWJsZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJlZVRhYmxlTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gVHJlZVRhYmxlTW9kdWxlO1xufSgpKTtcblRyZWVUYWJsZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGUsIHNoYXJlZF8yLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGV4cG9ydHM6IFtUcmVlVGFibGUsIHNoYXJlZF8yLlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1RyZWVUYWJsZSwgVUlUcmVlUm93XVxuICAgIH0pXG5dLCBUcmVlVGFibGVNb2R1bGUpO1xuZXhwb3J0cy5UcmVlVGFibGVNb2R1bGUgPSBUcmVlVGFibGVNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVldGFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy90cmVldGFibGUvdHJlZXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvdHJlZXRhYmxlL3RyZWV0YWJsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGZvcm1zXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIik7XG5leHBvcnRzLlRSSVNUQVRFQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogZm9ybXNfMS5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gVHJpU3RhdGVDaGVja2JveDsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgVHJpU3RhdGVDaGVja2JveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJpU3RhdGVDaGVja2JveChjZCkge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIFRyaVN0YXRlQ2hlY2tib3gucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cyA9IHRydWU7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmlTdGF0ZUNoZWNrYm94LnByb3RvdHlwZS5vbktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzIpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyaVN0YXRlQ2hlY2tib3gucHJvdG90eXBlLm9uS2V5dXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzIpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyaVN0YXRlQ2hlY2tib3gucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSBudWxsIHx8IHRoaXMudmFsdWUgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWUgPT0gdHJ1ZSlcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZSA9PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJpU3RhdGVDaGVja2JveC5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHRydWU7XG4gICAgfTtcbiAgICBUcmlTdGF0ZUNoZWNrYm94LnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCgpO1xuICAgIH07XG4gICAgVHJpU3RhdGVDaGVja2JveC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIFRyaVN0YXRlQ2hlY2tib3gucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIFRyaVN0YXRlQ2hlY2tib3gucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgVHJpU3RhdGVDaGVja2JveC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gVHJpU3RhdGVDaGVja2JveDtcbn0oKSk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRyaVN0YXRlQ2hlY2tib3gucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJpU3RhdGVDaGVja2JveC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRyaVN0YXRlQ2hlY2tib3gucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJpU3RhdGVDaGVja2JveC5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLklucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRyaVN0YXRlQ2hlY2tib3gucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVHJpU3RhdGVDaGVja2JveC5wcm90b3R5cGUsIFwic3R5bGVDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLk91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlXzEuRXZlbnRFbWl0dGVyKVxuXSwgVHJpU3RhdGVDaGVja2JveC5wcm90b3R5cGUsIFwib25DaGFuZ2VcIiwgdm9pZCAwKTtcblRyaVN0YXRlQ2hlY2tib3ggPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdwLXRyaVN0YXRlQ2hlY2tib3gnLFxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nU3R5bGVdPVxcXCJzdHlsZVxcXCIgW25nQ2xhc3NdPVxcXCIndWktY2hrYm94IHVpLXRyaXN0YXRlY2hrYm94IHVpLXdpZGdldCdcXFwiIFtjbGFzc109XFxcInN0eWxlQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCAjaW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgW2F0dHIuaWRdPVxcXCJpbnB1dElkXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFthdHRyLnRhYmluZGV4XT1cXFwidGFiaW5kZXhcXFwiIHJlYWRvbmx5IFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiAoa2V5dXApPVxcXCJvbktleXVwKCRldmVudClcXFwiIChrZXlkb3duKT1cXFwib25LZXlkb3duKCRldmVudClcXFwiIChmb2N1cyk9XFxcIm9uRm9jdXMoKVxcXCIgKGJsdXIpPVxcXCJvbkJsdXIoKVxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWktY2hrYm94LWJveCB1aS13aWRnZXQgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kZWZhdWx0XFxcIiAoY2xpY2spPVxcXCJvbkNsaWNrKCRldmVudCxpbnB1dClcXFwiXFxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyd1aS1zdGF0ZS1hY3RpdmUnOnZhbHVlIT1udWxsLCd1aS1zdGF0ZS1kaXNhYmxlZCc6ZGlzYWJsZWQsJ3VpLXN0YXRlLWZvY3VzJzpmb2N1c31cXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidWktY2hrYm94LWljb24gZmEgdWktY2xpY2thYmxlXFxcIiBbbmdDbGFzc109XFxcInsnZmEtY2hlY2snOnZhbHVlPT10cnVlLCdmYS1jbG9zZSc6dmFsdWU9PWZhbHNlfVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiLFxuICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLlRSSVNUQVRFQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1JdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgVHJpU3RhdGVDaGVja2JveCk7XG5leHBvcnRzLlRyaVN0YXRlQ2hlY2tib3ggPSBUcmlTdGF0ZUNoZWNrYm94O1xudmFyIFRyaVN0YXRlQ2hlY2tib3hNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyaVN0YXRlQ2hlY2tib3hNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBUcmlTdGF0ZUNoZWNrYm94TW9kdWxlO1xufSgpKTtcblRyaVN0YXRlQ2hlY2tib3hNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBjb3JlXzEuTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW1RyaVN0YXRlQ2hlY2tib3hdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtUcmlTdGF0ZUNoZWNrYm94XVxuICAgIH0pXG5dLCBUcmlTdGF0ZUNoZWNrYm94TW9kdWxlKTtcbmV4cG9ydHMuVHJpU3RhdGVDaGVja2JveE1vZHVsZSA9IFRyaVN0YXRlQ2hlY2tib3hNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmlzdGF0ZWNoZWNrYm94LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmltZW5nL2NvbXBvbmVudHMvdHJpc3RhdGVjaGVja2JveC90cmlzdGF0ZWNoZWNrYm94LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL2NvbXBvbmVudHMvdHJpc3RhdGVjaGVja2JveC90cmlzdGF0ZWNoZWNrYm94LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIE9iamVjdFV0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RVdGlscygpIHtcbiAgICB9XG4gICAgT2JqZWN0VXRpbHMucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvYmoxLCBvYmoyLCBmaWVsZCkge1xuICAgICAgICBpZiAoZmllbGQpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucmVzb2x2ZUZpZWxkRGF0YShvYmoxLCBmaWVsZCkgPT09IHRoaXMucmVzb2x2ZUZpZWxkRGF0YShvYmoyLCBmaWVsZCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHNCeVZhbHVlKG9iajEsIG9iajIpO1xuICAgIH07XG4gICAgT2JqZWN0VXRpbHMucHJvdG90eXBlLmVxdWFsc0J5VmFsdWUgPSBmdW5jdGlvbiAob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAob2JqMSA9PSBudWxsICYmIG9iajIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqMSA9PSBvYmoyKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqMS5fJHZpc2l0ZWQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9iajEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iajIgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9iajEuXyR2aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gb2JqMSkge1xuICAgICAgICAgICAgICAgIGlmIChwID09PSBcIl8kdmlzaXRlZFwiKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShwKSAhPT0gb2JqMi5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIChvYmoxW3BdKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iajFbcF0gJiYgb2JqMVtwXS5fJHZpc2l0ZWQgfHwgIXRoaXMuZXF1YWxzKG9iajFbcF0sIG9iajJbcF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvYmoyW3BdKSA9PSAndW5kZWZpbmVkJyB8fCAocCAhPSAnY29tcGFyZScgJiYgb2JqMVtwXS50b1N0cmluZygpICE9IG9iajJbcF0udG9TdHJpbmcoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqMVtwXSAhPSBvYmoyW3BdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gb2JqMikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9iajFbcF0pID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgb2JqMS5fJHZpc2l0ZWQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBPYmplY3RVdGlscy5wcm90b3R5cGUucmVzb2x2ZUZpZWxkRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAoZGF0YSAmJiBmaWVsZCkge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmluZGV4T2YoJy4nKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSBmaWVsZC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtmaWVsZHNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0VXRpbHMucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwgZmllbGRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgICAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdmFsdWVfMSA9IHZhbHVlOyBfaSA8IHZhbHVlXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB2YWx1ZV8xW19pXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGZpZWxkc18xID0gZmllbGRzOyBfYSA8IGZpZWxkc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNfMVtfYV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChTdHJpbmcodGhpcy5yZXNvbHZlRmllbGREYXRhKGl0ZW0sIGZpZWxkKSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKGZpbHRlclZhbHVlLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZEl0ZW1zO1xuICAgIH07XG4gICAgT2JqZWN0VXRpbHMucHJvdG90eXBlLnJlb3JkZXJBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHRhcmdldDtcbiAgICAgICAgaWYgKHZhbHVlICYmIChmcm9tICE9PSB0bykpIHtcbiAgICAgICAgICAgIGlmICh0byA+PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0byAtIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRhcmdldC0tKSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlLnNwbGljZSh0bywgMCwgdmFsdWUuc3BsaWNlKGZyb20sIDEpWzBdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdFV0aWxzO1xufSgpKTtcbk9iamVjdFV0aWxzID0gX19kZWNvcmF0ZShbXG4gICAgY29yZV8xLkluamVjdGFibGUoKVxuXSwgT2JqZWN0VXRpbHMpO1xuZXhwb3J0cy5PYmplY3RVdGlscyA9IE9iamVjdFV0aWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0dXRpbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaW1lbmcvY29tcG9uZW50cy91dGlscy9vYmplY3R1dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJpbWVuZy9jb21wb25lbnRzL3V0aWxzL29iamVjdHV0aWxzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qIFNob3J0aGFuZCAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9jb21tb24vYXBpXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvY29tbW9uL3NoYXJlZFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9hdXRvY29tcGxldGUvYXV0b2NvbXBsZXRlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvYmxvY2t1aS9ibG9ja3VpXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvYnJlYWRjcnVtYi9icmVhZGNydW1iXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvblwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2NhcHRjaGEvY2FwdGNoYVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2NhbGVuZGFyL2NhbGVuZGFyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvY2Fyb3VzZWwvY2Fyb3VzZWxcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9jaGFydC9jaGFydFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2NoZWNrYm94L2NoZWNrYm94XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvY2hpcHMvY2hpcHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9jb2RlaGlnaGxpZ2h0ZXIvY29kZWhpZ2hsaWdodGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvY29sb3JwaWNrZXIvY29sb3JwaWNrZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9jb250ZXh0bWVudS9jb250ZXh0bWVudVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2RhdGFncmlkL2RhdGFncmlkXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZGF0YWxpc3QvZGF0YWxpc3RcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9kYXRhc2Nyb2xsZXIvZGF0YXNjcm9sbGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZGF0YXRhYmxlL2RhdGF0YWJsZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2RlZmVyL2RlZmVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvY29uZmlybWRpYWxvZy9jb25maXJtZGlhbG9nXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZGlhbG9nL2RpYWxvZ1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2RyYWdkcm9wL2RyYWdkcm9wXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZHJvcGRvd24vZHJvcGRvd25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9lZGl0b3IvZWRpdG9yXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZmllbGRzZXQvZmllbGRzZXRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9maWxldXBsb2FkL2ZpbGV1cGxvYWRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9nYWxsZXJpYS9nYWxsZXJpYVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2dtYXAvZ21hcFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2dyb3dsL2dyb3dsXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvaW5wbGFjZS9pbnBsYWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvaW5wdXRtYXNrL2lucHV0bWFza1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2lucHV0c3dpdGNoL2lucHV0c3dpdGNoXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvaW5wdXR0ZXh0L2lucHV0dGV4dFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2lucHV0dGV4dGFyZWEvaW5wdXR0ZXh0YXJlYVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL2xpZ2h0Ym94L2xpZ2h0Ym94XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvbGlzdGJveC9saXN0Ym94XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvbWVnYW1lbnUvbWVnYW1lbnVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9tZW51L21lbnVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9tZW51YmFyL21lbnViYXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9tZXNzYWdlcy9tZXNzYWdlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL211bHRpc2VsZWN0L211bHRpc2VsZWN0XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvb3JkZXJsaXN0L29yZGVybGlzdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL29yZ2FuaXphdGlvbmNoYXJ0L29yZ2FuaXphdGlvbmNoYXJ0XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvb3ZlcmxheXBhbmVsL292ZXJsYXlwYW5lbFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3BhZ2luYXRvci9wYWdpbmF0b3JcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9wYW5lbC9wYW5lbFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3BhbmVsbWVudS9wYW5lbG1lbnVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9wYXNzd29yZC9wYXNzd29yZFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3BpY2tsaXN0L3BpY2tsaXN0XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9yYWRpb2J1dHRvbi9yYWRpb2J1dHRvblwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3JhdGluZy9yYXRpbmdcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9zY2hlZHVsZS9zY2hlZHVsZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3NlbGVjdGJ1dHRvbi9zZWxlY3RidXR0b25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy9zbGlkZW1lbnUvc2xpZGVtZW51XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3NwbGl0YnV0dG9uL3NwbGl0YnV0dG9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvc3RlcHMvc3RlcHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy90YWJ2aWV3L3RhYnZpZXdcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy90YWJtZW51L3RhYm1lbnVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy90ZXJtaW5hbC90ZXJtaW5hbFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3RpZXJlZG1lbnUvdGllcmVkbWVudVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21wb25lbnRzL3RvZ2dsZWJ1dHRvbi90b2dnbGVidXR0b25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy90b29sYmFyL3Rvb2xiYXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXBcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy90cmVlL3RyZWVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50cy90cmVldGFibGUvdHJlZXRhYmxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvdHJpc3RhdGVjaGVja2JveC90cmlzdGF0ZWNoZWNrYm94XCIpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpbWVuZy9wcmltZW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcmltZW5nL3ByaW1lbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RzbGliL3RzbGliLmVzNi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdteS1hcHAnLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxyXG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCI+XHJcbiAgICAgICAgPGgxPkhlbGxvIHt7bmFtZX19PC9oMT5cclxuICAgICAgICA8cC1jYWxlbmRhciBbKG5nTW9kZWwpXT1cInZhbHVlXCI+PC9wLWNhbGVuZGFyPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PiAgXHJcbiAgPC9kaXY+XHJcbiAgYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50ICB7IFxyXG4gIG5hbWUgPSAnQW5ndWxhcic7IFxyXG4gIHZhbHVlOiBEYXRlO1xyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3RzbGludC1sb2FkZXIhLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBOZ01vZHVsZSB9ICAgICAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSAgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2FuaW1hdGlvbnMnO1xyXG5cclxuaW1wb3J0IHsgQ2FsZW5kYXJNb2R1bGUgfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xyXG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSAgZnJvbSAnLi9hcHAuY29tcG9uZW50JztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgaW1wb3J0czogICAgICBbIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2FsZW5kYXJNb2R1bGUgXSxcclxuICBkZWNsYXJhdGlvbnM6IFsgQXBwQ29tcG9uZW50IF0sXHJcbiAgYm9vdHN0cmFwOiAgICBbIEFwcENvbXBvbmVudCBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdHNsaW50LWxvYWRlciEuL3NyYy9hcHAvYXBwLm1vZHVsZS50cyIsImltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xyXG5cclxuaW1wb3J0IHsgQXBwTW9kdWxlIH0gZnJvbSAnLi9hcHAvYXBwLm1vZHVsZSc7XHJcblxyXG5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdHNsaW50LWxvYWRlciEuL3NyYy9tYWluLnRzIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSkoMTIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL0Bhbmd1bGFyL2NvcmUuZXM1LmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSkoMjQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vQGFuZ3VsYXIvY29tbW9uLmVzNS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oNikpKDg4KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oNikpKDg0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvZm9ybXMvQGFuZ3VsYXIvZm9ybXMuZXM1LmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSkoODcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9yb3V0ZXIvQGFuZ3VsYXIvcm91dGVyLmVzNS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oNikpKDE2KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLmVzNS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oNikpKDQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvclxuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKSg4Nik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMuZXM1LmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==